# Operating System Note

操作系统用来管理硬件和软件。

命令接口（允许用户直接使用）：

联机命令接口：用户说一句，系统做一句。

脱机命令接口：用户说一堆，系统做一堆。（批处理命令，比如执行`.bat`文件）

程序接口：即指系统调用。

操作系统的特征：

* 并发

    宏观上同时发生，微观上交替发生。并行指的是两个或多个事件同时发生。

    cpu 多个核心之间是并行，单核执行多任务是并发。

* 共享

    有两种资源共享方式：互斥共享，同时共享。“同时”往往是宏观上的。

    互斥共享：一个时间段内只允许一个进程访问该资源

    同时共享：一个时间段内允许多个进程同时访问某个资源。（其实底层原理仍然是分时共享）

    并发和共享互为存在条件。正是因为我们有并发性的需求，所以才要求资源可以共享。如果一个资源无法被共享（无论是分时共享，还是实际的共享），那么它也不可能支持并发。

* 虚拟

    如内存的空分复用，CPU 的时分复用。（在这里只了解概念就可以了，不需要深入）

    虚拟化是对共享的一种实现手段。同理，如果不需要并发，那么就不需要虚拟。（真的不需要吗？比如沙盒之类的环境）

* 异步

    进程以不可知的速度走走停停。只有系统拥有并发性，才有可能导致异步性。

    由于可分配的资源有限，进程可分配的资源不是一贯到底的，而是走走停停，以不可预知的速度。

    我认为异步就是进程在等资源。

    编程中的异步和这里说的异步有点细微的区别。编程上说的异步指的是单线程模拟多个任务，每个任务都有自己要等待的 IO 资源，只有当 IO 资源有效时，才能继续推动任务前进。

并发和共享是操作系统最基本的两个特征。

操作系统的分类：

* 批处理系统

    分为单道批处理系统，多道批处理系统。

    多道批处理系统可以利用流水线思想，使得 IO 单元和计算单元总是处于忙碌的状态，减少空闲等待时间，从而提高整体的效率。

* 分时操作系统

    计算机以时间片为单位，轮流为各个用户/作业服务。可以处理人机交互问题。

* 实时操作系统

    要求在严格的时限内处理完事件。

特权指令只有在核心态下才能执行。

操作系统内核的几个模块：

* 时钟管理

* 中断处理

* 原语

* 对系统资源进行管理。主要包括进程管理，存储器管理，设备管理。

    包含这个模块的内核被称为大内核，不包含这个模块的内核被称为微内核。

用户态到核心态需要使用中断来实现。核心态到用户态可以使用核心态的指令来实现。

1. 当中断发生时，CPU 立即进入核心态。

2. 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。

3. 对于不同的中断信号，会进行不同的处理。

内部中断（trap, fault, abort）：

1. 自愿中断：指令中断（trap指令）
1. 强迫中断：硬件故障（比如缺页），软件中断（比如整数除0）

外部中断：

1. 外设请求（如 io 操作完成发出的中断信号）
1. 人工干预（如用户强行终止一个进程）

系统调用的过程：

1. 传递系统调用参数
1. 用户态执行陷入指令，引发一个内中断，CPU进入核心态
1. 核心态执行系统调用相应服务程序
1. 返回用户程序

系统调用的分类：

* 设备管理

* 文件管理

* 进程控制

* 进程通信

* 内存管理

## 进程

进程是资源分配、调度的基本单位。

进程实体（进程映像）：程序段、数据段、PCB。

PCB 是进程存在的唯一标志。

PCB：

1. 进程描述信息：进程标识符 PID，用户标识符 UID

1. 进程控制和管理信息：进程当前状态，进程优先级

1. 资源分配清单：程序段指针，数据段指针，键盘，鼠标

1. 处理机相关信息：各种寄存器值

进程的组织：链接方式

1. 执行指针指向当前运行态的进程

1. 就绪队列指针指向就绪态的进程链

1. 阻塞队列指针指向阻塞态的进程链

进程的三种状态：运行态，就绪态，阻塞态

原语：执行期间不允许中断。原理是先关中断，再执行指令，再开中断。

进程控制：

1. 更新 PCB 中的信息
1. 将 PCB 插入合适的队列
1. 分配/回收资源

与进程相关的原语：

1. 创建
1. 终止
1. 阻塞
1. 唤醒
1. 切换

### 进程通信

各进程的内存地址空间相互独立。

1. 共享内存（两个进程对共享空间的访问必须是互斥的）

1. 管道（pipe）：在内存中开辟一个大小固定的缓冲区

    只能半双工通信。如果想全双工，需要两个管道。

1. 消息

## 线程

线程是一个基本的 CPU 执行单元，也是程序执行流的最小单位。

用户级线程：用户能看到，内核看不到

内核级线程：内核能看到，用户看不到

内核极线程才是处理机分配的单位

多线程模型：多对一，一对一，多对多

## 处理机调度

1. 高级调度（创建进程）
1. 中级调度（内存调度）
1. 低级高度（进程调度）

挂起态（suspend）：就绪挂起，阻塞挂起

进程调度的时机：

1. 当前进程主动放弃处理机

    1. 进程正常终止
    1. 运行过程中发生异常
    1. 进程主动请求 io 阻塞

1. 当前进程被动放弃处理机

    1. 分给进程的时间片用完
    1. 有更紧急的事需要处理（I/O 中断）
    1. 有更高优先级的进程进入就绪队列

不能进行进程调度：

1. 在处理中断的过程中
1. 进程在操作系统**内核**程序临界区中
1. 在原子操作过程中

**进程调度的方式**

1. 非抢占方式，只允许进程主动放弃处理机。适用于早期的批处理系统。

1. 抢占方式，允许优先处理更紧急的进程。适用于实时系统等。

**调度算法的评价指标**

1. cpu 利用率

    利用率 = 忙碌的时间 / 总时间

1. 系统吞吐量

    吞吐量 = 总共完成了多少道作业 / 总共花了多少时间

1. 周转时间

    作业周转时间 = 作业完成时间 - 作业提交时间

    平均周转时间

    带权周转时间 = 作业周转时间 / 作业实际运行时间

    带权周转时间越小越好

    平均带权周转时间

1. 等待时间

    进程/作业处于等待处理机状态时间之和

    如果是纯计算型的进程，那么 等待时间 = 周转时间 - 运行时间

    如果又有计算，又有 I/O，那么 等待时间 = 周转时间 - 运行时间 - I/O 操作时间

    平均等待时间

1. 响应时间

    用户从提交请求到首次产生响应所用时间

**调度算法**

饥饿：某个进程长期得不到服务。

1. 先来先服务（FCFS, First Come First Serve）

    其实就是等待时间越久的越优先得到服务。

    非抢占式，主要体现公平

    对长作业有利，对短作业不利

    不会导致饥饿。

1. 短作业优先（Shortest Job First, SJF，SPF）

    服务时间最短的作业/进程优先得到服务

    平均等待时间，平均周转时间最少

    非抢占式/抢占式（SRNT）

    抢占式：最短剩余时间优先（SRNT）算法。每当有进程加入就绪队列时就需要调度。平均等待时间，平均周转时间最少。抢占式的这几个指标要优于非抢占式。

    对短作业有利，对长作业不利。有可能导致饥饿。

1. 高响应比优先（HRRN）

    在每次调度时计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。只有当前运行的进程主动放弃 cpu 时（正常/异常完成，或主动阻塞），才需要进行调度。

    响应比 = （等待时间 + 要求服务时间）/ 要求服务时间

    非抢占式

    不会导致饥饿

**交互式系统的调度算法**

1. 时间片轮转调度算法（RR，Round-Robin）

    轮流让各个进程执行一个时间片（比如 100 ms）。

    抢占式。由时钟装置发出时钟中断来通知 CPU 时间片已到。

    若时间片太大，则退化为先来先服务算法，会增大进程响应时间。若时间片太小，则进程切换过于频繁，降低效率。通常不让切换开销超过 1%。

    不区分任务的紧急程度。不会导致饥饿。

    常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间。

1. 优先级调度算法（）

    按优先级最高的任务进行调度。

    既有抢占式（就绪队列发生改变时，检查所有进程的优先情况），又有非抢占式（等待进程主动退出时，检查所有进程的优先级情况）。

    通常：

    1. 系统进程优先级高于用户进程
    1. 前台进程优先级高于后台进程
    1. 操作系统更偏好 I/O 型进程（I/O 繁忙型进程）

    如果采用动态优先级，则考虑

    1. 若进程等待时间长，则提升优先级
    1. 若进程运行时间长，则降低优先级
    1. 若I/O操作频繁，则提高优先级

1. 多级反馈队列调度算法

    设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。

    进程先进入 1 级队列，若没执行完，则放到 2 级队列队尾，以此类推。

    只有第 k 级队列为空时，才会为 k + 1 级队头的进程分配时间片。被抢占处理机的进程重新放回原队列的队尾。

    抢占式。若某级队列上面的队列改变，则先处理上面的队列。

    可能会导致饥饿。

## 进程同步和互斥

访问临界资源的代码叫做临界区。

对于临界区的资源访问，操作系统应实现 4 个原则：

1. 空闲让进
1. 忙则等待
1. 有限等待
1. 让权等待。进不了临界区的进程，要释放处理机，防止忙等

**进程互斥的软件实现方法**

1. 单标志法

    p0 进程：

    ```c++
    while (turn != 0);
    critical section;
    turn = 1;
    remainder section;
    ```

    p1 进程：

    ```c++
    while (turn != 1);
    critical section;
    turn = 0;
    remainder section;
    ```

    违背“空闲让进”原则：若此时允许进入临界区的进程是 p0，而 p0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 p1 访问。

1. 双标志先检查法

    ```c++
    bool flag[2];  // 表示进入临界区意愿的数组
    flag[0] = false;
    flag[1] = false;  // 刚开始两个进程都不想进入临界区
    ```

    P0 进程：

    ```c++
    while (flag[1]);
    flag[0] = true;
    critical section;
    flag[0] = false;
    remainder section;
    ```

    P1 进程：

    ```c++
    while (flag[0]);
    flag[1] = true;
    critical section;
    flag[1] = false;
    remainder section;
    ```

    违反“忙则等待”原则，P0 和 P1 可能会同时访问临界区（两个 flag 都设置为 true）。

1. 双标志后检查法

    ```c++
    bool flag[2];
    flag[0] = false;
    flag[1] = false;
    ```

    P0 进程：

    ```c++
    flag[0] = true;
    while (flag[1]);
    critical section;
    flag[0] = false;
    remainder section;
    ```

    P1 进程：

    ```c++
    flag[1] = true;
    while (flag[0]);
    critical section;
    flag[1] = false;
    remainder section;
    ```

    违背“空闲让进”和“有限等待”原则。会产生饥饿现象。

1. Peterson 算法

    主动退让。turn 表示愿意让哪个进程进入临界区。

    ```c++
    bool flag[2];
    int turn = 0;
    ```

    p0 进程：

    ```c++
    flag[0] = true;
    turn = 1;
    while (flag[1] && turn == 1);
    critical section;
    flag[0] = false;
    remainder section;
    ```

    p1 进程：

    ```c++
    flag[1] = true;
    turn = 0;
    while (flag[0] && turn == 0);
    critical section;
    flag[1] = false;
    remainder section;
    ```

    未解决“让权等待”原则。如果某个进程没进入临界区，仍然会占用 cpu 资源，发生“忙等”。

**中断屏蔽方法**

1. 开/关中断指令

    ```c++
    关中断;
    临界区;
    开中断;
    ```

    不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程。

1. TS （TestAndSetLock）指令，或 TSL 指令

    ```c++
    bool TestAndSet (bool *lock)
    {
        bool old;
        old = *lock;
        *lock = true;  // 无论之前是否加锁，都将 lock 设置为 true
        return old;  // 返回 lock 原来的值
    }
    ```

    ```c++
    while (TestAndSet (&lock));  // 上锁并检查
    ciritical section;
    lock = false;  // 解锁
    remainder section;
    ```

    tsl 指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作。适用于多处理机环境。

    不满足让权等待原则。

1. swap （又叫 exchange, 或简称 xchg）

    ```c++
    bool old = true;
    while (old == true)
        swap(&lock, &old);
    critical section;
    lock = false;
    ramainder section;
    ```

    swap 和 tsl 并无太大区别。无法实现让权等待。

**信号量机制**

信号量用来表示系统中某种资源的数量。

1. 整数型信号量

    一对原语：`wait(S)`，`signal(S)`。又称为`P(S)`，`V(S)`。

    ```c++
    int S = 1;

    void wait (int S) {
        while (S <= 0);
        S = S - 1;
    }

    void signal (int S) {
        S = S + 1;
    }
    ```

    进程 P0:

    ```c++
    wait(S);
    使用打印机资源 ...
    signal(S);
    ```

    进程 P1:

    ```c++
    wait(S);
    使用打印机资源 ...
    signal(S);
    ```

    ...

    进程 Pn:

    ```c++
    wait(S);
    使用打印机资源 ...
    signal(S);
    ```

    不满足“让权等待”原则。

1. 记录型信号量

    ```c++
    typedef struct {
        int value;
        struct process *L;
    } semaphore;
    ```

    如果剩余资源数不够，使用 block 原语使进程从运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中

    ```c++
    void wait (semaphore S) {
        S.value--;
        if (S.value < 0) {
            block (S.L);
        }
    }
    ```

    释放资源后，若还有别的进程在等待这种资源，则使用 wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态

    ```c++
    void signal (semaphore S) {
        s.value++;
        if (S.value <= 0) {
            wakeup(S.L);
        }
    }
    ```

    申请不到资源的进程会自我阻塞，放弃 cpu，遵循了“让权等待”原则。

**信号量实现进程互斥、同步和前驱**

mutex 是初值为 1 的信号量。

前驱指的是多层的一前一后关系（比如有向图）。需要为每一对前驱关系设置一个同步信号量。在“前操作”之后对相应的同步变量执行`V`操作，在“后操作”之前对相应的同步变量执行`P`操作。

## 一些问题

* 生产者、消费者问题

    生产者每次生产一个产品放入大小为 n 的缓冲区中，消费者每次从缓冲区中取出一个产品并使用。只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。缓冲区是临界资源，各进程必须互斥地访问。

    需要设置 3 个信号量：mutex, empty, full。mutex 用作互斥信号量，实现对缓冲区的互斥访问；empty 用作同步信号量，表示空闲缓冲区的数量；full 用作同步信号量，表示产品的数量，即非空缓冲区的数量。

    ```c++
    semaphore mutex = 1, empty = n, full = 0;

    producer() {
        while (1) {
            生产一个产品;
            P(empty);
            P(mutex);
            把产品放入缓冲区;
            V(mutex);
            V(full);
        }
    }

    consumer() {
        while (1) {
            P(full);
            P(mutex);
            从缓冲区取出一个产品;
            V(mutex);
            V(empty);
            使用产品;
        }
    }
    ```

    实现互斥的`P`操作一定要在实现同步的`P`操作之后，否则会发生死锁。

    `V`操作不会导致进程阻塞，因此两个`V`操作顺序可以交换。

* 多生产者，多消费者问题

* 吸烟者问题

* 读者、写者问题

* 哲学家进餐问题

## 管程

管程用于高级同步，由下面几个部分组成：

1. 局部于管程的**共享数据结构**说明；
1. 对该数据结构进行操作的**一组过程（函数）**；
1. 对局部于管程的共享数据设置初始值的语句；
1. 管程有一个名字。

管程的基本特征：

1. 局部于管程的数据只能被局部于管程的过程所访问
1. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
1. 每次仅允许一个进程在管程内执行某个内部过程

```c++
monitor ProducerConsumer
    condition full, empty;  // 条件变量用来实现同步（排队）
    int count = 0;  // 缓冲区中的产品数
    void insert (Item item) {  // 把产品 item 放入缓冲区
        if (count == N)
            wait (full);
        count++;
        insert_item (item);
        if (count == 1)
            signal (empty);
    }
    Item remove() {  // 从缓冲区中取出一个产品
        if (count == 0)
            wait (empty);
        count--;
        if (count == N-1)
            signal(full);
        return remove_item();
    }
end monitor;
```

生产者进程：

```c++
producer () {
    while (1) {
        item = 生产一个产品;
        ProdecerConsumer.insert(item);
    }
}
```

消费者进程：

```c++
consumer (){
    while (1) {
        item = ProdecerConsumer.remove();
        消费产品item;
    }
}
```

## 死锁

死锁：并发环境下，各进程因竞争资源而造成的*互相等待对方手里的资源，导致各进程都阻塞，无法向前推进*的现象。

饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。

死循环：某进程执行过程中一直跳不出某个循环的现象。

死锁产生的四个条件：

1. 互斥条件。资源是互斥的，不是共享的。
1. 不可剥夺条件。进程的资源只能主动释放。
1. 请求和保持条件。进程已经保持了至少一个资源，但又提出了新的请求。
1. 循环等待条件。存在一种进程资源的循环等待链。（发生循环等待时未必死锁，循环等待是死锁的必要不充分条件）

发生死锁的时机：

1. 对系统不可剥夺资源的竞争。（打印机是不可剥夺资源，CPU是可剥夺资源）
1. 进程推进顺序非法。
1. 信号量的使用不当。（信号量可看作是一种抽象的系统资源）

死锁的处理策略：

1. 预防死锁。破坏产生死锁的四个必要条件中的一个或几个。

    1. 破坏互斥条件

        比如 SPOOLing 技术，把独享设备改成共享设备。

    1. 破坏不剥夺条件

        某个进程请求不到新资源时，释放保持的所有资源。或者由操作系统强行剥夺资源。

    1. 破坏请求和保持条件

        采用静态分配方法。让进程一次性把所有资源申请完，若有某些资源得不到满足，则进程不投入运行。

    1. 破坏循环等待条件

        采用顺序资源分配法。每个进程必须按编号递增的顺序请求资源。这样就不可能由大编号等待小编号进程的资源。

1. 避免死锁。比如银行家算法。

    **安全序列**：如果系统按某种序列分配资源，则每个进程都能顺利完成。若系统进入了不安全状态，那么就有可能发生死锁。

    银行家算法：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。

1. 死锁的检测和解除。允许死锁的发生，但操作系统会检测并解除。

    死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。

    在化简资源分配图后，还连着边的那些进程就是死锁进程。

    解除死锁的方法：

    1. 资源剥夺法。

        挂起（暂时放到外存上）某些死锁进程，并抢占它的资源。

    1. 撤销进程法（终止进程法）

        强制撤销部分、甚至全部死锁进程。

    1. 进程回退法。让一个或多个进程回退到足以避免死锁的地步。

## 内存管理

逻辑地址（相对地址），绝对地址（物理地址）。

装入的方式：

1. 绝对装入

    在编译时程序知道内存的绝对地址。只适用于单道程序环境。

1. 静态重定位（可重定位装入）

    通过装入程序对地址重定位，将逻辑地址变成物理地址。作业在装入内存时，必须分配其要求的全部内存空间。适用于早期的多道批处理系统。

1. 动态重定位（动态运行时装入）

    把地址转换推迟到程序真正要执行时才进行。需要重定位寄存器的支持。适用于现代操作系统。

**内存保护**

各个进程间的内存独立。

保护的方法：

1. 在 CPU 中采用上限寄存器和下限寄存器，检查是否越界。

1. 重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）。界地址寄存器中存放的是进程的最大逻辑地址。

**覆盖与交换**

覆盖：将程序分成多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存。

内存中分了一个**固定区**和多个**覆盖区**。

必须由程序员声明覆盖结构。只适用于早期系统。

交换：内存空间紧张时，将某些进程暂时换出外存，换外存中某些已具备运行条件的进程换入内存。（进程在内存与磁盘间动态调度）即中级调度（内存调度）。也由此引出挂起态（阻塞挂起，就绪挂起）

**内存的分配**

1. 单一连续分配

    内存被分为系统区和用户区。内存中只能有一道用户程序。只适用于早期操作系统（MS-DOS）。

1. 固定分区分配

    将用户空间分成若干个固定大小的分区，每个分区中只装入一道作业。

    1. 分区大小相等
    1. 分区大小不等

    系统通过建立分区说明表，记录每个分区的大小、起始地址、状态（是否已分配），实现各个分区的分配与回收。

1. 动态分区分配

    在进程装入内存时，根据进程的大小动态地建立分区。

    记录内存使用情况：空闲分区表，空闲分区链。

    内部碎片：分配给某进程的内存区域中，有些地方没用上。

    外部碎片：内存中某些空闲分区太小而难以利用。解决：使用紧凑（compaction）技术进行内存整理。

    动态分区分配算法：

    1. first fit：效果最好。

    1. best fit：容易产生外部碎片

    1. worst fit：大进程不容易安放

    1. next fit：每次都从上次查找结束的位置开始检索。比 first fit 效率稍高一点点。

    分配与回收：修改分区表的分区大小和起始地址，分区链也差不多原理。

**分页（非连续分配管理）**

基本分页存储管理：把内存分成许多个大小相等的小分区（比如每个分区 4KB）。每个分区是一个*页框*（或*页帧*，*内存块*，*物理块*）。用户进程的地址空间也分为与页框大小相等的一个个区域，称为*页*或*页面*。

`页号：逻辑地址 / 页面长度`

`页内偏移量 = 逻辑地址 % 页面长度`

页面起始位置：采用某种数据结构维护。

如果用 k 位表示页内偏移量，那么说系统中一个页面的大小是`2^k`个内存单元。若有 m 位表示页号，则说明在系统中，一个进程最多允许有`2^m`个页面。对于 32 位的地址，若用 12 位表示页内偏移量，则`0 ~ 11`位为页内偏移量，或称*页内地址*；12 ~ 31 位为*页号*。 

有关页表的计算 P38。不是很懂。


