# 临时项目管理

这个文件中列出的项目，每天过一遍。

* 感觉 bash, makefile, cmake, sed, awk, vim 这几个都是挺重要的，把 qa 加上去吧，每天练习

* 以每 30mins 检测 2 个 qa 为准

* 每天的随机检测非常重要，一定要把时间均摊到每天。

* 旧的 qa 没复习完前就不要写新 qa 了，因为都不知道学到哪了，也不知道该整理什么资料

* 创建一个 qa 池和一个随机数生成器，每次先从 qa 池中随机挑选一个项目，然后再随机选一个 unit，进行检测

    如果遇到不会的 unit，那么找它的 dependency，如果 dependency 还不会，那么再找它的 dependency，以此类推。

    必须要把 qa 均摊在每一天内，这样的 qa 才有意义。

    目前重点先增加 cmake，c++ 和 vulkan 这三个。

每天应该先启动 D 系统任务执行系统，如果任务列表为空，那么跳转到这里，收集当天要执行的任务。

临时项目管理作为其他所有项目的依赖项目，作为根节点。每次都第一个启动，每次都从这里开始，每次都回退到这里。

每个项目开始之前，先进行随机检测。每个项目随机检测的时间不应该超过半个小时。

1. 项目调研 -> 产生项目规划

    寻找参考资源，简单分析项目可行性，分析项目依赖

2. 任务调研 -> 产生具体任务列表

    简单浏览一遍参考资源待看的部分，大概了解下材料的难度，细分再细分，直到感觉某个概念，某一段话，某个公式，自己可以短时间内搞定为止，将其写到任务列表上。

    更长远的思路写个大致的规划。

项目调研和任务调研也都算在任务清单中，他们所占用的时间和精力一点不比具体的任务少。

调研：如果对已有的书面学习材料的调研，那么就顺序阅读，不回看，如果理解顺利，那么一直看下去，直到遇到无法理解（解释有矛盾，或者有未知信息）的地方为止。最大调研时间 20 分钟，超过 20 则停止。

调研时需要回答的几个问题：

1. 看了刚才的内容，我能否用它来做一些事情？和过去我学过的内容有什么关系？

    如果这个问题可以回答，那么就将它加入任务列表里。

1. 刚才看过的内容，里面的每个概念我能否用自己的话描述？

    如果不能描述，那么中止。如果这个答案依赖某个遗忘的内容，那么将复习遗忘内容加到任务列表里。如果这个答案依赖一个未知的内容，那么将新的调研加入到任务列表里。

调研与具体的任务安排都是平等的关系。

假设：我们假设人脑每次能处理的任务的复杂程度有限，每次处理一项任务的最大时间也有限。因此需要把任务切分成刚好够人脑处理的一个片断。

未来需要做什么的任务列表固然很重要，但是描述自己在过去的一段时间里做了什么同样重要。

每个项目都尽量遵循 复习（随机检测 qa） -> 学习 -> 调研 的步骤，不一定按这个顺序，但这三项起码要有。

有关“学习”：

1. 这里的学习是一个专有概念，其行为包括但不限于，阅读学习材料，做实验验证学习资料上的内容，做实验验证自己的猜想，记笔记，写一个新的 qa，完成任务列表上的任务

目前遇到的最大问题就是，有些问题不清楚能否解决，不清楚靠什么解决，只有在尝试解决的时候才会遇到很多新问题，并不断用已有知识去解决新问题。这样解决问题的思路就像一个无底洞，无法预知解决的时间，只能靠不断往其中投入时间。这类问题目前仍没有很好的解决方案。

不做任务执行系统，就没有顿挫的感觉，就不可能有高效率。只与项目池打交道，会产生无穷无尽的任务，从而无法分辨任务的边界，导致效率越来越低。

qa 一定要基于 note，而不是独立于 note。qa 与 note 最大的区别在于，qa 是条目式的，缺少细节，并且有 dependency，而 note 专注结构和细节，并且有更多的思考和延伸参考资料。

* 需要一个 graph 工具，建立不同的东西之间的连接

    stack 工具只适合任务的 trace

* 一个比较好的 explore 的想法是先从 amazon 上搜索书籍，然后在 zlib 或 libgen 上下载

* 有关笔记的整理

    可以消除一些笔记中穿插的一些 reference 资源，或者将资源提取出来。

* 缓存策略和 stack 策略都非常有用，使得条理很清晰

* [思考] 无论是 qa 还是 note，除了添加内容，更需要优化。这个优化该如何进行？

    如果只添加内容，不优化内容，那么东西越来越多，而且组织混乱。

    目前正在进行的一个优化是将按时间顺序写下的笔记，重新整理成按结构存储的数据。

* 每天结束前整理当天的 feedback

    比较紧急的写到系统里，不太紧急的写到 log 里，每周批量处理

* 显然项目管理系统需要每天更新，因为任务执行系统会改变项目管理系统中的内容

    而且项目管理系统必须是当天结束时更新，这样才能不对第二天收集任务清单造成影响

* log 不应该与 task 放在同一个文件里，翻来翻去太费时间

* 思考：像这种既没有经验，也没有参考，只能靠临时反应进行和大量交互进行下去的任务，该如何分配时间？

    没有任何的可借鉴经验，不清楚结果，这种任务被称为 blackhole task.

## qa

目前的 qa 项目：vulkan, c++, vim, cmake, makefile

把 vim 加入到每日 qa 中

* qa 的每个 unit 设计不应过于复杂。如果实际检测时间超过 30 mins，那么需要拆开。

    这里的拆开指的是写成 dependency 的形式，如果 dependency 之间做过，那么直接复杂 dep 的结果，从而减少当前 unit 的 exam 时间。

## Vulkan 学习 [0]

参考资料：

1. pdf 电子书《vulkan_tutorial_en》

2. 配套代码 <https://github.com/Overv/VulkanTutorial/blob/main/code/22_descriptor_set_layout.cpp>

3. pdf 电子书 vulkan programming guide

依赖项目：

1. 英语单词

近期的目标是画出一个三角形。听说 vulkan 自带了 ray tracing 功能，学到后面的话看看吧。

目前主要在看 descriptor set，先能独立画出一个彩色三角形。

然后看一下 uniform buffer 相关的，让三角形动起来。

再看一看 model loading，学会加载模型。

接下来看 compute shader 相关的东西。

添加一个 resource，官方的 vulkan programming guide。

* `vkGetDeviceQueue`指定的 queue 有数量总数吗？

* 为什么<https://github.com/Overv/VulkanTutorial/blob/main/code/22_descriptor_set_layout.cpp>没有用到 layout pool ?也没有用到 allocate，直接就是 create，为什么？


任务列表：

1. [v] 调研 Physical devices and queue families P58 ~ P65，给出任务列表

    看起来仍然是通过枚举的方式找到需要的设备。

    0. [ ] [学习] P58 ～ P61，尝试将 amd 的 gpu 枚举出来

    1. [ ] [学习] P61 ~ P65，尝试列出 amd device 的 queue family

2. [ ] 调研 P65 Logical device and queues，给出任务列表

3. [ ] 调研 P169 ~ P185 Uniform buffers，给出任务列表

4. [ ] 177 ~ 185 descriptor sets

    1. descriptor pool 在创建时需要提供什么？

    2. 假如 descriptor set 需要 allocate，那么说明资源是有限的，分配是自动的。

    3. 直接看代码吧，书上讲的太乱了，而且废话太多。

5. vulkan programming guide

    侧重一下 renderpass 和 subpass 的关系，barrier 对 image layout 的转换，以及 copy image from buffer

    sparse memory 是干嘛用的，看书上的意思，是可以让资源对象在运行时重新绑定到一块不同的内存上？

    1. P47 ~ P52

        feedback:

        1. allocator 明显目前用不到，而且也没有做实验的时间，也不能抄书做 note，因此这部分就应该跳过。

            那么这样的内容明显就不是一次能消化完的，只能做个大概的总结，需要下次任务再看一遍。

        2. 找一个 allocator 的 example

    2. P52 ~ P58
    3. P58 ~ P71
    4. P71 ~ P77
    5. P77 ~ P78
    6. chapter 3 and later

    7. moving data

## OpenCL 学习 [1]

参考资料：

1. pdf 电子书《pdfcoffee.com_opencl-programming-guidepdf-pdf-free》

2. 其他网上的资料

基本的东西会了，剩下的系统地看一看吧，查漏补缺。

重点看一看内置函数。

任务列表：

1. [v] 尝试一下 xyzw 索引和 s数字 索引

2. [v] 从 P117 看到 P123，显式类型转换，简单试验几个，记几个常用的

3. [ ] P133 开始看各种修饰符。这个可能和内存的属性有关，感觉还是挺重要的

    0. [ ] Address Space Qualifiers P135 ~ P140，四种内存地址类型，以及不同类型之间的转换

        0. [v] Global Address Space

        1. [ ] constant address space

            constant 是编译器直接写在程序的常量区吗？

        2. [ ] local address space

        3. [ ] private address space

        local 真的会比 global 快吗？

    1. P140 Access Qualifiers

    2. P141 Type Qualifiers

4. [ ] 从 P149 开始调研第 5 章内置函数，给出任务列表

    0. Work-Item Functions P150 ~ P152

    1. Math functions P153 ~ P168

    2. 调研 others

## 计算机图形学 学习 [2]

参考资料：

1. 虎书《Fundamentals-of-Computer-Graphics-Fourth-Edition》

2. Games 101

3. 其他网上的资料

依赖项目：

1. 英语单词

数学基础目前还算够用，每天记录一点点公式就可以了，一个概念，一段话，一个公式，不需要学习太多。

目前已经看完了第四章 ray tracing，并做了代码的实现。现在想先看一看光栅化的 pipeline，自己去尝试光栅化一条直线，一个三角形。

后续的安排是调研一下第 13 章，慢慢学一些折射，透明的效果。

任务列表：

1. 数学基础

    1. [ ] P18 ~ P20 三角形定义与常用的三角函数性质

        看了反三角函数，其中最有用的是 atan2。实际上也确实是这样。不过 atan2 的两个参数是 (y, x) 还是 (x, y)？

    1. P22 2.4.2 Cartesian Coordinates of a Vector

    1. P24 2.4.4 Cross Product

    1. P30 2.5 Curves and Surfaces

    1. 如何以一组向量为基，表示任意一个向量？

1. 光栅化 pipeline 部分

    1. [v] P161 8.1.1 line drawing，用代码实现一下

    1. [ ] 直线的光栅化还有一个用增量的方式判断，简单了解下记个笔记就行，不用实现

    1. P164 8.1.2 Triangle Rasterization 尝试学习，理解

1. 光追渲染部分

    1. [v] 调研折射效果

    1. [ ] P324 ~ P327 13.1 折射，尝试实现一个透明球体

        已经实现了求折射射线，接下来尝试求反射光强度$R(\theta)$。

        对于一个透明物体，尝试找到出射点。

        使用 ri ratio 来判断是否进入或离开物体可行吗？如果摄像机在水中，这个方法是否会失效？

        如果这种方法失效，是否有更好的解决方案？

    1. P327 ~ P328 13.2 实例化，更方便地采样

        这一段及后面的慢慢看

    1. P328 ~ P329 13.3 使用布尔操作构造新物体

    1. P329 13.4 distribution ray tracing，目前还没仔细调研

1. 辐射度量学 Light 章节

    1. [ ] 重新从头整理一遍辐射度量学的公式和笔记 60mins

        要求书上任意一个地方都可以找到对应的笔记。

        要求可以解释**笔记中**任意一个字母的含义，公式的推导。

        已经整理完了 irradiance 相关的东西，接下来整理 radiance 相关的内容。在笔记里想把 radiance 和$L_f$调换一下位置，同时弄清楚 radiance 的具体含义。

        任务中止原因：达到了最大知识容纳限度。

1. Color 章节

    这一章讲怎么把辐射转换成人眼可见的颜色。

## 解析几何 学习

参考资料：

1. 《Gordon Fuller - Analytic Geometry-ADDISON-WESLEY @ (1954)》

依赖项目：

1. 英语单词

希望能学到些有关参数方程的知识，其他的知识就当作查漏补缺。

任务列表：

1. [ ] 调研全书，列出几个感兴趣的部分，继续调研

## 基于路径追踪的全局光照

参考资料：

1. firefox 上打开的 tab

1. Games101 的 slides

    <https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html>

1. 别人基于 games101 的一个 c++ 实现

    <https://github.com/zhiwei-c/Monte-Carlo-Path-Tracing/tree/main>

1. 路径追踪的知乎专栏

    <https://zhuanlan.zhihu.com/p/475547095>

不需要深度调研，简单跑跑 demo，研究下代码就可以了。

依赖项目：

1. 计算机图形学

    必须熟悉完计算机图形学 Light 和 Color 两个章节后，再来做这个项目。

任务列表：

1. 调研 Global Illumination project，尝试照着他的思路，实现一个差不多的渲染器

1. 实现 refraction 效果

    1. 实现 reflectance

    1. 计算折射衰减

1. [v] 屏蔽 refraction 效果，先实现一个 path tracing

1. [v] 创建一个房间场景，让光在房间中弹射

1. [v] 对接场景文件

1. 将任务拆分并并行化，使用 opencl 加速

1. 实现更多的效果，比如贴图采样，抗锯齿

1. 完成 blender, maya 插件开发

    1. [ ] [调研] 调研 blender 插件开发的 sdk，看看能不能找到类似场景文件的东西或与渲染器输入输出相关的资料。

## 英语单词

参考资料：

1. `english_words.md`

这个项目作为被依赖的项目而启动。

## 随机检测

现在主要需要实现 new, prev rand 的功能。等这两个实现后，需要实现 dependency 的功能，根据一个条目，可以查到它的依赖条目，根据依赖条目。

任务列表：

1. 实现功能：随机打开一个项目，随机进行检测

2. 根据指定条目，查找到它的依赖条目。

    每个条目

## 调研 kmd 在 container 中运行的可行性

1. 使用`sed`替换整行，替换的字符串中，有`$()`命令得到的系统信息

1. 在 44 机器上搭建 kmd 编译环境，成功编译出 xdx 的 kmd

1. 在 server 上拉取 umd 的代码，使用上海镜像

1. 在 44 机器上搭建 umd 的编译环境，成功编译出 umd

1. 调研 kmd 代码，查看其构成，尝试找到负责与 pci 交互的那一部分

1. 调研 modprobe 和 depmod 的作用，并写代码实践

## 编译调研

## 调研 meson, ninja

## 分布式计算调研

## 微积分

## 其他

1. 指针的指针，区分指针的指针所指的内容不能被修改，指针所指的内容不能被修改（指针的指针本身不能被修改），指针本身不能被修改

    分别如何 new, malloc

* gnu 出的这一套 makefile 教程，我觉得写得还不错，条理挺清晰的，有时间了看看

    Ref: <https://www.gnu.org/software/make/manual/html_node/Conditional-Example.html>

* makefile 的 tutorial

    <https://www.gnu.org/software/make/manual/html_node/Using-Variables.html>

    <https://stackoverflow.com/questions/2145590/what-is-the-purpose-of-phony-in-a-makefile>

    有时间了接着看

* c++ 版本的 opencl 入门

    <https://objectcomputing.com/resources/publications/sett/july-2011-gpu-computing-with-opencl>

* modern c++

    <https://github.com/federico-busato/Modern-CPP-Programming>

* libeigen

    other linger algebra libraries: <https://stackoverflow.com/questions/1380371/what-are-the-most-widely-used-c-vector-matrix-math-linear-algebra-libraries-a>

    以 libeigen 为主，其他的库对比着学下。

    * numcpp

        矩阵运算库

        <https://github.com/dpilger26/NumCpp>

        <https://zhuanlan.zhihu.com/p/341485401>

* 将 c++ `nth_element` 的使用加入到 qa 中。

* 学一下 c++ 的 std format

* 当一个程序越来越大时，如何能快速知道以前开发过了什么功能，快速对自己的项目上手，这个问题需要思考一下

    目前一个思路是对当前项目也写一个简易的 qa，安排进检测列表

* 思考：如果想完善 qa 的内容，该怎么办？

* vim 中的 redo 是哪个？

