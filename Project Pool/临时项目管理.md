# 临时项目管理

这个文件中列出的项目，每天过一遍。

每天应该先启动任务执行系统，如果任务列表为空，那么跳转到这里，收集当天要执行的任务。

将任务管理系统作为一个基本的项目，每周至少整理一次。

每个项目都尽量遵循 复习（随机检测 qa） -> 学习 -> 调研 的步骤，不一定按这个顺序，但这三项起码要有。

有关“学习”：

1. 这里的学习是一个专有概念，其行为包括但不限于，阅读学习材料，做实验验证学习资料上的内容，做实验验证自己的猜想，记笔记，写一个新的 qa，完成任务列表上的任务

目前遇到的最大问题就是，有些问题不清楚能否解决，不清楚靠什么解决，只有在尝试解决的时候才会遇到很多新问题，并不断用已有知识去解决新问题。这样解决问题的思路就像一个无底洞，无法预知解决的时间，只能靠不断往其中投入时间。这类问题目前仍没有很好的解决方案。

不做任务执行系统，就没有顿挫的感觉，就不可能有高效率。只与项目池打交道，会产生无穷无尽的任务，从而无法分辨任务的边界，导致效率越来越低。

* 需要一个 graph 工具，建立不同的东西之间的连接

    stack 工具只适合任务的 trace

* 一个比较好的 explore 的想法是先从 amazon 上搜索书籍，然后在 zlib 或 libgen 上下载

* [思考] 无论是 qa 还是 note，除了添加内容，更需要优化。这个优化该如何进行？

    如果只添加内容，不优化内容，那么东西越来越多，而且组织混乱。

    目前正在进行的一个优化是将按时间顺序写下的笔记，重新整理成按结构存储的数据。

* 每天的与任务相关的 feedback 要整理到临时项目管理里

    显然项目管理系统需要每天更新，因为任务执行系统会改变项目管理系统中的内容

    而且项目管理系统必须是当天结束时更新，这样才能不对第二天收集任务清单造成影响

    可以先存放到 cache 中，每三天整理一次

* log 不应该与 task 放在同一个文件里，翻来翻去太费时间

## cached

* cacHed task

    cmake 环境变量的用法

* [ ] compiler: 整理编译器的笔记，并创建一个 qa

* 所谓调研就是在尽量不做实验的情况下，看看能理解多少东西，不理解的东西就记下来

* 如果遇到的知识是条目式的，没有理解难度，但是数量比较大，是否该将其列入到记忆任务中？还是说调研时先跳过？

* 暴露的接口越多，代码越底层，可组合的方式就越多，功能越强大，编程越繁琐难用

    可见代码量也是评价一个库是否好用的参考标准

    反过来想，如果要实现一个功能，拆分了代码后，并不能增加可组合的方式，那么它就一定是需要优化的。

    比如 vulkan，虽然比 opengl 繁琐，但是完全支持异步，多线程，这就是拆分功能的代价。

* 对于黑洞任务，应该用时间去限制

    比如只执行 30 分钟，然后整理一下已经得到的信息，解决的问题，尝试对未来的进度进行估计。

    这样的过程应该被称为采样。

* 低频（主能量）信息对应的是直觉，高频（低能量）信息对应的是强推理

* 思考 qa 的 dependency 机制

* 应该三天整理一次 log

    五天整理一次 log 会花将近一个小时

* 临时项目管理中的项目不应该超过 7 个, 不然就管理不过来了

* 以后可以把 cache tabs 的时间缩减到 15 分钟

* 每天离开工作区之前应该把 task 中的 feedback 整合到临时项目管理中

* 深度学习和数学最本质的区别是，深度学习只告诉你他的方法为什么行，不告诉你别人的方法为什么不行，而数学会同时告诉你这两者

* 可以规定一下，如果 2 天（或者 3 天）都能通过某个 domain 的 qa，那么就可以申请增加新的 qa。

* 为什么`g++ -g main.cpp -lvulkan -lglfw -o main`可以通过编译，`g++ -g -lvulkan -lglfw main.cpp -o main`就不行？

* 顺着笔记找 qa 效率并不高，更好的做法是随机在笔记的后面部分找一个问题，然后写到 qa 里，再倒过来找 qa 的 dependency.

* note 的每个 item 也尽量控制得短一些，类似代码的函数长度

* 把正则表达式加入到项目中

* 进度的 sync

    如果一个项目长时间不合理发展，就会出现调研、 qa 和笔记不匹配的情况。这种情况下，需要对进度进行 sync，确认下面几个问题：

    1. 如果无法从学习资料中总结出新的笔记，那么认为学习和笔记的 sync 完成

    1. 如果无法再从笔记中找到一个新的 qa，那么认为 qa 和笔记的 sync 完成

    1. qa 里不能有 empty

    1. test, qa 文件夹 clean

    显然，项目进度的 sync 不应该出现在项目管理里，而应该由任务执行系统负责。

* 应该提出 cached tasks, cached questions 这些概念

* 以后再做 c++ 的 qa，要么写一点点语法，要么就是做题

* 找一个 c++ 学习资料，系统学一下比较好

* 学习资源的调研主要用于完成下面几件事情

    1. 发现学习资源里，是否有需要做实验验证的地方，是否可以用实验验证他说的，是否有可以用实验澄清的模糊不清的表达

    2. 语言表达是否有歧义

    3. 未完待续

* 其实与 cache 对应的是工作区（working area），而工作区的整洁是 stack　的要求，不然各种回退操作都会混乱，没有办法快速定位到想要的资源

* 其实调研也是一种是 cache，是一种广度优先搜索，它安排了必须要回答的问题，优化了任务列表的结构，整合了小范围内的信息，防止有歧义在前，回答在后的情况发生

    调研不做实验，不使用实验对猜想做验证

* 需要一个指标来评价当天有多少时间是被任务系统接管的，就叫它接管率好了

    接管率从一定程度止反映了专心程度

* cache tabs

    把开的标签页处理完后，就该每天处理缓存的 url 了

* 将刷题记录到项目管理里

## qa

cached:

* 一个 qa 文件里所有的 unit 平分 1

    然后每次遇到熟悉的 unit，可以让这个 unit 的权重减少 n% (暂定 10%)，然后重新分配所有权重，总和仍然是 1

* 需要给每个 unit 设置一个比重，在抽取随机数时按比重抽取

    感觉比较熟悉的，之前重复出现过的 unit，可以把比重设置得低一点

* cmake qa:

    修改`使用 cmake 根据下面的代码编译出`libhmath.so`库，然后编译出可执行文件。`的`[u_0]`。

    增加`mymath.h`和`mymath.cpp`相关内容。

* vulkan qa

    将`[u_0]`：`创建一个 vulkan instance。`对应的`[u_1]`改成

    ```cpp
    #define GLFW_INCLUDE_VULKAN
    #include <GLFW/glfw3.h>

    int main()
    {
        glfwInit();
        uint32_t glfw_req_inst_ext_cnt;
        const char **glfw_req_inst_exts = glfwGetRequiredInstanceExtensions(&glfw_req_inst_ext_cnt);

        VkInstance inst;
        VkInstanceCreateInfo inst_crt_info{};
        inst_crt_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
        inst_crt_info.enabledExtensionCount = glfw_req_inst_ext_cnt;
        inst_crt_info.ppEnabledExtensionNames = glfw_req_inst_exts;
        VkApplicationInfo app_info{};
        app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
        app_info.apiVersion = VK_API_VERSION_1_0;
        app_info.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
        app_info.engineVersion = VK_MAKE_VERSION(1, 0, 0);
        app_info.pApplicationName = "hello";
        app_info.pEngineName = "no engine"; 
        inst_crt_info.pApplicationInfo = &app_info;
        VkResult result;
        result = vkCreateInstance(&inst_crt_info, nullptr, &inst);
        if (result != VK_SUCCESS)
        {
            printf("fail to create vk instance.\n");
            exit(-1);
        }
        printf("successfully create a vulkan instance.\n");
        return 0;
    }
    ```

    这样写比较简洁。

    并将`[u_0]`改成只创建 instance，不创建 debug messenger

* opencl qa

    将`[u_0]`，``请写一个向量相加的算子`add`。``对应的`[u_1]`改为

    ```opencl
    kernel void add(global float *A, global float *B, global float *out)
    {
        size_t id = get_global_id(0);
        out[id] = A[id] + B[id];
    }
    ```

* opengl qa

    完善或删除或缓存 `请使用 VBO 画一个 cube。`

    因为`[u_1]`目前还是 empty，所以不要让他出现在 qa 中。

目前的 qa 项目： vulkan, c++, vim, cmake, makefile

* 感觉 bash, makefile, cmake, sed, awk, vim 这几个都是挺重要的，把 qa 加上去吧，每天练习

* qa 的每个 unit 设计不应过于复杂。如果实际检测时间超过 30 mins，那么需要拆开。

    这里的拆开指的是写成 dependency 的形式，如果 dependency 之间做过，那么直接复杂 dep 的结果，从而减少当前 unit 的 exam 时间。

* 给随机检测增加新功能

    * 使用`./main --generate-id`根据当前时间创建一个新的哈希值

    * 使用`./main --id-to-idx <id> <qa_file>`找到指定哈希值的索引

    * 在 vim 中根据正则表达式搜索指定索引所在的位置

    * 修复`--list`的 bug。

        在找到`[u_0]`后，只要找到下一个`[xxx]`模式就可以了，`[u_0]`的内容为`[u_0]`往后，`[xxx]`往前。

        dep:

        * 正则表达式

    * [v] 使用`./main --update-idx <qa_file>`更新所有 unit 的 idx 

* 把 vim 加入到每日 qa 中

## Vulkan 学习 [0]

* cached

    * vulkan 使用 uniform buffer 改变三角形的颜色 final code

        ```cpp
        #include "../simple_vulkan/simple_vk.hpp"

        int main()
        {
            VkResult result;
            glfwInit();
            VkInstance inst;
            create_vk_instance(inst);
            glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
            GLFWwindow *window = glfwCreateWindow(700, 500, "hello", nullptr, nullptr);
            VkSurfaceKHR surf;
            glfwCreateWindowSurface(inst, window, nullptr, &surf);
            VkPhysicalDevice phy_dev;
            uint32_t queue_family_idx;
            select_vk_physical_device(phy_dev, queue_family_idx, queue_family_idx, inst, surf);
            VkDevice device;
            VkQueue queue;
            create_vk_device(device, queue, queue, phy_dev, queue_family_idx, queue_family_idx);
            VkSwapchainKHR swpch;
            create_vk_swapchain(swpch, device, surf, queue_family_idx);
            VkRenderPass render_pass = create_render_pass(VK_FORMAT_B8G8R8A8_SRGB, device);

            // create pipeline
            auto vert_shader_code = read_file("vert_2.spv");  // "vert_2.spv"
            auto frag_shader_code = read_file("frag_2.spv");  // "frag_2.spv"
            VkShaderModule vertShaderModule = create_shader_module(vert_shader_code, device);
            VkShaderModule fragShaderModule = create_shader_module(frag_shader_code, device);
            VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
            vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
            vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
            vertShaderStageInfo.module = vertShaderModule;
            vertShaderStageInfo.pName = "main";
            VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
            fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
            fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
            fragShaderStageInfo.module = fragShaderModule;
            fragShaderStageInfo.pName = "main";
            VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};
            
            VkVertexInputBindingDescription vtx_binding_desc{};
            vtx_binding_desc.binding = 0;
            vtx_binding_desc.stride = sizeof(float) * 3;  // (x, y, z) 三个分量
            vtx_binding_desc.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

            VkVertexInputAttributeDescription vtx_attr_desc{};
            vtx_attr_desc.binding = 0;
            vtx_attr_desc.location = 0;
            vtx_attr_desc.format = VK_FORMAT_R32G32B32_SFLOAT;
            vtx_attr_desc.offset = 0;

            VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
            vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
            vertexInputInfo.vertexBindingDescriptionCount = 1;
            vertexInputInfo.pVertexBindingDescriptions = &vtx_binding_desc;
            vertexInputInfo.vertexAttributeDescriptionCount = 1;
            vertexInputInfo.pVertexAttributeDescriptions = &vtx_attr_desc;

            VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
            inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
            inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
            inputAssembly.primitiveRestartEnable = VK_FALSE;

            VkPipelineViewportStateCreateInfo viewportState{};
            viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
            viewportState.viewportCount = 1;
            viewportState.scissorCount = 1;

            VkPipelineRasterizationStateCreateInfo rasterizer{};
            rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
            rasterizer.depthClampEnable = VK_FALSE;
            rasterizer.rasterizerDiscardEnable = VK_FALSE;
            rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
            rasterizer.lineWidth = 1.0f;
            rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
            rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
            rasterizer.depthBiasEnable = VK_FALSE;

            VkPipelineMultisampleStateCreateInfo multisampling{};
            multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
            multisampling.sampleShadingEnable = VK_FALSE;
            multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

            VkPipelineColorBlendAttachmentState colorBlendAttachment{};
            colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
            colorBlendAttachment.blendEnable = VK_FALSE;

            VkPipelineColorBlendStateCreateInfo colorBlending{};
            colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
            colorBlending.logicOpEnable = VK_FALSE;
            colorBlending.logicOp = VK_LOGIC_OP_COPY;
            colorBlending.attachmentCount = 1;
            colorBlending.pAttachments = &colorBlendAttachment;
            colorBlending.blendConstants[0] = 0.0f;
            colorBlending.blendConstants[1] = 0.0f;
            colorBlending.blendConstants[2] = 0.0f;
            colorBlending.blendConstants[3] = 0.0f;

            std::vector<VkDynamicState> dynamicStates = {
                VK_DYNAMIC_STATE_VIEWPORT,
                VK_DYNAMIC_STATE_SCISSOR
            };
            VkPipelineDynamicStateCreateInfo dynamicState{};
            dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
            dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
            dynamicState.pDynamicStates = dynamicStates.data();

            VkDescriptorPoolCreateInfo desc_pool_crt_info{};
            desc_pool_crt_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
            desc_pool_crt_info.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
            desc_pool_crt_info.maxSets = 5;
            desc_pool_crt_info.poolSizeCount = 1;
            VkDescriptorPoolSize desc_pool_size{};
            desc_pool_size.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
            desc_pool_size.descriptorCount = 2;
            desc_pool_crt_info.pPoolSizes = &desc_pool_size;
            VkDescriptorPool desc_pool;
            result = vkCreateDescriptorPool(device, &desc_pool_crt_info, nullptr, &desc_pool);
            if (result != VK_SUCCESS)
            {
                printf("fail to create descriptor pool, error code: %d\n", result);
                exit(-1);
            }

            VkDescriptorSetLayout desc_set_layout;
            VkDescriptorSetLayoutCreateInfo desc_set_layout_crt_info{};
            desc_set_layout_crt_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
            desc_set_layout_crt_info.bindingCount = 1;
            VkDescriptorSetLayoutBinding desc_set_layout_binding{};
            desc_set_layout_binding.binding = 0;
            desc_set_layout_binding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
            desc_set_layout_binding.descriptorCount = 1;
            desc_set_layout_binding.stageFlags = VK_SHADER_STAGE_ALL;
            desc_set_layout_crt_info.pBindings = &desc_set_layout_binding;
            result = vkCreateDescriptorSetLayout(device, &desc_set_layout_crt_info, nullptr, &desc_set_layout);
            if (result != VK_SUCCESS)
            {
                printf("fail to create descriptor set layout, error code: %d\n", result);
                exit(-1);
            }

            VkDescriptorSet desc_set;
            VkDescriptorSetAllocateInfo desc_set_allo_info{};
            desc_set_allo_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
            desc_set_allo_info.pSetLayouts = &desc_set_layout;
            desc_set_allo_info.descriptorSetCount = 1;
            desc_set_allo_info.descriptorPool = desc_pool;
            result = vkAllocateDescriptorSets(device, &desc_set_allo_info, &desc_set);
            if (result != VK_SUCCESS)
            {
                printf("fail to allocate descriptor set, error code: %d\n", result);
                exit(-1);
            }

            VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
            pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
            pipelineLayoutInfo.setLayoutCount = 1;
            pipelineLayoutInfo.pSetLayouts = &desc_set_layout;
            pipelineLayoutInfo.pushConstantRangeCount = 0;
            VkPipelineLayout pipelineLayout;
            vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout);

            VkGraphicsPipelineCreateInfo pipelineInfo{};
            pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
            pipelineInfo.stageCount = 2;
            pipelineInfo.pStages = shaderStages;
            pipelineInfo.pVertexInputState = &vertexInputInfo;
            pipelineInfo.pInputAssemblyState = &inputAssembly;
            pipelineInfo.pViewportState = &viewportState;
            pipelineInfo.pRasterizationState = &rasterizer;
            pipelineInfo.pMultisampleState = &multisampling;
            pipelineInfo.pColorBlendState = &colorBlending;
            pipelineInfo.pDynamicState = &dynamicState;
            pipelineInfo.layout = pipelineLayout;
            pipelineInfo.renderPass = render_pass;
            pipelineInfo.subpass = 0;
            pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

            VkPipeline pipeline;
            if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline) != VK_SUCCESS) {
                throw std::runtime_error("failed to create graphics pipeline!");
            }

            // VkPipeline pipeline = create_pipeline("./vert_2.spv", "frag_2.spv", 9 * sizeof(float), {0, 3 * sizeof(float)}, device, {700, 500}, render_pass);
            
            uint32_t swpch_img_count;
            vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, nullptr);
            std::vector<VkImage> swpch_imgs(swpch_img_count);
            vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, swpch_imgs.data());

            std::vector<VkImageView> swpch_img_views(swpch_img_count);
            VkImageViewCreateInfo img_view_crt_info{};
            img_view_crt_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
            img_view_crt_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
            img_view_crt_info.format = VK_FORMAT_B8G8R8A8_SRGB;
            img_view_crt_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};
            for (int i = 0; i < swpch_img_count; ++i)
            {
                img_view_crt_info.image = swpch_imgs[i];
                result = vkCreateImageView(device, &img_view_crt_info, nullptr, &swpch_img_views[i]);
                if (result != VK_SUCCESS)
                {
                    printf("fail to create image view, error code %d\n", result);
                    exit(-1);
                }
            }

            VkFramebufferCreateInfo frame_buf_crt_info{};
            frame_buf_crt_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
            frame_buf_crt_info.renderPass = render_pass;
            frame_buf_crt_info.attachmentCount = 1;
            frame_buf_crt_info.width = 700;
            frame_buf_crt_info.height = 500;
            frame_buf_crt_info.layers = 1;
            std::vector<VkFramebuffer> frame_bufs(swpch_img_count);
            for (int i = 0; i < swpch_img_count; ++i)
            {
                frame_buf_crt_info.pAttachments = &swpch_img_views[i];
                result = vkCreateFramebuffer(device, &frame_buf_crt_info, nullptr, &frame_bufs[i]);
                if (result != VK_SUCCESS)
                {
                    printf("fail to create frame buffer, error code: %d\n", result);
                    exit(-1);
                }
            }

            VkCommandPool cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
            cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
            VkCommandBuffer cmd_buf;
            VkCommandBufferAllocateInfo cmd_buf_alc_info{};
            cmd_buf_alc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
            cmd_buf_alc_info.commandBufferCount = 1;
            cmd_buf_alc_info.commandPool = cmd_pool;
            cmd_buf_alc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
            result = vkAllocateCommandBuffers(device, &cmd_buf_alc_info, &cmd_buf);
            if (result != VK_SUCCESS)
            {
                printf("fail to allocate command buffer\n");
                exit(-1);
            }

            float vtxs[9] = {
                0, -1, 0,
                1, 1, 0,
                -1, 1, 0
            };
            VkBuffer vtx_buf;
            VkDeviceMemory vtx_buf_mem;
            create_vk_buffer(vtx_buf, vtx_buf_mem, phy_dev, device, 3 * 3 * sizeof(float), VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
            float *p_mem_data = nullptr;
            result = vkMapMemory(device, vtx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
            memcpy(p_mem_data, vtxs, sizeof(vtxs));
            vkUnmapMemory(device, vtx_buf_mem);
            vkDeviceWaitIdle(device);

            float temp_mem[9];
            vkMapMemory(device, vtx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
            memcpy(temp_mem, p_mem_data, sizeof(vtxs));
            vkUnmapMemory(device, vtx_buf_mem);

            uint32_t idxs[3] = {0, 1, 2};
            VkBuffer idx_buf;
            VkDeviceMemory idx_buf_mem;
            create_vk_buffer(idx_buf, idx_buf_mem, phy_dev, device, sizeof(idxs), VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
            vkMapMemory(device, idx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
            memcpy(p_mem_data, idxs, sizeof(idxs));
            vkUnmapMemory(device, idx_buf_mem);

            float rgb[3] = {0.8, 0.5, 0.5};
            VkBuffer color_buf;
            VkDeviceMemory color_buf_mem;
            create_vk_buffer(color_buf, color_buf_mem, phy_dev, device, sizeof(float) * 3, 
                VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
            vkMapMemory(device, color_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
            memcpy(p_mem_data, rgb, sizeof(rgb));
            vkUnmapMemory(device, color_buf_mem);

            VkWriteDescriptorSet wrt_desc_set{};
            wrt_desc_set.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
            wrt_desc_set.dstSet = desc_set;
            VkDescriptorBufferInfo desc_buf_info{};
            desc_buf_info.buffer = color_buf;
            wrt_desc_set.pBufferInfo = &desc_buf_info;
            wrt_desc_set.descriptorCount = 1;
            desc_buf_info.offset = 0;
            desc_buf_info.range = VK_WHOLE_SIZE;
            wrt_desc_set.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
            wrt_desc_set.dstArrayElement = 0;
            wrt_desc_set.dstBinding = 0;
            vkUpdateDescriptorSets(device, 1, &wrt_desc_set, 0, nullptr);

            VkSemaphore sem_finish_rendering = create_semaphore(device);
            VkSemaphore sem_img_available = create_semaphore(device);
            VkFence fence_acq_img = create_fence(device);
            VkFence fence_queue_submit = create_fence(device);

            vkResetFences(device, 1, &fence_acq_img);
            uint32_t available_img_idx;
            result = vkAcquireNextImageKHR(device, swpch, UINT64_MAX, sem_img_available, fence_acq_img, &available_img_idx);

            VkCommandBufferBeginInfo cmd_buf_beg_info{};
            cmd_buf_beg_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
            cmd_buf_beg_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
            vkBeginCommandBuffer(cmd_buf, &cmd_buf_beg_info);

                VkRenderPassBeginInfo rdps_beg_info{};
                rdps_beg_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
                rdps_beg_info.renderPass = render_pass;
                rdps_beg_info.framebuffer = frame_bufs[available_img_idx];
                rdps_beg_info.renderArea.offset = {0, 0};
                rdps_beg_info.renderArea.extent = {700, 500};
                rdps_beg_info.clearValueCount = 1;
                VkClearValue clr_val{0, 0, 0, 1};
                rdps_beg_info.pClearValues = &clr_val;
                vkCmdBeginRenderPass(cmd_buf, &rdps_beg_info, VK_SUBPASS_CONTENTS_INLINE);

                    vkCmdBindPipeline(cmd_buf, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);
                    vkCmdBindDescriptorSets(cmd_buf, VK_PIPELINE_BIND_POINT_GRAPHICS,
                        pipelineLayout, 0, 1, &desc_set, 0, nullptr);
                    VkViewport viewport{};
                    viewport.x = 0.0f;
                    viewport.y = 0.0f;
                    viewport.width = 700;
                    viewport.height = 500;
                    viewport.minDepth = 0.0f;
                    viewport.maxDepth = 1.0f;
                    vkCmdSetViewport(cmd_buf, 0, 1, &viewport);
                    VkRect2D scissor{};
                    scissor.offset = {0, 0};
                    scissor.extent.width = 700;
                    scissor.extent.height = 500;
                    vkCmdSetScissor(cmd_buf, 0, 1, &scissor);
                    VkDeviceSize offset = 0;
                    vkCmdBindVertexBuffers(cmd_buf, 0, 1, &vtx_buf, &offset);
                    
                    // vkCmdBindIndexBuffer(cmd_buf, idx_buf, 0, VK_INDEX_TYPE_UINT32);
                    // vkCmdDrawIndexed(cmd_buf, 3, 1, 0, 0, 0);
                    vkCmdDraw(cmd_buf, 3, 1, 0, 0);

                vkCmdEndRenderPass(cmd_buf);

            result = vkEndCommandBuffer(cmd_buf);

            vkResetFences(device, 1, &fence_queue_submit);
            VkSubmitInfo submit_info{};
            submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
            submit_info.signalSemaphoreCount = 1;
            submit_info.pSignalSemaphores = &sem_finish_rendering;
            submit_info.waitSemaphoreCount = 1;
            submit_info.waitSemaphoreCount = 0;
            submit_info.pWaitSemaphores = &sem_img_available;
            submit_info.commandBufferCount = 1;
            submit_info.pCommandBuffers = &cmd_buf;
            VkPipelineStageFlags pipeline_stage_flags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
            submit_info.pWaitDstStageMask = &pipeline_stage_flags;
            vkQueueSubmit(queue, 1, &submit_info, fence_queue_submit);

            vkQueueWaitIdle(queue);
            vkDeviceWaitIdle(device);

            VkPresentInfoKHR prst_info{};
            prst_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
            prst_info.swapchainCount = 1;
            prst_info.pSwapchains = &swpch;
            prst_info.pImageIndices = &available_img_idx;
            prst_info.waitSemaphoreCount = 1;
            prst_info.pWaitSemaphores = &sem_finish_rendering;
            vkQueuePresentKHR(queue, &prst_info);

            getchar();
            return 0;
        }
        ```

        `shader_2.vert`:

        ```glsl
        #version 450

        layout(location = 0) in vec3 inPosition;

        layout (binding = 0) uniform RGB {
            vec3 rgb;
        } rgbs;

        layout(location = 0) out vec3 frag_color;

        void main() {
            gl_Position = vec4(inPosition, 1.0);
            frag_color = rgbs.rgb;
        }
        ```

        `shader_2.frag`:

        ```glsl
        #version 450

        layout(location = 0) in vec3 frag_color;
        layout(location = 0) out vec3 outColor;

        void main() {
            outColor = vec3(0.5, 0.8, 0.5);
            outColor = frag_color;
        }
        ```

    * cached question: 尝试用这段代码拿 vulkan 的 physical device 的 queue family properties，

        ```cpp
        for (int i = 0; i < phy_dev_cnt; ++i)
        {
            vkGetPhysicalDeviceQueueFamilyProperties(phy_devs[i], &queue_family_cnt, nullptr);
            queue_familys.resize(queue_family_cnt);
            vkGetPhysicalDeviceQueueFamilyProperties(phy_devs[i], &queue_family_cnt, queue_familys.data());
            printf("%d-th physical device has %d queue families:\n", i, queue_family_cnt);
            for (int j = 0; j < queue_family_cnt; ++j)
            {
                printf("    %d: queue count: %d, queue falgs: %d, time stamp: %d\n", j, queue_familys[j].queueCount,
                    queue_familys[j].queueCount, queue_familys[j].timestampValidBits);
            }
        }
        ```

        输出：

        ```
        0-th physical device has 3 queue families:
            0: queue count: 1, queue falgs: 1, time stamp: 64
            1: queue count: 4, queue falgs: 4, time stamp: 64
            2: queue count: 1, queue falgs: 1, time stamp: 64
        ```

        为什么 0 号 queue family 和 2 号 queue family 是一模一样的？

参考资料：

1. pdf 电子书《vulkan_tutorial_en》

2. 配套代码 <https://github.com/Overv/VulkanTutorial/blob/main/code/22_descriptor_set_layout.cpp>

3. pdf 电子书 vulkan programming guide

依赖项目：

1. 英语单词

近期的目标是画出一个三角形。听说 vulkan 自带了 ray tracing 功能，学到后面的话看看吧。

目前主要在看 descriptor set，先能独立画出一个彩色三角形。

然后看一下 uniform buffer 相关的，让三角形动起来。

再看一看 model loading，学会加载模型。

接下来看 compute shader 相关的东西。

添加一个 resource，官方的 vulkan programming guide。

* `vkGetDeviceQueue`指定的 queue 有数量总数吗？

* 为什么<https://github.com/Overv/VulkanTutorial/blob/main/code/22_descriptor_set_layout.cpp>没有用到 layout pool ?也没有用到 allocate，直接就是 create，为什么？


任务列表：

* [v] 调研 P65 Logical device and queues，给出任务列表

* [v] create vulkan pipeline

    descriptor 主要是用于 uniform buffer 的，vertex input 用不到这个。

    因此还要看 pipeline 创建的详细过程，最重要的是 input binding

* [v] vulkan qa, idx 12 is not completed.

    fix it with dependencies and `GLFW_NO_API`.

3. [ ] P169 ~ P185 Uniform buffers

    1. [v] 学习 command pool，command buffer 的创建

    2. [v] 学习 vertex buffer, index buffer 的绑定

    3. [v] record command buffer

    4. [v] create synchonous objects

    5. [v] draw frame，画一个绿色的三角形

    * [ ] 使用 uniform buffer 改变三角形的颜色

* [ ] 添加 vulkan 的 qa： 给出画一个三角形的流程步骤

* [ ] vulkan pipeline synchronization

* [ ] do a servey

* vulkan programming guide

    侧重一下 renderpass 和 subpass 的关系，barrier 对 image layout 的转换，以及 copy image from buffer

    sparse memory 是干嘛用的，看书上的意思，是可以让资源对象在运行时重新绑定到一块不同的内存上？

    1. P47 ~ P52

        feedback:

        1. allocator 明显目前用不到，而且也没有做实验的时间，也不能抄书做 note，因此这部分就应该跳过。

            那么这样的内容明显就不是一次能消化完的，只能做个大概的总结，需要下次任务再看一遍。

        2. 找一个 allocator 的 example

    2. P52 ~ P58
    3. P58 ~ P71
    4. P71 ~ P77
    5. P77 ~ P78
    6. chapter 3 and later
    7. moving data

## OpenCL 学习 [1]

cached:

* 如果一个 kernel 函数没有参数，那么调用 ocl simple 库就会出错

    有空了看一下这个 bug

* opencl 的笔记缺少很多基础东西，需要慢慢补全

* 如果有多个`xxx.cl`程序组成一个大的项目，host 又该如何编译？

参考资料：

1. pdf 电子书《pdfcoffee.com_opencl-programming-guidepdf-pdf-free》

2. 其他网上的资料

基本的东西会了，剩下的系统地看一看吧，查漏补缺。

重点看一看内置函数。

任务列表：

1. [v] 尝试一下 xyzw 索引和 s数字 索引

2. [v] 从 P117 看到 P123，显式类型转换，简单试验几个，记几个常用的

3. [v] P133 各种修饰符

    cached:

    * local 真的会比 global 快吗？

* [v] 更改 opencl qa: 请写一个向量相加的主程序

    deps:

    1. opencl 入门程序

* [ ] 继续调研第 5 章

    current process: P181 Vector Data Load and Store Functions

* [ ] 写一个中值滤波算子，用前面学到的内置函数

## 算法 algorithms

* [v] 写一下冒泡排序，归并排序

## 编译器 Compiler

* cached

Resources:

* 《现代编译原理C语言描述》

* Compilers Principles Techniques and Tools (2nd Edition) 

* 120 Introducing bison.pdf

    介绍了 bison 程序的简单用法，并给出了一个 example。

    但是缺少很多编译的基础知识，这部分需要去看书才行。

调研 bision

Tasks:

* [v] 看正则表达式的缩写，图 2-2

* [o] 习题 2.1, 2.2

* [v] 学习图 2-3，解释，背会

* [v] 解释图 2-4

* [ ] 整理编译器的笔记，并创建一个 qa

* [ ] compiler: 理解“识别最长的匹配”，解释图 2-5 30 mins

* [ ] 整理正则表达式的知识点，解释书上给出的 example

* [ ] 调研 nfa, nfa 转 dfa，lex

## 计算机图形学 学习 [2]

参考资料：

1. 虎书《Fundamentals-of-Computer-Graphics-Fourth-Edition》

2. Games 101

3. 其他网上的资料

依赖项目：

1. 英语单词

数学基础目前还算够用，每天记录一点点公式就可以了，一个概念，一段话，一个公式，不需要学习太多。

目前已经看完了第四章 ray tracing，并做了代码的实现。现在想先看一看光栅化的 pipeline，自己去尝试光栅化一条直线，一个三角形。

后续的安排是调研一下第 13 章，慢慢学一些折射，透明的效果。

任务列表：

1. 数学基础

    1. [ ] P18 ~ P20 三角形定义与常用的三角函数性质

        看了反三角函数，其中最有用的是 atan2。实际上也确实是这样。不过 atan2 的两个参数是 (y, x) 还是 (x, y)？

    1. P22 2.4.2 Cartesian Coordinates of a Vector

    1. P24 2.4.4 Cross Product

    1. P30 2.5 Curves and Surfaces

    1. 如何以一组向量为基，表示任意一个向量？

1. 光栅化 pipeline 部分

    1. [v] P161 8.1.1 line drawing，用代码实现一下

    1. [ ] 直线的光栅化还有一个用增量的方式判断，简单了解下记个笔记就行，不用实现

    1. P164 8.1.2 Triangle Rasterization 尝试学习，理解

1. 光追渲染部分

    1. [v] 调研折射效果

    1. [ ] P324 ~ P327 13.1 折射，尝试实现一个透明球体

        已经实现了求折射射线，接下来尝试求反射光强度$R(\theta)$。

        对于一个透明物体，尝试找到出射点。

        使用 ri ratio 来判断是否进入或离开物体可行吗？如果摄像机在水中，这个方法是否会失效？

        如果这种方法失效，是否有更好的解决方案？

    1. P327 ~ P328 13.2 实例化，更方便地采样

        这一段及后面的慢慢看

    1. P328 ~ P329 13.3 使用布尔操作构造新物体

    1. P329 13.4 distribution ray tracing，目前还没仔细调研

1. 辐射度量学 Light 章节

    1. [ ] 重新从头整理一遍辐射度量学的公式和笔记 60mins

        要求书上任意一个地方都可以找到对应的笔记。

        要求可以解释**笔记中**任意一个字母的含义，公式的推导。

        已经整理完了 irradiance 相关的东西，接下来整理 radiance 相关的内容。在笔记里想把 radiance 和$L_f$调换一下位置，同时弄清楚 radiance 的具体含义。

        任务中止原因：达到了最大知识容纳限度。

1. Color 章节

    这一章讲怎么把辐射转换成人眼可见的颜色。

## 解析几何 学习

参考资料：

1. 《Gordon Fuller - Analytic Geometry-ADDISON-WESLEY @ (1954)》

依赖项目：

1. 英语单词

希望能学到些有关参数方程的知识，其他的知识就当作查漏补缺。

任务列表：

1. [ ] 调研全书，列出几个感兴趣的部分，继续调研

## 基于路径追踪的全局光照

参考资料：

1. firefox 上打开的 tab

1. Games101 的 slides

    <https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html>

1. 别人基于 games101 的一个 c++ 实现

    <https://github.com/zhiwei-c/Monte-Carlo-Path-Tracing/tree/main>

1. 路径追踪的知乎专栏

    <https://zhuanlan.zhihu.com/p/475547095>

不需要深度调研，简单跑跑 demo，研究下代码就可以了。

依赖项目：

1. 计算机图形学

    必须熟悉完计算机图形学 Light 和 Color 两个章节后，再来做这个项目。

任务列表：

1. 调研 Global Illumination project，尝试照着他的思路，实现一个差不多的渲染器

1. 实现 refraction 效果

    1. 实现 reflectance

    1. 计算折射衰减

1. [v] 屏蔽 refraction 效果，先实现一个 path tracing

1. [v] 创建一个房间场景，让光在房间中弹射

1. [v] 对接场景文件

1. 将任务拆分并并行化，使用 opencl 加速

1. 实现更多的效果，比如贴图采样，抗锯齿

1. 完成 blender, maya 插件开发

    1. [ ] [调研] 调研 blender 插件开发的 sdk，看看能不能找到类似场景文件的东西或与渲染器输入输出相关的资料。

## 英语单词

参考资料：

1. `english_words.md`

这个项目作为被依赖的项目而启动。

## 随机检测

现在主要需要实现 new, prev rand 的功能。等这两个实现后，需要实现 dependency 的功能，根据一个条目，可以查到它的依赖条目，根据依赖条目。

任务列表：

1. [v] 实现功能：随机打开一个项目，随机进行检测

2. 根据指定条目，查找到它的依赖条目。

    每个条目

## 调研 kmd 在 container 中运行的可行性

1. 使用`sed`替换整行，替换的字符串中，有`$()`命令得到的系统信息

1. 在 44 机器上搭建 kmd 编译环境，成功编译出 xdx 的 kmd

1. 在 server 上拉取 umd 的代码，使用上海镜像

1. 在 44 机器上搭建 umd 的编译环境，成功编译出 umd

1. 调研 kmd 代码，查看其构成，尝试找到负责与 pci 交互的那一部分

1. 调研 modprobe 和 depmod 的作用，并写代码实践



## 调研 meson, ninja

## 分布式计算调研

## 微积分

## C/C++

主要任务是学完 modern c++，即 c++23 及之前的内容，找一些开源库看一看。

1. 指针的指针，区分指针的指针所指的内容不能被修改，指针所指的内容不能被修改（指针的指针本身不能被修改），指针本身不能被修改

    分别如何 new, malloc

* modern c++

    <https://github.com/federico-busato/Modern-CPP-Programming>

* 学一下 c++ 的 std format

1. 学习一下 c++ make uniquue

    可以自定义一个类型，然后使用 make unique 创建一个固定长度的数组。

    ```cpp
    // c++14
    auto constantContainer = std::make_unique<YourType []> ( size );

    // c++11
    std::unique_ptr<YourType[]> constantContainer {new YourType[ size ]};


    // Access
    constantContainer[ i ]
    ```

    有空了研究一下这段代码，分析一下利弊。

## Vim

本项目的目标是学完 vim，可以使用 vim 代替 vscode 进行日常的代码开发和调试，以及文本文档的编辑。

* vim 中的 redo 是哪个？

## 正则表达式

## 其他

* c++ 版本的 opencl 入门

    <https://objectcomputing.com/resources/publications/sett/july-2011-gpu-computing-with-opencl>

* libeigen

    other linger algebra libraries: <https://stackoverflow.com/questions/1380371/what-are-the-most-widely-used-c-vector-matrix-math-linear-algebra-libraries-a>

    以 libeigen 为主，其他的库对比着学下。

    * numcpp

        矩阵运算库

        <https://github.com/dpilger26/NumCpp>

        <https://zhuanlan.zhihu.com/p/341485401>

