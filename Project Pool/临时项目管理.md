# 临时项目管理

这个文件中列出的项目，每天过一遍。

每天应该先启动任务执行系统，如果任务列表为空，那么跳转到这里，收集当天要执行的任务。

将任务管理系统作为一个基本的项目，每周至少整理一次。

假设：我们假设人脑每次能处理的任务的复杂程度有限，每次处理一项任务的最大时间也有限。因此需要把任务切分成刚好够人脑处理的一个片断。

未来需要做什么的任务列表固然很重要，但是描述自己在过去的一段时间里做了什么同样重要。

每个项目都尽量遵循 复习（随机检测 qa） -> 学习 -> 调研 的步骤，不一定按这个顺序，但这三项起码要有。

有关“学习”：

1. 这里的学习是一个专有概念，其行为包括但不限于，阅读学习材料，做实验验证学习资料上的内容，做实验验证自己的猜想，记笔记，写一个新的 qa，完成任务列表上的任务

目前遇到的最大问题就是，有些问题不清楚能否解决，不清楚靠什么解决，只有在尝试解决的时候才会遇到很多新问题，并不断用已有知识去解决新问题。这样解决问题的思路就像一个无底洞，无法预知解决的时间，只能靠不断往其中投入时间。这类问题目前仍没有很好的解决方案。

不做任务执行系统，就没有顿挫的感觉，就不可能有高效率。只与项目池打交道，会产生无穷无尽的任务，从而无法分辨任务的边界，导致效率越来越低。

* 需要一个 graph 工具，建立不同的东西之间的连接

    stack 工具只适合任务的 trace

* 一个比较好的 explore 的想法是先从 amazon 上搜索书籍，然后在 zlib 或 libgen 上下载

* 有关笔记的整理

    可以消除一些笔记中穿插的一些 reference 资源，或者将资源提取出来。

* 缓存策略和 stack 策略都非常有用，使得条理很清晰

* [思考] 无论是 qa 还是 note，除了添加内容，更需要优化。这个优化该如何进行？

    如果只添加内容，不优化内容，那么东西越来越多，而且组织混乱。

    目前正在进行的一个优化是将按时间顺序写下的笔记，重新整理成按结构存储的数据。

* 每天结束前整理当天的 feedback

    比较紧急的写到系统里，不太紧急的写到 log 里，每周批量处理

* 显然项目管理系统需要每天更新，因为任务执行系统会改变项目管理系统中的内容

    而且项目管理系统必须是当天结束时更新，这样才能不对第二天收集任务清单造成影响

* log 不应该与 task 放在同一个文件里，翻来翻去太费时间

* 思考：像这种既没有经验，也没有参考，只能靠临时反应进行和大量交互进行下去的任务，该如何分配时间？

    没有任何的可借鉴经验，不清楚结果，这种任务被称为 blackhole task.

## cached

* opencl 的笔记缺少很多基础东西，需要慢慢补全

* vulkan

    目前的进展到这里

    ```cpp
    #include "../simple_vulkan/simple_vk.hpp"

    int main()
    {
        glfwInit();
        VkInstance inst;
        create_vk_instance(inst);
        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        GLFWwindow *window = glfwCreateWindow(700, 500, "hello", nullptr, nullptr);
        VkSurfaceKHR surf;
        glfwCreateWindowSurface(inst, window, nullptr, &surf);
        VkPhysicalDevice phy_dev;
        uint32_t queue_family_idx;
        select_vk_physical_device(phy_dev, queue_family_idx, queue_family_idx, inst, surf);
        VkDevice device;
        VkQueue queue;
        create_vk_device(device, queue, queue, phy_dev, queue_family_idx, queue_family_idx);
        VkSwapchainKHR swpch;
        create_vk_swapchain(swpch, device, surf, queue_family_idx);
        VkRenderPass render_pass = create_render_pass(VK_FORMAT_B8G8R8A8_SRGB, device);
        VkPipeline pipeline = create_pipeline("./vert_2.spv", "frag_2.spv", 0, {0, 0}, device, {700, 500}, render_pass);
        
        uint32_t swpch_img_count;
        vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, nullptr);
        std::vector<VkImage> swpch_imgs(swpch_img_count);
        vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, swpch_imgs.data());

        std::vector<VkImageView> swpch_img_views(swpch_img_count);
        VkImageViewCreateInfo img_view_crt_info{};
        img_view_crt_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        img_view_crt_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
        img_view_crt_info.format = VK_FORMAT_B8G8R8A8_SRGB;
        img_view_crt_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};
        VkResult result;
        for (int i = 0; i < swpch_img_count; ++i)
        {
            img_view_crt_info.image = swpch_imgs[i];
            result = vkCreateImageView(device, &img_view_crt_info, nullptr, &swpch_img_views[i]);
            if (result != VK_SUCCESS)
            {
                printf("fail to create image view, error code %d\n", result);
                exit(-1);
            }
        }

        VkFramebufferCreateInfo frame_buf_crt_info{};
        frame_buf_crt_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        frame_buf_crt_info.renderPass = render_pass;
        frame_buf_crt_info.attachmentCount = 1;
        frame_buf_crt_info.width = 700;
        frame_buf_crt_info.height = 500;
        frame_buf_crt_info.layers = 1;
        std::vector<VkFramebuffer> frame_bufs(swpch_img_count);
        for (int i = 0; i < swpch_img_count; ++i)
        {
            frame_buf_crt_info.pAttachments = &swpch_img_views[i];
            result = vkCreateFramebuffer(device, &frame_buf_crt_info, nullptr, &frame_bufs[i]);
            if (result != VK_SUCCESS)
            {
                printf("fail to create frame buffer, error code: %d\n", result);
                exit(-1);
            }
        }

        VkCommandPool cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
        cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
        VkCommandBuffer cmd_buf;
        VkCommandBufferAllocateInfo cmd_buf_alc_info{};
        cmd_buf_alc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        cmd_buf_alc_info.commandBufferCount = 1;
        cmd_buf_alc_info.commandPool = cmd_pool;
        cmd_buf_alc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        result = vkAllocateCommandBuffers(device, &cmd_buf_alc_info, &cmd_buf);
        if (result != VK_SUCCESS)
        {
            printf("fail to allocate command buffer\n");
            exit(-1);
        }

        return 0;
    }
    ```

    下次直接从这里开始，不用再浪费时间了。

* 以后可以把 cache tabs 的时间缩减到 15 分钟

* 每天离开工作区之前应该把 task 中的 feedback 整合到临时项目管理中

* 深度学习和数学最本质的区别是，深度学习只告诉你他的方法为什么行，不告诉你别人的方法为什么不行，而数学会同时告诉你这两者

* cacked tasks

    cmake 环境变量的用法

* compiler

    cacked tasks:

    1. 整理正则表达式的知识点，解释书上给出的 example

    2. 理解“识别最长的匹配”，解释图 2-5

* 可以规定一下，如果 2 天（或者 3 天）都能通过某个 domain 的 qa，那么就可以申请增加新的 qa。

* vulkan descriptor

    1. 前置的东西还是太多。目前只看完了 image view 和 framebuffer 的创建。

        下次看 command pool，command buffer 的创建，然后是 resource

        vertex buffer, index buffer

        create synchronous objects, record command buffer, draw frame

* 为什么`g++ -g main.cpp -lvulkan -lglfw -o main`可以通过编译，`g++ -g -lvulkan -lglfw main.cpp -o main`就不行？

* vulkan qa, idx 12 is not completed.

    fix it with dependencies and `GLFW_NO_API`.

* 顺着笔记找 qa 效率并不高，更好的做法是随机在笔记的后面部分找一个问题，然后写到 qa 里，再倒过来找 qa 的 dependency.

* note 的每个 item 也尽量控制得短一些，类似代码的函数长度

* 把正则表达式加入到项目中

* 进度的 sync

    如果一个项目长时间不合理发展，就会出现调研、 qa 和笔记不匹配的情况。这种情况下，需要对进度进行 sync，确认下面几个问题：

    1. 如果无法从学习资料中总结出新的笔记，那么认为学习和笔记的 sync 完成

    1. 如果无法再从笔记中找到一个新的 qa，那么认为 qa 和笔记的 sync 完成

    1. qa 里不能有 empty

    1. test, qa 文件夹 clean

    显然，项目进度的 sync 不应该出现在项目管理里，而应该由任务执行系统负责。

* 应该提出 cached tasks, cached questions 这些概念

* 添加 vulkan 的 qa： 给出画一个三角形的流程步骤

* 以后再做 c++ 的 qa，要么写一点点语法，要么就是做题

* 找一个 c++ 学习资料，系统学一下比较好

* 学习资源的调研主要用于完成下面几件事情

    1. 发现学习资源里，是否有需要做实验验证的地方，是否可以用实验验证他说的，是否有可以用实验澄清的模糊不清的表达

    2. 语言表达是否有歧义

    3. 未完待续

* 其实与 cache 对应的是工作区（working area），而工作区的整洁是 stack　的要求，不然各种回退操作都会混乱，没有办法快速定位到想要的资源

* 其实调研也是一种是 cache，是一种广度优先搜索，它安排了必须要回答的问题，优化了任务列表的结构，整合了小范围内的信息，防止有歧义在前，回答在后的情况发生

    调研不做实验，不使用实验对猜想做验证

* 需要一个指标来评价当天有多少时间是被任务系统接管的，就叫它接管率好了

    接管率从一定程度止反映了专心程度

* cache tabls

    把开的标签页处理完后，就该每天处理缓存的 url 了

* 将刷题记录到项目管理里

## qa

目前的 qa 项目： vulkan, c++, vim, cmake, makefile

* 感觉 bash, makefile, cmake, sed, awk, vim 这几个都是挺重要的，把 qa 加上去吧，每天练习

* qa 的每个 unit 设计不应过于复杂。如果实际检测时间超过 30 mins，那么需要拆开。

    这里的拆开指的是写成 dependency 的形式，如果 dependency 之间做过，那么直接复杂 dep 的结果，从而减少当前 unit 的 exam 时间。

* 给随机检测增加新功能

    * 使用`./main --generate-id`根据当前时间创建一个新的哈希值

    * 使用`./main --id-to-idx <id> <qa_file>`找到指定哈希值的索引

    * 在 vim 中根据正则表达式搜索指定索引所在的位置

    * 修复`--list`的 bug。

        在找到`[u_0]`后，只要找到下一个`[xxx]`模式就可以了，`[u_0]`的内容为`[u_0]`往后，`[xxx]`往前。

        dep:

        * 正则表达式

    * [v] 使用`./main --update-idx <qa_file>`更新所有 unit 的 idx 

* 把 vim 加入到每日 qa 中

## Vulkan 学习 [0]

参考资料：

1. pdf 电子书《vulkan_tutorial_en》

2. 配套代码 <https://github.com/Overv/VulkanTutorial/blob/main/code/22_descriptor_set_layout.cpp>

3. pdf 电子书 vulkan programming guide

依赖项目：

1. 英语单词

近期的目标是画出一个三角形。听说 vulkan 自带了 ray tracing 功能，学到后面的话看看吧。

目前主要在看 descriptor set，先能独立画出一个彩色三角形。

然后看一下 uniform buffer 相关的，让三角形动起来。

再看一看 model loading，学会加载模型。

接下来看 compute shader 相关的东西。

添加一个 resource，官方的 vulkan programming guide。

* `vkGetDeviceQueue`指定的 queue 有数量总数吗？

* 为什么<https://github.com/Overv/VulkanTutorial/blob/main/code/22_descriptor_set_layout.cpp>没有用到 layout pool ?也没有用到 allocate，直接就是 create，为什么？


任务列表：

2. [v] 调研 P65 Logical device and queues，给出任务列表

3. [ ] P169 ~ P185 Uniform buffers

    1. [ ] 学习 command pool，command buffer 的创建

    2. [ ] 学习 vertex buffer, index buffer 的绑定

    3. [ ] create synchronous objects, record command buffer, draw frame，画一个绿色的三角形

5. vulkan programming guide

    侧重一下 renderpass 和 subpass 的关系，barrier 对 image layout 的转换，以及 copy image from buffer

    sparse memory 是干嘛用的，看书上的意思，是可以让资源对象在运行时重新绑定到一块不同的内存上？

    1. P47 ~ P52

        feedback:

        1. allocator 明显目前用不到，而且也没有做实验的时间，也不能抄书做 note，因此这部分就应该跳过。

            那么这样的内容明显就不是一次能消化完的，只能做个大概的总结，需要下次任务再看一遍。

        2. 找一个 allocator 的 example

    2. P52 ~ P58
    3. P58 ~ P71
    4. P71 ~ P77
    5. P77 ~ P78
    6. chapter 3 and later

    7. moving data

## OpenCL 学习 [1]

参考资料：

1. pdf 电子书《pdfcoffee.com_opencl-programming-guidepdf-pdf-free》

2. 其他网上的资料

基本的东西会了，剩下的系统地看一看吧，查漏补缺。

重点看一看内置函数。

任务列表：

1. [v] 尝试一下 xyzw 索引和 s数字 索引

2. [v] 从 P117 看到 P123，显式类型转换，简单试验几个，记几个常用的

3. [ ] P133 开始看各种修饰符。这个可能和内存的属性有关，感觉还是挺重要的

    0. [ ] Address Space Qualifiers P135 ~ P140，四种内存地址类型，以及不同类型之间的转换

        0. [v] Global Address Space

        1. [ ] constant address space

            constant 是编译器直接写在程序的常量区吗？

        2. [ ] local address space

        3. [ ] private address space

        local 真的会比 global 快吗？

    1. P140 Access Qualifiers

    2. P141 Type Qualifiers

4. [ ] 从 P149 开始调研第 5 章内置函数，给出任务列表

    0. Work-Item Functions P150 ~ P152

    1. Math functions P153 ~ P168

    2. 调研 others

## 计算机图形学 学习 [2]

参考资料：

1. 虎书《Fundamentals-of-Computer-Graphics-Fourth-Edition》

2. Games 101

3. 其他网上的资料

依赖项目：

1. 英语单词

数学基础目前还算够用，每天记录一点点公式就可以了，一个概念，一段话，一个公式，不需要学习太多。

目前已经看完了第四章 ray tracing，并做了代码的实现。现在想先看一看光栅化的 pipeline，自己去尝试光栅化一条直线，一个三角形。

后续的安排是调研一下第 13 章，慢慢学一些折射，透明的效果。

任务列表：

1. 数学基础

    1. [ ] P18 ~ P20 三角形定义与常用的三角函数性质

        看了反三角函数，其中最有用的是 atan2。实际上也确实是这样。不过 atan2 的两个参数是 (y, x) 还是 (x, y)？

    1. P22 2.4.2 Cartesian Coordinates of a Vector

    1. P24 2.4.4 Cross Product

    1. P30 2.5 Curves and Surfaces

    1. 如何以一组向量为基，表示任意一个向量？

1. 光栅化 pipeline 部分

    1. [v] P161 8.1.1 line drawing，用代码实现一下

    1. [ ] 直线的光栅化还有一个用增量的方式判断，简单了解下记个笔记就行，不用实现

    1. P164 8.1.2 Triangle Rasterization 尝试学习，理解

1. 光追渲染部分

    1. [v] 调研折射效果

    1. [ ] P324 ~ P327 13.1 折射，尝试实现一个透明球体

        已经实现了求折射射线，接下来尝试求反射光强度$R(\theta)$。

        对于一个透明物体，尝试找到出射点。

        使用 ri ratio 来判断是否进入或离开物体可行吗？如果摄像机在水中，这个方法是否会失效？

        如果这种方法失效，是否有更好的解决方案？

    1. P327 ~ P328 13.2 实例化，更方便地采样

        这一段及后面的慢慢看

    1. P328 ~ P329 13.3 使用布尔操作构造新物体

    1. P329 13.4 distribution ray tracing，目前还没仔细调研

1. 辐射度量学 Light 章节

    1. [ ] 重新从头整理一遍辐射度量学的公式和笔记 60mins

        要求书上任意一个地方都可以找到对应的笔记。

        要求可以解释**笔记中**任意一个字母的含义，公式的推导。

        已经整理完了 irradiance 相关的东西，接下来整理 radiance 相关的内容。在笔记里想把 radiance 和$L_f$调换一下位置，同时弄清楚 radiance 的具体含义。

        任务中止原因：达到了最大知识容纳限度。

1. Color 章节

    这一章讲怎么把辐射转换成人眼可见的颜色。

## 解析几何 学习

参考资料：

1. 《Gordon Fuller - Analytic Geometry-ADDISON-WESLEY @ (1954)》

依赖项目：

1. 英语单词

希望能学到些有关参数方程的知识，其他的知识就当作查漏补缺。

任务列表：

1. [ ] 调研全书，列出几个感兴趣的部分，继续调研

## 基于路径追踪的全局光照

参考资料：

1. firefox 上打开的 tab

1. Games101 的 slides

    <https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html>

1. 别人基于 games101 的一个 c++ 实现

    <https://github.com/zhiwei-c/Monte-Carlo-Path-Tracing/tree/main>

1. 路径追踪的知乎专栏

    <https://zhuanlan.zhihu.com/p/475547095>

不需要深度调研，简单跑跑 demo，研究下代码就可以了。

依赖项目：

1. 计算机图形学

    必须熟悉完计算机图形学 Light 和 Color 两个章节后，再来做这个项目。

任务列表：

1. 调研 Global Illumination project，尝试照着他的思路，实现一个差不多的渲染器

1. 实现 refraction 效果

    1. 实现 reflectance

    1. 计算折射衰减

1. [v] 屏蔽 refraction 效果，先实现一个 path tracing

1. [v] 创建一个房间场景，让光在房间中弹射

1. [v] 对接场景文件

1. 将任务拆分并并行化，使用 opencl 加速

1. 实现更多的效果，比如贴图采样，抗锯齿

1. 完成 blender, maya 插件开发

    1. [ ] [调研] 调研 blender 插件开发的 sdk，看看能不能找到类似场景文件的东西或与渲染器输入输出相关的资料。

## 英语单词

参考资料：

1. `english_words.md`

这个项目作为被依赖的项目而启动。

## 随机检测

现在主要需要实现 new, prev rand 的功能。等这两个实现后，需要实现 dependency 的功能，根据一个条目，可以查到它的依赖条目，根据依赖条目。

任务列表：

1. [v] 实现功能：随机打开一个项目，随机进行检测

2. 根据指定条目，查找到它的依赖条目。

    每个条目

## 调研 kmd 在 container 中运行的可行性

1. 使用`sed`替换整行，替换的字符串中，有`$()`命令得到的系统信息

1. 在 44 机器上搭建 kmd 编译环境，成功编译出 xdx 的 kmd

1. 在 server 上拉取 umd 的代码，使用上海镜像

1. 在 44 机器上搭建 umd 的编译环境，成功编译出 umd

1. 调研 kmd 代码，查看其构成，尝试找到负责与 pci 交互的那一部分

1. 调研 modprobe 和 depmod 的作用，并写代码实践

## 编译器

Resources:

* 《现代编译原理C语言描述》

* Compilers Principles Techniques and Tools (2nd Edition) 

* 120 Introducing bison.pdf

    介绍了 bison 程序的简单用法，并给出了一个 example。

    但是缺少很多编译的基础知识，这部分需要去看书才行。

调研 bision

## 调研 meson, ninja

## 分布式计算调研

## 微积分

## C/C++

主要任务是学完 modern c++，即 c++23 及之前的内容，找一些开源库看一看。

1. 指针的指针，区分指针的指针所指的内容不能被修改，指针所指的内容不能被修改（指针的指针本身不能被修改），指针本身不能被修改

    分别如何 new, malloc

* modern c++

    <https://github.com/federico-busato/Modern-CPP-Programming>

* 学一下 c++ 的 std format

1. 学习一下 c++ make uniquue

    可以自定义一个类型，然后使用 make unique 创建一个固定长度的数组。

    ```cpp
    // c++14
    auto constantContainer = std::make_unique<YourType []> ( size );

    // c++11
    std::unique_ptr<YourType[]> constantContainer {new YourType[ size ]};


    // Access
    constantContainer[ i ]
    ```

    有空了研究一下这段代码，分析一下利弊。

## Vim

本项目的目标是学完 vim，可以使用 vim 代替 vscode 进行日常的代码开发和调试，以及文本文档的编辑。

* vim 中的 redo 是哪个？

## 其他

* c++ 版本的 opencl 入门

    <https://objectcomputing.com/resources/publications/sett/july-2011-gpu-computing-with-opencl>

* libeigen

    other linger algebra libraries: <https://stackoverflow.com/questions/1380371/what-are-the-most-widely-used-c-vector-matrix-math-linear-algebra-libraries-a>

    以 libeigen 为主，其他的库对比着学下。

    * numcpp

        矩阵运算库

        <https://github.com/dpilger26/NumCpp>

        <https://zhuanlan.zhihu.com/p/341485401>

