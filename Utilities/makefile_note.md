# Makefile Note

Ref: <https://www.gnu.org/software/make/manual/html_node/index.html#SEC_Contents>

> When make recompiles the editor, each changed C source file must be recompiled. If a header file has changed, each C source file that includes the header file must be recompiled to be safe. Each compilation produces an object file corresponding to the source file. Finally, if any source file has been recompiled, all the object files, whether newly made or saved from previous compilations, must be linked together to produce the new executable editor. 

rules:

```Makefile
target … : prerequisites …
        recipe
        …
        …

```

A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’ (see Phony Targets).

A prerequisite is a file that is used as input to create the target. A target often depends on several files.

A recipe is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you need to put a tab character at the beginning of every recipe line! This is an obscurity that catches the unwary. If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character (see Other Special Variables). 

Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisites change. However, the rule that specifies a recipe for the target need not have prerequisites. For example, the rule containing the delete command associated with the target ‘clean’ does not have prerequisites. 

A rule, then, explains how and when to remake certain files which are the targets of the particular rule. make carries out the recipe on the prerequisites to create or update the target. A rule can also explain how and when to carry out an action. See Writing Rules.

A makefile may contain other text besides rules, but a simple makefile need only contain rules. Rules may look somewhat more complicated than shown in this template, but all fit the pattern more or less. 

**A Simple Makefile**:

```Makefile
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
```

When a target is a file, it needs to be recompiled or relinked if any of its prerequisites change. In addition, any prerequisites that are themselves automatically generated should be updated first.

A recipe may follow each line that contains a target and prerequisites. These recipes say how to update the target file. A tab character (or whatever character is specified by the `.RECIPEPREFIX` variable; see Other Special Variables) must come at the beginning of every line in the recipe to distinguish recipes from other lines in the makefile. (Bear in mind that make does not know anything about how the recipes work. It is up to you to supply recipes that will update the target file properly. All make does is execute the recipe you have specified when the target file needs to be updated.) 

Targets that do not refer to files but are just actions are called phony targets. See Phony Targets, for information about this kind of target.

By default, `make` starts with the first target (not targets whose names start with ‘.’ unless they also contain one or more ‘/’). This is called the default goal. (Goals are the targets that make strives ultimately to update. You can override this behavior using the command line (see Arguments to Specify the Goals) or with the .DEFAULT_GOAL special variable (see Other Special Variables). 

The recompilation must be done if the source file, or any of the header files named as prerequisites, is more recent than the object file, or if the object file does not exist. 

`make`会检测文件的修改时间，如果 prerequisites 的时间比 target 的时间要新，那么就重新构建 target。所以只要把`.c`，`.cpp`，`.h`等文件放到 prerequisites 中，那么就可以每次修改完源代码，就自动构建依赖了。

Variables allow a text string to be defined once and substituted in multiple places later (see How to Use Variables). 

It is standard practice for every makefile to have a variable named objects, OBJECTS, objs, OBJS, obj, or OBJ which is a list of all object file names.

Example:

```Makefile
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
```

Then, each place we want to put a list of the object file names, we can substitute the variable’s value by writing ‘$(objects)’

Example:

```Makefile
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)
```

it has an implicit rule for updating a ‘.o’ file from a correspondingly named ‘.c’ file using a ‘cc -c’ command.

When a ‘.c’ file is used automatically in this way, it is also automatically added to the list of prerequisites. We can therefore omit the ‘.c’ files from the prerequisites, provided we omit the recipe. 

Example:

```Makefile
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
        rm edit $(objects)
```

## Quickstart

### 1. echo hello world

在一个空文件夹下新建`Makefile`文件，内容如下：

`Makefile`:

```makefile
hello:
	echo "hello world"
```

运行`make`命令，可以看到输出：

```
echo "hello world"
hello world
```

注意，`echo`前是一个`tab`，而不是 4 个空格，这是 Makefile 的规定。如果写成空格，会报错。

Makefiles must be indented using TABs and not spaces or `make` will fail.

上面的代码中，`hello`被称为 target，下面的`echo "hello world"`被称为 recipes 或 rules。他们的意思也很明显了：我们使用 recipe 来构建 target。

### 2. compile hello world

在一个空文件夹下新建`main.cpp`文件，内容如下

`main.cpp`:

```cpp
#include <iostream>
using namespace std;

int main()
{
	cout << "hello world" << endl;
	return 0;
}
```

然后新建`Makefile`文件，内容如下：

```Makefile
main:
	g++ main.cpp -o main
```

编译：

```bash
make
```

编译输出：

```bash
g++ main.cpp -o main
```

此时可以看到编译出的文件：`main`

运行：

```bash
./main
```

输出：

```
hello world
```

Makefile 会把 target 看作一个文件，如果 target 不存在，那么使用 recipe 进行构建。在这个例子中，Makefile 先检测到`main`文件不存在，然后使用`g++ main.cpp -o main`进行构建。

在前面的 echo hello world 例子中，target 是`hello`，由于`echo "hello world"`总是无法生成`hello`文件，所以每次运行`make`都会执行`echo "hello world"`。在当前例子中，由于`g++`命令执行后可以生成`main`文件，所以第二次执行`make`命令，将不会执行任何操作，并输出`make: 'main' is up to date.`。

### 3. dependency

[to do]

`make`并没有版本控制系统，所以如果我们此时修改了`main.cpp`中的内容，再执行`make`，那么`make`检测到`main`文件存在后便不再执行任何操作

## Rules

通常每

rules:

```makefile
targets: prerequisites
    command
    command
    command
```

* The `targets` are file names, separated by spaces. Typically, there is only one per rule.

* The `commands` are a series of steps typically used to make the target(s). These need to start with a tab character, not spaces.

* The `prerequisites` are also file names, separated by spaces. These files need to exist before the commands for the target are run. These are also called *dependencies*.

Example:

```makefile
blah: blah.o
	cc blah.o -o blah  # Runs third

blah.o: blah.c
	cc -c blah.c -o blah.o  # Runs second

blah.c:
	echo "int main() { return 0; }" > blah.c  # Runs first
```

依赖链分析：`blah`的生成需要`blah.o`，`make`程序往下找到`blah.o`目标，发现它依赖于`blah.c`；然后`make`程序发现`blah.c`什么都不信赖，所以直接就执行对应的命令了。

`make`程序会将`Makefile`中的第一个 target 作为 default target。

如果某个 target 已经被创建，那么`make`就会跳过这个 target。

如果某个 target 不创建任何文件，那么每次`make`，它被依赖时，总是执行。常见的`clean`选项就利用了这个特点：

```makefile
some_file:
    touch some_file

clean:
    rm -rf some_file
```

此时如果执行`make`，那么会执行`some_file` target。如果执行`make clean`，那么会执行`clean` target。

使用变量：

```makefile
files := file1 file2
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file
```

取变量值可以使用`$()`，也可以使用`${}`。

说明：

1. 这个例子里变量用`:=`赋值了，也可以使用`=`。

另外一个例子：

```makefile
x := dude

all:
	echo $(x)
	echo ${x}

	# Bad practice, but works
	echo $x 
```

自己写的一个例子：

```makefile
lib_src = hello.c

main: main.c hello.o
	cc main.c hello.o -o main

hello.o: hello.c
	cc -c ${lib_src} -o hello.o

clean:
	rm -f main

echo_lib_src:
	echo ${lib_src}
```

执行多个 targets:

```makefile
all: one two three

one:
	touch one
two:
	touch two
three:
	touch three

clean:
	rm -f one two three
```

multiple targets:

```makefile
all: f1.o f2.o

f1.o f2.o:
	echo $@
# Equivalent to:
# f1.o:
#	 echo f1.o
# f2.o:
#	 echo f2.o
```

其中`$@`表示 target name。

`make`的执行结果：

```
echo f1.o
f1.o
echo f2.o
f2.o
```

说明：

1. 如果执行`make`或`make all`，那么会分别执行`make f1.o`和`make f2.o`。如果执行`make f1.o`，那么只会执行`make f1.o`；`f2.o`同理。如果执行`make f1.o f2.o`，那么效果同`make`和`make all`。

**Wildcard**

常用的 wildcard 有`*`和`%`。

* `*` wildcard