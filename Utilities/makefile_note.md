# Makefile Note

## cache

* 在 Makefile 中，`$(VAR)`和`${VAR}`在功能上是完全相同的，可以互换使用。

    使用 makefile 的内置函数时，必须使用圆括号，比如`$(subst from,to,text)`

    综合看来，makefile 中使用圆括号较多，使用花括号`${VAR}`比较少见。

    makefile 中，不允许使用`$VAR`。只会解析`$V`。

    example:

    ```makefile
    NAME = MyApp
    VAR = wrong_value
    V = correct_value

    test:
    	@echo "你想输出 MyApp, 但实际会输出: $NAME"
    	@echo "解析后相当于: $(V)NAME"
    	@echo "而变量 V 的值是: $(V)"
    ```

    output:

    ```
    你想输出 MyApp, 但实际会输出: AME
    解析后相当于: correct_valueNAME
    而变量 V 的值是: correct_value
    ```

* makefile 中的子文件夹与`.PHONY`

    假如当前的工程目录为：

    ```
    - proj
        my_lib.h
        my_lib.cpp
        Makefile
        - tests
            xxx.h
            xxx.cpp
            Makefile
        - imported_libs
            yyy.h
            yyy.cpp
            Makefile
    ```

    如果我们希望`proj`文件夹中的 makefile 可以进入到子文件夹`tests`和`imported_libs`中执行 make 进行子模块的编译，那么我们写出的`proj/Makefile`文件可能是这样的：

    ```makefile
    all: libs imported_libs tests
    	@echo "in all target"

    libs:
    	@echo "in libs target"
    	touch libs.txt
    	# g++ -c my_lib.cpp -o my_lib.o

    imported_libs:
    	@echo "in imported_libs target"
    	$(MAKE) -C imported_libs

    tests:
    	@echo "in tests target"
    	$(MAKE) -C tests

    clean:
    	$(MAKE) -C tests clean
    	$(MAKE) -C imported_libs clean
    	rm -f libs.txt
    ```

    `make`输出如下：

    ```
    in libs target
    touch libs.txt
    # g++ -c my_lib.cpp -o my_lib.o
    in all target
    ```

    可以看到虽然``all`的依赖目标中包含有`imported_libs`和`tests`，但是这两个根本没执行。因此已经有同名的文件夹存在。

    此时需要`.PHONY`来解决这个问题：

    ```makefile
    .PHONY: tests imported_libs

    all: libs imported_libs tests
    	@echo "in all target"

    libs:
    	@echo "in libs target"
    	touch libs.txt
    	# g++ -c my_lib.cpp -o my_lib.o

    imported_libs:
    	@echo "in imported_libs target"
    	$(MAKE) -C imported_libs

    tests:
    	@echo "in tests target"
    	$(MAKE) -C tests

    clean:
    	$(MAKE) -C tests clean
    	$(MAKE) -C imported_libs clean
    	rm -f libs.txt
    ```

    `make`的 output:

    ```
    in libs target
    touch libs.txt
    # g++ -c my_lib.cpp -o my_lib.o
    in imported_libs target
    make -C imported_libs
    make[1]: Entering directory '/home/hlc/Documents/Projects/makefile_test/imported_libs'
    in imported_libs dir...
    touch imported_libs.txt
    make[1]: Leaving directory '/home/hlc/Documents/Projects/makefile_test/imported_libs'
    in tests target
    make -C tests
    make[1]: Entering directory '/home/hlc/Documents/Projects/makefile_test/tests'
    in tests dir...
    touch tests.txt
    make[1]: Leaving directory '/home/hlc/Documents/Projects/makefile_test/tests'
    in all target
    ```

* makefile 中的依赖机制

    1. `target`如果没有依赖项，那么检测名为`target`的文件/文件夹是否存在，若不存在，则执行`target`，否则不执行

    2. 若`target`有依赖项`dep`，那么判断`dep`文件是否比`target`新，如果是，那么执行`target`，如果`dep`只是目标，不是文件，那么无论`dep`是否执行，总是认为`dep`比`target`新

    3. 如果有`.phony: target dep`存在，那么认为`target`和`dep`都只是目标，不是文件

* makefile 中的`export`

* makefile 里，编译时依赖 a.o 和 b.o 文件，但是这两个文件不在当前目录里，如何在 g++ 命令里方便地把它们加上去？

    目前有三种方案：

    1. 创建一个`a.o`所在目录的路径变量，后面使用`${OBJ_DIR}/a.o`, `${OBJ_DIR}/b.o`的方式把它们添加到 g++ 的编译命令里：

        ```makefile
        OBJ_DIR = ../obj
        OBJS = $(OBJ_DIR)/a.o $(OBJ_DIR)/b.o
        TARGET = main

        $(TARGET): $(OBJS)
        	g++ $^ -o $@
        ```

        其中，

        * `$^`：代表所有依赖文件（即`a.o`和`b.o`）

        * `$@`：代表目标文件（即`main`）

    2. 直接使用绝对路径

        ```makefile
        main: ../path/to/a.o ../another/path/to/b.o
        	g++ $^ -o $@
        ```

    3. 使用`patsubst`命令做字符串替换

        ```makefile
        OBJ_NAMES = a b
        OBJ_PATH = ../myobjs

        # 使用 patsubst 函数将 a b 转换为 ../myobjs/a.o ../myobjs/b.o
        OBJS = $(patsubst %,$(OBJ_PATH)/%.o,$(OBJ_NAMES))

        main: $(OBJS)
        	g++ $^ -o $@
        ```

* makefile 文件名可以是`Makefile`，也可以是`makefile`,但是不能是`makefilE`。

    也就是说，文件名只对第一个字母大小写不敏感。

## note

* hello world example

    `Makefile`:

    ```makefile
    hello:
    	echo "hello, world"
    ```

    run: `make`

    output:

    ```
    echo "hello, world"
    hello, world
    ```

    其中`hello`是一个 target，makefile 中的第一个 target 是默认 target，当执行`make`命令时，会执行默认 target。

    target 跟的是 command，所有的 command 都以`\t`缩进，不能是空格，否则会报错。

* target 与文件

    > A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’ (see Phony Targets).

    每个 target 都与当前目录下的一个文件相对应，如果名字为`<target>`的文件不存在，则执行 target 下面的 command。如果文件存在，那么不执行命令。

    example:

    files in current dir:

    ```
    hello  Makefile
    ```

    ```makefile
    hello:
    	echo "hello, world"
    ```

    run: `make`

    output:

    ```
    make: 'hello' is up to date.
    ```

* target 与前置条件（prerequisite）

    在 target 的冒号后跟其他 target，可以指定当前 target 的依赖。

    example:

    ```makefile
    main: main.c
    	gcc -g main.c -o main
    ```

    run: `make`

    output:

    ```
    gcc -g main.c -o main
    ```

## 其他

Ref: <https://www.gnu.org/software/make/manual/html_node/index.html#SEC_Contents>

> When make recompiles the editor, each changed C source file must be recompiled. If a header file has changed, each C source file that includes the header file must be recompiled to be safe. Each compilation produces an object file corresponding to the source file. Finally, if any source file has been recompiled, all the object files, whether newly made or saved from previous compilations, must be linked together to produce the new executable editor. 

rules:

```Makefile
target … : prerequisites …
        recipe
        …
        …

```

A prerequisite is a file that is used as input to create the target. A target often depends on several files.

A recipe is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you need to put a tab character at the beginning of every recipe line! This is an obscurity that catches the unwary. If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character (see Other Special Variables). 

Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisites change. However, the rule that specifies a recipe for the target need not have prerequisites. For example, the rule containing the delete command associated with the target ‘clean’ does not have prerequisites. 

A rule, then, explains how and when to remake certain files which are the targets of the particular rule. make carries out the recipe on the prerequisites to create or update the target. A rule can also explain how and when to carry out an action. See Writing Rules.

A makefile may contain other text besides rules, but a simple makefile need only contain rules. Rules may look somewhat more complicated than shown in this template, but all fit the pattern more or less. 

**A Simple Makefile**:

```Makefile
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
```

When a target is a file, it needs to be recompiled or relinked if any of its prerequisites change. In addition, any prerequisites that are themselves automatically generated should be updated first.

A recipe may follow each line that contains a target and prerequisites. These recipes say how to update the target file. A tab character (or whatever character is specified by the `.RECIPEPREFIX` variable; see Other Special Variables) must come at the beginning of every line in the recipe to distinguish recipes from other lines in the makefile. (Bear in mind that make does not know anything about how the recipes work. It is up to you to supply recipes that will update the target file properly. All make does is execute the recipe you have specified when the target file needs to be updated.) 

Targets that do not refer to files but are just actions are called phony targets. See Phony Targets, for information about this kind of target.

By default, `make` starts with the first target (not targets whose names start with ‘.’ unless they also contain one or more ‘/’). This is called the default goal. (Goals are the targets that make strives ultimately to update. You can override this behavior using the command line (see Arguments to Specify the Goals) or with the .DEFAULT_GOAL special variable (see Other Special Variables). 

The recompilation must be done if the source file, or any of the header files named as prerequisites, is more recent than the object file, or if the object file does not exist. 

`make`会检测文件的修改时间，如果 prerequisites 的时间比 target 的时间要新，那么就重新构建 target。所以只要把`.c`，`.cpp`，`.h`等文件放到 prerequisites 中，那么就可以每次修改完源代码，就自动构建依赖了。

Variables allow a text string to be defined once and substituted in multiple places later (see How to Use Variables). 

It is standard practice for every makefile to have a variable named objects, OBJECTS, objs, OBJS, obj, or OBJ which is a list of all object file names.

Example:

```Makefile
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
```

Then, each place we want to put a list of the object file names, we can substitute the variable’s value by writing ‘$(objects)’

Example:

```Makefile
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)
```

it has an implicit rule for updating a ‘.o’ file from a correspondingly named ‘.c’ file using a ‘cc -c’ command.

When a ‘.c’ file is used automatically in this way, it is also automatically added to the list of prerequisites. We can therefore omit the ‘.c’ files from the prerequisites, provided we omit the recipe. 

Example:

```Makefile
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
        rm edit $(objects)
```

## Quickstart

### 1. echo hello world

在一个空文件夹下新建`Makefile`文件，内容如下：

`Makefile`:

```makefile
hello:
	echo "hello world"
```

运行`make`命令，可以看到输出：

```
echo "hello world"
hello world
```

注意，`echo`前是一个`tab`，而不是 4 个空格，这是 Makefile 的规定。如果写成空格，会报错。

Makefiles must be indented using TABs and not spaces or `make` will fail.

上面的代码中，`hello`被称为 target，下面的`echo "hello world"`被称为 recipes 或 rules。他们的意思也很明显了：我们使用 recipe 来构建 target。

### 2. compile hello world

在一个空文件夹下新建`main.cpp`文件，内容如下

`main.cpp`:

```cpp
#include <iostream>
using namespace std;

int main()
{
	cout << "hello world" << endl;
	return 0;
}
```

然后新建`Makefile`文件，内容如下：

```Makefile
main:
	g++ main.cpp -o main
```

编译：

```bash
make
```

编译输出：

```bash
g++ main.cpp -o main
```

此时可以看到编译出的文件：`main`

运行：

```bash
./main
```

输出：

```
hello world
```

Makefile 会把 target 看作一个文件，如果 target 不存在，那么使用 recipe 进行构建。在这个例子中，Makefile 先检测到`main`文件不存在，然后使用`g++ main.cpp -o main`进行构建。

在前面的 echo hello world 例子中，target 是`hello`，由于`echo "hello world"`总是无法生成`hello`文件，所以每次运行`make`都会执行`echo "hello world"`。在当前例子中，由于`g++`命令执行后可以生成`main`文件，所以第二次执行`make`命令，将不会执行任何操作，并输出`make: 'main' is up to date.`。

### 3. dependency

[to do]

`make`并没有版本控制系统，所以如果我们此时修改了`main.cpp`中的内容，再执行`make`，那么`make`检测到`main`文件存在后便不再执行任何操作

## Rules

通常每

rules:

```makefile
targets: prerequisites
    command
    command
    command
```

* The `targets` are file names, separated by spaces. Typically, there is only one per rule.

* The `commands` are a series of steps typically used to make the target(s). These need to start with a tab character, not spaces.

* The `prerequisites` are also file names, separated by spaces. These files need to exist before the commands for the target are run. These are also called *dependencies*.

Example:

```makefile
blah: blah.o
	cc blah.o -o blah  # Runs third

blah.o: blah.c
	cc -c blah.c -o blah.o  # Runs second

blah.c:
	echo "int main() { return 0; }" > blah.c  # Runs first
```

依赖链分析：`blah`的生成需要`blah.o`，`make`程序往下找到`blah.o`目标，发现它依赖于`blah.c`；然后`make`程序发现`blah.c`什么都不信赖，所以直接就执行对应的命令了。

`make`程序会将`Makefile`中的第一个 target 作为 default target。

如果某个 target 已经被创建，那么`make`就会跳过这个 target。

如果某个 target 不创建任何文件，那么每次`make`，它被依赖时，总是执行。常见的`clean`选项就利用了这个特点：

```makefile
some_file:
    touch some_file

clean:
    rm -rf some_file
```

此时如果执行`make`，那么会执行`some_file` target。如果执行`make clean`，那么会执行`clean` target。

使用变量：

```makefile
files := file1 file2
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file
```

取变量值可以使用`$()`，也可以使用`${}`。

说明：

1. 这个例子里变量用`:=`赋值了，也可以使用`=`。

另外一个例子：

```makefile
x := dude

all:
	echo $(x)
	echo ${x}

	# Bad practice, but works
	echo $x 
```

自己写的一个例子：

```makefile
lib_src = hello.c

main: main.c hello.o
	cc main.c hello.o -o main

hello.o: hello.c
	cc -c ${lib_src} -o hello.o

clean:
	rm -f main

echo_lib_src:
	echo ${lib_src}
```

**打印一个变量**：

```makefile
$(info    VAR is $(VAR))
```

Ref: <https://stackoverflow.com/questions/16467718/how-to-print-out-a-variable-in-makefile>

打印变量这个功能挺有用的，有时间了看下。

**使用 eval 改变变量的值**

```makefile
$(eval COMPONENTS = opengl)
```

说明：

1. 目前不清楚使用 eval 对变量赋值和直接对变量赋值有什么不同

**执行多个 targets**:

```makefile
all: one two three

one:
	touch one
two:
	touch two
three:
	touch three

clean:
	rm -f one two three
```

multiple targets:

```makefile
all: f1.o f2.o

f1.o f2.o:
	echo $@
# Equivalent to:
# f1.o:
#	 echo f1.o
# f2.o:
#	 echo f2.o
```

其中`$@`表示 target name。

`make`的执行结果：

```
echo f1.o
f1.o
echo f2.o
f2.o
```

说明：

1. 如果执行`make`或`make all`，那么会分别执行`make f1.o`和`make f2.o`。如果执行`make f1.o`，那么只会执行`make f1.o`；`f2.o`同理。如果执行`make f1.o f2.o`，那么效果同`make`和`make all`。

**Wildcard**

常用的 wildcard 有`*`和`%`。

* `*` wildcard

## Conditional

```makefile
libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
        $(CC) -o foo $(objects) $(libs_for_gcc)
else
        $(CC) -o foo $(objects) $(normal_libs)
endif
```

匹配一个空变量：

```makefile
ifeq ($(TOP),)
$(error TOP not defined: Was preconfig.mk included in root makefile?)
endif
```

## Functions

Function call examples:

```makefile
$(function arguments)
${function arguments}
```

调用内置函数的一个例子：

```makefile
comma:= ,
empty:=
space:= $(empty) $(empty)
foo:= a b c
bar:= $(subst $(space),$(comma),$(foo))
# bar is now ‘a,b,c’.
```

## Variables

**在 makefile 中尝试输出当前的所有变量**

Ref: <https://stackoverflow.com/questions/7117978/gnu-make-list-the-values-of-all-variables-or-macros-in-a-particular-run>

上一级 make 和下一级 make 间的环境变量继承关系是怎样的？

如果下一级的 make 继承上一级的 make，那么就可以在执行下一级 make 前，把所有变量保存下来，从而可以单独运行下一级 make。这样就能独立编译一些模块了。

**makefile 中`:=`和`=`的不同**

`:=`是一次性赋值，`=`是递归赋值，一个变量改变，所有与之相关的变量都受其影响。

有空了看一下。

Ref: <https://stackoverflow.com/questions/4879592/whats-the-difference-between-and-in-makefile>

## Miscellaneous

1. 在 makefile 里使用`cd`进入其他目录

    ```Makefile
    target:
        cd xxx; run xxx;
        // or use this:
        cd xxx && run xxxx
    ```

    Ref: <https://stackoverflow.com/questions/1789594/how-do-i-write-the-cd-command-in-a-makefile>

* 在 make 时报错`*** missing separator.  Stop.`

    很有可能是`\t`被換成了空格。

* 如果一个 makefile 里的一个 target 只使用`$()`调用函数，不执行 bash 命令，那么它被视作什么也不做

    这时候会产生一条`make: xxx is up to date`的提示。

* 待处理的笔记（需要把 qa 完善，才能处理这些笔记）

    每个 makefile 都包含下面这五种成分： explicit rules, implicit rules, variable definitions, directives, and comments.

	其中 explicit rules 告诉 make 程序如何构建一个 target（通常是一个文件），implicit rules 告诉 make 如何构造链式依赖（主要是那些 prerequisites）

	一个命令只能做三件事：

	* Reading another makefile (see Including Other Makefiles).

	* Deciding (based on the values of variables) whether to use or ignore a part of the makefile.

	* Defining a variable from a verbatim string containing multiple lines.

	可以使用`-f name` or `--file=name`执行指定的 makefile。

	**include**

	将 make 程序从当前行停下来，先读取其他 makefile

	```makefile
	include filenames…
	```

	`filenames` can contain shell file name patterns. If `filenames` is empty, nothing is included and no error is printed. If the file names contain any variable or function references, they are expanded.

	Example:

	```makefile
	include foo *.mk $(bar)
	```

	include 文件的搜索顺序：

	1. current directory

	2. 使用`-I` or `--include-dir`指定的目录

	3. `/usr/local/include`, `/usr/include`

	The `.INCLUDE_DIRS` variable will contain the current list of directories that make will search for included files.

	You can avoid searching in these default directories by adding the command line option `-I` with the special value `-` (e.g., `-I-`) to the command line. This will cause make to forget any already-set include directories, including the default directories. 

	如果找不到 include 后面的文件，make 不会立即报错，只有当读完 makefile 所有内容，仍找不到构建 include 所需的 makefile 的方法后，才会报 fatal error。

	如果想让 make 在找不到 include 文件时不报错，可以使用`-include filenames…`。

	注：

	1. 这个`-I-`不知道怎么用，目前看来也没有什么用

	**MAKEFILES**

	If the environment variable MAKEFILES is defined, make considers its value as a list of names (separated by whitespace) of additional makefiles to be read before the others. 

	搜索的路径与`include`相同。

	看不出来有啥用。

	小知识：`%`会 matches any target whatever.

	**make的两个工作流程**

	GNU make does its work in two distinct phases. During the first phase it reads all the makefiles, included makefiles, etc. and internalizes all the variables and their values and implicit and explicit rules, and builds a dependency graph of all the targets and their prerequisites. During the second phase, make uses this internalized data to determine which targets need to be updated and run the recipes necessary to update them. 

	这两个阶段直接决定了 when variable and function expansion happens

	We say that expansion is immediate if it happens during the first phase: make will expand that part of the construct as the makefile is parsed. We say that expansion is deferred if it is not immediate. Expansion of a deferred construct part is delayed until the expansion is used: either when it is referenced in an immediate context, or when it is needed during the second phase. 

	* Variable Assignment

			```makefile
			immediate = deferred
			immediate ?= deferred
			immediate := immediate
			immediate ::= immediate
			immediate :::= immediate-with-escape
			immediate += deferred or immediate
			immediate != immediate

			define immediate
			deferred
			endef

			define immediate =
			deferred
			endef

			define immediate ?=
			deferred
			endef

			define immediate :=
			immediate
			endef

			define immediate ::=
			immediate
			endef

			define immediate :::=
			immediate-with-escape
			endef

			define immediate +=
			deferred or immediate
			endef

			define immediate !=
			immediate
			endef
			```

			For the append operator ‘+=’, the right-hand side is considered immediate if the variable was previously set as a simple variable (‘:=’ or ‘::=’), and deferred otherwise.

			For the immediate-with-escape operator ‘:::=’, the value on the right-hand side is immediately expanded but then escaped (that is, all instances of $ in the result of the expansion are replaced with $$).

			For the shell assignment operator ‘!=’, the right-hand side is evaluated immediately and handed to the shell. The result is stored in the variable named on the left, and that variable is considered a recursively expanded variable (and will thus be re-evaluated on each reference). 

	* Conditional Directives

			Conditional directives are parsed immediately. This means, for example, that automatic variables cannot be used in conditional directives, as automatic variables are not set until the recipe for that rule is invoked. If you need to use automatic variables in a conditional directive you must move the condition into the recipe and use shell conditional syntax instead. 

	* Rule Definition

			```makefile
			immediate : immediate ; deferred
					deferred
			```

			That is, the target and prerequisite sections are expanded immediately, and the recipe used to build the target is always deferred. This is true for explicit rules, pattern rules, suffix rules, static pattern rules, and simple prerequisite definitions. 

	**How Makefiles Are Parsed**

	1. Read in a full logical line, including backslash-escaped lines (see Splitting Long Lines).

	2. Remove comments (see What Makefiles Contain).

	3. If the line begins with the recipe prefix character and we are in a rule context, add the line to the current recipe and read the next line (see Recipe Syntax).

	4. Expand elements of the line which appear in an immediate expansion context (see How make Reads a Makefile).

	5. Scan the line for a separator character, such as ‘:’ or ‘=’, to determine whether the line is a macro assignment or a rule (see Recipe Syntax).

	6. Internalize the resulting operation and read the next line. 

