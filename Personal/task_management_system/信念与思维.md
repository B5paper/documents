# 信念与思维

人生活在时间中，目前时间是正向流动的，因此我们也必须一件一件地做事情，这些事情被称作任务。

有一些任务类型，在每天的活动中经常出现，为了提高处理效率，我们把这些任务单独命名，并拿出来分析，找到常用的处理方法。

有一些不可能一天两天就把完成的任务，我们将其称为项目。

## cache

* 团队合作的两种冲突：A 干了 B 的活（抢活）；A 和 B 都不想干活（甩锅）

    如果要避免这种情况，必须让这几个当事人在开始干活前开会划分职责范围，然后定期开会同步进度（比如一周一次或两周一次）。

    最根本的解决办法还是自己能吃透这一块，给手下的人根据不同的性格不同的能力安排合适的活，比如适合调 bug 就只去调 bug，有做设计的能力就去做设计，喜欢写代码就安排变动比较多的活，并且手下的人愿意听从自己的安排，自己的能力可以兜底。

* 做梦梦到客厅的电话柜顶上的天花板漏水了，水像柱子一样往下流，妈妈在对面的沙发上坐着无动于衷。我哭着喊道：“你根本不是我妈！如果我妈在这里，早就抢过水盆去接水，然后把漏水的地方修好了。”我非常清楚坐在沙发上这个人只是个没有感情的复制人，是个没有灵魂只有面容的躯壳。

    醒来后想到，灵气是我们身为人的一部分，如果让机器人模仿我们熟悉的人，但是表现不一样的人格，那么我们只会生气。然后又想到，情感确实是我们说不清道不明的一部分，超越了理性，控制着我们的行为和想法，“无论如何我都要回到那个地方去，找到原来的人的物”，这种想法会不断地淹没理性的发问：“为什么要回去？去见谁？怎么见？还能再见到吗？”

    过了一天，再想起梦来，理性又占据上风：为什么会有没有灵魂的假人？为什么天花板会漏水？为什么在旧家不在新家？这段情节能否扩展一下做一段感人的动画或视频（比如以机器人为题材，讨论如果有机器人和故人长得一模一样，但是没有故人的灵魂，那么人们会感到开心还是恐惧？再比如主角在老师父手下修行，老师父不知何时被调了包，主角其实早有疑虑，终于有一天，假老师父做了一件真老师父无论如何都做不出来的事，比如xxx坏了没去修，看着小动物死了无动于衷，此时主角大哭：你根本不是我的师父，如果是我的师父，早就去xxx了）？

* 理论上，说话是一件不可能完成的任务。因为我们需要寻找所有组词造句的可能性，才能说出一句完整的句子，它的时间复杂性是不可接受的。但是每个人都能完成，这是不可思议的一件事。目前不清楚为什么。

    2025/07/04/00: 有两点猜想：1. 常用表达就是最佳表达，因此大脑只需要像马尔可夫链一样在几个常用选项中选择一个就可以了，并且只依赖前面一到两个词做出选择，因此说话时的计算量不大。2. 常用表达不是最佳表达，但是大脑的工作方式并不是搜索全部假设空间，而是先并行地浮现几个一句话中的关键词或关键概念，然后把这几个概念串起来形成一句话，就像做填空题。这说明大脑的工作方式与计算机差异巨大。

* dfs 学习的两个常用方法

    1. 栈式（链式）问题回溯

    2. 猜想，假设，跳跃

* 笔记的结构

    先记录单个独立主题，再记录 topic，topic 中是多个独立主题的组合

* 任务完不成应该分两种情况处理，一种是有极大可能完成，只不过时间不够，另一种是还在调研搜集信息阶段，不清楚是否能完。显然这两种情况的处理方式应该是不同的。

* 在准备去执行一项任务时，不应该考虑当前状态是否为最佳，而应该考虑当前状态是否满足最低要求

* 笔记与中间结果

    有些需要记录的内容明显是中间结果而不是笔记，如果把中间结果当成笔记来记，那么在归类的时候就不知道该把归类到什么地方去。

    中间过程只是记录，不是结论，因此很难复用。这些不应该出现在笔记里。

* 对于一项任务，如果我们可以想象模拟出执行它的全过程，并可以预测所有可能的结果，那么它就不是一个“调研”

    比如“记忆”，就不是一个调研；随机检测 qa 也不是一个调研。

* 如果一个任务没有指定具体的类型，那么就默认认为它是个调研任务

* 在开始一项任务前我们真的需要最佳状态吗？如果最小状态可以满足，那么就认为任务可以开始。

* 非线性项目

    如果完成一个项目用到的知识无法全部从 qa 和 note 中得到，并且这个项目有时间约束，那么这个项目就是一个非线性项目。

* 非线性变化

    假如现在有一团热气流和冷气流相遇，如果在对气流一无所知的情况下去做仿真，大概率得到的结果是冷气流与热气流的温度逐渐趋于相同，锋面的温度变化最快，远端的温度变化最慢。我们大概率不能直接仿真出龙卷风，台风。

    假如我们提前知道了冷暖气流相遇有可能出现台风，那么大概率会修改我们的仿真算法，使结果中一定几率出现台风。

    对于云层也是一样，假如我们对云的知识一无所知，那么大概率只能仿真出一块一块的云，但是自然界有卷云、排成阵列的云、下击暴流的云，如果我们提前不知道这些概念，那么它们几乎不会在仿真里出现。

    假如我们称冷暖空气的温度变化、天空中的白云为线性变化，台风、阵列云就是非线性变化，那么问题是：非线性变化是什么带来的？我们在仿真时如何才能尽可能地捕捉到这种变化？

* 我们的对抗并不是谁把任务做完，谁投入时间长谁就能取胜的，而是大家都把当前工作做到精致的情况下，继续对未来的可能性进行探索、冒险、赌博和选择。

    按部就班的回答不会有奇迹。

* 非 cache 笔记（顺序笔记）的原则：假设自己对所有的概念都一无所知，又假设所有后续的笔记都依赖前面的笔记。

* 概念重定义

    对于一个所有概念都清晰定义的系统，如果剔除某个概念 A 的定义，只保留其他概念对 A 的使用，那么根据这些使用的描述，我们能从什么程度上反推出 A 的定义？

    example:

    > 为了获得高带宽，shared Memory被分成32（对应warp中的thread）个相等大小的内存块，他们可以被同时访问。不同的CC版本，shared memory以不同的模式映射到不同的块（稍后详解）。如果warp访问shared Memory，对于每个bank只访问不多于一个内存地址，那么只需要一次内存传输就可以了，否则需要多次传输，因此会降低内存带宽的使用。

    上面是某个博客的一段文字，其中用到了 bank 的概念，但是并没有给出 bank 的定义。我们是否能仅通过类似这样描述性的文字，推测出 bank 的定义或含义？

* 如果有 new task，可以添加到当日的 task list 里，但是必须添加`[new]`标记

    比如：

    ```
    * [ ] task 1
    
    * [ ] task 2

    ...

    * [new] new task 1

    * [new] new task 2

    ...
    ```

    添加到当日的 task list，可以防止

* 没办法写成笔记的东西

    * 寻找解决问题的灵感或对未知未来探索的过程

        “探索”的过程不可写，首先写出来就会失去灵性，既受限于文字，也失去了“虚”的感觉；其次写下来的思考速度会变慢，书面表达的思考速度太慢了。

        但是已经探索明白的，可能会形成方案的思路可以记录下来，作为一个待调研的思路。

    * 临时的记录、中间步骤、中间猜想与中间结论

        这种比较适合写到 tmp 中。比如记录一下目前的函数调用嵌套了多少层，要搜索的字符串的 start pos，某个对象的指针的值等。

        其实写到 tmp 中也会拖慢思考速度，这种最适合的就是在脑子中临时记住。

* 如果一个项目是有用的，那么最好的开始时间就是现在。

    假如往后推迟了几天，就无法找到一个完美的开始时间，总是想着所有工作都准备就绪，所有状态都达到最佳，并且可以专心一下午，没有其他事情打扰，这样的情况可能只有 5% 的概念会出现。所以还不如直接现在就不完美地开始。将项目添加到任务管理系统里，并且保持追踪，这才是最佳的做法。

* 与其专门准备一个下午去做一件事，不如把这件事分摊到每天。

    想要专门腾出一段时间做一件事是困难的，通常会：想做事情 A，终于等到有空闲时间的机会了，这时候又觉得事情 B 更有意思，或者刚开始一会事情 A，又被突如其来的事情打断了。

    况且连等到空闲时间的机会都很少，不是身体疲惫，就是精神不佳。实际上，我们大部分时间都是这样的状态，与其等到最佳的状态，不如适应不佳的状态。

* 浮躁

    场景：地理上因为某块地有躁气，人们追求快而浮躁，就像在浮屠塔一样。此时有一个人初来乍到，被卷入纷争，不停地有人引诱，诈骗，躁动，疯狂，幸好这个人经受住了考验。离开此地后才发现这个地方向上冒着煞气or是个鬼城。这两个结局都挺不错的。

    人的精神世界来自于对物质的态度，来自于与自然的共处，来自于人与人之间的关系处理，来自与社会的联结，来自于自己的思想。精神世界的广阔程度与物质世界不相上下。精神世界经受的考验也与物质世界经受的考验（饥饿，温度，劳累等）相当。

* 重新强调一遍，退出任务时保证 stack 干净非常重要。桌面、床铺等日常环境同样如此。

* 给出一个定时器，到达时间后停下来做任务总结。未到时间就想停下则需要锻炼注意力。

* 容错

    学术界的科研容错率太低，如果有类似科技树的东西来指引科研的成就和成功率，哪些方向做过了，哪些没做过，那么我们就可以做出选择，对于不想做出重大贡献的科研人员，只需要选择成就较低、成功率比较高的 branch 进行研究即可；对于有志向的科学家，则可以选择成功率更低，难度更大的 branch。很可惜这样的指引几乎不存在。经常有人错估了难度，导致研究出了东西时，发现别人都做过了。

* 是否掌握一项技能，最好的判断方法是看能不能复现。

* 如果两个过程细节不同，但是全局相同，那么对照实现起来非常麻烦，我们无法根据单步调试一行一行地照搬，必须整理了抽象的全过程，再去做实现

    但是这个过程也是非常有意义的，全局相同，说明这两个过程的核心相同；过程不同，说明加入了噪声干扰和泛化。如果能对这两个过程进行研究，找到相同的核心和本质，还是可以提升自己的。

* 有关效率的进度

    创建任务管理系统 -> 通过系统来提升效率 -> 在同样的时间内完成超越别组的任务 -> 等待其他组/人的进度 -> 挤出些许自由时间 -> 进行算法的调研和验证 -> 做出创新

    目前看来，这条设想进行得不错。

* 有关算法创新的进度

    选择一个需要大量 coding 的工作，锻炼 coding 能力，实现脑中所想皆可用代码验证（目前选择了驱动） -> 进行算法创新

    目前看来这条设想也是对的。确实有了大量 coding 的机会，但是又不仅限于增删查改，许多中等算法题目得到了应用，非常不错。

* 进与退

    光靠进无法达到目标，必须退退进进才有可能找到正确的方式。就像调研与时间的约束，以及笔记的 cache 退化，都是允许了退的情况下，取得了很好的效果。

    或许进是一种深度优先搜索，退是一种广度优先搜索。但是感觉进与退蕴含的比这两者要多。

* 印记

    重大的事件会在身上留下不可逆的印记，我们不可能总是完美。

* 魔鬼与模仿

    魔鬼在被处死前模仿人类流下眼泪求生，人类答应放他一条生路后，魔鬼趁机反杀了人类。那么魔鬼模仿人类流泪，和人类真正的流泪，有什么本质区别吗？猜想：魔鬼只是模仿并得到利益，当其他人向魔鬼哭诉时，魔鬼不会放他生路；而人类的哭诉之所以和魔鬼不同，是因为人类会联想到，当其他人向自己哭诉时，自己也会放其他人生路。

    如果猜想成立，那么魔鬼就永远无法变成人类，因为魔鬼的模仿总是从利益出发。

* 滚动的齿轮

    假如有很多个减速齿轮耦合在一起，最外面的齿轮转动比较快，那么最里面的齿轮转动很慢。拿这点和探索类比，我们在探索未知时先收集简单的规则和知识，组成集合$S_1$，然后再根据$S_1$的内容，再次遍历 resource，得到新的规则，修改旧的规则，组成集合$S_2$，像这样将集合$S$越滚越大，直到可以解释所有的 resource。有那么多的学科，那么多的社会规则，但是这套探索的方法在很多时候都行之有效。我们可以认为这种方法是最里面的齿轮。

    或许有更好的方法，更高效的方法，但是一定会受到更里面的齿轮的控制，更里面的齿轮普适范围更广，转动得更慢。

* 其实调研也是一种是 cache，是一种广度优先搜索，它安排了必须要回答的问题，优化了任务列表的结构，整合了小范围内的信息，防止有歧义在前，回答在后的情况发生

    调研不做实验，不使用实验对猜想做验证

* 形式与环境不是本质，但是极大程度影响了本质的发现过程

    在 win 系统下，多桌面不方便，所以很难快速地切换任务，也很难给一个任务独立的工作空间，更不可能栈式地递归展开依赖任务，因此在 win 上很难形成像现在一样的任务管理系统。

    虽然说多桌面不是任务管理和时间规划的本质，但是它促进了效率较高的任务管理方式的发现。

    因此改善办公环境，尝试一些新的环境的改变可能会带来一些变化。

* 不可能存在静态的平衡，只可能出现动态的平衡

    打乒乓球时要求每打完一拍都要快速“归位”，以做好迎接下一拍的准备，那么生活中是否有一些 routine，可以保证在执行下一项任务前，可以精神饱满，不饿不渴不累，周围没有杂音干扰，注意力可以快速且长期地集中？
    
    比如在学习某篇论文之前，先睡 30 分，再运动 20 分，再吃一点东西，再喝几口水，做完这样的 routine 后，再全身心阅读论文？或者每晚睡够 8 个小时，早上晨跑，吃早饭，10 点喝一次水，中午吃完饭午休，晚上按时睡觉，这样来保证上午 8 点到 11 点一定精力充沛，下午 2 点到 6 点，晚上 7 点到 9 点一定精力充沛。我觉得这样的静态平衡是不可能做到的。

    取而代之的静态方案是，在一项任务的末尾开始考虑与下一项任务的衔接，如果渴了就喝水，如果饿了就吃点零食，如果特别困就去睡觉。在一项任务开始之前，也可以简易地收拾下周围环境，保证接下来 30 ～ 40 分可以注意力集中。这样的动态平衡目前看来是比较好的解决方案。

* 对抗与平衡

    假如失去了两种力量的对抗，那么就失去了方向。我们选择前进，其实指的并不是失去对抗后往前乱走，而是找到了新的平衡点后，从旧的平衡点迁移到新的平衡点，在新的平衡点处继续进行对抗。

* 佛教的我执与哥德尔不完备定理

    哥德尔不完备定理指出，在公理体系内，存在真且无法被证明的命题。佛教讲究无相，从不执着于众生相，一直到放下我执，在我执这里有一个自我执涉。假如说了“放下我执”，那么大家对我执就有了语言的相，总是想起这一句话；假如不说“放下我执”，那么大家又不知道该怎么做。密教选择不说，靠跨越语言、跨越文字的个人领悟；显教选择说，虽然语言逻辑上没问题，但是我执又很难放下了。

    由此可见，佛教的难题其实就是哥德尔不完备定理的一个体现。正因如此，佛才说：“不可说。”说出来就不灵了。

* 如果一个地方曾经感觉很有灵气，但是再次去时感觉没有灵气了，很可能是因为没有风。

* 一位亦正亦邪的神：负责掌控人类的情感，肉体，非理性的部分

    当他释放力量时，颓废的人变得亢奋，电影院的人失声痛苦，胆小的人变得无畏，斤斤计较的人不再看重个人得失，人类会完成许多之前无法完成的事情。

    但是人们又会勾起欲望，靠着身体的强壮和力量互相厮杀，逐渐走向堕落。

* 如果不尽自己的全力，那么就是对对手的挑衅和羞辱

    类似于百米赛跑时，“我允许你先跑 30 米”的感觉。

* 包絡面

    我们的状态有时是波峰，有时是波谷，系统的作用就是在波峰上制作一张包絡面，使得我们的状态几乎总是沿着波峰前进。

* 有关景物所引发的思考

    假如我们被要求看到一个景物后，联想到随机一件事。那么这件事很大概率是在我们心里与景物联系最紧密的。因此分析我们联想到的内容，就可以分析我们的心理状态。有点像罗夏测试。反过来想，我们也可以把所想强行融合到景物上，对景物进行主观改造。

* 有关畸形环境与正确的道路

    假如我们遇到的所有环境都是畸形的，畸形环境之外还有正确的环境，我们可能会陷入局部最优，无法振荡出来。那么是否有一些方法让我们从畸形的环境后找到正确的规律呢？

    举个例子，假如周围所有人都在玩抖音，我们如何才能有机会发现抖音之外的正确道路呢？

* faster and faster

    技术更新换代越来越快，工作的职业周期也越来越短，以前可能 20 年才会淘汰一批技术，现在可能 10 年，5 年就有新的技术出现，旧的技术被淘汰。留给打工人的技术积累期越来越短，以前可能要求 35 到 40 岁能在圈子里积累一些声望，现在需要 30 到 35 岁就在圈子里积累一些声望，再往后可能是 25 到 30 岁。老员工被淘汰，应届生的工资越来越高，代价是留给应届生发展的时间也越来越短，如果到了 35 岁没有一番成就，一定会被淘汰。

    不断压缩的职业成长时间与不断提高的校招生薪资，似乎在暗示我们，并不是其他原因造就了这种现象，而是来自我们自身想要快速跨越阶级的欲望。

* 目标优先的探索模型

    从目标开始倒着找所有需要达成目标的条件，如果条件比较容易满足就快速满足一下。在满足中间条件时，肯定会发现有些中间条件仍然值得探究，此时必须选择暂时放弃，继续满足其他中间条件。值得探究的中间条件都保存起来，在完成目标后再去逐一探索。

    如果不是目标优先，那么就不断组合新概念与自己已有的其他概念，如果有收获就记录下来，感觉差不多了再进行下一个新概念。

    这两种模式必须穿插进行，效果才最好。

* 应该建立一个 reference resources 目录，把所有的引用资源都放到这里

    如果每个目录下都是从`ref_0`编号，移动笔记时就会混乱。

    如果统一管理 reference，就不会出现这个问题。

    可以从`ref_0`一直编号到`ref_100`，随着 ref 不断被处理，再删掉`ref_0`重新开始。

    每次删除的时候，可以在 documents 里用`grep`搜索`ref_0`保证没有被引用的地方。

* 如果看到一个名词没有任何头绪，那么就去*调研*它

    比如当天的任务，如果没有头绪，那么就*调研***当天的任务**。

    比如某个项目，如果不知道怎么开展，那么就去*调研*这个项目。

    如果对于某个任务，忘了它是怎么开始的，想不起来和它相关的所有东西，那么就去调研这个任务。

* 恶性竞争

    假如有两个公司 A 和 B，A 做的是热门泡沫方向，B 做的是扎实工作方向，结果 A 能融到资，B 融不到钱，最终 B 倒闭，A 最后也会因为泡沫破裂而倒闭。

    对融资公司来说，B 可能投资几年都什么起色，但是投资 A 可能有 10% 的机率挣大钱。理性的人可能会按比重分配资产投资，但是不要低估人性的贪婪，为了赌这一点很低的可能性，投资公司可能会加杠杆梭哈。

    假如有三家投资公司 C, D, E，这三家都投了 A 所在的行业，已知这个行业一定有一个胜出者，其实就是 C, D, E 在下注赌。C, D, E 都觉得最幸运的应该是自己，假如自己不跟注，那么挣钱的就一定会是别的两家投资公司。这样很不甘心。

    最终的结局是所有公司都赔了，每个环节的最优选择，导致了全局的最坏结果，非常讽刺。

* 遇到这样一种情况，假如`A = [1, 100]`，`B = [rand(1, 100) * 10] U [100, 1000]`，要理解某个知识，需要 B 中的各个知识点

    但是 B 中的资料需要到 A 中去查。

    如果把 A 从头到尾看一遍，那么需要大量的时间。但是不看 A 就无法理解 B 所需要的知识。

    这样的情况比较难处理。

* 10 亿以上重资产的创业能不能盈利和宏观经济有关

* 计划的重点在于可以回退

    之前大部分计划无法执行下去是因为只能顺序执行，没有考虑过失败和回退。

    如果总是回退，那么会导致没有动力去执行任务，也不汰好。

    这两者中间应该有个平衡点。

* 未经证实的，对概念的一个可能的解释被称为一个猜想。

* 如果可以使用“猜想”去解释一个现象，那么就可以进入实验阶段

    如果可以无法作出“猜想”，只知道哪个方向可能提供更多的信息，那么只能是“调研”

    无法作出猜想的阶段，都只是收集信息的阶段。目标就是为了作出猜想。

* 调研的目的不是完成任务，而是要有输出

* 假如 A 是一个节点，所有的联系都是从 B, C, D ... 指向 A，从 A 起始没有任何向外的边，那么 A 就很难被发现了。

    相反，如果有连接从其他节点指向 A，哪怕只有一条，也终究会被搜索到。

    这种现象可以被称为概念的禁锢。

* 每份笔记中应该专门开一个 examples 区域，整理详细的 example

    在笔记正文中出现的 example 只需要专注详解原理就行了，可以只是代码片段，也可以不检查返回值，不进行错误处理。

    example 区域中的 example，需要在追求简洁的基础上，增加一些返回值判断和错误处理，有完整可编译运行的代码，并且有运行的输出。

    问题：qa 中的代码片段该归属于哪一种？

* 进度的 sync

    如果一个项目长时间不合理发展，就会出现调研、 qa 和笔记不匹配的情况。这种情况下，需要对进度进行 sync，确认下面几个问题：

    1. 如果无法从学习资料中总结出新的笔记，那么认为学习和笔记的 sync 完成

    1. 如果无法再从笔记中找到一个新的 qa，那么认为 qa 和笔记的 sync 完成

    1. qa 里不能有 empty

    1. test, qa 文件夹 clean

    1. 可以连续三天通过随机 qa

    1. 项目池/笔记中不能有相关的 cache

    显然，项目进度的 sync 不应该出现在项目管理里，而应该由任务执行系统负责。

* 应该创建一个项目叫 reorg，同 qa 一起，组成自举系统

    reorg 用于每次在所有笔记，所有项目，以及所有理论系统中挑选出一个片段，尝试对其进行整理，重组，发散或者删除。

下面是一些标准任务以及处理它们的一些经验。

## 想法与待解决的问题（cached）

这一部分作为想法，灵感以及问题的缓冲区，记录各种相关的内容。

* 思考：像这种既没有经验，也没有参考，只能靠临时反应进行和大量交互进行下去的任务，该如何分配时间？

    没有任何的可借鉴经验，不清楚结果，这种任务被称为 blackhole task.

* 缓存策略和 stack 策略都非常有用，使得条理很清晰

* 有关笔记的整理

    可以消除一些笔记中穿插的一些 reference 资源，或者将资源提取出来。

* 假设：我们假设人脑每次能处理的任务的复杂程度有限，每次处理一项任务的最大时间也有限。因此需要把任务切分成刚好够人脑处理的一个片断。

* 未来需要做什么的任务列表固然很重要，但是描述自己在过去的一段时间里做了什么同样重要。

* 需要对任何结构化的资料进行定期整理，包括笔记，qa，任务管理系统，以及临时项目管理。

    主要整理方式就是从无序到有序，从混沌到结构，有相同点的整理到一起，有临时想到的写到缓存里。

* 当一个程序越来越大时，如何能快速知道以前开发过了什么功能，快速对自己的项目上手，这个问题需要思考一下

    目前一个思路是对当前项目也写一个简易的 qa，安排进检测列表

* 这一部分（即想法与待解决的问题）是否应该归类到反馈系统？

    或者说，所有的 log，缓存，是否都算是反馈系统的一部分？

    栈（依赖关系）的处理是否不算反馈系统的一部分？

* 有关 blackhole task 的处理

    因为 blackhole task 的问题都是动态创建且短暂的，总是在经历快速的假设->实验->推理的过程，所以无法像“学习”过程一样有固定的时间。但是可以研究如何快速保存任务进度，随时中断，从而可以预定时间。

* 有关任务处理的一些问题

    在执行一个任务时产生了新的问题，新的任务，把这些东西放到 log 中去，不要影响堻圭前的任务。

* 从混沌到结构，从无序到有序

    在结构化的笔记上面，创建一个混沌区域，这个区域中都是临时想到的一些想法，等这些想法积累得足够多了，就将它们组合成结构化的知识。

    另外一个是，临时想出的想法，先缓存起来，不耽误当前任务的执行，等有空余时间了再批量处理。

    这两点或许会非常非常重要，是整个任务管理系统的基石。

* 如果一个任务，在其他任务创建 stack 时，经常会创建到它，那么就称这个任务为伴生任务。

* 缓存待完成的任务是一个非常好用的经验，但是并不能长时间使用，因为缓存不太消耗脑子，可以非常容易地获得短暂的满足，所以脑子一直处于放松的状态，时间一长就是在浪费时间。

* reduce 过程通常比较轻松，不会消耗太多的精力，如果一直 reduce 就会陷入空虚。

    cache tabs 也是一种 reduce.

    因此和 reduce 相关的任务，要设置一个时间上限，不能无休止地 reduce。

* 目前的随机检测系统实际上已经支持了随机任务 + 随机索引，以后只要规定 qa 的数量就可以了

* 可以使用 move 从函数中返回局部对象吗？

* vulkan 可以把核心绘制部分写成 qa，即 draw frame 函数

* vulkan 的 qa，如果不把 dependency 机制做好，那么很难继续下去

## 调研

所谓调研就是在尽量不做实验的情况下，看看能理解多少东西，不理解的东西就记下来

调研的目的是投稿少量的时间和精力，从大任务中生成小任务，将不标准的任务转换成部分标准的任务，并给出时间规划。

* 调研的三个结果

    要么给出更多的问题，要么给出已经收集到的信息，要么给出具体的任务。

    如果有更多的问题待处理，那么就给出问题。如果找不到什么问题，那么至少应该给出信息。

    如果感觉某些任务可以完成，那么就给出任务。

    只给信息，不给问题，可能是因为需要后续判断是否还要做这个方向。

1. 项目调研 -> 产生项目规划

    寻找参考资源，简单分析项目可行性，分析项目依赖

2. 任务调研 -> 产生具体任务列表

    简单浏览一遍参考资源待看的部分，大概了解下材料的难度，细分再细分，直到感觉某个概念，某一段话，某个公式，自己可以短时间内搞定为止，将其写到任务列表上。

    更长远的思路写个大致的规划。

项目调研和任务调研也都算在任务清单中，他们所占用的时间和精力一点不比具体的任务少。

调研：如果对已有的书面学习材料的调研，那么就顺序阅读，不回看，如果理解顺利，那么一直看下去，直到遇到无法理解（解释有矛盾，或者有未知信息）的地方为止。最大调研时间 20 分钟，超过 20 则停止。

调研时需要回答的几个问题：

1. 看了刚才的内容，我能否用它来做一些事情？和过去我学过的内容有什么关系？

    如果这个问题可以回答，那么就将它加入任务列表里。

1. 刚才看过的内容，里面的每个概念我能否用自己的话描述？

    如果不能描述，那么中止。如果这个答案依赖某个遗忘的内容，那么将复习遗忘内容加到任务列表里。如果这个答案依赖一个未知的内容，那么将新的调研加入到任务列表里。

调研与具体的任务安排都是平等的关系。

## 复习

如果对学到的知识不进行复习，那么很快就会遗忘。

为了提高复习效率，这里使用问答的形式进行复习，因此又叫 question and answer，又叫 qa。

* 每天的随机检测非常重要，一定要把时间均摊到每天，这样的 qa 才有意义。

* 旧的 qa 没复习完前就不要写新 qa 了，因为都不知道学到哪了，也不知道该整理什么资料

* 创建一个 qa 池和一个随机数生成器，每次先从 qa 池中随机挑选一个项目，然后再随机选一个 unit，进行检测

    如果遇到不会的 unit，那么找它的 dependency，如果 dependency 还不会，那么再找它的 dependency，以此类推。

* 每个项目开始之前，先进行随机检测。每个项目随机检测的时间不应该超过半个小时。

* 以每 30mins 检测 2 个 qa 为准

* qa 一定要基于 note，而不是独立于 note。qa 与 note 最大的区别在于，qa 是条目式的，缺少细节，并且有 dependency，而 note 专注结构和细节，并且有更多的思考和延伸参考资料。

* 关于 qa 文件格式的改变

    使用`[idx]`标签标注从上往下的索引，用于唯一定位，从 0 开始。

    使用`[id]`标签标注一个哈希值，用于唯一定位。使用对当前时间的哈希即可，主要不重复就可以了。

    使用`[dep]`指定当前条目所依赖的条目，写法如下：

    ```
    [dep]
    <id> - <u_0>
    <id> - <u_0>
    ...
    ```

    因为`[id]`和`[u_0]`可能在文件里出现很多次，所以仅使用这两个无法快速精准定位。

    `[u_0]`也有可能写得很长，还是用 title 吧。

## 记忆

对于标准化的记忆过程，需要精心准备干净、准确的记忆材料，并使用称为“联合”的概念来描述记忆，另外还必须使用复习来巩固才能达到想要的效果。

所谓的联合，即提到 A，马上想到 B，其中 A 和 B 都是记忆材料。A -> B 这样的联合称为单向联合。如果提到 B 也能想到 A，那么 A <-> B 这样的称为双向联合。

实现联合最原始的方法是机械记忆法，即熟悉完 A 材料后马上熟悉 B 材料。其中熟悉的方法有看，读，听，写，默念。附加的条件有：不同场景，不同时间，不同顺序，不同位置。

不同场景：桌子前，操场上，街道边，厕所里，晴天，雨天，热闹的场合，安静的场合等不同场景下记忆，效果更好。

不同时间：凌晨，早上，中午，晚上，半夜。

不同顺序：假设要记忆 A1 -> B1，A2 -> B2 等这样的材料，如果总是按照 A1, A2, A3 等这样的顺序，那么会产生时间和空间的连续性。所以顺序记忆比乱序记忆更容易一些。在完成顺序记忆后，需要使用某些产生随机数的方法来达到乱序的效果。

除了这些，还可以有不同材质，不同形式，不同字体等等。

双向联合：单向联合要求看到 A 后给出 B，并不要求看到 B 后给出 A。双向联合要求两个方向都要做到，因此要把单向联合的过程实施两遍。

**记忆材料**

无论如何实现联合，都必须满足如下条件：当看到 A 材料时，无法看到 B 材料；当熟悉完 A 材料后，需要马上可以熟悉 B 材料，或者自己给出 B 材料后，需要马上可以检验给出的 B 材料对不对。另外还需要可以乱序记忆。为了实现这个需求，目前我能想到的有下面三种形式：

1. 在笔记本上分栏记录记忆材料，左侧为 A 材料，右侧为 B 材料。

    当联合时，看完左侧 A 材料，在右侧可以看到应对的 B 材料。在检测时，可以捂住 B 材料的内容，复述完后移开手，可以直接检验复述是否正确。

    当乱序记忆时，可以用纸片抽签的形式产生随机数，定位到第几则记忆材料。

1. 在小卡片上正面写材料 A，背面写材料 B。

    联合时只需要分别看 A 材料和 B 材料就可以了，很方便。缺点是比较薄的纸会隐约看到背面的内容。

    乱序记忆时只要对卡片进行洗牌就可以了。

1. 使用电脑数据库，编程实现 A 材料，B 材料的出现以及乱序记忆。

**联想记忆法**

联想记忆法有跳跃联合，形变，谐音，同异点等。

1. 跳跃联合。如果我们的脑子里已经有 A -> B 的联合和 B -> C 的联合，那么就可以以 B 为中间节点，快速地形成 A -> C 的联合。问题在于并不是每个节点 B 都是容易找到的。

1. 如果我们可以对材料 A 施加形变、联想谐音、虚构故事或添加逻辑达到材料 C，那么就可以把形变过程、谐音、故事或逻辑作为中间节点 B。此时 B 越新奇，越有冲击力，记忆的效果越好。

**跳跃游戏**

平时无聊的时候，给出某个节点 A，比如一个词语，一个图形，一段语音，然后进行联想到其他的记忆节点 B1，B2，B3 等等。再从 B1, B2, B3 等节点中选择一个，进行下一轮发散。我称其为思维跳跃游戏。

**检测**

为了完成一个记忆过程，检测是必要的。有一个猜想是记忆的本质不是模仿，而是创造。在检测时，我们需要看完材料 A 后，给出 B'（方式为说出来，写出来，想象出来等），然后与材料 B 进行对比，完全相同才算联合的形成。

对于一组记忆材料的检测有两种方式：

1. 顺序检测。检测的顺序和记忆的顺序相同。这种比较容易达成。因为往往简单重复账户

**记忆的复习**

记忆的遗忘规律有如下几个：前几天忘得快，其后忘得越来越慢；记忆的材料越相似，越容易混淆。

目前采用的复习方案是：

1. 第一天要求完成顺序记忆和至少一次乱序检测。

1. 第二天要求完成乱序检测。

## 理解

### cache

* 当我们说一个任务无法完成时，意味着我们必须要完成其他前置任务，依赖任务

* 如果学新概念/知识时，所有的新概念都可以从已知的知识轻松推导出来，那么就称这种学习过程为线性学习

    如果在学习一块新知识时，新知识中的一部分或全部无法通过已知概念推导出来，那么就称这种学习过程为非线性学习

* 非线性学习的一些方法

    * 总会有一些东西是可以一眼看懂的（从旧知识中推导出来），对这些一眼可以看懂的知识进行条目化总结。

        sync 这些新概念，直到可以用它们解释其他的新知识

    * 猜想-验证，对于无法理解的概念，先给出自己的一个猜想的解释，然后做出一些预测，再去验证，最后修正自己的猜想

        难点在于，有时候需要同时对大量的新概念提出猜想，变量过多，不容易修正自己的猜想。

    * 孤岛信息的连结

        如果有一段一两句话的知识点，虽然看不懂，但是可能在新知识体系中有用，不需要理解，但是需要知道它出现过，以后可能用得到，这种孤岛信息可以选择性地收集起来，以备后面使用。

* 基于 nccl 调研的非线性学习心得

    这个过程和扫雷有点像，都是从确定已知的信息开始，从内向外逐渐推测功能，做出猜想和假设，并做实验进行验证。

    比如在 set_path() 函数中判断 path 的含义时，我们可以看懂并确定的代码时，每次搜索到一个 rem_node，都会搜索其 rem_link，当发现 rem_link 指向当前 node 时，就把 rem_link 添加到 rem_path 最开头的位置，并将 path 的内容添加到 rem_path 的后面。由此我们做出猜想：rem_path 的作用是从 rem_node 出发，终点为 base node 的 edge list。由于此猜想在后面的代码被多次验证，所以大概率是对的。由此我们还可以做出推断：与 rem_path 相对应，path 的作用是从当前 node 出发，指向 base node。这个推断再次被证明为对的，我们又可以做出推断：`getPath(struct ncclTopoSystem* system, struct ncclTopoNode* node, int t, int64_t id, struct ncclTopoLinkList** path)`的作用是返回从`node`出发，指向 type 为`t`，topo id 为`id`的 node 的 path。

    注意推断（inference）和评论（comment）的区别，推断可以推动理解的进展，评论只能发散思维，或者提出问题。推断的一个重要标志是通过实验验证猜想，而评论只需要说出感觉，重新叙述，提出问题，作出评价。

* ai 的回答不可能替代人的理解

    猜想：人的理解的本质是将新知识的每一个概念节点与脑中已有的旧知识的大量概念节点进行匹配，最终可以对某个现象做出解释，预测，并且有能力验证。新概念的融入要求不能对既有的知识体系引入矛盾。由于这个过程一定是需要人亲自完成的，所以 ai 并不能缩短这一过程的时间。ai 可以提供信息源，可以提高匹配过程的效率，但是无法真正地取代匹配。因此 ai 的回答不可能替代人的理解。

* 必要的 bfs 与非线性

    对于有嵌套结构的材料，有两种方式可以尝试理解，一种是 dfs，另一种是 bfs。dfs 指的是首先关注材料的第一段话，第一句话，或关注代码的第一行函数，然后再层层展开，直到遇到不能理解的，要么去查资料，要么回退到上一层，并尝试向前/向后看一些，并给出猜想，由此再向后推进。

    bfs 指的是先浏览材料整体，根据自己当前的水平和理解，给出各个模块的作用以及模块与模块之前联系的猜想。此时会大量使用非线性的技巧。

    显然 dfs 更细致，更精确，但是如果非骨干的细节过多，会耽误对主干的理解。dfs 的周期通常很长，一个任务 pending 很多天无法完成，导致任务越积累越多。那么什么时候该用 bfs？如果是一个调研性质的任务，不需要强制实现，并且希望任务尽快收尾，那么就使用 bfs。如果某个任务需要强制实现，并且这个任务长期存在，那么就使用 dfs。

* dfs 停止的条件

    阅读材料时，每次开始认为是一个 block，每遇到一个无法解释的点，则记 uncomprehensive point +1，记录够 N 个后，则认为这个 block 到此已经无法再理解了。可以尝试从下面开始，或者往下跳几段/几章，开始一个新的 block。如果新的 block 也无法理解，则记录 uncomprehensive block +1，攒够 N_2 个后，则认为整个 material 是无法理解的。

* 未知概念的非线性搜索范围

    一个初步的方案：假如概念 1 没有理解，可以暂时跳过，继续看后面的东西。假如看到了概念 2，概念 2 依赖于概念 1，概念 3 也依赖概念 1，但是概念 3 与概念 2 是独立的，那么可以借助概念 2 和 3 理解概念 1. 假如概念 4 依赖概念 2，而概念 2 还没弄明白，那么就应该停止了。

### note

**理解**

对于给出的一个名词、定理或问题，如果我们可以给出解释和例子，使得想象中不懂这门课的人也能完全听懂，那么就称我们理解了这个名词。

**可理解的**

如果一段话中的每个名词、逻辑和自己提出的问题，我们都能予以解答，那么就称这段话是可理解的。

显然，如果不理解一段话，无非是遇到了以下几种问题：

1. 名词看不明白

    1. 没有解释的新名词

    1. 之前学过这个名词，但是忘了

    1. 名词有歧义

1. 逻辑解释不通

1. 自己提出的问题无法解答

很多时候我们的不理解是含糊的，混乱的。之所以要把各种不理解的情况列出来，是因为我们必须要把问题清晰完整地陈述出来。这是走向理解的第一步。

事实上，一切的不理解最终都推向一个无法解答的矛盾。只有把这个矛盾清晰完整地说出来，我们才能说我们不理解这个东西。

**螺旋**

许多东西并不是刚看到时就能理解的，经常看到了后面才能理解，或者看到了其它资料才能理解。这种现象称作螺旋。

## 理论

1. 理论要能快速入门，简单易懂，便于查询，易于操作。

1. 理论要迭代渐进。如果一个问题是可以被改善的，那么就是值得感激的。

1. 理论要考虑到最恶劣的环境。

## 笔记

1. 笔记必须先以时间顺序写成，然后再按空间顺序整理。

    在学新东西的时候，总是一个概念一个概念学，不容易直接和其他领域的知识形成联系。因此做笔记的时候也是扁平化地不断记录新的概念，新的操作，自己的想法感悟等等。

    但是扁平化地记录一段时间新的概念后，复习时往往会发现不同概念间的树状或网状联系。此时需要对笔记进行再排序，形成一个有组织、有架构的笔记。

    这两个概念类似于各个工具的 tutorial 和 reference。tutorial 遵循时间顺序，reference 遵循空间顺序。

1. 笔记遵循的范式是先写严谨的概念定义，或者写定理与证明，然后再写数条解释，包括背景介绍，概念里需要注意的细节，为什么要这样设计等等。

    **概念名词**

    精确的定义

    说明：

    1. xxx
    1. xxx

    **定理**

    定理内容

    证明：

    xxx

    说明：

    1. xxx
    1. xxxx

1. 假如总是在做笔记，那么就容易造成抄书，什么都不理解。假如总是在理解，那么前面学过的东西就会忘，思路混乱。

    所以记笔记的原则是首先要理解内容，然后再记录下精华部分和自己的心得。

    最好的办法是先在纸上画画写写，等理解得差不多了，再把纸上的精华变成电子版。

## 学习

学习包含理解、笔记、记忆、复习，做题这几个部分。

1. 定理：只学不复习等于没学。

    因此如果不能保证安排后续的复习，就不要开始学一样东西，因为最终会忘得一干二净。

* 抛弃形式化学习的几个建议

    先学常用的，再学不常用的。

    先学能理解的，再学不能理解的。能理解：每看一句话，都能用自己的语言，已有的知识对它进行解释。如果有需要猜测的地方，那么就得做实验验证。如果猜想与假设太多，那么就认定是不理解的。完全看不懂也属于不能理解。

    切忌还没理解意思就直接照搬原文作为笔记。不理解的东西就不要写到笔记里。

    基于 example 学习，而不是基于 spec/theory 学习。

    语言的描述是模糊的，具体的例子是精确的。

* 即使是 qa，也要先按时间顺序提修改建议，然后再去改动。不然容易改了一半发现前面的写的也不好，最后越改越多。

## 情绪