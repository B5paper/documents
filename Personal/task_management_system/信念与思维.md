# 信念与思维

人生活在时间中，目前时间是正向流动的，因此我们也必须一件一件地做事情，这些事情被称作任务。

有一些任务类型，在每天的活动中经常出现，为了提高处理效率，我们把这些任务单独命名，并拿出来分析，找到常用的处理方法。

有一些不可能一天两天就把完成的任务，我们将其称为项目。

**cache**

* 恶性竞争

    假如有两个公司 A 和 B，A 做的是热门泡沫方向，B 做的是扎实工作方向，结果 A 能融到资，B 融不到钱，最终 B 倒闭，A 最后也会因为泡沫破裂而倒闭。

    对融资公司来说，B 可能投资几年都什么起色，但是投资 A 可能有 10% 的机率挣大钱。理性的人可能会按比重分配资产投资，但是不要低估人性的贪婪，为了赌这一点很低的可能性，投资公司可能会加杠杆梭哈。

    假如有三家投资公司 C, D, E，这三家都投了 A 所在的行业，已知这个行业一定有一个胜出者，其实就是 C, D, E 在下注赌。C, D, E 都觉得最幸运的应该是自己，假如自己不跟注，那么挣钱的就一定会是别的两家投资公司。这样很不甘心。

    最终的结局是所有公司都赔了，每个环节的最优选择，导致了全局的最坏结果，非常讽刺。

* 遇到这样一种情况，假如`A = [1, 100]`，`B = [rand(1, 100) * 10] U [100, 1000]`，要理解某个知识，需要 B 中的各个知识点

    但是 B 中的资料需要到 A 中去查。

    如果把 A 从头到尾看一遍，那么需要大量的时间。但是不看 A 就无法理解 B 所需要的知识。

    这样的情况比较难处理。

* 10 亿以上重资产的创业能不能盈利和宏观经济有关

* 计划的重点在于可以回退

    之前大部分计划无法执行下去是因为只能顺序执行，没有考虑过失败和回退。

    如果总是回退，那么会导致没有动力去执行任务，也不汰好。

    这两者中间应该有个平衡点。

* 未经证实的，对概念的一个可能的解释被称为一个猜想。

* 如果可以使用“猜想”去解释一个现象，那么就可以进入实验阶段

    如果可以无法作出“猜想”，只知道哪个方向可能提供更多的信息，那么只能是“调研”

    无法作出猜想的阶段，都只是收集信息的阶段。目标就是为了作出猜想。

* 调研的目的不是完成任务，而是要有输出

* 假如 A 是一个节点，所有的联系都是从 B, C, D ... 指向 A，从 A 起始没有任何向外的边，那么 A 就很难被发现了。

    相反，如果有连接从其他节点指向 A，哪怕只有一条，也终究会被搜索到。

    这种现象可以被称为概念的禁锢。

* 每份笔记中应该专门开一个 examples 区域，整理详细的 example

    在笔记正文中出现的 example 只需要专注详解原理就行了，可以只是代码片段，也可以不检查返回值，不进行错误处理。

    example 区域中的 example，需要在追求简洁的基础上，增加一些返回值判断和错误处理，有完整可编译运行的代码，并且有运行的输出。

    问题：qa 中的代码片段该归属于哪一种？

* 进度的 sync

    如果一个项目长时间不合理发展，就会出现调研、 qa 和笔记不匹配的情况。这种情况下，需要对进度进行 sync，确认下面几个问题：

    1. 如果无法从学习资料中总结出新的笔记，那么认为学习和笔记的 sync 完成

    1. 如果无法再从笔记中找到一个新的 qa，那么认为 qa 和笔记的 sync 完成

    1. qa 里不能有 empty

    1. test, qa 文件夹 clean

    1. 可以连续三天通过随机 qa

    1. 项目池/笔记中不能有相关的 cache

    显然，项目进度的 sync 不应该出现在项目管理里，而应该由任务执行系统负责。

* 应该创建一个项目叫 reorg，同 qa 一起，组成自举系统

    reorg 用于每次在所有笔记，所有项目，以及所有理论系统中挑选出一个片段，尝试对其进行整理，重组，发散或者删除。

下面是一些标准任务以及处理它们的一些经验。

## 想法与待解决的问题（cached）

这一部分作为想法，灵感以及问题的缓冲区，记录各种相关的内容。

* 思考：像这种既没有经验，也没有参考，只能靠临时反应进行和大量交互进行下去的任务，该如何分配时间？

    没有任何的可借鉴经验，不清楚结果，这种任务被称为 blackhole task.

* 缓存策略和 stack 策略都非常有用，使得条理很清晰

* 有关笔记的整理

    可以消除一些笔记中穿插的一些 reference 资源，或者将资源提取出来。

* 假设：我们假设人脑每次能处理的任务的复杂程度有限，每次处理一项任务的最大时间也有限。因此需要把任务切分成刚好够人脑处理的一个片断。

* 未来需要做什么的任务列表固然很重要，但是描述自己在过去的一段时间里做了什么同样重要。

* 需要对任何结构化的资料进行定期整理，包括笔记，qa，任务管理系统，以及临时项目管理。

    主要整理方式就是从无序到有序，从混沌到结构，有相同点的整理到一起，有临时想到的写到缓存里。

* 当一个程序越来越大时，如何能快速知道以前开发过了什么功能，快速对自己的项目上手，这个问题需要思考一下

    目前一个思路是对当前项目也写一个简易的 qa，安排进检测列表

* 这一部分（即想法与待解决的问题）是否应该归类到反馈系统？

    或者说，所有的 log，缓存，是否都算是反馈系统的一部分？

    栈（依赖关系）的处理是否不算反馈系统的一部分？

* 有关 blackhole task 的处理

    因为 blackhole task 的问题都是动态创建且短暂的，总是在经历快速的假设->实验->推理的过程，所以无法像“学习”过程一样有固定的时间。但是可以研究如何快速保存任务进度，随时中断，从而可以预定时间。

* 有关任务处理的一些问题

    在执行一个任务时产生了新的问题，新的任务，把这些东西放到 log 中去，不要影响堻圭前的任务。

* 从混沌到结构，从无序到有序

    在结构化的笔记上面，创建一个混沌区域，这个区域中都是临时想到的一些想法，等这些想法积累得足够多了，就将它们组合成结构化的知识。

    另外一个是，临时想出的想法，先缓存起来，不耽误当前任务的执行，等有空余时间了再批量处理。

    这两点或许会非常非常重要，是整个任务管理系统的基石。

* 如果一个任务，在其他任务创建 stack 时，经常会创建到它，那么就称这个任务为伴生任务。

* 缓存待完成的任务是一个非常好用的经验，但是并不能长时间使用，因为缓存不太消耗脑子，可以非常容易地获得短暂的满足，所以脑子一直处于放松的状态，时间一长就是在浪费时间。

* reduce 过程通常比较轻松，不会消耗太多的精力，如果一直 reduce 就会陷入空虚。

    cache tabs 也是一种 reduce.

    因此和 reduce 相关的任务，要设置一个时间上限，不能无休止地 reduce。

* 目前的随机检测系统实际上已经支持了随机任务 + 随机索引，以后只要规定 qa 的数量就可以了

* 可以使用 move 从函数中返回局部对象吗？

* vulkan 可以把核心绘制部分写成 qa，即 draw frame 函数

* vulkan 的 qa，如果不把 dependency 机制做好，那么很难继续下去

## 调研

所谓调研就是在尽量不做实验的情况下，看看能理解多少东西，不理解的东西就记下来

调研的目的是投稿少量的时间和精力，从大任务中生成小任务，将不标准的任务转换成部分标准的任务，并给出时间规划。

* 调研的三个结果

    要么给出更多的问题，要么给出已经收集到的信息，要么给出具体的任务。

    如果有更多的问题待处理，那么就给出问题。如果找不到什么问题，那么至少应该给出信息。

    如果感觉某些任务可以完成，那么就给出任务。

    只给信息，不给问题，可能是因为需要后续判断是否还要做这个方向。

1. 项目调研 -> 产生项目规划

    寻找参考资源，简单分析项目可行性，分析项目依赖

2. 任务调研 -> 产生具体任务列表

    简单浏览一遍参考资源待看的部分，大概了解下材料的难度，细分再细分，直到感觉某个概念，某一段话，某个公式，自己可以短时间内搞定为止，将其写到任务列表上。

    更长远的思路写个大致的规划。

项目调研和任务调研也都算在任务清单中，他们所占用的时间和精力一点不比具体的任务少。

调研：如果对已有的书面学习材料的调研，那么就顺序阅读，不回看，如果理解顺利，那么一直看下去，直到遇到无法理解（解释有矛盾，或者有未知信息）的地方为止。最大调研时间 20 分钟，超过 20 则停止。

调研时需要回答的几个问题：

1. 看了刚才的内容，我能否用它来做一些事情？和过去我学过的内容有什么关系？

    如果这个问题可以回答，那么就将它加入任务列表里。

1. 刚才看过的内容，里面的每个概念我能否用自己的话描述？

    如果不能描述，那么中止。如果这个答案依赖某个遗忘的内容，那么将复习遗忘内容加到任务列表里。如果这个答案依赖一个未知的内容，那么将新的调研加入到任务列表里。

调研与具体的任务安排都是平等的关系。

## 复习

如果对学到的知识不进行复习，那么很快就会遗忘。

为了提高复习效率，这里使用问答的形式进行复习，因此又叫 question and answer，又叫 qa。

* 每天的随机检测非常重要，一定要把时间均摊到每天，这样的 qa 才有意义。

* 旧的 qa 没复习完前就不要写新 qa 了，因为都不知道学到哪了，也不知道该整理什么资料

* 创建一个 qa 池和一个随机数生成器，每次先从 qa 池中随机挑选一个项目，然后再随机选一个 unit，进行检测

    如果遇到不会的 unit，那么找它的 dependency，如果 dependency 还不会，那么再找它的 dependency，以此类推。

* 每个项目开始之前，先进行随机检测。每个项目随机检测的时间不应该超过半个小时。

* 以每 30mins 检测 2 个 qa 为准

* qa 一定要基于 note，而不是独立于 note。qa 与 note 最大的区别在于，qa 是条目式的，缺少细节，并且有 dependency，而 note 专注结构和细节，并且有更多的思考和延伸参考资料。

* 关于 qa 文件格式的改变

    使用`[idx]`标签标注从上往下的索引，用于唯一定位，从 0 开始。

    使用`[id]`标签标注一个哈希值，用于唯一定位。使用对当前时间的哈希即可，主要不重复就可以了。

    使用`[dep]`指定当前条目所依赖的条目，写法如下：

    ```
    [dep]
    <id> - <u_0>
    <id> - <u_0>
    ...
    ```

    因为`[id]`和`[u_0]`可能在文件里出现很多次，所以仅使用这两个无法快速精准定位。

    `[u_0]`也有可能写得很长，还是用 title 吧。

## 记忆

对于标准化的记忆过程，需要精心准备干净、准确的记忆材料，并使用称为“联合”的概念来描述记忆，另外还必须使用复习来巩固才能达到想要的效果。

所谓的联合，即提到 A，马上想到 B，其中 A 和 B 都是记忆材料。A -> B 这样的联合称为单向联合。如果提到 B 也能想到 A，那么 A <-> B 这样的称为双向联合。

实现联合最原始的方法是机械记忆法，即熟悉完 A 材料后马上熟悉 B 材料。其中熟悉的方法有看，读，听，写，默念。附加的条件有：不同场景，不同时间，不同顺序，不同位置。

不同场景：桌子前，操场上，街道边，厕所里，晴天，雨天，热闹的场合，安静的场合等不同场景下记忆，效果更好。

不同时间：凌晨，早上，中午，晚上，半夜。

不同顺序：假设要记忆 A1 -> B1，A2 -> B2 等这样的材料，如果总是按照 A1, A2, A3 等这样的顺序，那么会产生时间和空间的连续性。所以顺序记忆比乱序记忆更容易一些。在完成顺序记忆后，需要使用某些产生随机数的方法来达到乱序的效果。

除了这些，还可以有不同材质，不同形式，不同字体等等。

双向联合：单向联合要求看到 A 后给出 B，并不要求看到 B 后给出 A。双向联合要求两个方向都要做到，因此要把单向联合的过程实施两遍。

**记忆材料**

无论如何实现联合，都必须满足如下条件：当看到 A 材料时，无法看到 B 材料；当熟悉完 A 材料后，需要马上可以熟悉 B 材料，或者自己给出 B 材料后，需要马上可以检验给出的 B 材料对不对。另外还需要可以乱序记忆。为了实现这个需求，目前我能想到的有下面三种形式：

1. 在笔记本上分栏记录记忆材料，左侧为 A 材料，右侧为 B 材料。

    当联合时，看完左侧 A 材料，在右侧可以看到应对的 B 材料。在检测时，可以捂住 B 材料的内容，复述完后移开手，可以直接检验复述是否正确。

    当乱序记忆时，可以用纸片抽签的形式产生随机数，定位到第几则记忆材料。

1. 在小卡片上正面写材料 A，背面写材料 B。

    联合时只需要分别看 A 材料和 B 材料就可以了，很方便。缺点是比较薄的纸会隐约看到背面的内容。

    乱序记忆时只要对卡片进行洗牌就可以了。

1. 使用电脑数据库，编程实现 A 材料，B 材料的出现以及乱序记忆。

**联想记忆法**

联想记忆法有跳跃联合，形变，谐音，同异点等。

1. 跳跃联合。如果我们的脑子里已经有 A -> B 的联合和 B -> C 的联合，那么就可以以 B 为中间节点，快速地形成 A -> C 的联合。问题在于并不是每个节点 B 都是容易找到的。

1. 如果我们可以对材料 A 施加形变、联想谐音、虚构故事或添加逻辑达到材料 C，那么就可以把形变过程、谐音、故事或逻辑作为中间节点 B。此时 B 越新奇，越有冲击力，记忆的效果越好。

**跳跃游戏**

平时无聊的时候，给出某个节点 A，比如一个词语，一个图形，一段语音，然后进行联想到其他的记忆节点 B1，B2，B3 等等。再从 B1, B2, B3 等节点中选择一个，进行下一轮发散。我称其为思维跳跃游戏。

**检测**

为了完成一个记忆过程，检测是必要的。有一个猜想是记忆的本质不是模仿，而是创造。在检测时，我们需要看完材料 A 后，给出 B'（方式为说出来，写出来，想象出来等），然后与材料 B 进行对比，完全相同才算联合的形成。

对于一组记忆材料的检测有两种方式：

1. 顺序检测。检测的顺序和记忆的顺序相同。这种比较容易达成。因为往往简单重复账户

**记忆的复习**

记忆的遗忘规律有如下几个：前几天忘得快，其后忘得越来越慢；记忆的材料越相似，越容易混淆。

目前采用的复习方案是：

1. 第一天要求完成顺序记忆和至少一次乱序检测。

1. 第二天要求完成乱序检测。

## 理解

**理解**

对于给出的一个名词、定理或问题，如果我们可以给出解释和例子，使得想象中不懂这门课的人也能完全听懂，那么就称我们理解了这个名词。

**可理解的**

如果一段话中的每个名词、逻辑和自己提出的问题，我们都能予以解答，那么就称这段话是可理解的。

显然，如果不理解一段话，无非是遇到了以下几种问题：

1. 名词看不明白

    1. 没有解释的新名词

    1. 之前学过这个名词，但是忘了

    1. 名词有歧义

1. 逻辑解释不通

1. 自己提出的问题无法解答

很多时候我们的不理解是含糊的，混乱的。之所以要把各种不理解的情况列出来，是因为我们必须要把问题清晰完整地陈述出来。这是走向理解的第一步。

事实上，一切的不理解最终都推向一个无法解答的矛盾。只有把这个矛盾清晰完整地说出来，我们才能说我们不理解这个东西。

**螺旋**

许多东西并不是刚看到时就能理解的，经常看到了后面才能理解，或者看到了其它资料才能理解。这种现象称作螺旋。

## 理论

1. 理论要能快速入门，简单易懂，便于查询，易于操作。

1. 理论要迭代渐进。如果一个问题是可以被改善的，那么就是值得感激的。

1. 理论要考虑到最恶劣的环境。

## 笔记

1. 笔记必须先以时间顺序写成，然后再按空间顺序整理。

    在学新东西的时候，总是一个概念一个概念学，不容易直接和其他领域的知识形成联系。因此做笔记的时候也是扁平化地不断记录新的概念，新的操作，自己的想法感悟等等。

    但是扁平化地记录一段时间新的概念后，复习时往往会发现不同概念间的树状或网状联系。此时需要对笔记进行再排序，形成一个有组织、有架构的笔记。

    这两个概念类似于各个工具的 tutorial 和 reference。tutorial 遵循时间顺序，reference 遵循空间顺序。

1. 笔记遵循的范式是先写严谨的概念定义，或者写定理与证明，然后再写数条解释，包括背景介绍，概念里需要注意的细节，为什么要这样设计等等。

    **概念名词**

    精确的定义

    说明：

    1. xxx
    1. xxx

    **定理**

    定理内容

    证明：

    xxx

    说明：

    1. xxx
    1. xxxx

1. 假如总是在做笔记，那么就容易造成抄书，什么都不理解。假如总是在理解，那么前面学过的东西就会忘，思路混乱。

    所以记笔记的原则是首先要理解内容，然后再记录下精华部分和自己的心得。

    最好的办法是先在纸上画画写写，等理解得差不多了，再把纸上的精华变成电子版。

## 学习

学习包含理解、笔记、记忆、复习，做题这几个部分。

1. 定理：只学不复习等于没学。

    因此如果不能保证安排后续的复习，就不要开始学一样东西，因为最终会忘得一干二净。

* 抛弃形式化学习的几个建议

    先学常用的，再学不常用的。

    先学能理解的，再学不能理解的。能理解：每看一句话，都能用自己的语言，已有的知识对它进行解释。如果有需要猜测的地方，那么就得做实验验证。如果猜想与假设太多，那么就认定是不理解的。完全看不懂也属于不能理解。

    切忌还没理解意思就直接照搬原文作为笔记。不理解的东西就不要写到笔记里。

    基于 example 学习，而不是基于 spec/theory 学习。

    语言的描述是模糊的，具体的例子是精确的。

* 即使是 qa，也要先按时间顺序提修改建议，然后再去改动。不然容易改了一半发现前面的写的也不好，最后越改越多。

## 情绪