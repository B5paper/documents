# 信念与思维

人生活在时间中，目前时间是正向流动的，因此我们也必须一件一件地做事情，这些事情被称作任务。

有一些任务类型，在每天的活动中经常出现，为了提高处理效率，我们把这些任务单独命名，并拿出来分析，找到常用的处理方法。

有一些不可能一天两天就把完成的任务，我们将其称为项目。

## cache

* “构造”很重要，或者说，生成假设空间的能力很重要。

	先有假设，然后才能推理分析。这是创造力的来源。

	“构造”很难。推理谁都会，但是构造很难。

* 基于 dfs 的学习法，每次遇到无法理解的问题就卡在那里，浪费很多时间。或者是都能理解，但是非常非常不常用，进入到陌生的领域。或者说虽然有用，但是需要做实验验证才能完全理解，但是这时没有完善的实验条件。或者虽然是有用的知识，并且可以做实验，但是与目标任务无关。显然基于 dfs 的学习法是有问题的，我们不可能把一本书/一套视频/一个网站全部看完才去看另一个信息源。

    基于 bfs 的学习法才是正确的方法，遇到问题就停下来，看看其他地方，每次都只看自己可以看懂的，有用的，螺旋积累知识。

    虽然这么说，但是 dfs 仍然是必要的，难以理解的东西可能稍微往后看一点就能理解了，或者复杂的东西稍微推导一下就看明白了。

    这两者的平衡目前还是需要靠直觉去把控。

* 笔记中想法、批注的更新该如何表示？

    必须要保留旧的想法记录，因为这样可以形成一串思考线索，不然只能看到最终的思考结果。

    2024/05/07/00: 有两个形式可以参考，一个是邮件列表 forward，另一个是贴吧。目前先采用贴吧的形式，使用日期加冒号作为新一个批注的开始，每次都只追加，不修改，不删除。如果遇到必须解决的问题再修改这个形式。同一天的不同想法使用最后两位数字进行区分。

* 笔记的结构

    先记录单个独立主题，再记录 topic，topic 中是多个独立主题的组合

* 晚上吃饭不要吃到撑，不然会特别困，几乎没有精力继续学习。吃个半饱就可以了。

* 概念漫步

* 可解构与复杂性

    假如一个复杂的模块可以被解构成子模块，那么我们就认为它是简单的，是复杂性可降解的。但是还存在一些模块，无法被解构为子模块，当我们想处理这样的模块时，必须把这个模块相关的所有内容都加载到缓存中，这样的模块越不可解构，复杂性越高。

* 尽管现在做的努力都是尽量让所有非线性的行为变成线性，但是真当所有行为都变成线性时，又怀念非线性的失重感，尝试在线性之外找到非线性的领域

* 交互式地阅读材料并不能解决效率逐渐降低的问题，只能缓解。如果想要解决，还是得靠真正的输出。

* 如果一个任务被标记为`P`（有思路，但未完成），那么应该在任务池中将其修改为一个长期任务`{ }`。

* 无视 dep 的 ai

    ai 出现前，每个任务必须找到它的 dep，把前置任务做完才能做当前任务。比如想要学习网络代理，那必须要学前置知识 ip，nat，socket 等等。但是启动代理可以只是 config 一下文件，然后输入几行命令，并不会用到所有的前置知识。没有 ai 的时候，只能一点点地学完前置网络知识，才能学习使用代理。在学习前置知识的时候，又不知道学多少是正好合适的，有可能不小心学多了。现在有了 ai，可以跳过大部分的前置知识，直击核心问题，这样就使得我们可以使用刚好合适的知识去解决问题，效率非常高。可以认为 ai 创建了一条绕过 dep 的 shortcut。

* 蜘蛛

    目前的工作模式，感觉比较像蜘蛛在织网。从已知的概念出发，一点点地，一圈一圈地向外扩展。

* 似乎大家接收的教育越多，待人接物就越有礼貌，行为习惯越符合规范的礼仪，谈吐和行为越趋近于相同。但是假如我们把不同性格、知识、爱好、习惯的人，都训练成同一知识、反应、思维和习惯，那么世界还会这样多姿多彩吗？还是说，我们永远无法把人们都训练成相同的人，无论是从现实的意义上（没有财力、精力维持这样的机构），还是从理想的意义上（人不可能被驯化，无论何时都保持自我）？

* 恐怖的 AI

    目前的很多 AI 生成的视频内容，人物都很非常表情僵硬，但是总是能给出合适的反应和肢体动作，会给人造成恐怖的感觉。这和一些恐怖片挺像的，都是一开始大家都是正常人，慢慢地才发现身边有不正常的人，像是一个伪装者。

* 规律必须足够简单，才能被发现

    分析一段代码，只看到二进制位变来变去，数学运算算来算去，但是不清楚这段代码的目的是什么。如果不看实现细节，只看这段代码的输入和输出，马上就分析出来这段代码的目的是 xxx。这是否说明，我们只能处理发现几种简单规律模式的发现，只给定细节无法推断出宏观的规律，只有当模式足够简单，我们才能提炼出模式？

* 如果我们无法根据所有的信息做出假设，那么可以剔除大部分信息后，根据一两个点做出联想和假设

    ```cpp
    if (paths[i].bw > maxBw || (paths[i].bw == maxBw && paths[i].type < minType)) {
      maxBw = paths[i].bw;
      minType = paths[i].type;
      if (pathType)
        *pathType = minType;
      count = 0;
    }
    ```

    比如这段代码，我们仅根据`paths[i].bw > maxBw`，`count = 0;`判断出，这段可能是找最大值，找到比现有值更大的值，那么就清空数组。拿到这个猜想后，再根据这个猜想判断其他代码的含义，是否符合这个猜想。

* 信息屏蔽

    如果新增的信息量过大，那么我们在假设空间中寻找样本点时，会因为要考虑的东西过多而难以构造样本点。或者即使构造出假设与猜想，也没有精力或能力去验证。这样会导致整个思维系统无法运行。此时我们必须进行信息屏蔽，每天只选择性地接受一些自己可以处理的信息。就算根据局部信息得到的结论是错的也没有关系，因为整个思维系统的纠错机制最终会将错误的结论排除掉。

* 注意力测试

    如果可以闭上眼睛默数 500 下，那么说明当前心无杂念，注意力可以集中。反之，则说明杂念太多，心不净。

* 伏笔与回环

    如果一个伏笔在一百章之后仍能回收，那么有可能是先写了结局，再去前面剧情埋伏笔，也有可能前面写了段无用剧情，后面注意到了这个剧情，再在结尾添加一段，把伏笔圆上。无论如何，都暗示我们写埋有伏笔的小说，线性地从前写到后一定是不可能的，必须经过反复的负反馈，把逻辑调理通顺，把伏笔都尽数回收。

* 如果多人合作，那么负责区域划分必须明确

* 即使癸酉癸酉本的各种线索都确凿无疑，仍有许多人坚持自己的想法不肯承认其真实性，说明真的有人只相信自己愿意相信的，即使真相已经在面前。

* 百度百科对金簪雪里埋的解析基本就是瞎解析，这是否说明很多的解析和赏析都是瞎解读，语文很多时候都不可靠？

* 古人对人物的不同性格观察得如此细致，远远超越了现在的 mbti，这是否也说明我对人的性格观察得太少，以为所有人都是想学习知识做出科研贡献

* 幸亏当初没好好学，在背红楼梦意义的时候，只是机械记忆了表现封建统治下家族的兴衰，也没有去深究，现在看来，当初这种认识都是完全错误的，幸好当时没有好好学。

* 红楼梦前文线索充足，情节复杂，甚至多次预演暗示结局，但是仅靠前八十回仍无法推测后二十八回的情节，是否意味着对于一个复杂系统，我们无法靠部分规律推测出全貌？

* 如果有突然冒出来的想法，还是停下手头的事先记录想法比较好，后面忘了就再也想不起来了。

* 现代中国教育轻而易举改变了我们对红楼的认知，那么是否还有别的领域被篡改或教得不好呢？

* ai 视频确实恐怖，但是另外一种ai正确却毫无生气，比如微博里的ai水军，回复要么是重复问题，要么是重复感叹，要么是毫无情感的赞美，他们的回复虽然正确，但是没有灵气，也没有情绪波动。

* 正是经历了多次人事变动，才能固化下来自己的方法论，变得稳定。这个过程有点像深度学习的增广变换。但是想到大多数人经历足够长的时间和足够多的事情后，都可以完成这个过程，其实这种能力也不算稀罕。

* 面对面交流与网络交流的误会更少，能面对面交流的情况不要隔着网络交流。

* 感觉公司的风水不好，无法静下心来，容易增加攻击性，容易上头，容易情绪极端。

* 境界不可能突然提升。境界的提升需要与自己作战，自己又不可能被轻易打败，所以境界不可能突然提升。

* 总以为我们是在赌浪头，原来他们是从一座浪尖到另一座浪尖

* 根据之前的笔记记录的对未知概念的推断过程，可以得出，凡是有推翻之前错误的假设的情况，总是因为发现了新的证据，新的证据更强，更清晰，歧义更少

* 文字与大模型

    大模型并没有展示创建概念这一过程，文字中的很多概念与抽象是人们事先已经创建好的，大模型只是做了适配。

* 过于强势的人不适合合作，让其单打独斗又不如组建团队稳定，因此不要和强势的人往来

* 关于接项目

    最好少接或者不接项目，实在不行了再去做项目。因为这样才能随时把项目丢出去脱身。总之不要主动去揽活。

* 成就感很强的情况是一群人从零开始摸索，慢慢找到规律，取得成就的过程。

    其实玩游戏也是一样的道理，最开心的时候是大家都不会玩的时候。

* 非线性学习的 pivot

    假如一个线性的学习顺序是 A -> B -> C -> D -> E，但是接触概念时先接触到了 C，发现只能从 C 出发去解释 D, E，但是不知道怎么解释 C。

    此时有两种方式，一是从 C 出发，猜测前置概念 A, B，做出假设，并根据 C, D, E 相关的现象和推论验证 A, B 假设的正确性；另一种是顺藤摸瓜，找到 C 的源头 A, B，对学习顺序做一个 pivot，从 A 开始学起，把非线性的过程变成线性的。

* 团队合作的两种冲突：A 干了 B 的活（抢活）；A 和 B 都不想干活（甩锅）

    如果要避免这种情况，必须让这几个当事人在开始干活前开会划分职责范围，然后定期开会同步进度（比如一周一次或两周一次）。

    最根本的解决办法还是自己能吃透这一块，给手下的人根据不同的性格不同的能力安排合适的活，比如适合调 bug 就只去调 bug，有做设计的能力就去做设计，喜欢写代码就安排变动比较多的活，并且手下的人愿意听从自己的安排，自己的能力可以兜底。

* 做梦梦到客厅的电话柜顶上的天花板漏水了，水像柱子一样往下流，妈妈在对面的沙发上坐着无动于衷。我哭着喊道：“你根本不是我妈！如果我妈在这里，早就抢过水盆去接水，然后把漏水的地方修好了。”我非常清楚坐在沙发上这个人只是个没有感情的复制人，是个没有灵魂只有面容的躯壳。

    醒来后想到，灵气是我们身为人的一部分，如果让机器人模仿我们熟悉的人，但是表现不一样的人格，那么我们只会生气。然后又想到，情感确实是我们说不清道不明的一部分，超越了理性，控制着我们的行为和想法，“无论如何我都要回到那个地方去，找到原来的人的物”，这种想法会不断地淹没理性的发问：“为什么要回去？去见谁？怎么见？还能再见到吗？”

    过了一天，再想起梦来，理性又占据上风：为什么会有没有灵魂的假人？为什么天花板会漏水？为什么在旧家不在新家？这段情节能否扩展一下做一段感人的动画或视频（比如以机器人为题材，讨论如果有机器人和故人长得一模一样，但是没有故人的灵魂，那么人们会感到开心还是恐惧？再比如主角在老师父手下修行，老师父不知何时被调了包，主角其实早有疑虑，终于有一天，假老师父做了一件真老师父无论如何都做不出来的事，比如xxx坏了没去修，看着小动物死了无动于衷，此时主角大哭：你根本不是我的师父，如果是我的师父，早就去xxx了）？

* 理论上，说话是一件不可能完成的任务。因为我们需要寻找所有组词造句的可能性，才能说出一句完整的句子，它的时间复杂性是不可接受的。但是每个人都能完成，这是不可思议的一件事。目前不清楚为什么。

    2025/07/04/00: 有两点猜想：1. 常用表达就是最佳表达，因此大脑只需要像马尔可夫链一样在几个常用选项中选择一个就可以了，并且只依赖前面一到两个词做出选择，因此说话时的计算量不大。2. 常用表达不是最佳表达，但是大脑的工作方式并不是搜索全部假设空间，而是先并行地浮现几个一句话中的关键词或关键概念，然后把这几个概念串起来形成一句话，就像做填空题。这说明大脑的工作方式与计算机差异巨大。

* dfs 学习的两个常用方法

    1. 栈式（链式）问题回溯

    2. 猜想，假设，跳跃

* 笔记的结构

    先记录单个独立主题，再记录 topic，topic 中是多个独立主题的组合

* 任务完不成应该分两种情况处理，一种是有极大可能完成，只不过时间不够，另一种是还在调研搜集信息阶段，不清楚是否能完。显然这两种情况的处理方式应该是不同的。

* 在准备去执行一项任务时，不应该考虑当前状态是否为最佳，而应该考虑当前状态是否满足最低要求

* 笔记与中间结果

    有些需要记录的内容明显是中间结果而不是笔记，如果把中间结果当成笔记来记，那么在归类的时候就不知道该把归类到什么地方去。

    中间过程只是记录，不是结论，因此很难复用。这些不应该出现在笔记里。

* 对于一项任务，如果我们可以想象模拟出执行它的全过程，并可以预测所有可能的结果，那么它就不是一个“调研”

    比如“记忆”，就不是一个调研；随机检测 qa 也不是一个调研。

* 如果一个任务没有指定具体的类型，那么就默认认为它是个调研任务

* 在开始一项任务前我们真的需要最佳状态吗？如果最小状态可以满足，那么就认为任务可以开始。

* 非线性项目

    如果完成一个项目用到的知识无法全部从 qa 和 note 中得到，并且这个项目有时间约束，那么这个项目就是一个非线性项目。

* 非线性变化

    假如现在有一团热气流和冷气流相遇，如果在对气流一无所知的情况下去做仿真，大概率得到的结果是冷气流与热气流的温度逐渐趋于相同，锋面的温度变化最快，远端的温度变化最慢。我们大概率不能直接仿真出龙卷风，台风。

    假如我们提前知道了冷暖气流相遇有可能出现台风，那么大概率会修改我们的仿真算法，使结果中一定几率出现台风。

    对于云层也是一样，假如我们对云的知识一无所知，那么大概率只能仿真出一块一块的云，但是自然界有卷云、排成阵列的云、下击暴流的云，如果我们提前不知道这些概念，那么它们几乎不会在仿真里出现。

    假如我们称冷暖空气的温度变化、天空中的白云为线性变化，台风、阵列云就是非线性变化，那么问题是：非线性变化是什么带来的？我们在仿真时如何才能尽可能地捕捉到这种变化？

* 我们的对抗并不是谁把任务做完，谁投入时间长谁就能取胜的，而是大家都把当前工作做到精致的情况下，继续对未来的可能性进行探索、冒险、赌博和选择。

    按部就班的回答不会有奇迹。

* 非 cache 笔记（顺序笔记）的原则：假设自己对所有的概念都一无所知，又假设所有后续的笔记都依赖前面的笔记。

* 概念重定义

    对于一个所有概念都清晰定义的系统，如果剔除某个概念 A 的定义，只保留其他概念对 A 的使用，那么根据这些使用的描述，我们能从什么程度上反推出 A 的定义？

    example:

    > 为了获得高带宽，shared Memory被分成32（对应warp中的thread）个相等大小的内存块，他们可以被同时访问。不同的CC版本，shared memory以不同的模式映射到不同的块（稍后详解）。如果warp访问shared Memory，对于每个bank只访问不多于一个内存地址，那么只需要一次内存传输就可以了，否则需要多次传输，因此会降低内存带宽的使用。

    上面是某个博客的一段文字，其中用到了 bank 的概念，但是并没有给出 bank 的定义。我们是否能仅通过类似这样描述性的文字，推测出 bank 的定义或含义？

* 如果有 new task，可以添加到当日的 task list 里，但是必须添加`[new]`标记

    比如：

    ```
    * [ ] task 1
    
    * [ ] task 2

    ...

    * [new] new task 1

    * [new] new task 2

    ...
    ```

    添加到当日的 task list，可以防止

* 没办法写成笔记的东西

    * 寻找解决问题的灵感或对未知未来探索的过程

        “探索”的过程不可写，首先写出来就会失去灵性，既受限于文字，也失去了“虚”的感觉；其次写下来的思考速度会变慢，书面表达的思考速度太慢了。

        但是已经探索明白的，可能会形成方案的思路可以记录下来，作为一个待调研的思路。

    * 临时的记录、中间步骤、中间猜想与中间结论

        这种比较适合写到 tmp 中。比如记录一下目前的函数调用嵌套了多少层，要搜索的字符串的 start pos，某个对象的指针的值等。

        其实写到 tmp 中也会拖慢思考速度，这种最适合的就是在脑子中临时记住。

* 如果一个项目是有用的，那么最好的开始时间就是现在。

    假如往后推迟了几天，就无法找到一个完美的开始时间，总是想着所有工作都准备就绪，所有状态都达到最佳，并且可以专心一下午，没有其他事情打扰，这样的情况可能只有 5% 的概念会出现。所以还不如直接现在就不完美地开始。将项目添加到任务管理系统里，并且保持追踪，这才是最佳的做法。

* 与其专门准备一个下午去做一件事，不如把这件事分摊到每天。

    想要专门腾出一段时间做一件事是困难的，通常会：想做事情 A，终于等到有空闲时间的机会了，这时候又觉得事情 B 更有意思，或者刚开始一会事情 A，又被突如其来的事情打断了。

    况且连等到空闲时间的机会都很少，不是身体疲惫，就是精神不佳。实际上，我们大部分时间都是这样的状态，与其等到最佳的状态，不如适应不佳的状态。

* 重新强调一遍，退出任务时保证 stack 干净非常重要。桌面、床铺等日常环境同样如此。

* 给出一个定时器，到达时间后停下来做任务总结。未到时间就想停下则需要锻炼注意力。

* 容错

    学术界的科研容错率太低，如果有类似科技树的东西来指引科研的成就和成功率，哪些方向做过了，哪些没做过，那么我们就可以做出选择，对于不想做出重大贡献的科研人员，只需要选择成就较低、成功率比较高的 branch 进行研究即可；对于有志向的科学家，则可以选择成功率更低，难度更大的 branch。很可惜这样的指引几乎不存在。经常有人错估了难度，导致研究出了东西时，发现别人都做过了。

* 是否掌握一项技能，最好的判断方法是看能不能复现。

* 如果两个过程细节不同，但是全局相同，那么对照实现起来非常麻烦，我们无法根据单步调试一行一行地照搬，必须整理了抽象的全过程，再去做实现

    但是这个过程也是非常有意义的，全局相同，说明这两个过程的核心相同；过程不同，说明加入了噪声干扰和泛化。如果能对这两个过程进行研究，找到相同的核心和本质，还是可以提升自己的。

* 有关效率的进度

    创建任务管理系统 -> 通过系统来提升效率 -> 在同样的时间内完成超越别组的任务 -> 等待其他组/人的进度 -> 挤出些许自由时间 -> 进行算法的调研和验证 -> 做出创新

    目前看来，这条设想进行得不错。

* 有关算法创新的进度

    选择一个需要大量 coding 的工作，锻炼 coding 能力，实现脑中所想皆可用代码验证（目前选择了驱动） -> 进行算法创新

    目前看来这条设想也是对的。确实有了大量 coding 的机会，但是又不仅限于增删查改，许多中等算法题目得到了应用，非常不错。

* 进与退

    光靠进无法达到目标，必须退退进进才有可能找到正确的方式。就像调研与时间的约束，以及笔记的 cache 退化，都是允许了退的情况下，取得了很好的效果。

    或许进是一种深度优先搜索，退是一种广度优先搜索。但是感觉进与退蕴含的比这两者要多。

* 印记

    重大的事件会在身上留下不可逆的印记，我们不可能总是完美。

* 魔鬼与模仿

    魔鬼在被处死前模仿人类流下眼泪求生，人类答应放他一条生路后，魔鬼趁机反杀了人类。那么魔鬼模仿人类流泪，和人类真正的流泪，有什么本质区别吗？猜想：魔鬼只是模仿并得到利益，当其他人向魔鬼哭诉时，魔鬼不会放他生路；而人类的哭诉之所以和魔鬼不同，是因为人类会联想到，当其他人向自己哭诉时，自己也会放其他人生路。

    如果猜想成立，那么魔鬼就永远无法变成人类，因为魔鬼的模仿总是从利益出发。

* 滚动的齿轮

    假如有很多个减速齿轮耦合在一起，最外面的齿轮转动比较快，那么最里面的齿轮转动很慢。拿这点和探索类比，我们在探索未知时先收集简单的规则和知识，组成集合$S_1$，然后再根据$S_1$的内容，再次遍历 resource，得到新的规则，修改旧的规则，组成集合$S_2$，像这样将集合$S$越滚越大，直到可以解释所有的 resource。有那么多的学科，那么多的社会规则，但是这套探索的方法在很多时候都行之有效。我们可以认为这种方法是最里面的齿轮。

    或许有更好的方法，更高效的方法，但是一定会受到更里面的齿轮的控制，更里面的齿轮普适范围更广，转动得更慢。

* 其实调研也是一种是 cache，是一种广度优先搜索，它安排了必须要回答的问题，优化了任务列表的结构，整合了小范围内的信息，防止有歧义在前，回答在后的情况发生

    调研不做实验，不使用实验对猜想做验证

* 形式与环境不是本质，但是极大程度影响了本质的发现过程

    在 win 系统下，多桌面不方便，所以很难快速地切换任务，也很难给一个任务独立的工作空间，更不可能栈式地递归展开依赖任务，因此在 win 上很难形成像现在一样的任务管理系统。

    虽然说多桌面不是任务管理和时间规划的本质，但是它促进了效率较高的任务管理方式的发现。

    因此改善办公环境，尝试一些新的环境的改变可能会带来一些变化。

* 不可能存在静态的平衡，只可能出现动态的平衡

    打乒乓球时要求每打完一拍都要快速“归位”，以做好迎接下一拍的准备，那么生活中是否有一些 routine，可以保证在执行下一项任务前，可以精神饱满，不饿不渴不累，周围没有杂音干扰，注意力可以快速且长期地集中？
    
    比如在学习某篇论文之前，先睡 30 分，再运动 20 分，再吃一点东西，再喝几口水，做完这样的 routine 后，再全身心阅读论文？或者每晚睡够 8 个小时，早上晨跑，吃早饭，10 点喝一次水，中午吃完饭午休，晚上按时睡觉，这样来保证上午 8 点到 11 点一定精力充沛，下午 2 点到 6 点，晚上 7 点到 9 点一定精力充沛。我觉得这样的静态平衡是不可能做到的。

    取而代之的静态方案是，在一项任务的末尾开始考虑与下一项任务的衔接，如果渴了就喝水，如果饿了就吃点零食，如果特别困就去睡觉。在一项任务开始之前，也可以简易地收拾下周围环境，保证接下来 30 ～ 40 分可以注意力集中。这样的动态平衡目前看来是比较好的解决方案。

* 对抗与平衡

    假如失去了两种力量的对抗，那么就失去了方向。我们选择前进，其实指的并不是失去对抗后往前乱走，而是找到了新的平衡点后，从旧的平衡点迁移到新的平衡点，在新的平衡点处继续进行对抗。

* 佛教的我执与哥德尔不完备定理

    哥德尔不完备定理指出，在公理体系内，存在真且无法被证明的命题。佛教讲究无相，从不执着于众生相，一直到放下我执，在我执这里有一个自我执涉。假如说了“放下我执”，那么大家对我执就有了语言的相，总是想起这一句话；假如不说“放下我执”，那么大家又不知道该怎么做。密教选择不说，靠跨越语言、跨越文字的个人领悟；显教选择说，虽然语言逻辑上没问题，但是我执又很难放下了。

    由此可见，佛教的难题其实就是哥德尔不完备定理的一个体现。正因如此，佛才说：“不可说。”说出来就不灵了。

* 如果一个地方曾经感觉很有灵气，但是再次去时感觉没有灵气了，很可能是因为没有风。

* 如果不尽自己的全力，那么就是对对手的挑衅和羞辱

    类似于百米赛跑时，“我允许你先跑 30 米”的感觉。

* 包絡面

    我们的状态有时是波峰，有时是波谷，系统的作用就是在波峰上制作一张包絡面，使得我们的状态几乎总是沿着波峰前进。

* 有关景物所引发的思考

    假如我们被要求看到一个景物后，联想到随机一件事。那么这件事很大概率是在我们心里与景物联系最紧密的。因此分析我们联想到的内容，就可以分析我们的心理状态。有点像罗夏测试。反过来想，我们也可以把所想强行融合到景物上，对景物进行主观改造。

* 有关畸形环境与正确的道路

    假如我们遇到的所有环境都是畸形的，畸形环境之外还有正确的环境，我们可能会陷入局部最优，无法振荡出来。那么是否有一些方法让我们从畸形的环境后找到正确的规律呢？

    举个例子，假如周围所有人都在玩抖音，我们如何才能有机会发现抖音之外的正确道路呢？

* faster and faster

    技术更新换代越来越快，工作的职业周期也越来越短，以前可能 20 年才会淘汰一批技术，现在可能 10 年，5 年就有新的技术出现，旧的技术被淘汰。留给打工人的技术积累期越来越短，以前可能要求 35 到 40 岁能在圈子里积累一些声望，现在需要 30 到 35 岁就在圈子里积累一些声望，再往后可能是 25 到 30 岁。老员工被淘汰，应届生的工资越来越高，代价是留给应届生发展的时间也越来越短，如果到了 35 岁没有一番成就，一定会被淘汰。

    不断压缩的职业成长时间与不断提高的校招生薪资，似乎在暗示我们，并不是其他原因造就了这种现象，而是来自我们自身想要快速跨越阶级的欲望。

* 目标优先的探索模型

    从目标开始倒着找所有需要达成目标的条件，如果条件比较容易满足就快速满足一下。在满足中间条件时，肯定会发现有些中间条件仍然值得探究，此时必须选择暂时放弃，继续满足其他中间条件。值得探究的中间条件都保存起来，在完成目标后再去逐一探索。

    如果不是目标优先，那么就不断组合新概念与自己已有的其他概念，如果有收获就记录下来，感觉差不多了再进行下一个新概念。

    这两种模式必须穿插进行，效果才最好。

* 应该建立一个 reference resources 目录，把所有的引用资源都放到这里

    如果每个目录下都是从`ref_0`编号，移动笔记时就会混乱。

    如果统一管理 reference，就不会出现这个问题。

    可以从`ref_0`一直编号到`ref_100`，随着 ref 不断被处理，再删掉`ref_0`重新开始。

    每次删除的时候，可以在 documents 里用`grep`搜索`ref_0`保证没有被引用的地方。

* 如果看到一个名词没有任何头绪，那么就去*调研*它

    比如当天的任务，如果没有头绪，那么就*调研***当天的任务**。

    比如某个项目，如果不知道怎么开展，那么就去*调研*这个项目。

    如果对于某个任务，忘了它是怎么开始的，想不起来和它相关的所有东西，那么就去调研这个任务。

* 恶性竞争

    假如有两个公司 A 和 B，A 做的是热门泡沫方向，B 做的是扎实工作方向，结果 A 能融到资，B 融不到钱，最终 B 倒闭，A 最后也会因为泡沫破裂而倒闭。

    对融资公司来说，B 可能投资几年都什么起色，但是投资 A 可能有 10% 的机率挣大钱。理性的人可能会按比重分配资产投资，但是不要低估人性的贪婪，为了赌这一点很低的可能性，投资公司可能会加杠杆梭哈。

    假如有三家投资公司 C, D, E，这三家都投了 A 所在的行业，已知这个行业一定有一个胜出者，其实就是 C, D, E 在下注赌。C, D, E 都觉得最幸运的应该是自己，假如自己不跟注，那么挣钱的就一定会是别的两家投资公司。这样很不甘心。

    最终的结局是所有公司都赔了，每个环节的最优选择，导致了全局的最坏结果，非常讽刺。

* 遇到这样一种情况，假如`A = [1, 100]`，`B = [rand(1, 100) * 10] U [100, 1000]`，要理解某个知识，需要 B 中的各个知识点

    但是 B 中的资料需要到 A 中去查。

    如果把 A 从头到尾看一遍，那么需要大量的时间。但是不看 A 就无法理解 B 所需要的知识。

    这样的情况比较难处理。

* 10 亿以上重资产的创业能不能盈利和宏观经济有关

* 计划的重点在于可以回退

    之前大部分计划无法执行下去是因为只能顺序执行，没有考虑过失败和回退。

    如果总是回退，那么会导致没有动力去执行任务，也不汰好。

    这两者中间应该有个平衡点。

* 未经证实的，对概念的一个可能的解释被称为一个猜想。

* 如果可以使用“猜想”去解释一个现象，那么就可以进入实验阶段

    如果可以无法作出“猜想”，只知道哪个方向可能提供更多的信息，那么只能是“调研”

    无法作出猜想的阶段，都只是收集信息的阶段。目标就是为了作出猜想。

* 调研的目的不是完成任务，而是要有输出

* 假如 A 是一个节点，所有的联系都是从 B, C, D ... 指向 A，从 A 起始没有任何向外的边，那么 A 就很难被发现了。

    相反，如果有连接从其他节点指向 A，哪怕只有一条，也终究会被搜索到。

    这种现象可以被称为概念的禁锢。

* 每份笔记中应该专门开一个 examples 区域，整理详细的 example

    在笔记正文中出现的 example 只需要专注详解原理就行了，可以只是代码片段，也可以不检查返回值，不进行错误处理。

    example 区域中的 example，需要在追求简洁的基础上，增加一些返回值判断和错误处理，有完整可编译运行的代码，并且有运行的输出。

    问题：qa 中的代码片段该归属于哪一种？

* 进度的 sync

    如果一个项目长时间不合理发展，就会出现调研、 qa 和笔记不匹配的情况。这种情况下，需要对进度进行 sync，确认下面几个问题：

    1. 如果无法从学习资料中总结出新的笔记，那么认为学习和笔记的 sync 完成

    1. 如果无法再从笔记中找到一个新的 qa，那么认为 qa 和笔记的 sync 完成

    1. qa 里不能有 empty

    1. test, qa 文件夹 clean

    1. 可以连续三天通过随机 qa

    1. 项目池/笔记中不能有相关的 cache

    显然，项目进度的 sync 不应该出现在项目管理里，而应该由任务执行系统负责。

* 应该创建一个项目叫 reorg，同 qa 一起，组成自举系统

    reorg 用于每次在所有笔记，所有项目，以及所有理论系统中挑选出一个片段，尝试对其进行整理，重组，发散或者删除。

## 经济与社会

* 滑坡

    大部分企业总是贴着法律的最低标准生产，如果是没有法律监管的模糊地带，那么质量会低到不可想象。比如茶叶，卖树枝也是不违法的，所以低价茶叶里经常混有树枝。再比如小饭店，食材的劣质程度低到无法想象。当质量没有锚定点时，总是会不断地滑坡，直到达到法律的最低标准。是否有解决这个问题的思路？

    即使是贵的东西，质量也有好有坏，与其害怕花更多的钱买质量更低的商品，不如直接买便宜的有法律标准保底的。这样就导致贵的东西卖不出去，质量无法提升。

## 个人人生

* 天才与平凡

    报道天才的文章有很多，不乏年少成名，数学比赛金牌，少年AI创业，小学就学明白了量子力学微积分，媒体对这些报道总是不遗余力，不吝文字，甚至对这些追求形成了一种疯魔的状态，但是很少有人关注普通人该如何生活，正如普通人的标签普通一般，无法引起注意。MBTI 性格分析似乎在帮助我们认识自己，还算是关注普通人该如何认识自己，发掘自己的特点。媒体正确的做法，难道不是研究如何让不同特长的 A, B, C, D, E, F 类型的人更好地认识自己，融入社会，找到合适的位置吗？这样看来，其实张雪峰是做得比较好的，但是这应该是政府的责任，应该是媒体的责任。报道天才并不稀奇，能让每个平凡的人都发挥出自己的闪光点，才是媒体的强大。

## 情感规律与故事叙事

* 重新看了下老男孩微电影，对比这几天研究的红楼梦，重点关注了下电影里的线索，比如前面出现过，后面没再出现的，或者对情节没有推动作用，纯粹是凑数的镜头，发现老男孩其实并没有想象中那么感人。想象中的老男孩，最后参加节目，应该前期演出拉胯，中途被喊停，但是筷子组合并没有停下，坚持把节目演完，并在情绪高潮处怼桌子，最后被保安拉下台。既然在这里怼桌子，那就不能在前面的剧情里怼，前面必须想象着怼。情感在递进到高潮后，需要一个超出常理的情节来完成释放的过程，而在老男孩电影中，最后只是平淡地演完了节目，开始躲在厕所对表演有影响吗？没有。电视前的校花为什么哭了？前面的剧情有伏笔吗？也没有。其实整个剧本看下来，本来就是上学期间到处捣乱的一群学生，长大后进入社会的生活百态罢了。他们善良吗？没有。他们有一技之长吗？没有。他们有坚持对什么的热爱吗？似乎有，迈克尔杰克逊。但是这并不足以感动观众，因为动机不纯，弹唱跳舞只是为了追求女生，抛弃了这个目的，又是否花了时间肯吃苦去练习呢？如果仅仅表现生活百态，还真不如麦兜当当伴我心。

* 心动时刻

    情绪的高潮（或剧情的高潮）应该做出一些不合常理的举动。晃动的镜头，奔跑，大火，抛弃与释放……平时被理性束缚着思想和行为，但是感性可以冲破这一限制，这就是感性的魅力。前期的铺垫要够，线索要足够多

    有空了可以搜集下相关的剧情或视频片段。

## 剧情

* 疯狂

    剧情：首先是一伙人设下一个圈套，诱惑新来的人上钩，新来的人在危机关头识破陷阱，成功逃脱，但是设下陷阱的那一伙人却疯狂地为争夺某样东西，而互相残杀，即使自己缺胳膊少腿，也丝毫体会不到疼痛，眼里只剩下那样东西。

* 浮躁

    场景：地理上因为某块地有躁气，人们追求快而浮躁，就像在浮屠塔一样。此时有一个人初来乍到，被卷入纷争，不停地有人引诱，诈骗，躁动，疯狂，幸好这个人经受住了考验。离开此地后才发现这个地方向上冒着煞气or是个鬼城。这两个结局都挺不错的。

    人的精神世界来自于对物质的态度，来自于与自然的共处，来自于人与人之间的关系处理，来自与社会的联结，来自于自己的思想。精神世界的广阔程度与物质世界不相上下。精神世界经受的考验也与物质世界经受的考验（饥饿，温度，劳累等）相当。

* 一位亦正亦邪的神：负责掌控人类的情感，肉体，非理性的部分

    当他释放力量时，颓废的人变得亢奋，电影院的人失声痛苦，胆小的人变得无畏，斤斤计较的人不再看重个人得失，人类会完成许多之前无法完成的事情。

    但是人们又会勾起欲望，靠着身体的强壮和力量互相厮杀，逐渐走向堕落。

下面是一些标准任务以及处理它们的一些经验。

## 想法与待解决的问题（cached）

这一部分作为想法，灵感以及问题的缓冲区，记录各种相关的内容。

* 思考：像这种既没有经验，也没有参考，只能靠临时反应进行和大量交互进行下去的任务，该如何分配时间？

    没有任何的可借鉴经验，不清楚结果，这种任务被称为 blackhole task.

* 缓存策略和 stack 策略都非常有用，使得条理很清晰

* 有关笔记的整理

    可以消除一些笔记中穿插的一些 reference 资源，或者将资源提取出来。

* 假设：我们假设人脑每次能处理的任务的复杂程度有限，每次处理一项任务的最大时间也有限。因此需要把任务切分成刚好够人脑处理的一个片断。

* 未来需要做什么的任务列表固然很重要，但是描述自己在过去的一段时间里做了什么同样重要。

* 需要对任何结构化的资料进行定期整理，包括笔记，qa，任务管理系统，以及临时项目管理。

    主要整理方式就是从无序到有序，从混沌到结构，有相同点的整理到一起，有临时想到的写到缓存里。

* 当一个程序越来越大时，如何能快速知道以前开发过了什么功能，快速对自己的项目上手，这个问题需要思考一下

    目前一个思路是对当前项目也写一个简易的 qa，安排进检测列表

* 这一部分（即想法与待解决的问题）是否应该归类到反馈系统？

    或者说，所有的 log，缓存，是否都算是反馈系统的一部分？

    栈（依赖关系）的处理是否不算反馈系统的一部分？

* 有关 blackhole task 的处理

    因为 blackhole task 的问题都是动态创建且短暂的，总是在经历快速的假设->实验->推理的过程，所以无法像“学习”过程一样有固定的时间。但是可以研究如何快速保存任务进度，随时中断，从而可以预定时间。

* 有关任务处理的一些问题

    在执行一个任务时产生了新的问题，新的任务，把这些东西放到 log 中去，不要影响堻圭前的任务。

* 从混沌到结构，从无序到有序

    在结构化的笔记上面，创建一个混沌区域，这个区域中都是临时想到的一些想法，等这些想法积累得足够多了，就将它们组合成结构化的知识。

    另外一个是，临时想出的想法，先缓存起来，不耽误当前任务的执行，等有空余时间了再批量处理。

    这两点或许会非常非常重要，是整个任务管理系统的基石。

* 如果一个任务，在其他任务创建 stack 时，经常会创建到它，那么就称这个任务为伴生任务。

* 缓存待完成的任务是一个非常好用的经验，但是并不能长时间使用，因为缓存不太消耗脑子，可以非常容易地获得短暂的满足，所以脑子一直处于放松的状态，时间一长就是在浪费时间。

* reduce 过程通常比较轻松，不会消耗太多的精力，如果一直 reduce 就会陷入空虚。

    cache tabs 也是一种 reduce.

    因此和 reduce 相关的任务，要设置一个时间上限，不能无休止地 reduce。

* 目前的随机检测系统实际上已经支持了随机任务 + 随机索引，以后只要规定 qa 的数量就可以了

* 可以使用 move 从函数中返回局部对象吗？

* vulkan 可以把核心绘制部分写成 qa，即 draw frame 函数

* vulkan 的 qa，如果不把 dependency 机制做好，那么很难继续下去

## 调研

所谓调研就是在尽量不做实验的情况下，看看能理解多少东西，不理解的东西就记下来

调研的目的是投稿少量的时间和精力，从大任务中生成小任务，将不标准的任务转换成部分标准的任务，并给出时间规划。

* 调研的三个结果

    要么给出更多的问题，要么给出已经收集到的信息，要么给出具体的任务。

    如果有更多的问题待处理，那么就给出问题。如果找不到什么问题，那么至少应该给出信息。

    如果感觉某些任务可以完成，那么就给出任务。

    只给信息，不给问题，可能是因为需要后续判断是否还要做这个方向。

1. 项目调研 -> 产生项目规划

    寻找参考资源，简单分析项目可行性，分析项目依赖

2. 任务调研 -> 产生具体任务列表

    简单浏览一遍参考资源待看的部分，大概了解下材料的难度，细分再细分，直到感觉某个概念，某一段话，某个公式，自己可以短时间内搞定为止，将其写到任务列表上。

    更长远的思路写个大致的规划。

项目调研和任务调研也都算在任务清单中，他们所占用的时间和精力一点不比具体的任务少。

调研：如果对已有的书面学习材料的调研，那么就顺序阅读，不回看，如果理解顺利，那么一直看下去，直到遇到无法理解（解释有矛盾，或者有未知信息）的地方为止。最大调研时间 20 分钟，超过 20 则停止。

调研时需要回答的几个问题：

1. 看了刚才的内容，我能否用它来做一些事情？和过去我学过的内容有什么关系？

    如果这个问题可以回答，那么就将它加入任务列表里。

1. 刚才看过的内容，里面的每个概念我能否用自己的话描述？

    如果不能描述，那么中止。如果这个答案依赖某个遗忘的内容，那么将复习遗忘内容加到任务列表里。如果这个答案依赖一个未知的内容，那么将新的调研加入到任务列表里。

调研与具体的任务安排都是平等的关系。

## 复习

如果对学到的知识不进行复习，那么很快就会遗忘。

为了提高复习效率，这里使用问答的形式进行复习，因此又叫 question and answer，又叫 qa。

* 每天的随机检测非常重要，一定要把时间均摊到每天，这样的 qa 才有意义。

* 旧的 qa 没复习完前就不要写新 qa 了，因为都不知道学到哪了，也不知道该整理什么资料

* 创建一个 qa 池和一个随机数生成器，每次先从 qa 池中随机挑选一个项目，然后再随机选一个 unit，进行检测

    如果遇到不会的 unit，那么找它的 dependency，如果 dependency 还不会，那么再找它的 dependency，以此类推。

* 每个项目开始之前，先进行随机检测。每个项目随机检测的时间不应该超过半个小时。

* 以每 30mins 检测 2 个 qa 为准

* qa 一定要基于 note，而不是独立于 note。qa 与 note 最大的区别在于，qa 是条目式的，缺少细节，并且有 dependency，而 note 专注结构和细节，并且有更多的思考和延伸参考资料。

* 关于 qa 文件格式的改变

    使用`[idx]`标签标注从上往下的索引，用于唯一定位，从 0 开始。

    使用`[id]`标签标注一个哈希值，用于唯一定位。使用对当前时间的哈希即可，主要不重复就可以了。

    使用`[dep]`指定当前条目所依赖的条目，写法如下：

    ```
    [dep]
    <id> - <u_0>
    <id> - <u_0>
    ...
    ```

    因为`[id]`和`[u_0]`可能在文件里出现很多次，所以仅使用这两个无法快速精准定位。

    `[u_0]`也有可能写得很长，还是用 title 吧。

## 记忆

对于标准化的记忆过程，需要精心准备干净、准确的记忆材料，并使用称为“联合”的概念来描述记忆，另外还必须使用复习来巩固才能达到想要的效果。

所谓的联合，即提到 A，马上想到 B，其中 A 和 B 都是记忆材料。A -> B 这样的联合称为单向联合。如果提到 B 也能想到 A，那么 A <-> B 这样的称为双向联合。

实现联合最原始的方法是机械记忆法，即熟悉完 A 材料后马上熟悉 B 材料。其中熟悉的方法有看，读，听，写，默念。附加的条件有：不同场景，不同时间，不同顺序，不同位置。

不同场景：桌子前，操场上，街道边，厕所里，晴天，雨天，热闹的场合，安静的场合等不同场景下记忆，效果更好。

不同时间：凌晨，早上，中午，晚上，半夜。

不同顺序：假设要记忆 A1 -> B1，A2 -> B2 等这样的材料，如果总是按照 A1, A2, A3 等这样的顺序，那么会产生时间和空间的连续性。所以顺序记忆比乱序记忆更容易一些。在完成顺序记忆后，需要使用某些产生随机数的方法来达到乱序的效果。

除了这些，还可以有不同材质，不同形式，不同字体等等。

双向联合：单向联合要求看到 A 后给出 B，并不要求看到 B 后给出 A。双向联合要求两个方向都要做到，因此要把单向联合的过程实施两遍。

**记忆材料**

无论如何实现联合，都必须满足如下条件：当看到 A 材料时，无法看到 B 材料；当熟悉完 A 材料后，需要马上可以熟悉 B 材料，或者自己给出 B 材料后，需要马上可以检验给出的 B 材料对不对。另外还需要可以乱序记忆。为了实现这个需求，目前我能想到的有下面三种形式：

1. 在笔记本上分栏记录记忆材料，左侧为 A 材料，右侧为 B 材料。

    当联合时，看完左侧 A 材料，在右侧可以看到应对的 B 材料。在检测时，可以捂住 B 材料的内容，复述完后移开手，可以直接检验复述是否正确。

    当乱序记忆时，可以用纸片抽签的形式产生随机数，定位到第几则记忆材料。

1. 在小卡片上正面写材料 A，背面写材料 B。

    联合时只需要分别看 A 材料和 B 材料就可以了，很方便。缺点是比较薄的纸会隐约看到背面的内容。

    乱序记忆时只要对卡片进行洗牌就可以了。

1. 使用电脑数据库，编程实现 A 材料，B 材料的出现以及乱序记忆。

**联想记忆法**

联想记忆法有跳跃联合，形变，谐音，同异点等。

1. 跳跃联合。如果我们的脑子里已经有 A -> B 的联合和 B -> C 的联合，那么就可以以 B 为中间节点，快速地形成 A -> C 的联合。问题在于并不是每个节点 B 都是容易找到的。

1. 如果我们可以对材料 A 施加形变、联想谐音、虚构故事或添加逻辑达到材料 C，那么就可以把形变过程、谐音、故事或逻辑作为中间节点 B。此时 B 越新奇，越有冲击力，记忆的效果越好。

**跳跃游戏**

平时无聊的时候，给出某个节点 A，比如一个词语，一个图形，一段语音，然后进行联想到其他的记忆节点 B1，B2，B3 等等。再从 B1, B2, B3 等节点中选择一个，进行下一轮发散。我称其为思维跳跃游戏。

**检测**

为了完成一个记忆过程，检测是必要的。有一个猜想是记忆的本质不是模仿，而是创造。在检测时，我们需要看完材料 A 后，给出 B'（方式为说出来，写出来，想象出来等），然后与材料 B 进行对比，完全相同才算联合的形成。

对于一组记忆材料的检测有两种方式：

1. 顺序检测。检测的顺序和记忆的顺序相同。这种比较容易达成。因为往往简单重复账户

**记忆的复习**

记忆的遗忘规律有如下几个：前几天忘得快，其后忘得越来越慢；记忆的材料越相似，越容易混淆。

目前采用的复习方案是：

1. 第一天要求完成顺序记忆和至少一次乱序检测。

1. 第二天要求完成乱序检测。

## 理解

### cache

* 当我们说一个任务无法完成时，意味着我们必须要完成其他前置任务，依赖任务

* 如果学新概念/知识时，所有的新概念都可以从已知的知识轻松推导出来，那么就称这种学习过程为线性学习

    如果在学习一块新知识时，新知识中的一部分或全部无法通过已知概念推导出来，那么就称这种学习过程为非线性学习

* 非线性学习的一些方法

    * 总会有一些东西是可以一眼看懂的（从旧知识中推导出来），对这些一眼可以看懂的知识进行条目化总结。

        sync 这些新概念，直到可以用它们解释其他的新知识

    * 猜想-验证，对于无法理解的概念，先给出自己的一个猜想的解释，然后做出一些预测，再去验证，最后修正自己的猜想

        难点在于，有时候需要同时对大量的新概念提出猜想，变量过多，不容易修正自己的猜想。

    * 孤岛信息的连结

        如果有一段一两句话的知识点，虽然看不懂，但是可能在新知识体系中有用，不需要理解，但是需要知道它出现过，以后可能用得到，这种孤岛信息可以选择性地收集起来，以备后面使用。

* 基于 nccl 调研的非线性学习心得

    这个过程和扫雷有点像，都是从确定已知的信息开始，从内向外逐渐推测功能，做出猜想和假设，并做实验进行验证。

    比如在 set_path() 函数中判断 path 的含义时，我们可以看懂并确定的代码时，每次搜索到一个 rem_node，都会搜索其 rem_link，当发现 rem_link 指向当前 node 时，就把 rem_link 添加到 rem_path 最开头的位置，并将 path 的内容添加到 rem_path 的后面。由此我们做出猜想：rem_path 的作用是从 rem_node 出发，终点为 base node 的 edge list。由于此猜想在后面的代码被多次验证，所以大概率是对的。由此我们还可以做出推断：与 rem_path 相对应，path 的作用是从当前 node 出发，指向 base node。这个推断再次被证明为对的，我们又可以做出推断：`getPath(struct ncclTopoSystem* system, struct ncclTopoNode* node, int t, int64_t id, struct ncclTopoLinkList** path)`的作用是返回从`node`出发，指向 type 为`t`，topo id 为`id`的 node 的 path。

    注意推断（inference）和评论（comment）的区别，推断可以推动理解的进展，评论只能发散思维，或者提出问题。推断的一个重要标志是通过实验验证猜想，而评论只需要说出感觉，重新叙述，提出问题，作出评价。

* ai 的回答不可能替代人的理解

    猜想：人的理解的本质是将新知识的每一个概念节点与脑中已有的旧知识的大量概念节点进行匹配，最终可以对某个现象做出解释，预测，并且有能力验证。新概念的融入要求不能对既有的知识体系引入矛盾。由于这个过程一定是需要人亲自完成的，所以 ai 并不能缩短这一过程的时间。ai 可以提供信息源，可以提高匹配过程的效率，但是无法真正地取代匹配。因此 ai 的回答不可能替代人的理解。

* 必要的 bfs 与非线性

    对于有嵌套结构的材料，有两种方式可以尝试理解，一种是 dfs，另一种是 bfs。dfs 指的是首先关注材料的第一段话，第一句话，或关注代码的第一行函数，然后再层层展开，直到遇到不能理解的，要么去查资料，要么回退到上一层，并尝试向前/向后看一些，并给出猜想，由此再向后推进。

    bfs 指的是先浏览材料整体，根据自己当前的水平和理解，给出各个模块的作用以及模块与模块之前联系的猜想。此时会大量使用非线性的技巧。

    显然 dfs 更细致，更精确，但是如果非骨干的细节过多，会耽误对主干的理解。dfs 的周期通常很长，一个任务 pending 很多天无法完成，导致任务越积累越多。那么什么时候该用 bfs？如果是一个调研性质的任务，不需要强制实现，并且希望任务尽快收尾，那么就使用 bfs。如果某个任务需要强制实现，并且这个任务长期存在，那么就使用 dfs。

* dfs 停止的条件

    阅读材料时，每次开始认为是一个 block，每遇到一个无法解释的点，则记 uncomprehensive point +1，记录够 N 个后，则认为这个 block 到此已经无法再理解了。可以尝试从下面开始，或者往下跳几段/几章，开始一个新的 block。如果新的 block 也无法理解，则记录 uncomprehensive block +1，攒够 N_2 个后，则认为整个 material 是无法理解的。

* 未知概念的非线性搜索范围

    一个初步的方案：假如概念 1 没有理解，可以暂时跳过，继续看后面的东西。假如看到了概念 2，概念 2 依赖于概念 1，概念 3 也依赖概念 1，但是概念 3 与概念 2 是独立的，那么可以借助概念 2 和 3 理解概念 1. 假如概念 4 依赖概念 2，而概念 2 还没弄明白，那么就应该停止了。

### note

**理解**

对于给出的一个名词、定理或问题，如果我们可以给出解释和例子，使得想象中不懂这门课的人也能完全听懂，那么就称我们理解了这个名词。

**可理解的**

如果一段话中的每个名词、逻辑和自己提出的问题，我们都能予以解答，那么就称这段话是可理解的。

显然，如果不理解一段话，无非是遇到了以下几种问题：

1. 名词看不明白

    1. 没有解释的新名词

    1. 之前学过这个名词，但是忘了

    1. 名词有歧义

1. 逻辑解释不通

1. 自己提出的问题无法解答

很多时候我们的不理解是含糊的，混乱的。之所以要把各种不理解的情况列出来，是因为我们必须要把问题清晰完整地陈述出来。这是走向理解的第一步。

事实上，一切的不理解最终都推向一个无法解答的矛盾。只有把这个矛盾清晰完整地说出来，我们才能说我们不理解这个东西。

**螺旋**

许多东西并不是刚看到时就能理解的，经常看到了后面才能理解，或者看到了其它资料才能理解。这种现象称作螺旋。

## 理论

1. 理论要能快速入门，简单易懂，便于查询，易于操作。

1. 理论要迭代渐进。如果一个问题是可以被改善的，那么就是值得感激的。

1. 理论要考虑到最恶劣的环境。

## 笔记

1. 笔记必须先以时间顺序写成，然后再按空间顺序整理。

    在学新东西的时候，总是一个概念一个概念学，不容易直接和其他领域的知识形成联系。因此做笔记的时候也是扁平化地不断记录新的概念，新的操作，自己的想法感悟等等。

    但是扁平化地记录一段时间新的概念后，复习时往往会发现不同概念间的树状或网状联系。此时需要对笔记进行再排序，形成一个有组织、有架构的笔记。

    这两个概念类似于各个工具的 tutorial 和 reference。tutorial 遵循时间顺序，reference 遵循空间顺序。

1. 笔记遵循的范式是先写严谨的概念定义，或者写定理与证明，然后再写数条解释，包括背景介绍，概念里需要注意的细节，为什么要这样设计等等。

    **概念名词**

    精确的定义

    说明：

    1. xxx
    1. xxx

    **定理**

    定理内容

    证明：

    xxx

    说明：

    1. xxx
    1. xxxx

1. 假如总是在做笔记，那么就容易造成抄书，什么都不理解。假如总是在理解，那么前面学过的东西就会忘，思路混乱。

    所以记笔记的原则是首先要理解内容，然后再记录下精华部分和自己的心得。

    最好的办法是先在纸上画画写写，等理解得差不多了，再把纸上的精华变成电子版。

## 学习

学习包含理解、笔记、记忆、复习，做题这几个部分。

1. 定理：只学不复习等于没学。

    因此如果不能保证安排后续的复习，就不要开始学一样东西，因为最终会忘得一干二净。

* 抛弃形式化学习的几个建议

    先学常用的，再学不常用的。

    先学能理解的，再学不能理解的。能理解：每看一句话，都能用自己的语言，已有的知识对它进行解释。如果有需要猜测的地方，那么就得做实验验证。如果猜想与假设太多，那么就认定是不理解的。完全看不懂也属于不能理解。

    切忌还没理解意思就直接照搬原文作为笔记。不理解的东西就不要写到笔记里。

    基于 example 学习，而不是基于 spec/theory 学习。

    语言的描述是模糊的，具体的例子是精确的。

* 即使是 qa，也要先按时间顺序提修改建议，然后再去改动。不然容易改了一半发现前面的写的也不好，最后越改越多。

## 情绪