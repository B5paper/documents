* dataloader

    syntax:

    ```py
    DataLoader(dataset, shuffle=True, sampler=None, batch_size=32)
    ```

    一个简单的 example:

    ```py
    import torch as t
    from torch.utils.data import Dataset, DataLoader

    class MyDataset(Dataset):
        def __init__(self):
            self.m_arr = list(range(8))
            self.m_len = len(self.m_arr)
        
        def __len__(self):
            return self.m_len
        
        def __getitem__(self, index):
            return self.m_arr[index]
        
    my_dataset = MyDataset()
    print("first elm: {}".format(my_dataset[0]))
    print("dataset len: {}".format(len(my_dataset)))

    my_dataloader = DataLoader(my_dataset, batch_size=2, shuffle=True)
    for batch_data in my_dataloader:
        print("batch_data: {}, type: {}, shape: {}".format(batch_data, type(batch_data), batch_data.shape))
    ```

    output:

    ```
    first elm: 0
    dataset len: 8
    batch_data: tensor([4, 1]), type: <class 'torch.Tensor'>, shape: torch.Size([2])
    batch_data: tensor([6, 7]), type: <class 'torch.Tensor'>, shape: torch.Size([2])
    batch_data: tensor([3, 0]), type: <class 'torch.Tensor'>, shape: torch.Size([2])
    batch_data: tensor([5, 2]), type: <class 'torch.Tensor'>, shape: torch.Size([2])
    ```

    DataLoaders on Built-in Datasets:

    ```py
    # importing the required libraries
    import torch
    from torch.utils.data import Dataset
    from torch.utils.data import DataLoader
    import seaborn as sns
    from torch.utils.data import TensorDataset

    # defining the dataset consisting of 
    # two columns from iris dataset
    iris = sns.load_dataset('iris')
    petal_length = torch.tensor(iris['petal_length'])
    petal_width = torch.tensor(iris['petal_width'])
    dataset = TensorDataset(petal_length, petal_width)

    # implementing dataloader on the dataset 
    # and printing per batch
    dataloader = DataLoader(dataset, 
                            batch_size=5, 
                            shuffle=True)

    for i in dataloader:
        print(i)
    ```

* dataset 似乎支持 slice 访问

    ```py
    my_dataset = MyDataset()
    print(my_dataset[:3])
    ```

    output:

    ```
    [0, 1, 2]
    ```

* python 删除文件

    python 可以使用`os.remove()`删除文件，但是`os.remove()`如果删除成功，不会有提示，如果删除失败，会报 exception。因此我们使用 try 来判断文件是否删除成功。

    ```py
    import os

    def remove_file(file_path):
        try:
            os.remove(file_path)
            print(f"文件 {file_path} 删除成功")
            return True
        except FileNotFoundError:
            print(f"文件 {file_path} 不存在")
            return False
        except PermissionError:
            print(f"没有权限删除文件 {file_path}")
            return False
        except OSError as e:
            print(f"删除文件时出错：{e}")
            return False

    # 使用示例
    success = remove_file("to_delete.txt")
    if success:
        print("删除操作成功完成")
    else:
        print("删除操作失败")
    ```

    output:

    ```
    文件 to_delete.txt 删除成功
    删除操作成功完成
    ```

* 模拟交易总结

    * 银行里投的 etf 买卖太慢，跟不上变化

    * 不能在 10 日均线上升的末尾买入，这个滞后性太严重了。当 10 日均线斜率为负后，其实股价已经跌了有几天了，价格已经跌出了买入的价格，铁定亏本

    * 持续持有的意义：开盘可能低开或者高开，如果每天都全仓买入或者卖出，无法处理开盘价。比如昨天收盘价 10 块，今天开盘价 15 块，如果昨天盘尾全部卖出，那么今天就算开盘就再买入，那么仍有 5 块吃不到。

* 股市可以看作容错很强的分布式计算，每个人都是一台计算机

* 不想看到宣扬圆满幸福的一生，想看到如何处理千疮百孔的一生

* 新时代的莎士比亚

    莎士比亚经历了底层的生活，又对生活观察细致，还有文学功底，这才造就了戏剧大师。而当今的剧本普遍缺乏对底层人民的观察，因此缺乏感染力。我们可以雇佣调查记者，收集底层人民或者行业的故事素材，进行艺术加工，做成感人的动画或剧本。这样的公司可以成为新时代的莎士比亚。

    调查记者只有一笔启动资金，在调查期间没有额外资金来源，只有一次紧急求救机会。必须经历贫寒，辱骂，贬低，才能对恶感同身受，才能找到感动人的点。只有经历磨难，才有可能肉身筑圣。

    一部分调查记者可以收集故事素材，另一部分调查记者可以去调研实际的经济情况，拿到真实的经济数据。无论哪种，都有点像间谍。

* peer connect

    `sock.h`:

    ```c
    #include <netinet/in.h>

    int sock_serv_sync(int cli_sock_fd);
    int sock_cli_sync(int cli_sock_fd);

    void sock_send(int fd, const void *buf, size_t buf_len);
    void sock_recv(int fd, void *buf, size_t buf_len);
    void sock_serv_exchange_data(int fd, void *buf, size_t buf_len);
    void sock_cli_exchange_data(int fd, void *buf, size_t buf_len);
    ```

    `sock.c`:

    ```c
    #include <stdio.h>
    #include <arpa/inet.h>
    #include <sys/socket.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/select.h>
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <sys/time.h>
    #include <sys/types.h>
    #include <ifaddrs.h>
    #include <string.h>


    int get_my_ipv4_addr(char *my_ipv4_addr)
    {
        struct ifaddrs *if_addrs;
        int ret = getifaddrs(&if_addrs);
        if (ret < 0)
        {
            printf("fail to get if addrs\n");
            return -1;
        }

        char* if_name_black_list[] = {
            "lo",
            "docker"
        };
        int if_name_black_list_len = sizeof(if_name_black_list) / sizeof(char*);

        struct ifaddrs *ifa_node = if_addrs;
        int is_valid_ip_addr = 0;
        while (ifa_node)
        {
            int is_ifname_black_list_matched = 0;
            for (int i = 0; i < if_name_black_list_len; ++i)
            {
                char *if_name = if_name_black_list[i];
                int if_name_len = strlen(if_name);
                int ret = strncmp(ifa_node->ifa_name, if_name, if_name_len);
                if (ret == 0)
                {
                    is_ifname_black_list_matched = 1;
                    break;
                }
            }

            if (is_ifname_black_list_matched)
            {
                ifa_node = ifa_node->ifa_next;
                continue;
            }

            struct sockaddr_in *addr = (struct sockaddr_in *) ifa_node->ifa_addr;
            if (addr->sin_family != AF_INET)
            {
                ifa_node = ifa_node->ifa_next;
                continue;
            }

            char addr_str[16] = {0};
            inet_ntop(AF_INET, &addr->sin_addr.s_addr, addr_str, 16);
            // printf("name: %s, addr: %s\n", ifa_node->ifa_name, addr_str);
            strncpy(my_ipv4_addr, addr_str, 16);
            is_valid_ip_addr = 1;
            break;
        }
        freeifaddrs(if_addrs);

        if (!is_valid_ip_addr)
            return -1;
            
        return 0;
    }


    int peer_connect(int *serv_fd, int *cli_fd, int *i_am_server,
        char **node_ipv4_addrs, const uint16_t listen_port)
    {
        // length of node_ipv4_addrs is always 2

        int _serv_fd = socket(AF_INET, SOCK_STREAM, 0);
        if (_serv_fd < 0)
        {
            printf("fail to create sock fd\n");
            return -1;
        }
        printf("successfully create serv sock fd: %d\n", _serv_fd);

        int _cli_fd = socket(AF_INET, SOCK_STREAM, 0);
        if (_cli_fd < 0)
        {
            printf("fail to create fd\n");
            return -1;
        }
        printf("successfully create cli sock fd: %d\n", _cli_fd);

        uint32_t listen_addr_ipv4 = INADDR_ANY;
        struct sockaddr_in serv_sock_addr;
        serv_sock_addr.sin_family = AF_INET;
        serv_sock_addr.sin_addr.s_addr = listen_addr_ipv4;
        serv_sock_addr.sin_port = htons(listen_port);

        int ret = bind(_serv_fd, (struct sockaddr*) &serv_sock_addr, sizeof(serv_sock_addr));
        if (ret < 0)
        {
            printf("fail to bind\n");
            return -1;
        }
        printf("bind addr: %08x, port: %u\n", listen_addr_ipv4, listen_port);

        ret = listen(_serv_fd, 5);
        if (ret < 0)
        {
            printf("fail to listen\n");
            return -1;
        }
        printf("start to listen...\n");

        char my_ip_addr_str[16] = {0};
        ret = get_my_ipv4_addr(my_ip_addr_str);
        if (ret < 0)
        {
            printf("fail to get my ipv4 addr\n");
            return -1;
        }
        printf("my ipv4 addr: %s\n", my_ip_addr_str);

        char *peer_ip_addr = NULL;
        for (int i = 0; i < 2; ++i)
        {
            char *ip_addr = node_ipv4_addrs[i];
            int ret = strncmp(ip_addr, my_ip_addr_str, 16);
            if (ret == 0)
                continue;
            peer_ip_addr = ip_addr;
            break;
        }
        if (peer_ip_addr == NULL)
        {
            printf("fail to get peer node ip addr\n");
            return -1;
        }
        printf("peer node ip addr: %s\n", peer_ip_addr);

        uint64_t loop_idx = 0;
        int timeout_sec = 2;
        int timeout_ms = 100;
        while (1)
        {
            printf("start loop %lu\n", loop_idx++);

            fd_set fdset;
            FD_ZERO(&fdset);
            FD_SET(_serv_fd, &fdset);
            struct timeval timeout;
            timeout.tv_sec = timeout_sec;
            timeout.tv_usec = timeout_ms * 1000;
            ret = select(_serv_fd + 1, &fdset, NULL, NULL, &timeout);
            if (ret < 0)
            {
                printf("fail to select, ret: %d\n", ret);
                return -1;
            }

            if (FD_ISSET(_serv_fd, &fdset))
            {
                *i_am_server = 1;
                *serv_fd = _serv_fd;
                shutdown(_cli_fd, SHUT_RDWR);
                break;
            }
            printf("timeout reached, no client connect in\n");

            struct sockaddr_in peer_addr;
            peer_addr.sin_family = AF_INET;
            in_addr_t peer_ip_addr_u32net;
            inet_pton(AF_INET, peer_ip_addr, &peer_ip_addr_u32net);
            peer_addr.sin_addr.s_addr = peer_ip_addr_u32net;
            peer_addr.sin_port = htons(listen_port);
            printf("connect to peer addr: %s\n", peer_ip_addr);
            ret = connect(_cli_fd, (struct sockaddr *) &peer_addr, sizeof(peer_addr));
            if (ret == 0)
            {
                *i_am_server = 0;
                *cli_fd = _cli_fd;
                shutdown(_serv_fd, SHUT_RDWR);
                break;
            }
            printf("timeout reached, can not connect to server\n");
        }
        return 0;
    }

    void sock_send(int fd, const void *buf, size_t buf_len)
    {
        int bytes_send = send(fd, buf, buf_len, 0);
        if (bytes_send != buf_len)
        {
            printf("fail to send data via socket\n");
            printf("bytes_send: %d, buf_len: %lu\n", bytes_send, buf_len);
            exit(-1);
        }
    }

    void sock_recv(int fd, void *buf, size_t buf_len)
    {
        int bytes_recv = recv(fd, buf, buf_len, 0);
        if (bytes_recv != buf_len)
        {
            printf("fail to recv data via socket\n");
            printf("bytes_recv: %d, buf_len: %lu\n", bytes_recv, buf_len);
            exit(-1);
        }
    }

    int sock_serv_sync(int cli_sock_fd)
    {
        sock_send(cli_sock_fd, "sync", 5);
        char buf[5] = {0};
        int bytes_recv = recv(cli_sock_fd, buf, 5, 0);
        if (bytes_recv != 5 || strcmp(buf, "sync") != 0)
        {
            printf("fail to recv sync\n");
            return -1;
        }
        return 0;
    }

    int sock_cli_sync(int cli_sock_fd)
    {
        char buf[5] = {0};
        int bytes_recv = recv(cli_sock_fd, buf, 5, 0);
        if (bytes_recv != 5 || strcmp(buf, "sync") != 0)
        {
            printf("fail to recv sync\n");
            return -1;
        }
        sock_send(cli_sock_fd, "sync", 5);
        return 0;
    }

    void sock_serv_exchange_data(int fd, void *buf, size_t buf_len)
    {
        sock_send(fd, buf, buf_len);
        sock_recv(fd, buf, buf_len);
    }

    void sock_cli_exchange_data(int fd, void *buf, size_t buf_len)
    {
        void *buf_copy = malloc(buf_len);
        memcpy(buf_copy, buf, buf_len);
        sock_recv(fd, buf, buf_len);
        sock_send(fd, buf_copy, buf_len);
        free(buf_copy);
    }

    ```

    这段代码主要使用 client, server 建立的微小时间差异来确立身份。

    可以见`ref_29`。