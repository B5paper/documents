* `RUNPATH`

    存储在可执行文件或动态库（.elf 文件）中的一个参数，它的主要作用是指定程序在运行时搜索动态链接库（.so 文件）的额外路径列表。

    动态链接器的典型搜索顺序如下（简化版，体现了 RUNPATH 的关键位置）：

    1. LD_LIBRARY_PATH 环境变量指定的目录。

    2. 可执行文件中嵌入的 RPATH 目录（如果存在，且没有 RUNPATH）。

    3. 系统缓存文件 /etc/ld.so.cache 中列出的目录。

    4. 默认的系统库目录，如 /lib 和 /usr/lib。

    5. 可执行文件中嵌入的 RUNPATH 目录（如果存在）。

    设置`RUNPATH`的方法：
    
    `gcc -Wl,-rpath=/path/to/your/libs -o my_program my_program.c`

* `--enable-new-dtags`

    --enable-new-dtags 是 GNU 链接器 (ld) 的一个选项。它的主要作用是：在创建可执行文件或动态库时，使用 RUNPATH 而不是 RPATH。

    example:

    ```bash
    # 启用 new dtags，生成 RUNPATH
    gcc -Wl,--enable-new-dtags,-rpath=/opt/mylib -o my_program main.c

    # 禁用 new dtags（或不指定），生成 RPATH
    gcc -Wl,--disable-new-dtags,-rpath=/opt/mylib -o my_program main.c
    # 或者直接
    gcc -Wl,-rpath=/opt/mylib -o my_program main.c
    ```

    checkout:

    ```bash
    readelf -d my_program | grep -E '(RUNPATH|RPATH)'
    ```

    * 启用`--enable-new-dtags`后，输出会显示`0x000000000000001d (RUNPATH) Library runpath: [/opt/mylib]`

    * 禁用时，输出会显示`0x000000000000000f (RPATH) Library rpath: [/opt/mylib]`

* 不能从`.so`中拿到库中所有的函数，因为有的`.c`中的函数可能是`static`的。也不能从`*.o`中拿到所有的函数，因为不一定所有的`.c`都生成`.o`，还有可能直接生成`.so`。

* `/etc/ld.so.conf.d/myapp.conf`

    将一个自定义的库路径（例如`/opt/myapp/lib`）添加到系统中所有应用程序的共享库搜索路径中。`ld-linux.so`会搜索`/etc/ld.so.conf.d`这个目录下的所有配置。

    example:

    ```conf
    /opt/myapp/lib
    ```

    创建或修改配置文件后，必须运行 ldconfig 命令来重建共享库缓存，使更改立即生效:

    ```bash
    sudo ldconfig
    ```

    这个命令会读取所有`/etc/ld.so.conf.d/`下的配置文件和`/etc/ld.so.conf`，生成一个快速的缓存文件`/etc/ld.so.cache`。动态链接器实际使用的是这个缓存文件来加速查找。

    主配置文件 /etc/ld.so.conf 通常会包含一行：`include /etc/ld.so.conf.d/*.conf`。

* `od -t x1`

    以十六进制（HEX）字节的形式，逐个字节地显示文件或输入流的内容。

    * `-t` (`--format`) : 用于指定输出数据的格式。它告诉 od 如何解释和显示文件中的字节。

    * `x1`: `x`表示 16 进制，`1`代表每个输出单元的大小是 1 个字节。

    example:

    ```
    0000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
    0000020 03 00 3e 00 01 00 00 00 10 0a 00 00 00 00 00 00
    0000040 40 00 00 00 00 00 00 00 38 4e 00 00 00 00 00 00
    ...
    ```

* `nsupdate`

    用于动态、增量地更新 DNS 域名。它允许你在不手动编辑 zone file（区域文件）和重启 DNS 服务的情况下，直接添加、修改或删除 DNS 记录。

    主要功能和用途

    * 动态 DNS (DDNS)

        这是 nsupdate 最经典的用途。很多家庭宽带或办公网络的公网 IP 地址是动态变化的。你可以在路由器或电脑上运行一个脚本，当检测到 IP 变化时，自动使用 nsupdate 命令向 DNS 服务器发送更新请求，将你的域名（如 home.example.com）快速指向新的 IP 地址。这样你始终可以通过一个固定的域名访问到动态 IP 的设备。

    * 自动化运维和脚本集成

        在自动化部署（CI/CD）、云基础设施管理中，经常需要批量创建或销毁服务器。这些流程可以通过脚本调用 nsupdate，自动为新服务器注册 DNS 记录，或者在下线时清理记录，实现全自动化管理。

    * 快速故障恢复

        如果需要将服务从一个 IP 迁移到另一个 IP，使用 nsupdate 可以几乎实时地更新 DNS 记录，大大缩短故障切换时间（RTO），比手动修改zone file并等待复制要快得多。

    工作原理

    nsupdate 并不直接操作 DNS 服务器上的配置文件。它的工作流程是：

    1. 连接：nsupdate 会连接到目标 DNS 服务器（通常是 BIND 9）的 53 端口，并使用 TSIG（Transaction SIGnature） 密钥进行身份验证。TSIG 确保了更新的安全性和合法性，防止任何人随意修改你的 DNS 记录。

    2. 发送更新指令：在交互式命令行或通过管道输入中，你发送一系列指令，例如：

        * `update add www.example.com 3600 A 192.0.2.1` （添加一条 A 记录）

        * `update delete oldhost.example.com A` （删除一条 A 记录）

    3. 服务器处理：DNS 服务器验证你的权限后，会在内存中直接更新它的 zone 数据，并递增该区域的序列号（SOA Serial）。这个更改会立即生效，并通知其他从服务器进行区域传输（AXFR/IXFR）以同步更新。

    example:

    假设我们有一个密钥key文件，用来向DNS服务器 dns.example.com 认证，并更新 example.com 域。

    ```bash
    # 启动 nsupdate 并指定服务器
    nsupdate -k /path/to/mykey.key

    # 在出现的交互提示符下输入命令
    > server dns.example.com
    > zone example.com
    > update add newserver.example.com 300 A 203.0.113.10
    > send
    > quit
    ```

    这条命令成功执行后，域名 newserver.example.com 就会立刻指向 203.0.113.10。

* `readl()`, `writel()`

    用于访问内存映射 I/O (MMIO) 设备，读取/写入 32 位（`long`）的数据。

    syntax:

    ```c
    void writel(u32 value, volatile void __iomem *addr);
    u32 readl(const volatile void __iomem *addr);
    ```

    `writel()`: 它确保了写入操作是原子的（不会被其他操作打断），并且会处理不同 CPU 架构可能存在的字节序（Big-Endian vs Little-Endian）和内存访问顺序问题，保证驱动程序的跨平台兼容性。

    `readl()`: 除了处理字节序和内存屏障，它还能防止编译器对读取操作进行错误的优化（例如，认为该地址的值不会变化而将其缓存，导致重复读取同一个旧值）。volatile 关键字确保了每次都会从硬件地址实实在在地读取数据。

    我们不应该直接解引用访问内存映射的 I/O 寄存器。

    可能遇到的问题：
    
    1. 编译器优化问题：多次读取同一个寄存器。编译器可能会进行优化，认为第一次读取的值和第二次是一样的，于是省去第二次的实际读取操作，直接使用缓存的值。

    1. 内存访问顺序问题（内存屏障）：CPU 和编译器为了提升效率，可能会打乱指令的执行顺序（Out-of-Order Execution）。

        问题场景：

        1. 向 FIFO 数据寄存器 写入数据 writel(data, FIFO_DATA);

        2. 向 控制寄存器 写入一个启动命令 writel(CMD_START, FIFO_CTRL);
        硬件要求必须先写数据再发命令。

        如果没有屏障，CPU或编译器可能为了效率，先执行步骤2再执行步骤1，导致硬件收到错误的顺序，操作失败。

    1. 字节序问题: 不同的 CPU 架构（如 x86/Little-Endian 和 PowerPC/Big-Endian）和多字节数据在内存中的存储方式（字节序）不同。外围设备也有自己期望的字节序。

        要向一个设备寄存器写入一个32位值 0x12345678。在小端序的 CPU 上，这个值在内存中存储为 78 56 34 12。如果设备期望的是大端序（即希望收到 12 34 56 78），直接解引用写入就会发送错误的数据。

    1. 访问宽度和原子性问题: 对于某些寄存器，32位的写入操作必须是原子的（不可分割的）。

* gnome 远程桌面无法重启后直接登录

    首先需要设置开机自动登录：

    settings -> users -> unlock -> enable atomatic login

    然后需要取消 key ring:

    安装`seahourse`（GNOME 的密码和密钥管理器）: `sudo apt install seahorse`

    进入 seahorse, passwords -> login 右键 -> change password -> 输入当前密码 -> 新密码空白，直接点 continue -> 确认

    此时再重启系统，可直接进入桌面，使用远程 rdp client 连接当前 host，可顺利连接。

    除了这种方法外，还可以为远程桌面创建独立的密钥环，这种方法比较复杂，不研究了。

* makefile 中特殊的自动变量

    这些自动变量主要用于表示目标和先决条件（依赖）。

    * `$@`: 表示规则中的目标文件名。

        在规则`main.o: main.c`中，`$@`的值就是`main.o`

        避免重复书写目标名。如果你想重命名目标，只需修改规则开头即可，命令部分无需改动。

    * `$<`: 表示规则中的 第一个先决条件 的名称。(第一个依赖)

        在规则`main.o: main.c header.h`中，`$<`的值就是`main.c`。

        在编译源文件（.c -> .o）时，我们通常只需要将源文件（.c）传递给编译器，头文件（.h）是通过 #include 指令包含的，不需要直接出现在编译命令中。$< 完美地提供了这个源文件。

    * `$^`: 表示规则中 所有不重复的先决条件，以空格分隔。（所有依赖）

        在`myapp: main.o utils.o`规则中，`$^`就是`main.o utils.o`。

        在链接生成最终可执行文件时，需要将所有目标文件（.o）都传递给链接器。使用 $^ 可以确保一个不漏。

    * `$?`: 表示所有 比目标更新的先决条件，以空格分隔。（更新的依赖）

        如果`header.h`被修改而`main.c`没有，在重建`main.o`时，`$?`的值就是`header.h`。

        这个变量在某些高级场景下很有用，例如当你需要只对发生变化的文件执行某些特殊操作（比如生成日志）时。在普通的编译命令中较少使用。

    * `$*`: 表示与目标匹配的 茎（即`%`匹配的部分）。常用于隐含规则和模式规则中。（茎，Stem）

        在模式规则`%.o: %.c`中，如果目标是`dir/foo.o`，则`$*`的值就是`dir/foo`。

        可以用来生成与源文件同名但扩展名不同的文件，或者在命令中使用匹配部分的名字。

    * `$+`: 类似于`$^`，但它 包含所有重复的先决条件。

        在规则`main.o: main.c header.h main.c`中，`$^`是`main.c header.h`，而`$+`是`main.c header.h main.c`。

    常用场景：

    * 编译单个源文件：使用`$<`(源文件) 和`$@`(目标文件)。

    * 链接多个目标文件：使用`$^`(所有目标文件) 和`$@`(可执行文件)。

* 字节序转换宏

    ```c
    #include <linux/byteorder/generic.h>

    cpu_to_be16(x)	// CPU字节序 到 大端字节序 (16位)	htobe16(x)
    cpu_to_be32(x)	// CPU字节序 到 大端字节序 (32位)	htobe32(x)
    cpu_to_be64(x)	// CPU字节序 到 大端字节序 (64位)	htobe64(x)
    cpu_to_le16(x)	// CPU字节序 到 小端字节序 (16位)	htole16(x)
    cpu_to_le32(x)	// CPU字节序 到 小端字节序 (32位)	htole32(x)
    cpu_to_le64(x)	// CPU字节序 到 小端字节序 (64位)	htole64(x)
    be16_to_cpu(x)	// 大端字节序 到 CPU字节序 (16位)	be16toh(x)
    be32_to_cpu(x)	// 大端字节序 到 CPU字节序 (32位)	be32toh(x)
    be64_to_cpu(x)	// 大端字节序 到 CPU字节序 (64位)	be64toh(x)
    le16_to_cpu(x)	// 小端字节序 到 CPU字节序 (16位)	le16toh(x)
    le32_to_cpu(x)	// 小端字节序 到 CPU字节序 (32位)	le32toh(x)
    le64_to_cpu(x)	// 小端字节序 到 CPU字节序 (64位)	le64toh(x)
    ```

    `cpu`代表当前 CPU 的字节序（即主机字节序）。