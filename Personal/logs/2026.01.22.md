* python 去重方法总结

    Python 中有多种去重方法，针对你提到的数据类型，需要不同处理方式：

    1. 基础列表去重（可哈希元素）

        ```python
        arr_1 = ['a', 'b', 'c', 'a']

        # 方法1：使用set（无序）
        arr_unique = list(set(arr_1))  # ['a', 'b', 'c'] 顺序可能改变

        # 方法2：保持原始顺序
        arr_unique = []
        for item in arr_1:
            if item not in arr_unique:
                arr_unique.append(item)
        # 或使用字典（Python 3.7+ 保证顺序）
        arr_unique = list(dict.fromkeys(arr_1))  # ['a', 'b', 'c']

        # 方法3：使用sorted排序
        arr_unique = sorted(set(arr_1), key=arr_1.index)  # ['a', 'b', 'c']
        ```

    2. 字典列表去重（不可哈希元素）

        字典是不可哈希的，不能直接用 set()，需要特殊处理：

        ```python
        arr_2 = [{'a': 1, 'b': 2}, {'a': 1, 'b': 2}, {'a': 2, 'b': 3}]

        # 方法1：使用JSON字符串作为中间形式（简单但有限制）
        import json
        def deduplicate_dicts(arr):
            seen = set()
            result = []
            for d in arr:
                # 先排序键保证一致性
                sorted_str = json.dumps(d, sort_keys=True)
                if sorted_str not in seen:
                    seen.add(sorted_str)
                    result.append(d)
            return result

        arr_unique = deduplicate_dicts(arr_2)
        # [{'a': 1, 'b': 2}, {'a': 2, 'b': 3}]

        # 方法2：转换为可哈希的元组
        def deduplicate_dicts_v2(arr):
            seen = set()
            result = []
            for d in arr:
                # 转换为排序后的键值元组
                t = tuple(sorted(d.items()))
                if t not in seen:
                    seen.add(t)
                    result.append(d)
            return result

        # 方法3：使用Pandas（大数据集更高效）
        import pandas as pd
        df = pd.DataFrame(arr_2)
        df_unique = df.drop_duplicates().to_dict('records')
        ```

    3. 使用工具函数

        ```python
        from typing import List, Any, Hashable
        import json

        def unique(sequence, keep_order=True):
            """
            通用去重函数
            """
            if not sequence:
                return []
            
            # 如果元素可哈希
            try:
                if keep_order:
                    return list(dict.fromkeys(sequence))
                else:
                    return list(set(sequence))
            except TypeError:
                # 处理不可哈希元素（如字典）
                if keep_order:
                    seen = set()
                    result = []
                    for item in sequence:
                        if isinstance(item, dict):
                            # 字典转换为可哈希的字符串
                            key = json.dumps(item, sort_keys=True)
                        else:
                            key = str(item)  # 其他不可哈希类型
                        
                        if key not in seen:
                            seen.add(key)
                            result.append(item)
                    return result
                else:
                    # 不保持顺序
                    unique_dicts = {}
                    for item in sequence:
                        key = json.dumps(item, sort_keys=True)
                        unique_dicts[key] = item
                    return list(unique_dicts.values())

        # 使用示例
        print(unique(arr_1))  # ['a', 'b', 'c']
        print(unique(arr_2))  # [{'a': 1, 'b': 2}, {'a': 2, 'b': 3}]
        ```

    4. 性能比较和建议

        | 方法 | 优点 | 缺点 | 适用场景 |
        | - | - | - | - |
        | set() | 速度快，简洁 | 不保持顺序 | 简单列表，不关心顺序 |
        | dict.fromkeys() | 保持顺序，较快 | 只适用于可哈希元素 | 需要保持顺序的简单列表 |
        | 手动循环检查 | 灵活可控 | 速度较慢 | 小数据集，复杂逻辑 |
        | JSON转换 | 处理复杂类型 | JSON限制（如不能序列化所有类型） | 字典列表去重 |

        推荐做法：

        * 简单列表：list(dict.fromkeys(arr))（保持顺序）

        * 字典列表：使用元组转换或JSON字符串方法

        * 大数据集：考虑使用Pandas

    注意事项：

    * 字典去重要注意键的顺序问题

    * 嵌套字典需要递归处理

    * 自定义对象需要实现 __hash__ 和 __eq__ 方法

* py 中的`f.write()`接受变参数吗，可以写入多个 str 吗

    f.write() 不接受变参数，它只能接受一个字符串参数。但你可以通过多种方式写入多个字符串：

    1. 基本用法（一次一个字符串）

        ```python
        with open('test.txt', 'w') as f:
            f.write("Hello ")      # 一次写入一个字符串
            f.write("World")       # 再次写入
            f.write("\n")          # 写入换行符
        # 文件内容: Hello World\n
        ```

    2. 实现写入多个字符串的方法

        方法1：使用字符串拼接

        ```python
        with open('test.txt', 'w') as f:
            f.write("Hello " + "World" + "!")  # 拼接后再写入
        # 或
        strings = ["Hello", " ", "World", "!"]
        with open('test.txt', 'w') as f:
            f.write(''.join(strings))  # 使用join拼接
        ```

        方法2：使用 writelines() 方法

        ```python
        with open('test.txt', 'w') as f:
            f.writelines(["Hello ", "World", "!\n"])
        # 注意：writelines不会自动添加换行符
        ```

        方法3：使用 print() 函数

        ```python
        with open('test.txt', 'w') as f:
            print("Hello", "World", sep=" ", file=f)  # sep控制分隔符
            # 相当于 f.write("Hello World")
        ```

        方法4：自定义包装函数

        ```python
        def write_many(f, *args, sep="", end="\n"):
            """模拟支持多个参数的write函数"""
            content = sep.join(str(arg) for arg in args) + end
            f.write(content)

        with open('test.txt', 'w') as f:
            write_many(f, "Hello", "World", "!")  # HelloWorld!\n
            write_many(f, "Line", 2, sep=" ")     # Line 2\n
        ```

    3. 性能考虑

        ```python
        import time

        # 测试不同方法的性能
        def test_performance():
            test_data = ["str" + str(i) for i in range(10000)]
            
            # 方法1：多次 write
            start = time.time()
            with open('test1.txt', 'w') as f:
                for s in test_data:
                    f.write(s)
            time1 = time.time() - start
            
            # 方法2：一次性写入
            start = time.time()
            with open('test2.txt', 'w') as f:
                f.write(''.join(test_data))
            time2 = time.time() - start
            
            print(f"多次write: {time1:.4f}秒")
            print(f"一次性写入: {time2:.4f}秒")
            # 通常一次性写入更快，因为减少了I/O操作次数
        ```

    4. 实际应用示例

        ```python
        # 日志写入
        def write_log(filename, *messages, level="INFO", timestamp=True):
            import datetime
            with open(filename, 'a') as f:
                if timestamp:
                    timestamp_str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    f.write(f"[{timestamp_str}] [{level}] ")
                
                # 拼接所有消息
                full_message = ' '.join(str(msg) for msg in messages)
                f.write(full_message + "\n")

        # 使用
        write_log("app.log", "User", "John", "logged in", "successfully")
        # 文件内容: [2024-01-22 10:30:00] [INFO] User John logged in successfully
        ```

    5. 类型安全建议

        ```python
        def safe_write(f, *args, sep="", end="\n"):
            """安全写入，自动处理类型转换"""
            try:
                # 将所有参数转换为字符串
                str_args = (str(arg) for arg in args)
                content = sep.join(str_args) + end
                f.write(content)
            except Exception as e:
                print(f"写入失败: {e}")

        with open('output.txt', 'w') as f:
            safe_write(f, "Number:", 42, "List:", [1, 2, 3], sep=" ")
            # 输出: Number: 42 List: [1, 2, 3]\n
        ```

    总结

    | 方法 | 优点 | 缺点 | 适用场景 |
    | - | - | - | - |
    | f.write(str) | 标准方法，直接 | 只接受一个参数 | 简单写入 |
    | 字符串拼接 | 灵活控制格式 | 需要手动拼接 | 格式复杂的写入 |
    | f.writelines() | 可传入列表 | 不自动加分隔符 | 批量写入字符串列表 |
    | print() | 自动加换行，支持多个参数 | 输出格式固定 | 类似控制台输出的格式 |
    | 自定义函数 | 完全自定义行为 | 需要额外代码 | 特定业务需求 |

    推荐做法：

    * 如果需要写入多个字符串，先使用 join() 拼接

    * 如果格式类似 print()，直接使用 print(..., file=f)

    * 如果需要频繁写入，考虑批量处理减少I/O操作

    * 对于特定需求，封装自己的写入函数

    记住：Python 的 write() 设计简单是为了保持函数单一职责原则，更复杂的写入逻辑应该由调用者处理。

* vim 替换中的`\zs`和`&`

    \zs - 设置匹配开始位置

    作用：在匹配模式中标记“真正匹配开始的位置”，前面的部分只作为匹配条件但不被替换。

    示例：

    ```vim
    :%s/\d\+\zs\.\d\+/,/
    ```

    * 匹配模式：\d\+\.\d\+（如 123.456）

    * \zs 前的 \d\+ 只是匹配条件

    * 实际替换的是 \zs 后的 \.\d\+

    * 结果：123,456（只替换小数点后的 .456 为 ,456）

    另一个例子：

    ```vim
    :%s/\w\+\zs\s\+//g
    ```

    * 删除每个单词后的空格，但保留单词本身

    & - 引用匹配的整个文本

    作用：在替换部分引用整个匹配的模式。

    示例：

    ```vim
    :%s/\w\+/[&]/g
    ```

    * 把每个单词用方括号括起来

    * hello world → [hello] [world]

    ```vim
    :%s/\d\+/&%/g
    ```

    * 在每个数字后加百分号

    * 123 test 456 → 123% test 456%

    组合使用示例

    ```vim
    :%s/\d\+\zs\.\d\+/&0/g
    ```

    * 匹配：数字.数字

    * \zs 前只作为条件

    * & 引用匹配部分（.数字）

    * 结果：给小数点后的数字加 0

    * 12.3 → 12.30

    这两个标记让 Vim 的替换更加灵活精确，可以精确控制匹配和替换的范围。

* Vim 替换命令中其他有用的标记

    **替换部分特殊标记**

    1. \1, \2, ... \9 - 引用捕获组

        ```vim
        :%s/\(\w\+\) \(\w\+\)/\2 \1/g
        " 交换两个单词的位置
        " hello world → world hello

        :%s/\(\d\+\)-\(\d\+\)/\2.\1/g
        " 交换用连字符分隔的数字
        " 123-456 → 456.123
        ```

    2. \0 - 引用整个匹配（与 & 相同）

        ```vim
        :%s/\w\+/item: \0/g
        " 每个单词前加 "item: "
        ```

    3. ~ - 使用上次替换的字符串

        ```vim
        " 第一次替换：
        :%s/foo/bar/g
        " 第二次替换可以使用 ~ 代表 "bar"：
        :%s/baz/~/g  " 实际替换为 baz → bar
        ```

    模式部分的特殊标记

    4. \ze - 设置匹配结束位置（与 \zs 对应）

        ```vim
        :%s/foo\zebar/BAR/g
        " 匹配 "foobar"，但实际匹配结束在 foo 后
        " 只替换 "foo"，不替换 "bar"
        " foobar → BARbar
        ```

    5. \zs 和 \ze 组合使用

        ```vim
        :%s/\w\+\zs\d\+\ze\w\+/###/g
        " 匹配：单词+数字+单词，但只替换数字部分
        " abc123def → abc###def
        ```

    6. \@<= - 正向回顾（positive lookbehind）

        ```vim
        :%s/\(\w\)\@<=x/X/g
        " 替换前面是单词字符的 x
        " axb cxd → aXb cXd
        " 但 xyz 中的 x 不变（前面不是单词字符）
        ```

    7. `\@<!` - 负向回顾（negative lookbehind）

        ```vim
        :%s/\(\d\)\@<!\./点/g
        " 替换前面不是数字的点
        " a.b → a点b
        " 但 1.5 中的 . 不变（前面是数字）
        ```

    8. \@= - 正向预览（positive lookahead）

        ```vim
        :%s/foo\(bar\)\@=/FOO/g
        " 替换后面是 bar 的 foo
        " foobar → FOObar
        " foobaz 不变
        ```

    9. \@! - 负向预览（negative lookahead）

        ```vim
        :%s/foo\(bar\)\@!/FOO/g
        " 替换后面不是 bar 的 foo
        " foobaz → FOObar
        " foobar 不变
        ```

    替换标志（flags）

    10. \c 和 \C - 忽略/区分大小写

        ```vim
        :%s/foo\c/bar/g  " 忽略大小写，匹配 foo, FOO, Foo 等
        :%s/foo\C/bar/g  " 区分大小写，只匹配 foo
        ```

    11. \v - 使用非常魔法模式

        ```vim
        :%s/\v(\w+)\s+(\w+)/\2 \1/g
        " 不需要转义括号
        " 对比：%s/\(\w\+\)\s\+\(\w\+\)/\2 \1/g
        ```

    12. \V - 使用原义模式

        ```vim
        :%s/\Va.b/a.b/g
        " 点就是字面意义的点，不是正则的 .
        " 匹配 "a.b" 而不是 "a任意字符b"
        ```

    其他有用标记

    13. \e - 结束替换字符串

        ```vim
        :%s/foo/\=toupper(submatch(0))\e bar/g
        " \e 后面的 " bar" 是普通文本
        " 结果：在匹配的 foo 转为大写后加 " bar"
        " foo → FOO bar
        ```

    14. \U, \L, \E - 大小写转换

        ```vim
        :%s/foo/\U&/g      " foo → FOO
        :%s/FOO/\L&/g      " FOO → foo
        :%s/foo\w*/\U&\Ebar/g  " \U 开始，\E 结束
        " foobar → FOOBARbar
        ```

    15. \u, \l - 转换下一个字符大小写

        ```vim
        :%s/foo/\u&/g      " foo → Foo
        :%s/FOO/\l&/g      " FOO → fOO
        ```

    替换中使用表达式 \=

    16. \= - 使用 Vim 脚本表达式

        ```vim
        :%s/\d\+/\=(submatch(0)*2)/g
        " 所有数字乘以 2

        :%s/\w\+/\=toupper(submatch(0))/g
        " 所有单词转大写

        :%s/.*/\=printf("%03d", submatch(0))/g
        " 格式化为 3 位数字
        ```

    实用组合示例

    ```vim
    " 1. 在每行行首添加行号
    :%s/^/\=printf("%3d: ", line('.'))/

    " 2. 将下划线命名转为驼峰
    :%s/_\(\w\)/\u\1/g

    " 3. 提取 email 用户名
    :%s/^\(\w\+\)@.*$/\1/

    " 4. 智能缩进调整
    :%s/^\(\s*\)/\=repeat(' ', len(submatch(1)) + 4)/

    " 5. 转义 HTML 特殊字符
    :%s/[&<>"]/\={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[submatch(0)]/g
    ```

    掌握这些标记可以让你在 Vim 中进行非常强大和灵活的文本处理！

* vim 中，s 前的百分号是什么意思

    在 Vim 中，:%s 前面的 % 表示在整个文件中执行替换，即对所有行进行操作。

    % 的含义

    % 是 Vim 中的一个范围符号，代表整个文件或当前缓冲区。

    ```vim
    :%s/pattern/replacement/g
    " 在整个文件中进行替换
    ```

    其他常用范围符号

    1. % - 整个文件

        ```vim
        :%s/foo/bar/g     " 替换文件中所有 foo
        ```

    2. 行号范围

        ```vim
        :10,20s/foo/bar/g  " 只在第10-20行替换
        :1,$s/foo/bar/g    " 从第1行到最后一行（同 %）
        :.s/foo/bar/g      " 只在当前行替换
        ```

    3. 'm - 标记位置

        ```vim
        :'a,'bs/foo/bar/g  " 在标记 a 到标记 b 之间替换
        ```

    4. 模式匹配范围

        ```vim
        :/^Start/,/^End/s/foo/bar/g
        " 从匹配 "Start" 的行到匹配 "End" 的行
        ```

    5. . - 当前行

        ```vim
        :.s/foo/bar/g      " 仅当前行
        :.,+5s/foo/bar/g   " 当前行及后面5行
        ```

    6. $ - 最后一行

        ```vim
        :.,$s/foo/bar/g    " 从当前行到最后一行
        ```

    实用示例对比

    ```vim
    " 不同范围的替换示例
    :%s/old/new/g        " 整个文件
    :1,50s/old/new/g     " 第1-50行
    :/begin/,/end/s/o/n/g # 从包含"begin"到包含"end"的行
    :'<,'>s/old/new/g    " 在可视模式选中的行（自动生成）
    :.,+3s/old/new/g     " 当前行及后面3行
    ```

    如果省略 % 会怎样？

    如果只写 :s 而不指定范围：

    ```vim
    :s/foo/bar/g
    ```

    这只会在当前行进行替换，不是整个文件！

    记忆技巧

    * % 像 "百分百" → 100% 的行都要处理

    * % 也像 "全部" (All) 的意思

    * :%s 是全局替换的标准写法

    所以你的例子：

    ```vim
    :%s/\d\+\zs\.\d\+/,/
    ```

    会在整个文件中查找匹配 \d\+\.\d\+（数字.数字）的模式，但只替换 \zs 之后的部分（即 .数字 部分），将其替换为 ,（保持 \zs 前的数字不变）。

* vim 替换命令的基本结构

    `:s/pattern/replace/flags`

* vim 替换中的 normal 模式

    * 配合 `:global` 命令: `g/pattern/normal I*`

        含义：在所有匹配到 pattern 的行上，执行“在行首插入星号”的操作。

        效果：这常用于批量给某些行加注释或列表标记。

    * 在替换式中使用表达式: `s/pattern/\=.../`，这属于高级用法。例如： :%s/pattern/\=execute('normal I*')/n

        含义：找到匹配项后，不直接通过替换文本来修改，而是调用 execute 函数去触发一段普通模式指令。

* `git config -f .gitmodules --list`

    读取并列出当前项目中 .gitmodules 文件的所有配置项。

    各参数含义：

    * git config - Git 配置管理命令

    * -f .gitmodules - --file .gitmodules 的简写

        * 指定从 .gitmodules 文件（而不是全局或本地配置）读取配置

    * --list - 列出所有配置项

    查看特定子模块的URL:

    `git config -f .gitmodules --get submodule.libs/foo.url`

    与其他配置的区别

    * git config --list - 列出所有配置（系统+全局+本地）

    * git config -f .gitmodules --list - 仅列出.gitmodules文件中的配置

* matlab `min()`, `max()`

    原型

    单输出：

    ```matlab
    M = min(A)          % 返回数组的最小元素
    M = min(A, [], dim) % 沿维度dim返回最小值
    ```

    多输出（获取值和位置）：

    ```matlab
    [M, I] = min(A)          % 同时返回最小值及其索引
    [M, I] = min(A, [], dim) % 沿维度dim返回最小值和索引
    ```

    元素级比较：

    ```matlab
    C = min(A, B)  % 返回A和B逐元素比较的较小值
    ```

    主要功能

    * 查找最小值：返回数组中的最小元素

    * 沿指定维度查找：可指定操作维度

    * 元素级比较：比较两个数组的对应元素

    * 获取索引：可同时返回最小值的位置

    基本用法示例

    ```matlab
    % 1. 向量最小值
    A = [3, 1, 4, 1, 5];
    min_val = min(A)  % 返回 1

    % 2. 同时获取值和索引
    [val, idx] = min(A)  % val=1, idx=2（第一个最小值的位置）

    % 3. 矩阵每列最小值
    B = [3, 7, 1; 2, 9, 5];
    col_min = min(B)  % 返回 [2, 7, 1]

    % 4. 沿指定维度
    row_min = min(B, [], 2)  % 每行最小值： [1; 2]

    % 5. 元素级比较
    C = [4, 2, 6];
    D = [1, 5, 3];
    result = min(C, D)  % 返回 [1, 2, 3]
    ```

    注意事项

    * 默认情况下，对于矩阵，min(A)返回每列的最小值

    * 忽略NaN值（除非所有元素都是NaN）

    * 可处理复数（按幅值比较）

    * max()用法完全相同，只是查找最大值

    * `[]`是占位的，无实际意义

        MATLAB 中许多函数使用相同的占位符模式：

        * sum(A, dim) ✓ 不需要占位符（没有两个数组相加的歧义）

        * min(A, [], dim) ✓ 需要占位符

        * max(A, [], dim) ✓ 需要占位符

        * mean(A, dim) ✓ 不需要占位符

    max()函数具有完全相同的语法和选项，只是功能相反（查找最大值）。
