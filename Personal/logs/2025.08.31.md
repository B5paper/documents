* qemu 中`-serial mon:stdio`

    `-serial` 选项用来指定串口输出的重定向目标，比如 file:xxx、pty、stdio 等。

    `mon` 表示 QEMU Monitor。

    `stdio` 表示把输入输出绑定到 当前终端的标准输入输出。

    `mon:stdio`表示将虚拟机的串口和 qemu monitor 的输入输出，都绑定到`stdio`。

    如果不写`mon`，只写`stdio`，那么按快捷键`Ctrl + A`，`C`，将不会出现 qemu monitor。（未验证）

    如果只写`mon`，不写`stdio`，那么输出如下：

    ```
    QEMU 6.2.0 monitor - type 'help' for more information
    (qemu) qemu-system-x86_64: -serial mon: 'mon' is not a valid char driver
    qemu-system-x86_64: -serial mon: could not connect serial device to character backend 'mon'
    ```

    如果使用`-nographic -serial stdio -monitor none`启动 qemu，那么无法使用 ssh 登陆。不清楚原因。

    这个命令的意思是`-serial stdio -monitor stdio`，但是不能这么写，会报错，因为`stdio`是一种独占资源，不能被分配两次。`-serial mon:stdio`则是多路复用形式的重定向，所以没问题。

* qemu 中，先按`Ctrl + A`，再按`C`，可以切换到 qemu 后台（即 qemu monitor），如下：

    ```
    SeaBIOS (version 1.15.0-1)


    iPXE (https://ipxe.org) 00:03.0 CA00 PCI2.10 PnP PMM+BFF8B420+BFECB420 CA00
                                                                                   


    Booting from Hard Disk...
    QEMU 6.2.0 monitor - type 'help' for more information
    (qemu) 
    ```

    前面的`(qemu)` prompt 标志着已经进入了 qemu 后台，此时可以执行一些后台指令，比如`info registers`。

    qemu monitor 不是虚拟机的一部分，是 qemu 监视和管理虚拟机的后台程序。

* `sync()`

    将内核缓冲区中所有未写入磁盘的数据（包括文件数据、元数据如inode等）立即写入到硬盘。

    syntax:

    ```c
    #include <unistd.h>

    void sync(void);
    ```

    `sync()`调用本身是异步的。它只是启动写入操作，不会等待所有数据实际写完才返回。

    sync() 会立即触发一个流程，通知内核将所有脏页（被修改过但未写入磁盘的缓冲区内容）排队写入磁盘。它作用于整个系统，刷新所有内核缓冲区，而不仅仅是调用它的那个进程的缓冲区。

* `sync`

    `sync`可以作为一个命令使用，效果和调用`sync()`相同。

* `spin_lock()`

    一种用于实现互斥（Mutual Exclusion）的同步原语。它是一种忙等待锁（Busy-Wait Lock），其核心特征在于：当一个线程尝试获取一个已被占用的锁时，它不会进入睡眠状态，而是会在一个循环中不断地“旋转”（Spinning），反复检查锁是否被释放，直到成功获取锁为止。

    syntax:

    ```c
    #include <linux/spinlock.h>

    void spin_lock(spinlock_t *lock);
    ```

    如果锁已被占用，函数不会返回，当前CPU核会在此自旋，直到成功获取锁。

    自旋锁设计的初衷是保护执行时间极短的临界区。它可以在中断上下文（Interrupt Context）中使用，而睡眠锁（如Mutex）绝对不可以，因为中断上下文中不允许调度（睡眠）。

    这里的中断上下文指的是中断处理程序 (ISR)、软中断 (softirq)、tasklet、工作队列（上半部）。

    example:

    ```c
    #include <linux/spinlock.h>

    spinlock_t my_lock;
    DEFINE_SPINLOCK(my_lock);  // 编译时静态初始化

    void my_func() {
        // spinlock_t my_lock;
        // spin_lock_init(&my_lock);  // 运行时动态初始化
        spin_lock(spinlock_t *lock);
        // critical area
        spin_unlock(spinlock_t *lock);
    }
    ```

    在持有自旋锁的同时再次请求获取同一个自旋锁（递归加锁），这会导致该CPU核永久自旋，系统卡死。

* 为什么中断上下文不能睡眠？

    1. 没有进程概念：中断上下文不属于任何进程。它只是“借道”执行，打断了当前正在运行的进程。如果它睡眠了，调度器不知道该唤醒哪个进程来继续执行它，因为它没有 struct task_struct 关联。这会导致系统彻底崩溃。

    2. 破坏原子性：中断是异步到来的，期望被快速处理。睡眠可能导致中断处理流程被无限期挂起，使得设备无法及时响应，其他中断也可能无法处理。

    3. 可能导致死锁：假设中断发生时，某个内核锁正被持有。如果中断处理程序尝试获取另一个锁，而这个操作又可能导致睡眠，那么系统就会死锁。持有锁的进程正在等待中断处理完成，而中断处理又在等待锁被释放。

* `timeout`

    如果计时器超时, ，timeout 会向子命令进程发送一个信号（默认是 TERM 信号），强制终止它, 并返回一个特定的退出状态码（默认为124）

    syntax:

    ```
    timeout [OPTIONS] DURATION COMMAND [ARG]...
    ```

    * DURATION：时间长度。这是必须指定的参数。它可以是一个整数，也可以是带单位的数字（例如 10s 表示10秒，2m 表示2分钟，1h 表示1小时）。如果只是数字，默认单位是秒。

    * COMMAND [ARG]...：你想要运行的实际命令及其参数。

    常用选项（OPTIONS）：

    * -s, --signal=SIGNAL：指定超时后要发送的信号。默认是 TERM (15)。

        例如，如果程序忽略 TERM 信号，你可以使用 -s KILL 来发送 KILL (9) 信号，强制杀死进程。

        查看所有信号：kill -l

    * -k, --kill-after=DURATION：双重保险。先发送 -s 指定的信号（默认TERM），如果再过 DURATION 时间后进程仍然存在，则发送 KILL 信号确保其被杀死。

    * --preserve-status：让 timeout 返回被它控制的命令的退出状态码。如果命令超时被杀死，仍然返回124。

    example:

    ```bash
    timeout 5s ping example.com
    timeout -s KILL 2m some-unstable-script.sh
    timeout -k 5s 10s some-command
    ```

    在脚本中使用并检查退出状态：

    ```bash
    #!/bin/bash
    timeout 30s long-running-task.sh

    case $? in
      0)  echo "Task completed successfully." ;;
      124) echo "Task timed out and was killed." ;;
      137) echo "Task was killed by a signal (e.g., KILL)." ;; # 如果用了 -s KILL，会返回137 (128+9)
      *)  echo "Task failed with exit code: $?" ;;
    esac
    ```

