* 不要忽略题目的暴力写法

    暴力写法是基础。

    在写出暴力写法的基础上，再去分析改进。这样的技能才是通用的。

* c++ 中 template 无法和`typeid()`合用

    ```cpp
    template<typename T, typename...Args>
    void _set_args(OclKern &kern, T arg, Args...args)
    {
        if (typeid(arg) == typeid(const char*) ||
            typeid(arg) == typeid(char*) ||
            typeid(arg) == typeid(string))
        {
            OclBuf &buf = global_ocl_env->bufs.at(arg);
            kern.sa(buf);
        }
        else
        {
            kern.sa(arg);
        }
        _set_args(kern, args...);
    }
    ```

    比如这段代码，在编译时期就会出错。编译器不走 if, else 分支，只看类型是否匹配。

    应该改成这样的：

    ```cpp
    template<typename T, typename...Args>
    enable_if_t<is_same_v<T, const char*>, void>
    _set_args(OclKern &kern, T arg, Args...args)
    {
        OclBuf &buf = global_ocl_env->bufs.at(arg);
        kern.sa(buf);
        _set_args(kern, args...);
    }

    template<typename T, typename...Args>
    enable_if_t<!is_same_v<T, const char*>, void>
    _set_args(OclKern &kern, T arg, Args...args)
    {
        kern.sa(arg);
        _set_args(kern, args...);
    }
    ```

    这样在编译时期就能走对应的通路。

    (这个功能叫什么？它和模板函数的重载，特化，有什么不同？可以不使用模板实现吗？)

    注意这个模板函数只匹配了`const char*`这一种类型，如果未来有`string`，`char*`等类型，还需要用`conjunction_v<>`等命令去匹配。

* `remove_const_t<>`作用于指针时，移除的是指针的`const`

    example:

    `remove_const_t<const char *const>`，移除的其实是第二个`const`。