* vertex based + pointer + vertex id, implement

    ```cpp
    #include <string>
    #include <stdio.h>
    #include <iostream>
    #include <vector>
    #include <unordered_map>
    using namespace std;

    struct Vertex
    {
        int id;
        vector<Vertex*> edges;
    };

    struct Graph
    {
        vector<Vertex*> verts;

        Vertex* add_vert() {
            Vertex *vert_ptr = new Vertex;
            // by default the id of vert is the same with idx
            vert_ptr->id = verts.size();
            verts.push_back(vert_ptr);
            return vert_ptr;
        }

        // id 必须存在，这一点由用户保证
        void del_vert(int id) {
            Vertex *vert_for_del = NULL;
            int idx_for_del = -1;
            for (int i = 0; i < verts.size(); ++i) {
                if (verts[i]->id == id) {
                    vert_for_del = verts[i];
                    idx_for_del = i;
                    break;
                }
            }

            for (int i = 0; i < verts.size(); ++i) {
                Vertex *vert = verts[i];
                vector<Vertex*> new_edges;
                int num_edges = verts[i]->edges.size();
                for (int j = 0; j < num_edges; ++j) {
                    if (vert->edges[j]->id != id) {
                        new_edges.push_back(vert->edges[j]);
                    }
                }
                vert->edges = move(new_edges);
            }

            decltype(paths) new_paths;
            for (auto &path : paths) {
                if (path.first.first == vert_for_del ||
                    path.first.second == vert_for_del) {
                    continue;
                }
                new_paths.insert(path);
            }
            paths = new_paths;

            verts.erase(verts.begin() + idx_for_del);
        }

        void add_edge(int vert_id, int nex_vert_id) {
            for (int i = 0; i < verts.size(); ++i) {
                if (verts[i]->id != vert_id) {
                    continue;
                }
                for (int j = 0; j < verts.size(); ++j) {
                    if (verts[j]->id == nex_vert_id) {
                        verts[i]->edges.push_back(verts[j]);
                        break;
                    }
                }
                break;
            }
        }

        // 边是没有顺序的，因此不能使用 int vert_idx 来删除边
        // 通过 Vertex *nex_vert 也可以唯一地定位到边，但是用户无法通过
        // 指针来定位，因此也不能使用 Vertex *nex_vert
        // 剩下的就只有使用 int nex_vert_id 了
        void del_edge(int vert_id, int nex_vert_id) {
            Vertex *vert = NULL;
            for (int i = 0; i < verts.size(); ++i) {
                if (verts[i]->id == vert_id) {
                    vert = verts[i];
                }
            }
            for (int i = 0; i < vert->edges.size(); ++i) {
                if (vert->edges[i]->id == nex_vert_id) {
                    vert->edges.erase(vert->edges.begin() + i);
                    break;
                }
            }
        }

        ~Graph() {
            for (Vertex *vert_ptr : verts) {
                delete vert_ptr;
            }
        }

        struct VertexPtrHash {
            size_t operator()(const pair<Vertex*, Vertex*> &src_dst) const
            {
                return hash<void*>()(src_dst.first) ^ hash<void*>()(src_dst.second);
            }
        };

        // <<src, dst>, path>
        unordered_map<pair<Vertex*, Vertex*>, vector<Vertex*>, VertexPtrHash> paths;
        int search_path_bfs(vector<Vertex*> **path_ptr, Vertex *src_vert, Vertex *dst_vert) {
            auto iter = paths.find({src_vert, dst_vert});
            if (iter != paths.end()) {
                *path_ptr = &iter->second;
                return 0;
            }
            vector<Vertex*> vert_queue_cur, vert_queue_nex;
            vert_queue_cur.push_back(src_vert);
            while (!vert_queue_cur.empty()) {
                for (int i = 0; i < vert_queue_cur.size(); ++i) {
                    Vertex *cur_vert = vert_queue_cur[i];
                    for (int j = 0; j < cur_vert->edges.size(); ++j) {
                        Vertex *nex_vert = cur_vert->edges[j];
                        if (paths.find({src_vert, nex_vert}) != paths.end())
                            continue;
                        vector<Vertex*> &path_src_to_cur = paths[{src_vert, cur_vert}];
                        vector<Vertex*> &path_src_to_nex = paths[{src_vert, nex_vert}];
                        path_src_to_nex = path_src_to_cur;
                        path_src_to_nex.push_back(nex_vert);
                        if (nex_vert == dst_vert) {
                            *path_ptr = &path_src_to_nex;
                            return 0;
                        }
                        vert_queue_nex.push_back(nex_vert);
                    }
                }
                vert_queue_cur = vert_queue_nex;
                vert_queue_nex.clear();
            }
            *path_ptr = nullptr;
            return -1;
        }

        void print() {
            if (verts.empty()) {
                printf("(empty)\n");
                return;
            }

            for (int i = 0; i < verts.size(); ++i) {
                printf("vert %d -> ", verts[i]->id);
                for (int j = 0; j < verts[i]->edges.size(); ++j) {
                    printf("%d, ", verts[i]->edges[j]->id);
                }
                putchar('\n');
            }
        }
    };

    int main()
    {
        Graph graph;

        for (int i = 0; i < 7; ++i) {
            graph.add_vert();
        }
        graph.verts[0]->edges.push_back(graph.verts[1]);
        graph.verts[0]->edges.push_back(graph.verts[2]);
        graph.verts[0]->edges.push_back(graph.verts[3]);
        graph.verts[1]->edges.push_back(graph.verts[2]);
        graph.verts[1]->edges.push_back(graph.verts[4]);
        graph.verts[2]->edges.push_back(graph.verts[5]);
        graph.verts[3]->edges.push_back(graph.verts[5]);
        graph.verts[4]->edges.push_back(graph.verts[5]);
        graph.verts[5]->edges.push_back(graph.verts[6]);

        Vertex *src_vert = graph.verts[0];
        Vertex *dst_vert = graph.verts[6];
        vector<Vertex*> *path_ptr;
        int ret = graph.search_path_bfs(&path_ptr, src_vert, dst_vert);
        if (ret != 0) {
            printf("fail to find a path\n");
            return -1;
        }

        vector<Vertex*> &path = *path_ptr;
        printf("%d", src_vert->id);
        for (int i = 0; i < path.size(); ++i) {
            printf(" -> %d", path[i]->id);
        }
        putchar('\n');
        putchar('\n');

        graph.print();
        putchar('\n');

        int num_verts = graph.verts.size();
        for (int i = 0; i < num_verts; ++i) {
            graph.del_vert(i);
        }
        
        graph.print();

        return 0;
    }
    ```

    output:

    ```
    0 -> 2 -> 5 -> 6

    vert 0 -> 1, 2, 3, 
    vert 1 -> 2, 4, 
    vert 2 -> 5, 
    vert 3 -> 5, 
    vert 4 -> 5, 
    vert 5 -> 6, 
    vert 6 -> 

    (empty)
    ```

    可以看到，使用 vertex id 后，输出对人类比较友好了。

    下面是一些细节说明：

    * `Vertex *vert_ptr = new Vertex;`

        vert 的内存是手动分配，而 vert 的指针交给 vector，这样保证了不会因为 vector 的自动扩容而导致 vert 的地址变化。

        由于 va 和进程是强绑定的，所以跨进程、通过网络传输时，需要额外的序列化和反序列化。

    * `vert_ptr->id = verts.size();`

        默认使用和索引一样的 id，这表示对 add vertex 的顺序是有要求的。

        由于每次都是按 size 分配 id，如果先删了几个，又增添几个 vert，那么 id 就比较混乱了。

    * 通过线性查找找到 id，

        ```cpp
        Vertex *vert_for_del = NULL;
        int idx_for_del = -1;
        for (int i = 0; i < verts.size(); ++i) {
            if (verts[i]->id == id) {
                vert_for_del = verts[i];
                idx_for_del = i;
                break;
            }
        }
        ```

        `vert_for_del`留着后面给 del path 的时候用。其实后面的 path 也可以使用`path.first.first->id == id`, `path.first.second->id == id`来判断，效果一样的。

        `idx_for_del`留着后面给`verts.erase(verts.begin() + idx_for_del);`时使用。

        这一段也可以改成

        ```cpp
        void del_vert(int id) {
            for (int i = 0; i < verts.size(); ++i) {
                if (verts[i]->id == id) {
                    verts.erase(verts.begin() + i);
                    break;
                }
            }

            for (int i = 0; i < verts.size(); ++i) {
                Vertex *vert = verts[i];
                vector<Vertex*> new_edges;
                int num_edges = verts[i]->edges.size();
                for (int j = 0; j < num_edges; ++j) {
                    if (vert->edges[j]->id != id) {
                        new_edges.push_back(vert->edges[j]);
                    }
                }
                vert->edges = move(new_edges);
            }

            decltype(paths) new_paths;
            for (auto &path : paths) {
                if (path.first.first->id == id ||
                    path.first.second->id == id) {
                    continue;
                }
                new_paths.insert(path);
            }
            paths = new_paths;
        }
        ```

        反正都是线性搜索，使用 id 和使用 ptr 区别不大。

    * `vector<Vertex*> new_edges;`

        连续删除 vector 中的元素比较麻烦，这里采用将有效数据放到一个新的 vector 里，最后再使用新 vector 取代旧 vector 的方式。

        由于 add_vert, del_vert 都是不频繁的操作，所以这个方式还算 ok。

    * `vert->edges = move(new_edges);`

        交换数据时，只需要交换 payload 指针就可以了。不知道使用 move 会不会快一点。

    * `void add_edge(int vert_id, int nex_vert_id)`

        verts 内部存储的是指针，但是用户在操作时，只需要提供 vert id，这样用户只要操作正确的 id，就能得到正确的结果，不需要关心 ptr。

        这样看来`Vertex* add_vert()`应该同时返回 vert ptr 和 vert id 比较好。

    * `void del_edge(int vert_id, int nex_vert_id)`

        当删除节点时，要删除所有与其关联的 edge 和 path。删除 edge 也同理，我们需要删除所有与之关联的 path。显然这里没有做到这一点。

    整个代码中使用了大量的线性查找，效率很低，构建一个 pointer -> id 的查找表是一个不可忽视的需求。