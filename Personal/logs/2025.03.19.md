* linux 删除自己编译的 kernel

    比如自己编译了`6.2.16`的内核，并且已经成功安装，现在要删除这个内核。

    1. 首先切换到其他内核上，确保当前正在用的内核不是要删除的内核

        check: `uname -r`, output: `6.8.0-52-generic`

    1. 到`/boot`目录下，输入`ls`

        output:

        ```
        config-5.19.0-50-generic      memtest86+_multiboot.bin
        config-6.2.16                 System.map-5.19.0-50-generic
        config-6.2.16.old             System.map-6.2.16
        config-6.8.0-52-generic       System.map-6.2.16.old
        efi                           System.map-6.8.0-52-generic
        grub                          vmlinuz
        initrd.img                    vmlinuz-5.19.0-50-generic
        initrd.img-5.19.0-50-generic  vmlinuz-6.2.16
        initrd.img-6.2.16             vmlinuz-6.2.16.old
        initrd.img-6.8.0-52-generic   vmlinuz-6.8.0-52-generic
        memtest86+.bin                vmlinuz.old
        memtest86+.elf
        ```

        删除三个文件：

        `rm vmlinuz-6.2.16 initrd.img-6.2.16 config-6.2.16 System.map-6.2.16`

    1. 进入`/lib/modules`，执行`ls`

        output:

        ```
        5.19.0-50-generic  6.5.0-44-generic  6.8.0-47-generic  6.8.0-52-generic
        6.2.16             6.8.0-40-generic  6.8.0-49-generic
        6.5.0-18-generic   6.8.0-45-generic  6.8.0-51-generic
        ```

        删除`6.2.16`文件夹：
        
        `rm -rf 6.2.16`

    1. 更新`grub`：`sudo update-grub`

        此时`grub`会自动重新搜索`/boot`中的可用内核，删除不存在的内核对应的菜单入口

    1. （可选）进入`/usr/src`，执行`ls`：

        output:

        ```
        linux-headers-5.19.0-50-generic   linux-source-6.2.0
        linux-headers-6.8.0-52-generic    linux-source-6.2.0.tar.bz2
        linux-hwe-5.19-headers-5.19.0-50  nvidia-530.30.02
        linux-hwe-6.8-headers-6.8.0-52
        ```

        如果要清空编译的结果，可以执行：

        ```bash
        cd linux-source-6.2.0
        make clean
        ```

        如果要彻底删除所有源代码，可以直接删除源代码目录：

        `rm -rf linux-source-6.2.0`

    ref: <https://www.cyberciti.biz/faq/debian-redhat-linux-delete-kernel-command/>

* `virt-sparsify`有可能会用到 root 权限，看 log 似乎会扫描 host 上的`/boot`目录下的 kernel 文件，并做一个复制操作。

* `virt-sparsify`的使用

    `virt-sparsify --tmp <tmp_dir_path> ./old_disk_img.qcow2 ./new_disk_img.qcow2`

    `virt-sparsify`在运行过程中，需要一个和原 disk img 差不多大的 tmp 空间保存临时数据，我们可以使用`--tmp`参数将 tmp 文件保存到指定的目录下。这个 tmp 文件的文件名是随机生成的，不用担心产生文件覆盖，因此也可以把 tmp 目录设置为当前目录。

    如果磁盘空间不够用，可以使用`--inplace`参数，这样不会产生 tmp 文件。

* qemu 使用`-kernel`指定内核启动虚拟机

    `qemu-system-x86_64 -accel kvm -m 4096 -smp 4 -hda ./ubuntu22.04-for-pci.qcow2 -kernel /boot/vmlinuz-6.2.16 -initrd /boot/initrd.img-6.2.16 -append "root=/dev/sda3"`

    说明：

    * `-hda ./ubuntu22.04-for-pci.qcow2`表示加入磁盘，但是进入操作系统后，具体的磁盘设备不一定是`/dev/hda`，也有可能是`/dev/sda`，对应的分区为`/dev/sda0`，`/dev/sda1`，`/dev/sda2`，...。

    * `-kernel /boot/vmlinuz-6.2.16`表示使用 host 上的`/boot/vmlinuz-6.2.16`内核。
    
        看网上介绍说这个内核是使用 gzip 压缩过的，未压缩的版本应该是 vmlinux。不清楚具体是怎么压缩的。

        这个参数也可以替换为
        
        `-kernel /usr/src/linux-source-6.2.0/arch/x86/boot/bzImage`
        
        或者
        
        `-kernel /usr/src/linux-source-6.2.0/arch/x86/boot/compressed/vmlinux.bin`

    * `-initrd /boot/initrd.img-6.2.16`是可选参数，可以不写。

        据说是因为`-hda`中有了 initrd，所以才不需要指定`-initrd`，具体情况不太清楚。

    * `-append "root=/dev/sda3"`：`-append`表示添加 linux kernel command line，`root=`表示将磁盘的哪个分区挂载到`/`目录上。

    * 6.2.16 的 kernel 在 guest 中启动后，systemd 会读取`/etc`，`/usr/lib`等目录下的配置，继续 load module，比如`autofs4`等。因此 guest 的`/lib/modules`中也必须有编译好的`6.2.16`目录，用来加载这些额外的 module。

        否则 systemd 会报错找不到 module，guest 系统会进入 emergency 模式。

* 一个调研任务本身只是个调研，那么它是否需要区分 P, O, x, v 等状态？

* c++ 对新 struct 进行初始化时，允许使用`.xxx = vvv`的方式，但是必须按照成员的顺序，不能乱序

    examples:

    * 不写`.xxx`进行初始化

        ```cpp

        ```

    * 使用`.xxx`进行初始化

        ```cpp

        ```

    * 使用`.xxx`选择性地初始化

        ```cpp

        ```

    * 乱序（out of order）初始化，报错

        ```cpp

        ```

* 没办法写成笔记的东西

    * 寻找解决问题的灵感或对未知未来探索的过程

        “探索”的过程不可写，首先写出来就会失去灵性，既受限于文字，也失去了“虚”的感觉；其次写下来的思考速度会变慢，书面表达的思考速度太慢了。

        但是已经探索明白的，可能会形成方案的思路可以记录下来，作为一个待调研的思路。

    * 临时的记录、中间步骤、中间猜想与中间结论

        这种比较适合写到 tmp 中。比如记录一下目前的函数调用嵌套了多少层，要搜索的字符串的 start pos，某个对象的指针的值等。

        其实写到 tmp 中也会拖慢思考速度，这种最适合的就是在脑子中临时记住。

* nccl 中 xml 的内存申请

    nccl 中与 xml 相关的 struct 如下：

    ```cpp
    struct ncclXmlNode {
        char name[MAX_STR_LEN+1];
        struct {
            char key[MAX_STR_LEN+1];
            char value[MAX_STR_LEN+1];
        } attrs[MAX_ATTR_COUNT+1];  // Need an extra one to consume extra params
        int nAttrs;
        int type;
        struct ncclXmlNode* parent;
        struct ncclXmlNode* subs[MAX_SUBS];
        int nSubs;
    };

    struct ncclXml {
        int maxIndex, maxNodes;
        struct ncclXmlNode nodes[1];
    };
    ```

    可以看到`ncclXml`里记录了`maxNodes`，即`nodes`数组的最大长度，`maxIndex`即目前`nodes`的实际长度，而`nodes`数组其实是实际子 nodes 的起始地址。

    `struct ncclXmlNode nodes[1];`这样的写法，是想既申请一个节点，作为 xml 的 root node，又可以将`nodes`作为指针，增加偏移指向 child nodes。

    下面是 nccl 里内存申请相关的函数：

    ```cpp
    static size_t xmlMemSize(int maxNodes) {
      return offsetof(struct ncclXml, nodes) + sizeof(struct ncclXmlNode)*maxNodes;
    }

    static ncclResult_t xmlAlloc(struct ncclXml** xml, int maxNodes) {
      char* mem;
      NCCLCHECK(ncclCalloc(&mem, xmlMemSize(maxNodes)));
      *xml = (struct ncclXml*)mem;
      (*xml)->maxNodes = maxNodes;
      return ncclSuccess;
    }
    ```

    可以看到，`xmlMemSize()`在计算 size 时，`offsetof(struct ncclXml, nodes)`计算的是 header 部分，`sizeof(struct ncclXmlNode)*maxNodes`统计的是 child nodes 所占的 size。

    这样的写法，有点像：

    ```c
    struct MyXml
    {
        header member var 1;
        header member var 2;
        header member var 3;
        ...
        root node 0;
        ----------------------
        child node 1;
        child node 2;
        child node 3;
        ...
    };
    ```

    这样即可将一个大小可动态变化的 struct 写成静态的第 1 部分和动态的第 2 部分。

    是否有 feedback？未想到。
