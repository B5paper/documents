* linux socket programming

    `server.c`:

    ```c
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <string.h>
    #include <stdio.h>
    #include <unistd.h>

    int main()
    {
        int serv_fd = socket(AF_INET, SOCK_STREAM, 0);
        if (serv_fd < 0)
        {
            printf("fail to create server sock fd\n");
            return -1;
        }
        printf("[OK] create server socket fd: %d\n", serv_fd);

        uint16_t listen_port = 6543;
        uint32_t listen_addr_ipv4 = INADDR_ANY;
        char ipv4_addr[16] = {0};
        const char *ret_ptr = inet_ntop(AF_INET, &listen_addr_ipv4, ipv4_addr, 16);
        if (ret_ptr == NULL)
        {
            printf("fail to convert u32 to ipv4 str\n");
            return -1;
        }

        struct sockaddr_in serv_addr;
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = listen_addr_ipv4;
        serv_addr.sin_port = htons(listen_port);
        int ret = bind(serv_fd, (struct sockaddr*) &serv_addr, sizeof(serv_addr));
        if (ret < 0)
        {
            printf("fail to bind serv fd %d, ret: %d\n", serv_fd, ret);
            return -1;
        }
        printf("[OK] bind fd %d to addr %s: %u\n", serv_fd, ipv4_addr, listen_port);

        ret = listen(serv_fd, 5);
        if (ret < 0)
        {
            printf("fail to listen\n");
            return -1;
        }
        printf("[OK] start to listen...\n");

        struct sockaddr_in cli_addr;
        socklen_t cli_addr_len = sizeof(cli_addr);
        int cli_fd = accept(serv_fd, (struct sockaddr*) &cli_addr, &cli_addr_len);
        if (cli_fd < 0)
        {
            printf("fail to accept, ret: %d\n", cli_fd);
            return -1;
        }
        printf("[OK] accept 1 incoming client.\n");

        ret_ptr = inet_ntop(AF_INET, &cli_addr.sin_addr.s_addr, ipv4_addr, 16);
        if (ret_ptr == NULL)
        {
            printf("fail to convert u32 ipv4 to string\n");
            return -1;
        }
        printf("\tincoming client: ip: %s, port: %u\n", ipv4_addr, cli_addr.sin_port);

        char *buf = "hello from server";
        size_t buf_len = strlen(buf) + 1;
        ssize_t bytes_send = send(cli_fd, buf, buf_len, 0);
        if (bytes_send != buf_len)
        {
            printf("fail to send, buf_len: %lu, bytes_send: %ld\n", buf_len, bytes_send);
            return -1;
        }
        printf("[OK] send buf: %s\n", buf);

        ret = shutdown(cli_fd, SHUT_RDWR);
        if (ret != 0)
        {
            printf("fail to shutdown client fd %d, ret: %d\n", cli_fd, ret);
            return -1;
        }
        printf("[OK] shutdown client fd %d.\n", cli_fd);

        ret = close(cli_fd);
        if (ret != 0)
        {
            printf("fail to close fd %d\n", cli_fd);
            return -1;
        }
        printf("[OK] close fd %d.\n", cli_fd);

        ret = shutdown(serv_fd, SHUT_RDWR);
        if (ret != 0)
        {
            printf("fail to shutdown server fd %d, ret: %d\n", serv_fd, ret);
            return -1;
        }
        printf("[OK] shutdown server fd %d.\n", serv_fd);

        ret = close(serv_fd);
        if (ret != 0)
        {
            printf("fail to close fd %d\n", serv_fd);
            return -1;
        }
        printf("[OK] close fd %d.\n", serv_fd);

        return 0;
    }
    ```

    `client.c`:

    ```c
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <string.h>
    #include <stdio.h>
    #include <unistd.h>

    int main()
    {
        int cli_fd = socket(AF_INET, SOCK_STREAM, 0);
        if (cli_fd < 0)
        {
            printf("fail to create client sock fd\n");
            return -1;
        }
        printf("[OK] create client socket fd: %d\n", cli_fd);

        uint16_t serv_port = 6543;
        const char serv_ipv4[16] = "127.0.0.1";
        struct in_addr ipv4_addr;
        int ret = inet_pton(AF_INET, serv_ipv4, &ipv4_addr);
        if (ret != 1)
        {
            printf("fail to convert ipv4 string to u32, ret: %d\n", ret);
            return -1;
        }

        struct sockaddr_in serv_addr;
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr = ipv4_addr;
        serv_addr.sin_port = htons(serv_port);
        ret = connect(cli_fd, (struct sockaddr*) &serv_addr, sizeof(serv_addr));
        if (ret != 0)
        {
            printf("fail to connect to server, ret: %d\n", ret);
            return -1;
        }
        printf("[OK] connect to server %s: %u\n", serv_ipv4, serv_port);

        char buf[20] = {0};
        size_t buf_len = 20;
        ssize_t bytes_recv = recv(cli_fd, buf, buf_len, 0);
        if (bytes_recv <= 0)
        {
            printf("fail to recv, buf_len: %lu, bytes_recv: %ld\n", buf_len, bytes_recv);
            return -1;
        }
        printf("[OK] recv buf: %s\n", buf);

        ret = shutdown(cli_fd, SHUT_RDWR);
        if (ret != 0)
        {
            printf("fail to shutdown fd %d, ret: %d\n", cli_fd, ret);
            return -1;
        }
        printf("[OK] shutdown fd %d.\n", cli_fd);

        ret = close(cli_fd);
        if (ret != 0)
        {
            printf("fail to close fd %d, ret: %d\n", cli_fd, ret);
            return -1;
        }
        printf("[OK] close fd %d.\n", cli_fd);

        return 0;
    }
    ```

    `Makefile`:

    ```makefile
    all: server client

    server: server.c
        gcc -g server.c -o server

    client: client.c
        gcc -g client.c -o client

    clean:
        rm -f server client
    ```

    compile: `make`

    run:

    `./server`

    `./client`

    output:

    * server end

        ```
        [OK] create server socket fd: 3
        [OK] bind fd 3 to addr 0.0.0.0: 6543
        [OK] start to listen...
        [OK] accept 1 incoming client.
            incoming client: ip: 127.0.0.1, port: 61611
        [OK] send buf: hello from server
        [OK] shutdown client fd 4.
        [OK] close fd 4.
        [OK] shutdown server fd 3.
        [OK] close fd 3.
        ```

    * client end

        ```
        [OK] create client socket fd: 3
        [OK] connect to server 127.0.0.1: 6543
        [OK] recv buf: hello from server
        [OK] shutdown fd 3.
        [OK] close fd 3.
        ```

    说明：

    * `sys/socket.h`文件中主要包含下面几个函数：`socket()`, `bind()`, `connect()`, `send()`, `recv()`, `listen()`, `accept()`, `shutdown()`

        这些函数组成了 socket 的基本功能。

        这里的 socket 并不完全是为 internet 设计的，有一些 unix domain 或者其他的 socket 也会用到这个库。

    * 如果有 Internet 相关的需要，还需要添加头文件`#include <arpa/inet.h>`

        宏`INADDR_ANY`，`htons()`, `inet_ntop()`等函数都包含在这个头文件内。

    * `shutdown()`和`close()`并不能使刚 bind ipv4 addr 的 fd 重新 bind 相同的 ipv4 addr。

    * `inet_pton()`第三个参数注意填的是长度的指针，不是长度的值

* leetcode problem

    * 1926. 迷宫中离入口最近的出口

        给你一个 m x n 的迷宫矩阵 maze （下标从 0 开始），矩阵中有空格子（用 '.' 表示）和墙（用 '+' 表示）。同时给你迷宫的入口 entrance ，用 entrance = [entrancerow, entrancecol] 表示你一开始所在格子的行和列。

        每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 entrance 最近 的出口。出口 的含义是 maze 边界 上的 空格子。entrance 格子 不算 出口。

        请你返回从 entrance 到最近出口的最短路径的 步数 ，如果不存在这样的路径，请你返回 -1 。

        

        示例 1：


        输入：maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
        输出：1
        解释：总共有 3 个出口，分别位于 (1,0)，(0,2) 和 (2,3) 。
        一开始，你在入口格子 (1,2) 处。
        - 你可以往左移动 2 步到达 (1,0) 。
        - 你可以往上移动 1 步到达 (0,2) 。
        从入口处没法到达 (2,3) 。
        所以，最近的出口是 (0,2) ，距离为 1 步。
        示例 2：


        输入：maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
        输出：2
        解释：迷宫中只有 1 个出口，在 (1,2) 处。
        (1,0) 不算出口，因为它是入口格子。
        初始时，你在入口与格子 (1,0) 处。
        - 你可以往右移动 2 步到达 (1,2) 处。
        所以，最近的出口为 (1,2) ，距离为 2 步。
        示例 3：


        输入：maze = [[".","+"]], entrance = [0,0]
        输出：-1
        解释：这个迷宫中没有出口。
        

        提示：

        maze.length == m
        maze[i].length == n
        1 <= m, n <= 100
        maze[i][j] 要么是 '.' ，要么是 '+' 。
        entrance.length == 2
        0 <= entrancerow < m
        0 <= entrancecol < n
        entrance 一定是空格子。


        代码：

        1. bfs

            ```cpp
            class Solution {
            public:
                int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
                    int num_row = maze.size();
                    int num_col = maze[0].size();
                    queue<pair<int, int>> q;
                    q.push({entrance[0], entrance[1]});
                    maze[entrance[0]][entrance[1]] = '-';
                    int dx[] = {-1, 0, 0, 1};
                    int dy[] = {0, -1, 1, 0};
                    int ans = 0;
                    while (!q.empty())
                    {
                        int que_size = q.size();
                        for (int i = 0; i < que_size; ++i)
                        {
                            int rx = q.front().first;
                            int ry = q.front().second;
                            q.pop();

                            if (rx == 0 || rx == num_row - 1 || ry == 0 || ry == num_col - 1)
                            {
                                if (ans != 0)
                                    return ans;
                            }

                            for (int j = 0; j < 4; ++j)
                            {
                                int x = rx + dx[j];
                                int y = ry + dy[j];
                                if (x < 0 || x >= num_row || y < 0 || y >= num_col)
                                    continue;
                                if (maze[x][y] == '+' || maze[x][y] == '-')
                                    continue;
                                q.push({x, y});
                                maze[x][y] = '-';
                            }
                        }
                        ans++;
                    }
                    return -1;
                }
            };
            ```

            说明：

            1. 可以直接用`{}`构造一个 pair 对象，写起来比`make_pair()`方便一些

            2. `{dx, dy} = {{-1, 0}, {0, 1}, {0, -1}, {1, 0}}`无法被两个 for 替代：

                ```cpp
                for (int dx = -1; dx <= 1; ++dx)
                {
                    for (int dy = -1; dy <= 1; ++dy)
                    {
                        // ...
                    }
                }
                ```

                这两种逻辑明显不等价

            3. 在写 bfs 时，因为是一轮一轮地往外走，所以需要`que_size`记录当前队列的长度，每一轮只处理`que_size`个队列中的数据

            4. 如果不使用`que_size`来一轮一轮地处理数据，那么必须在 queue 的 item 上额外加一个数据来记录状态信息，比如`{x, y, dist}`

            5. 由于 bfs 每次只往外扩散一步，所以只要到达出口，就一定是最短的，不需要担心叉路口

            6. 搜索过的地方要记录一下，防止重复搜索

            7. 矩阵的两种索引方式，一种是 ij 计算行数列数，一种是 xy 计算横坐标，纵坐标。目前看来使用`row`, `col`配合`ij`比较靠谱