* [v] reorg: documents 30 mins

    14:43 ~ 14:59

    feedback:

    * [asso] 调研 qemu edu driver 将寄存器`mmap()`到用户态，使用 polling 的方式代替中断

    * [ ] reorg: linux programming 30 mins

    * [asso] 写一套文件操作 API，分别使用文件函数和 mmap 函数打开文件，实现功能如下：

        1. 从指定位置开始，读指定字节的数据，若字节数为 <= 0，则读取所有数据

        1. 实现一个 generator，每调用一次读一行，文件的最后一行如果只有 EOF 没有 \n，那么也算一行。如果 \n 后紧接 EOF，那么算同一行

        1. 实现一个函数，将指定字节处（从 0 开始索引）的字节替换成指定字节

    * [asso] 调研文件编辑器如何实现插入/删除功能？

    * [ ] `remap_pfn_range()`

* [v] reorg: projects 30 mins

    15:22 ~15:28

    feedback:

    * [ ] 调研下面的写法，没有使用`const char *`，是否说明数据存在栈中，而不是字面常量中

        ```c
        const char conds[16][3] =
        {
          "eq", "ne", "cs", "cc",
          "mi", "pl", "vs", "vc",
          "hi", "ls", "ge", "lt",
          "gt", "le", "al", ""
        };
        ```

    * [ ] rocm 分为几个模块，阅读源码该从哪开始入手？

    * [ ] `ROCm/ROCgdb/gas/testsuite/gas/arm/maverick.c`是干嘛用的？

        里面似乎有许多指令集的排列组合。

* [v] qa: 2 units 30 mins

    15:32 ~ 15:38

    feedback:

    * [ ] terminal 是否可以显示数学公式，如果不能那么调研当检测到 unit 中有数学公式时，调用外部程序显示 unit 内容，保证数学公式可以正常显示

        现状：对于有数学公式的 qa，terminal 无法正常显示。

* [v] process 1 tab

    15:40 ~ 15:49

    feedback:

    * [ ] 调研 Differences between torch.nn and torch.nn.functional

        <https://www.geeksforgeeks.org/deep-learning/differences-between-torch-nn-and-torch-nn-functional/>

    * [ ] 调研 PyTorch Loss Functions

        <https://www.geeksforgeeks.org/deep-learning/pytorch-loss-functions/>

    * [ ] 调研 How to Implement Various Optimization Algorithms in Pytorch?

        <https://www.geeksforgeeks.org/machine-learning/how-to-implement-various-optimization-algorithms-in-pytorch/>

    * [ ] 调研 PyTorch Tutorial

        <https://www.geeksforgeeks.org/deep-learning/pytorch-learn-with-examples/>

    * [asso] 调研 6.12.2 Extended Asm - Assembler Instructions with C Expression Operands

        <https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>

    * [ ] reorg: 正则表达式 30 mins

    * [ ] `qemu-system-x86_64 -enable-kvm -device pci-bridge,id=mybridge -device e1000,bus=mybridge,addr=0x1`

    * [ ] `pci_find_bus()`

    * [ ] `pci_alloc_dev()`

    * [ ] 调研 ds 写的添加虚拟 pci 设备的代码（未验证）

        ```c
        // 文件名: vpci_device.c
        #include <linux/module.h>
        #include <linux/pci.h>
        #include <linux/device.h>

        // 定义虚拟 PCI 设备的 Vendor ID 和 Device ID
        #define VENDOR_ID 0x1234
        #define DEVICE_ID 0x5678

        static struct pci_dev *vpdev = NULL;

        static int __init vpci_init(void) {
            struct pci_bus *bus;
            int ret = -ENODEV;

            // 获取第一个 PCI 总线 (例如: 0000:00)
            bus = pci_find_bus(0, 0); 
            if (!bus) {
                printk(KERN_ERR "无法找到 PCI 总线\n");
                return ret;
            }

            // 动态分配一个 pci_dev 结构体
            vpdev = pci_alloc_dev(bus);
            if (!vpdev) {
                printk(KERN_ERR "无法分配 PCI 设备\n");
                return -ENOMEM;
            }

            // 设置设备基本信息
            vpdev->vendor = VENDOR_ID;     // 厂商 ID
            vpdev->device = DEVICE_ID;     // 设备 ID
            vpdev->devfn = PCI_DEVFN(0, 0); // 设备号 (Bus 0, Device 0)
            vpdev->class = PCI_CLASS_NETWORK_ETHERNET; // 设备类别 (示例: 网络设备)

            // 初始化设备并添加到 PCI 子系统
            pci_bus_add_device(vpdev);
            ret = pci_add_device(vpdev);
            if (ret < 0) {
                printk(KERN_ERR "无法添加 PCI 设备\n");
                pci_free_dev(vpdev);
                return ret;
            }

            printk(KERN_INFO "虚拟 PCI 设备已创建: %04x:%04x\n", VENDOR_ID, DEVICE_ID);
            return 0;
        }

        static void __exit vpci_exit(void) {
            if (vpdev) {
                pci_stop_and_remove_bus_device(vpdev); // 从总线移除设备
                pci_free_dev(vpdev);                   // 释放设备内存
                printk(KERN_INFO "虚拟 PCI 设备已移除\n");
            }
        }

        module_init(vpci_init);
        module_exit(vpci_exit);
        MODULE_LICENSE("GPL");
        ```

        若需要设备支持完整的配置空间操作（如 BAR 映射、中断等），需扩展模块代码：

        ```c
        // 在 vpci_init 中补充资源配置
        vpdev->resource[0].start = 0x1000;  // BAR0 起始地址 (虚拟)
        vpdev->resource[0].end = 0x1FFF;    // BAR0 结束地址
        vpdev->resource[0].flags = IORESOURCE_MEM; // 内存资源类型

        // 启用设备
        pci_enable_device(vpdev);
        ```

* [v] 调研 cuda 向量加的 example

    16:08 ~ 16:21

    feedback:

    * [ ] 有时候本地装有 vim 的插件，但是远程 ssh 机器上没装，而且远程 ssh 机器不能随便安装软件，比如不能`sudo apt install ctags`，那么该如何解决这个问题？或者如何将本地 vim 套件应用到远程 host 的代码编辑上？

    * [ ] 调研目前哪些常用算法是使用 cuda 实现的，并给出代码实现的 example

    * [ ] `cudaMallocHost()`, `cudaFreeHost()`

    * [ ] 为什么可以手动指定`threadsPerBlock`？其意义在哪里？

        ```cpp
        // 定义线程块数量和每个线程块中的线程数
        int threadsPerBlock = 256;
        int blocksPerGrid = (numElements + threadsPerBlock - 1) / threadsPerBlock; // 向上取整

        // 启动内核
        vectorAdd<<<blocksPerGrid, threadsPerBlock>>>(d_A, d_B, d_C, numElements);
        ```

* [v] 调研傅里叶变换，尝试对 sin 曲线进行傅里叶变换

    16:44 ~ 17:56

* [v] 任务模板中增加`qa: review`

    18:52 ~ 18:54

* [v] makefile 中的`?=`

    ~ 19:03

* [v] `OBJS = $(SRCS:.c=.o)`

    ~ 19:37

* [v] 调研`df -T /dev/shm`

    19:38 ~ 19:49

    `sudo mount -t tmpfs -o size=2G tmpfs /dev/shm`

    feedback:

    * [asso] 调研`/etc/fstab`的格式

* [v] 调研给 frpc 增加密码

    19:50 ~ 20:06

    feedback:

    * [asso] 调研 bash 技巧

        ```bash
        set +o history  # 禁用历史记录
        # 敏感操作
        set -o history  # 重新启用
        ```

* [ ] 调研 <https://www.geeksforgeeks.org/deep-learning/pytorch-learn-with-examples/>

    目前看到

    > Optimizing Model Training with PyTorch Datasets

* [ ] `optim.SGD`数学公式是什么？代码如何实现？

* [ ] 调研 rnn

    example 代码，尝试跑通

* [ ] 调研 IMDb 电影评论数据集 30 mins

    情感二分类，正面或负面

    res: <http://ai.stanford.edu/~amaas/data/sentiment/>

* [ ] 调研矩阵论 30 mins

* [ ] 调研`watch "ps -aux | grep v2ray"`为什么没输出

    `watch bash -c "ps -aux | grep v2ray"`为什么也没输出

* [ ] `/proc/iomem`

* [ ] 什么是基址寄存器（BARs）

* [ ] `vector<unique_ptr>`为什么 vscode + gdb 调试时不能鼠标悬停显示内容？ 

* [ ] vscode 如何同时滚动左右两个分栏？