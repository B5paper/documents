1. [v] cache tabs 15 mins

    10:30 ~ 10:47

2. [v] qa 4 个 30 mins

    10:51 ~ 11:16

    feedback:

    1. vulkan 增加 qa
    
        解释`vkGetPhysicalDeviceMemoryProperties()`得到的信息的含义。

    2. 整理 opengl qa 文件夹

3. [v] 整理 vulkan 笔记和任务列表 30 mins

    11:39 ~ 12:15

4. [v] 编译器习题 2.1, 2.2 30 mins

    13:46 ~ 14:44

    feedback:

    1. 必须要增加编译器的 qa 了，快忘完了

    2. [ ] 2.1 efg 小题

    3. [ ] 2.2 bc 小题

    4. 一些自己写的答案

        * 2.1 a

            $c^*b^+(c^*a^*b^*)^*a^+(a^*b^*c^*)^*$

        * 2.1 b

            如果以$a$开始，必须以$a$结束：$(a(b^*c^*)^*a)$

            如果不以$a$开始，那么中间字符串可以有上面的模式，也可以没有：$((b^*c^*)^*a(b^*c^*)^*a(b^*c^*)^*)^*$

        * 2.1 c

            4 的倍数要求最后三位是$100$，即$(1^*0^*)^*100$

        * 2.1 d

            情况 1：位数比 6 大，不考虑后面的位：$(1^+0^*)^+(1|0)^6$

            情况2：位数为 6，则对于`101001`从左往右各个位情况如下：

            1. 这位必须为 1

            2. 这位可以是 0 可以是 1

            3. 如果前面一位是 1，这位可为 0 可为 1；如果前面一位是 0，这位必为 1

            4. 可为 0 可为 1

            5. 0 或 1

            6. 若前面为 1，这里 0 或 1 都可以；若前面为 0 ，这里 0 或 1 都不可以

            由 5 和 6 联合推导出，第 5 位必为 1，第 6 位可为 0 可为 1

            由此得到：$1(1(1 | 0) | 01)(0 | 1)(1(0 | 1))$

            感觉这个不太对，还得再改改。因为如果前几位已经可以确定大小，后面的位数就可以不考虑了。

        * 2.2 a

            a 比 b 多的情况有无限种，所以无法匹配。

5. [v] 编译器学习图 2-3，解释，背会 30 mins

    14:45 ~ 15:28

    feedback:

    cached tasks:

    1. [ ] 研究图 2-2，图 2-3 到图 2-4 的转换，尝试自己推导

    2. [ ] 图 2-5 与识别最长的匹配

6. [v] opencl 继续调研第 5 章

    current process: P181 Vector Data Load and Store Functions

    15:50 ~ 17:34

    feedback:

    1. current progress: P190 Synchronization Functions

7. [v] 测试新版 zengine 的 bug

    17:35 ~ 18:48

8. [v] 做一道图论题

    18:48 ~ 19:36

    feedback:

    1. 做一道 leetcode 题差不多要一个小时