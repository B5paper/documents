* 二甲双胍

    二甲双胍是一种口服的处方降糖药，主要用于治疗2型糖尿病。它是全球最常用、也是最基础的一线降糖药物之一。

    它的核心作用是降低血糖，但作用机制非常独特。

    * 降低肝脏葡萄糖输出（减少“糖原异生”）：

        * 这是它最主要的作用。我们的肝脏在空腹时会自己生产葡萄糖。2型糖尿病患者的肝脏常常会“过度生产”葡萄糖，即使身体并不需要。

        * 二甲双胍能抑制肝脏产生和释放葡萄糖，从源头上减少了进入血液的糖分。

    * 提高身体对胰岛素的敏感性：

        * 2型糖尿病患者通常存在“胰岛素抵抗”，即身体细胞对胰岛素不敏感，导致血糖无法顺利进入细胞被利用。

        * 二甲双胍可以帮助肌肉、脂肪等外周组织更有效地利用胰岛素，从而更好地吸收和利用血液中的葡萄糖。

    * 延缓肠道吸收葡萄糖：

        * 它还能稍微减慢食物中的碳水化合物在肠道里被分解成葡萄糖并吸收入血的速度，有助于平稳餐后血糖。

    除了降糖，还有其他用途吗？

    是的，随着研究的深入，医生们也发现二甲双胍有一些“额外的好处”：

    * 减肥/控制体重：与其他一些可能导致体重增加的降糖药不同，二甲双胍对体重的影响是中性的，甚至对部分患者有轻微的减重效果。

    * 改善血脂：有助于降低“坏胆固醇”（低密度脂蛋白）和甘油三酯。

    * 治疗多囊卵巢综合征（PCOS）：这是二甲双胍一个非常重要的“跨界”应用。PCOS患者通常伴有胰岛素抵抗，服用二甲双胍可以改善胰岛素敏感性，从而帮助调节月经、恢复排卵和降低雄激素水平。

    * 心血管保护：有研究表明，长期服用二甲双胍可以降低糖尿病患者发生心血管并发症（如心脏病、中风）的风险。

    常见的副作用与注意事项

    * 常见副作用（多为胃肠道反应）：

        * 包括恶心、呕吐、腹泻、食欲不振、腹部不适等。

        * 这些反应通常在治疗初期出现，随身体适应会逐渐减轻。

        * 应对方法：随餐服用或餐后立即服用可以大大减轻不适。医生也常会从低剂量开始，逐渐加量。

    * 一个需要警惕的严重副作用（罕见）：

        * 乳酸酸中毒。这是一种非常罕见但严重的并发症。多发于有特定基础疾病的患者，如严重肾功能不全、心力衰竭、严重感染、脱水或大量饮酒的患者。

        * 因此，肝肾功能不全的患者需慎用或禁用。

    * 维生素B12缺乏：

        * 长期服用二甲双胍可能会影响维生素B12的吸收，建议定期监测。

* 曾谨言的高徒

    曾谨言： 指的是我国著名的物理学教授，特别是量子力学领域的泰斗。他编写的《量子力学教程》和《量子力学导论》

    潘建伟：量子通信，量子信息、量子光学和量子引力。世界首颗量子科学实验卫星“墨子号”。

* vim 自动补全

    * 函数内补全局部变量：`Ctrl + n`，或`Ctrl + p`

        此功能 vim 内置。

    * 补全函数名、全局变量等：`Ctrl + x` + `Ctrl + ]`

        ctags 默认不会索引函数内部的局部变量，它主要索引：

        * 函数定义

        * 类/结构体定义

        * 全局变量

        * 宏定义

        * 枚举常量

* vim 打开文件后，跳转到上次关闭时候的位置：

    `` ` + "``：

* qemu edu 使用 polling 方式计算阶乘

    在 bar0 偏移`0x20`处的寄存器的值`val`，如果`val & 0x01 != 0`，即`val`的最低位为 1，那么说明设备在忙计算。如果最低位为 0，那么说明设备计算结束。

    ```c
    // 0x08 (RW)factorial computation
    iowrite32(0x00, base_addr_bar0 + 0x20);
    iowrite32(5, base_addr_bar0 + 0x08);
    int cmp_cnt = 0;
    while (true) {
        val = ioread32(base_addr_bar0 + 0x20);
        if (val & 0x01) {
            pr_info("computing... %d\n", cmp_cnt++);
            continue;
        }
        break;
    }
    val = ioread32(base_addr_bar0 + 0x08);
    pr_info("fac: %d\n", val);
    ```

    output:

    ```
    [  364.548410] computing... 0
    [  364.548427] computing... 1
    [  364.548444] computing... 2
    [  364.548460] computing... 3
    [  364.548476] computing... 4
    [  364.548507] fac: 120
    ```

    注：

    * `iowrite32(0x00, base_addr_bar0 + 0x20);`

        禁用中断。

        如果一开始没有禁用中断，代码也没有正常处理中断，那么 device 会不停上报中断，即使卸载驱动后再重新加载驱动，device 也不会复位，依旧重复上报中断。只有重启 qemu 才能停止。

* qemu edu device 使用中断计算 facorial

    1. enable 中断

        `iowrite32(0x80, base_addr_bar0 + 0x20);`

    2. 读取中断寄存器的状态，每个中断源对应一个 bit，根据 bit 位判断中断源

        `int irq_reg_stat_val = ioread32(base_addr_bar0 + 0x24);`

    3. 读取计算出来的阶乘值

        `int fac_val = ioread32(base_addr_bar0 + 0x08);`

    4. 配置确认中断寄存器，告诉 device 此中断已被处理，防止 device 后续循环发送中断

        `iowrite32(irq_reg_stat_val, base_addr_bar0 + 0x64);`

    完整的 irq handler 如下：

    ```cpp
    irqreturn_t irq_handler(int irq, void *dev_id) {
        pr_info("in irq_handler()...\n");
        if (dev_id != hlc_pci_dev) {
            pr_warn("dev_id != hlc_pci_dev\n");
            return IRQ_NONE;
        }

        int irq_reg_stat_val = ioread32(base_addr_bar0 + 0x24);
        pr_info("reg status: %x\n", irq_reg_stat_val);  // 1

        int fac_val = ioread32(base_addr_bar0 + 0x08);
        pr_info("fac: %d\n", fac_val);

        iowrite32(irq_reg_stat_val, base_addr_bar0 + 0x64);

        pr_info("end of irq handler\n");
        return IRQ_HANDLED;
    }
    ```
    
    output:

    ```
    [ 5085.263385] in irq_handler()...
    [ 5085.263451] reg status: 1
    [ 5085.263471] fac: 120
    [ 5085.263504] end of irq handler
    ```
