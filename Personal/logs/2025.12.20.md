
* git archive（只下载文件，无git历史）

    ```bash
    # 直接下载tar包（最干净，没有.git文件夹）
    curl -L https://github.com/user/repo/archive/refs/tags/v1.0.tar.gz | tar -xz
    # 或者
    wget https://github.com/user/repo/archive/refs/tags/v1.0.tar.gz
    tar -xzf v1.0.tar.gz
    ```

* wget 下载 git repo

    ```bash
    # 方式2： 如果你连 .git 都不想要
    cd myproject/vendor
    wget https://github.com/thirdparty/lib/archive/refs/tags/v1.0.tar.gz
    tar -xzf v1.0.tar.gz
    mv lib-1.0 lib
    ```

    ```bash
    # 直接下载解压到 vendor 目录
    cd vendor
    curl -L <url>/archive/refs/tags/v1.0.tar.gz | tar -xz --strip-components=1
    ```

* 只关心 v1.0, v2.0, v3.0 这三个 commit，对其他的 commit 毫不关心

    * 单仓库多分支切换（如果需要git功能）

        (未测试)

        ```bash
        # 1. 先浅克隆一个版本
        git clone --depth 1 --branch v1.0 https://github.com/user/repo.git
        cd repo

        # 2. 添加其他版本作为远程分支（但只拉取特定提交）
        git remote set-branches origin v2.0 v3.0
        git fetch --depth 1 origin v2.0 v3.0

        # 3. 现在可以切换到不同版本
        git checkout v2.0  # 分离头指针状态
        git checkout v3.0  # 分离头指针状态
        ```

    * 使用 sparse-checkout（Git 2.25+）

        （未测试）

        ```bash
        # 1. 创建空仓库
        mkdir repo-all-versions
        cd repo-all-versions
        git init

        # 2. 添加远程
        git remote add origin https://github.com/user/repo.git

        # 3. 启用 sparse-checkout
        git sparse-checkout init --cone

        # 4. 只拉取特定标签
        for tag in v1.0 v2.0 v3.0; do
            git fetch --depth 1 origin tag $tag
            git checkout tags/$tag -b $tag
        done
        ```

* 创建一个包含三个版本的"快照"分支

    ```bash
    # 1. 浅克隆一个基础版本
    git clone --depth 1 https://github.com/user/repo.git
    cd repo

    # 2. 创建一个新分支
    git checkout -b my-versions

    # 3. 获取所有需要的标签
    git fetch --depth 1 origin tag v1.0
    git fetch --depth 1 origin tag v2.0
    git fetch --depth 1 origin tag v3.0

    # 现在你可以用 checkout 切换，但会进入分离头指针状态
    git checkout v1.0  # 查看v1.0
    git checkout v2.0  # 查看v2.0
    git checkout v3.0  # 查看v3.0
    git checkout my-versions  # 回到你的分支
    ```

    * 精确拉取三个提交

        ```bash
        # 1. 创建空仓库
        mkdir repo && cd repo
        git init

        # 2. 添加远程
        git remote add origin https://github.com/user/repo.git

        # 3. 只拉取这三个标签对应的提交
        git fetch --depth 1 origin tag v1.0
        git fetch --depth 1 origin tag v2.0
        git fetch --depth 1 origin tag v3.0

        # 4. 创建分支并包含这三个提交
        git checkout -b my-versions v3.0
        git merge v2.0  # 这可能会快进，因为v2.0是v3.0的祖先
        git merge v1.0  # 同样会快进
        ```

        验证它们在同一个分支上:

        ```bash
        # 查看标签的提交关系
        git log --oneline --graph --decorate v1.0 v2.0 v3.0

        # 查看某个标签在哪些分支上
        git branch --contains v1.0
        git branch --contains v2.0
        git branch --contains v3.0

        # 查看标签详情
        git show --name-only v1.0
        ```

* 比较版本差异：

    ```bash
    # 比较 v1.0 和 v2.0 的差异
    git diff v1.0..v2.0

    # 查看某个文件的变化
    git diff v1.0..v3.0 -- README.md

    # 查看提交历史
    git log v1.0..v3.0 --oneline
    ```

* 从 20GB 的大仓库中只提取几个特定提交，避免下载全部历史

    * 方法1：使用 git clone --filter=blob:none（Git 2.19+，最佳方案）

        ```bash
        # 部分克隆 - 只下载提交历史，不下载文件内容
        git clone --filter=blob:none --no-checkout https://github.com/user/repo.git
        cd repo

        # 现在只获取你需要的几个提交
        git fetch origin tag v1.0
        git fetch origin tag v2.0
        git fetch origin tag v3.0

        # 切换到某个版本（此时才下载对应的文件）
        git checkout v1.0
        ```

        优点：仓库目录很小，只有元数据，文件内容按需下载。

    * 方法2：使用 git clone --depth + git fetch --deepen

        ```bash
        # 1. 浅克隆v3.0（最新版本）
        git clone --depth 1 --branch v3.0 https://github.com/user/repo.git
        cd repo

        # 2. 逐步获取更早的历史直到包含v1.0
        git fetch --deepen 5  # 再获取5个历史提交
        # 检查是否包含v2.0和v1.0
        git log --oneline --all

        # 3. 如果还不够，继续加深
        git fetch --deepen 10
        ```

    * 方法3：使用 git archive + 手动创建新仓库

        ```bash
        # 1. 为每个版本下载压缩包
        mkdir my-repo && cd my-repo
        wget https://github.com/user/repo/archive/refs/tags/v1.0.tar.gz
        wget https://github.com/user/repo/archive/refs/tags/v2.0.tar.gz
        wget https://github.com/user/repo/archive/refs/tags/v3.0.tar.gz

        # 2. 创建新的git仓库
        git init
        tar -xzf v1.0.tar.gz --strip-components=1
        git add . && git commit -m "v1.0"
        rm -rf *  # 清空目录

        tar -xzf v2.0.tar.gz --strip-components=1
        git add . && git commit -m "v2.0"
        rm -rf *

        tar -xzf v3.0.tar.gz --strip-components=1
        git add . && git commit -m "v3.0"

        # 现在你有一个只有3个提交的新仓库
        ```

    * 方法4：使用 git cherry-pick 创建新分支

        ```bash
        # 1. 克隆最小版本
        git clone --depth 1 --branch v3.0 https://github.com/user/repo.git
        cd repo

        # 2. 获取特定提交的元数据（不下载文件）
        git fetch origin --depth 1 <commit-hash-of-v1.0>
        git fetch origin --depth 1 <commit-hash-of-v2.0>

        # 3. 创建新分支并挑选提交
        git checkout --orphan new-history  # 创建无父提交的新分支
        git cherry-pick <commit-hash-of-v1.0>
        git cherry-pick <commit-hash-of-v2.0>
        git cherry-pick <commit-hash-of-v3.0>

        # 现在 new-history 分支只有3个提交
        ```

    * 如果需要git功能但节省空间

        ```bash
        # 使用部分克隆 + 稀疏检出
        git clone --filter=blob:none --no-checkout https://github.com/user/repo.git
        cd repo

        # 获取需要的标签
        git fetch origin tag v1.0
        git fetch origin tag v2.0
        git fetch origin tag v3.0

        # 创建只有这三个提交的新分支
        git checkout --orphan slim-history
        for tag in v3.0 v2.0 v1.0; do
            git checkout $tag -- .  # 检出该版本的文件
            git commit -m "$tag"
        done
        ```

    * 使用 shallow + unshallow 精确控制

        ```bash
        #!/bin/bash
        # 精确获取三个提交

        # 获取v3.0（最新）
        git clone --depth 1 --branch v3.0 https://github.com/user/repo.git
        cd repo

        # 获取v2.0的提交（比v3.0早）
        git fetch origin v2.0 --depth 1

        # 获取v1.0的提交（比v2.0早）
        git fetch origin v1.0 --depth 1

        # 创建线性历史
        git checkout --orphan compressed-history
        for commit in $(git log --reverse --format="%H" --all); do
            git checkout $commit -- .
            git add -A
            git commit -m "版本 $(git describe --tags $commit 2>/dev/null || echo $commit)"
        done
        ```

* 如果遇到问题

    * 问题2：本地已存在同名分支

        ```bash
        # 如果本地已有 branch_local，想重新关联
        git checkout branch_local
        git branch --set-upstream-to=origin/branch_B
        git pull
        ```

    * 问题3：想要删除旧的本地分支重新开始

        ```bash
        # 切换到其他分支
        git checkout branch_A

        # 删除本地分支
        git branch -D branch_local

        # 重新创建并追踪
        git checkout -b branch_local origin/branch_B
        ```

* 验证操作结果

    ```bash
    # 查看所有分支及追踪关系
    git branch -avv

    # 查看当前分支追踪的远程分支
    git rev-parse --abbrev-ref @{upstream}

    # 查看远程分支的最近提交
    git log --oneline origin/branch_B
    ```

* 查看当前的追踪关系

    ```bash
    # 查看所有分支的追踪情况
    git branch -vv

    # 查看特定分支的追踪信息
    git rev-parse --abbrev-ref <branch_name>@{upstream}

    # 或简写
    git rev-parse --abbrev-ref @{u}
    ```

* 如果推送被拒绝的情况

    如果远程已存在同名分支，需要强制推送（谨慎使用）：

    ```bash
    git push -f origin <branch_name>
    ```

    或者先拉取远程分支再推送：

    ```bash
    # 如果远程已有同名分支，先拉取
    git pull origin <branch_name>
    # 解决可能的冲突后
    git push origin <branch_name>
    ```

* 查看远程 repo 信息

    ```bash
    # 查看所有远程分支
    git branch -r

    # 查看所有分支（本地和远程）
    git branch -a

    # 查看远程仓库信息
    git remote show origin
    ```

* 可以通过 git remote show origin 查看远程分支信息

* 同时指定分支和标签

    ```bash
    git clone -b <tag_name> <repository_url>
    ```

    这会将标签视为分支的起点（会进入分离头指针（Detached HEAD）状态）。

    example:

    ```bash
    git clone -b v1.0.0 https://github.com/user/repo.git
    ```

    这里发生的是：

    * Git 找到标签 v1.0.0 对应的提

    * 将代码克隆到本地

    * 直接检出到那个提交，而不是检出到一个分支

    * 你处于"分离头指针"状态

* git adverse

    If you want to create a new branch to retain commits you create, you may
    do so (now or later) by using -c with the switch command. Example:

    git switch -c <new-branch-name>

    Or undo this operation with:

    git switch -


    (base) hlc@Ubuntu2204:~/Documents/Projects/git_test/a$ git push
    fatal: The current branch b_2 has no upstream branch.
    To push the current branch and set the remote as upstream, use

        git push --set-upstream origin b_2
