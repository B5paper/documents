* git clone 时，指定 branch

    有以下几种方式：

    * 使用 -b 或 --branch 参数（最常用）

        ```bash
        git clone -b <branch_name> <repository_url>
        ```

        example:

        ```bash
        git clone -b develop https://github.com/user/repo.git
        ```

        这个命令等价于执行了以下操作：

        1. 将远程仓库的**所有数据**拉取到本地

            即`git fetch`

        2. 在本地创建一个 branch `<branch_name>`，内容与远程 branch `<branch_name>`相同，名字也相同

            `git branch <branch_name> origin/<branch_name>`

        3. 切换到刚创建的 branch

            `git switch <branch_name>`

        4. 设置 tracking 关系

            `git branch --set-upstream-to=origin/<branch_name>`

    * 使用`-b`结合`--single-branch`

        只拉取**指定分支**内容，不拉取其他分支。

        `git clone -b <branch> --single-branch <repo_url>`

* 在本地新建了一个 branch，但是远程仓库没有这个 branch，如何把这个 branch 推到远程仓库

    * 推送，并建立追踪关系（最常用）

        ```bash
        git push -u origin <remote_branch_name>
        # 等价于
        # git push --set-upstream origin <remote_branch_name>
        ```

    * 方法二：只推送，不建立追踪

        ```bash
        git push origin <branch_name>
        ```

    * 方法三：推送并重命名远程分支名

        ```bash
        git push origin <local_branch>:<remote_branch>
        ```

* 修改本地 branch 追踪的远程 branch

    * 使用 git branch --set-upstream-to（推荐）

        ```bash
        git branch --set-upstream-to=origin/<remote_branch> [local_branch]
        ```

    * 使用 git push -u 重新建立追踪

        ```bash
        git push -u origin <remote_branch>
        ```

    * 使用 git config

        ```bash
        # 设置追踪关系
        git config branch.<local_branch>.remote origin
        git config branch.<local_branch>.merge refs/heads/<remote_branch>
        ```

    注：

    1. 如果 remote 名不叫`origin`，需要改成对应的 remote name，比如`upstream`

* 本地的 branch 为 branch_A，远程仓库中别人新建了一个 branch_B，如何在本地新建 branch_local，并将 branch_B 的内容拉取下来，并建立跟踪关系

    * 方法1：直接创建本地分支并追踪远程分支（最推荐）

        ```bash
        # 1. 先获取远程最新的分支信息
        git fetch origin

        # 2. 创建本地分支并直接追踪远程分支
        git checkout -b branch_local origin/branch_B

        # 或简写为
        git checkout --track origin/branch_B
        ```

    * 方法2：先创建再设置追踪

        ```bash
        # 1. 获取远程分支信息
        git fetch origin

        # 2. 创建本地分支但不切换
        git branch branch_local origin/branch_B

        # 3. 切换到新分支
        git checkout branch_local
        ```

    * 方法3：使用 pull 的方式

        ```bash
        # 1. 先创建本地分支（基于当前分支）
        git checkout -b branch_local

        # 2. 设置追踪关系
        git branch --set-upstream-to=origin/branch_B

        # 3. 拉取远程内容
        git pull
        ```

        注:

        1. 感觉这种方法不对，因为可能有 mrege 冲突

* `git clone -b <tag_name> <repo_url>`

    这个命令会：

    1. 拉取整个仓库的所有历史记录（所有分支、所有标签的所有提交）

    2. 然后 checkout 到 v1.0 标签对应的提交

    3. 你处于分离头指针状态

    即使你只看 v1.0 的代码，本地仍然有全部历史。

* 只拉取 v1.0 的内容，不关心历史

    ```bash
    # 只拉取最新一层的提交
    git clone --depth 1 -b v1.0 https://github.com/user/repo.git
    ```

* git archive（只下载文件，无git历史）

    ```bash
    # 直接下载tar包（最干净，没有.git文件夹）
    curl -L https://github.com/user/repo/archive/refs/tags/v1.0.tar.gz | tar -xz
    # 或者
    wget https://github.com/user/repo/archive/refs/tags/v1.0.tar.gz
    tar -xzf v1.0.tar.gz
    ```

* wget 下载

    ```bash
    # 方式2：如果你连.git都不想要
    cd myproject/vendor
    wget https://github.com/thirdparty/lib/archive/refs/tags/v1.0.tar.gz
    tar -xzf v1.0.tar.gz
    mv lib-1.0 lib
    ```

    ```bash
    # 直接下载解压到 vendor 目录
    cd vendor
    curl -L <url>/archive/refs/tags/v1.0.tar.gz | tar -xz --strip-components=1
    ```

* 可以拉取更多历史（如果需要）：

    ```bash
    git fetch --deepen 10  # 再拉取10个历史提交
    ```

* 验证你是否在分离头指针状态

    ```bash
    # 克隆后查看状态
    git status
    # 输出：HEAD detached at v1.0.0

    # 查看HEAD指向
    git log --oneline -1
    cat .git/HEAD
    ```

* 只关心 v1.0, v2.0, v3.0 这三个 commit，对其他的 commit 毫不关心

    * 单仓库多分支切换（如果需要git功能）

        (未测试)

        ```bash
        # 1. 先浅克隆一个版本
        git clone --depth 1 --branch v1.0 https://github.com/user/repo.git
        cd repo

        # 2. 添加其他版本作为远程分支（但只拉取特定提交）
        git remote set-branches origin v2.0 v3.0
        git fetch --depth 1 origin v2.0 v3.0

        # 3. 现在可以切换到不同版本
        git checkout v2.0  # 分离头指针状态
        git checkout v3.0  # 分离头指针状态
        ```

    * 使用 sparse-checkout（Git 2.25+）

        （未测试）

        ```bash
        # 1. 创建空仓库
        mkdir repo-all-versions
        cd repo-all-versions
        git init

        # 2. 添加远程
        git remote add origin https://github.com/user/repo.git

        # 3. 启用 sparse-checkout
        git sparse-checkout init --cone

        # 4. 只拉取特定标签
        for tag in v1.0 v2.0 v3.0; do
            git fetch --depth 1 origin tag $tag
            git checkout tags/$tag -b $tag
        done
        ```

* 创建一个包含三个版本的"快照"分支

    ```bash
    # 1. 浅克隆一个基础版本
    git clone --depth 1 https://github.com/user/repo.git
    cd repo

    # 2. 创建一个新分支
    git checkout -b my-versions

    # 3. 获取所有需要的标签
    git fetch --depth 1 origin tag v1.0
    git fetch --depth 1 origin tag v2.0
    git fetch --depth 1 origin tag v3.0

    # 现在你可以用 checkout 切换，但会进入分离头指针状态
    git checkout v1.0  # 查看v1.0
    git checkout v2.0  # 查看v2.0
    git checkout v3.0  # 查看v3.0
    git checkout my-versions  # 回到你的分支
    ```

    * 精确拉取三个提交

        ```bash
        # 1. 创建空仓库
        mkdir repo && cd repo
        git init

        # 2. 添加远程
        git remote add origin https://github.com/user/repo.git

        # 3. 只拉取这三个标签对应的提交
        git fetch --depth 1 origin tag v1.0
        git fetch --depth 1 origin tag v2.0
        git fetch --depth 1 origin tag v3.0

        # 4. 创建分支并包含这三个提交
        git checkout -b my-versions v3.0
        git merge v2.0  # 这可能会快进，因为v2.0是v3.0的祖先
        git merge v1.0  # 同样会快进
        ```

        验证它们在同一个分支上:

        ```bash
        # 查看标签的提交关系
        git log --oneline --graph --decorate v1.0 v2.0 v3.0

        # 查看某个标签在哪些分支上
        git branch --contains v1.0
        git branch --contains v2.0
        git branch --contains v3.0

        # 查看标签详情
        git show --name-only v1.0
        ```

* 比较版本差异：

    ```bash
    # 比较v1.0和v2.0的差异
    git diff v1.0..v2.0

    # 查看某个文件的变化
    git diff v1.0..v3.0 -- README.md

    # 查看提交历史
    git log v1.0..v3.0 --oneline
    ```

* 从20GB的大仓库中只提取几个特定提交，避免下载全部历史

    * 方法1：使用 git clone --filter=blob:none（Git 2.19+，最佳方案）

        ```bash
        # 部分克隆 - 只下载提交历史，不下载文件内容
        git clone --filter=blob:none --no-checkout https://github.com/user/repo.git
        cd repo

        # 现在只获取你需要的几个提交
        git fetch origin tag v1.0
        git fetch origin tag v2.0
        git fetch origin tag v3.0

        # 切换到某个版本（此时才下载对应的文件）
        git checkout v1.0
        ```

        优点：仓库目录很小，只有元数据，文件内容按需下载。

    * 方法2：使用 git clone --depth + git fetch --deepen

        ```bash
        # 1. 浅克隆v3.0（最新版本）
        git clone --depth 1 --branch v3.0 https://github.com/user/repo.git
        cd repo

        # 2. 逐步获取更早的历史直到包含v1.0
        git fetch --deepen 5  # 再获取5个历史提交
        # 检查是否包含v2.0和v1.0
        git log --oneline --all

        # 3. 如果还不够，继续加深
        git fetch --deepen 10
        ```

    * 方法3：使用 git archive + 手动创建新仓库

        ```bash
        # 1. 为每个版本下载压缩包
        mkdir my-repo && cd my-repo
        wget https://github.com/user/repo/archive/refs/tags/v1.0.tar.gz
        wget https://github.com/user/repo/archive/refs/tags/v2.0.tar.gz
        wget https://github.com/user/repo/archive/refs/tags/v3.0.tar.gz

        # 2. 创建新的git仓库
        git init
        tar -xzf v1.0.tar.gz --strip-components=1
        git add . && git commit -m "v1.0"
        rm -rf *  # 清空目录

        tar -xzf v2.0.tar.gz --strip-components=1
        git add . && git commit -m "v2.0"
        rm -rf *

        tar -xzf v3.0.tar.gz --strip-components=1
        git add . && git commit -m "v3.0"

        # 现在你有一个只有3个提交的新仓库
        ```

    * 方法4：使用 git cherry-pick 创建新分支

        ```bash
        # 1. 克隆最小版本
        git clone --depth 1 --branch v3.0 https://github.com/user/repo.git
        cd repo

        # 2. 获取特定提交的元数据（不下载文件）
        git fetch origin --depth 1 <commit-hash-of-v1.0>
        git fetch origin --depth 1 <commit-hash-of-v2.0>

        # 3. 创建新分支并挑选提交
        git checkout --orphan new-history  # 创建无父提交的新分支
        git cherry-pick <commit-hash-of-v1.0>
        git cherry-pick <commit-hash-of-v2.0>
        git cherry-pick <commit-hash-of-v3.0>

        # 现在 new-history 分支只有3个提交
        ```

    * 如果需要git功能但节省空间

        ```bash
        # 使用部分克隆 + 稀疏检出
        git clone --filter=blob:none --no-checkout https://github.com/user/repo.git
        cd repo

        # 获取需要的标签
        git fetch origin tag v1.0
        git fetch origin tag v2.0
        git fetch origin tag v3.0

        # 创建只有这三个提交的新分支
        git checkout --orphan slim-history
        for tag in v3.0 v2.0 v1.0; do
            git checkout $tag -- .  # 检出该版本的文件
            git commit -m "$tag"
        done
        ```

    * 使用 shallow + unshallow 精确控制

        ```bash
        #!/bin/bash
        # 精确获取三个提交

        # 获取v3.0（最新）
        git clone --depth 1 --branch v3.0 https://github.com/user/repo.git
        cd repo

        # 获取v2.0的提交（比v3.0早）
        git fetch origin v2.0 --depth 1

        # 获取v1.0的提交（比v2.0早）
        git fetch origin v1.0 --depth 1

        # 创建线性历史
        git checkout --orphan compressed-history
        for commit in $(git log --reverse --format="%H" --all); do
            git checkout $commit -- .
            git add -A
            git commit -m "版本 $(git describe --tags $commit 2>/dev/null || echo $commit)"
        done
        ```

* `git log --oneline --graph --all --decorate`

* 调研`git fetch origin tag v1.0`

* 调研`git merge v1.0 v2.0 v3.0 `

* 如果遇到问题

    问题1：找不到远程分支
    
    ```bash
    # 确保先获取最新信息
    git fetch --all

    # 或指定远程仓库
    git fetch origin
    ```

    问题2：本地已存在同名分支

    ```bash
    # 如果本地已有 branch_local，想重新关联
    git checkout branch_local
    git branch --set-upstream-to=origin/branch_B
    git pull
    ```

    问题3：想要删除旧的本地分支重新开始

    ```bash
    # 切换到其他分支
    git checkout branch_A

    # 删除本地分支
    git branch -D branch_local

    # 重新创建并追踪
    git checkout -b branch_local origin/branch_B
    ```

* 快速检查远程分支是否存在

    ```bash
    # 在操作前可以先检查远程分支
    git ls-remote --heads origin | grep branch_B

    # 或查看远程分支详情
    git remote show origin
    ```

* 验证操作结果

    ```bash
    # 查看所有分支及追踪关系
    git branch -avv

    # 查看当前分支追踪的远程分支
    git rev-parse --abbrev-ref @{upstream}

    # 查看远程分支的最近提交
    git log --oneline origin/branch_B
    ```

* 快速验证命令

    ```bash
    # 查看所有远程分支（确保你要追踪的远程分支存在）
    git ls-remote --heads origin

    # 查看详细的远程仓库信息
    git remote show origin
    ```

* git fetch origin 获取最新远程分支信息

* 使用 git remote -v 查看配置的远程仓库

* 删除旧的追踪关系

    ```bash
    git branch --unset-upstream
    ```

* 查看当前的追踪关系

    ```bash
    # 查看所有分支的追踪情况
    git branch -vv

    # 查看特定分支的追踪信息
    git rev-parse --abbrev-ref <branch_name>@{upstream}

    # 或简写
    git rev-parse --abbrev-ref @{u}
    ```

* 删除远程分支（如果需要）

    ```bash
    # 删除远程分支
    git push origin --delete <branch_name>

    # 或简写
    git push origin :<branch_name>
    ```

* 如果推送被拒绝的情况

    如果远程已存在同名分支，需要强制推送（谨慎使用）：

    ```bash
    git push -f origin <branch_name>
    ```

    或者先拉取远程分支再推送：

    ```bash
    # 如果远程已有同名分支，先拉取
    git pull origin <branch_name>
    # 解决可能的冲突后
    git push origin <branch_name>
    ```

* 查看远程 repo 信息

    ```bash
    # 查看所有远程分支
    git branch -r

    # 查看所有分支（本地和远程）
    git branch -a

    # 查看远程仓库信息
    git remote show origin
    ```

* 如果不指定分支，默认克隆的是远程仓库的默认分支（通常是 main 或 master）

* 可以通过 git remote show origin 查看远程分支信息

* 同时指定分支和标签

    ```bash
    git clone -b <tag_name> <repository_url>
    ```

    这会将标签视为分支的起点（会进入分离头指针（Detached HEAD）状态）。

    example:

    ```bash
    git clone -b v1.0.0 https://github.com/user/repo.git
    ```

    这里发生的是：

    * Git 找到标签 v1.0.0 对应的提

    * 将代码克隆到本地

    * 直接检出到那个提交，而不是检出到一个分支

    * 你处于"分离头指针"状态

* git 中 head detected 状态

    当你在分离头指针状态时：

    * HEAD 直接指向一个具体的提交，而不是指向一个分支

    * 你不在任何分支上，就像一个"游离"的状态

    * 新建的提交不会自动保存到任何分支

    这种状态的特性:

    * 优点：

        * 可以查看历史版本的代码

        * 可以基于特定版本创建新分支

    * 缺点：

        * 新建提交会丢失：

            ```bash
            # 如果修改并提交
            git add .
            git commit -m "修改"
            # 这个提交没有分支指向它！
            ```

        * 切换分支会丢失工作：

            ```bash
            git checkout main
            # 警告：你刚刚的提交可能会被垃圾回收
            ```

    使用场景：

    * 临时查看历史版本某个特定 tag （commit）的内容

        此时不能提交修改。

    * 从某个 tag 出发，重新构建 branch

        创建新 branch 后，可以提交修改。
    
    如何脱离这个状态：

    ```bash
    # 克隆默认分支
    git clone https://github.com/user/repo.git

    # 切换到标签
    git checkout v1.0.0
    # 此时是分离头指针状态

    # 如果需要修改，创建分支
    git checkout -b fix-v1.0.0

    # 现在可以安全地修改和提交
    git add .
    git commit -m "基于v1.0.0的新功能"
    ```

* git adverse

    If you want to create a new branch to retain commits you create, you may
    do so (now or later) by using -c with the switch command. Example:

    git switch -c <new-branch-name>

    Or undo this operation with:

    git switch -


    (base) hlc@Ubuntu2204:~/Documents/Projects/git_test/a$ git push
    fatal: The current branch b_2 has no upstream branch.
    To push the current branch and set the remote as upstream, use

        git push --set-upstream origin b_2

* 使用`<img src='../../Reference_resources/xxx/pics/pic_1.png'>`在 md 文件中引用图片似乎也不太好，因为如果把当前 md 文件，或仅引用图片的段落換到其他文件夹里，那么`../../`这个路径就可能错误。

    把图片放到当前文件夹下似乎也不太好，因为可能 md 文字被移动地方了，但是图片没动，导致引用失效。没移动图片，一方面是容易忘，另一方面是不容易在众多图片中找到文字所匹配的。

    相比之下，感觉还是上面`../../`的方案更好一些，因为无论如何它都不需要移动图片文件。就算路径不对，只需要改变下`../`的数量就可以了。