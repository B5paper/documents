* rdma example note

    * `ibv_alloc_pd()`

        PD 指的是 protection domains

        CQ 指的是 Completion queues

        QP 指的是 Queue pair

        有关 PD 的描述：

        > Protection Domain (PD) is similar to a "process abstraction" in the operating system. All resources are tied to a particular PD. And accessing resources across PD will result in a protection fault.

        这个函数目前用于申请一个 PD 设备，这个 PD 设备就是 remote client 的 rdma device。

    * `ibv_create_comp_channel()`

        completion channel，主要用于异步 IO 判断是否有事件完成。

        > this is different from connection management (CM) event notifications.

        completion channel 同样会和一个 rdma device 相连。

    * `ibv_create_cq()`

        completion queue (CQ) 看来和 completion channel 还不太一样。

        这里用于存放 I/O completion 的 metadata

        metadata 其实是一个`ibv_wc`类型的结构体，wc 指的是 work completion

        其中 work 指的是 an I/O request in RDMA.

        `cm_client_id->verbs`指的就是 rdma device。用 verbs 来指代一个 device，有点奇怪。不明白为什么。

        cq 的创建依赖于 completion channel。

    * `ibv_req_notify_cq()`

        这其实相当于一个 filter 了，从 queue 中拿出指定的消息类型

        不过这个时候 cq 里应该是空的，这时能拿出什么东西呢？

    * `bzero()`

        看起来是给结构体置 0 的。

    * `rdma_create_qp()`

        注意这里开始用 rdma 开头了，不再使用 ibv 开头了。

        recv_cq 和 send_cq 都在同一个 cq 里。

        这里和 cq 一样，同样需要指定 pd

        `rdma_create_qp()`会填充`cm_client_id->qp`字段作为返回值。

    * `start_rdma_server()`

        * `rdma_create_event_channel()`

            这个说是也是一个 async comm event channel，但是不清楚这个和 cq 有什么区别。

        * `rdma_create_id()`

            `rdma_cm_id`的作用类似于一个 socket fd

        * `rdma_bind_addr()`

            不清楚为啥 rdma 的 addr 用的仍是 socket addr

        * `rdma_listen()`

            每当来一个新连接，cm event 会被发送到 cm event channel.

        * `process_rdma_cm_event()`

            这个就是我们自定义的函数了，用来 client 申请连接的事件。

        * `rdma_ack_cm_event()`

            给 client 应答。acknowledge

    * `accept_client_connection()`

        看注释这个函数也是接收 rdma client connection，不清楚和 cm 那个有啥不一样。

        * `rdma_buffer_register()`

            这个看起来更像是自己申请一块内存，然后放到 pd 里？

            确实是。

        * `ibv_post_recv()`

            看起来是先把要接收到 client 放到 qp 中，然后等 client 的消息来了就自动处理？

        * `rdma_accept()`

            不清楚 outstanding requests 是啥意思。看起来像是处理包的多少？

            似乎到这里，才真正接收了客户端的连接。

        * `process_rdma_cm_event()`

            这是第二次被调用了，看来每有一个 cm 消息就调用一次。

        * `rdma_ack_cm_event()`

            和前面一样。

        * `rdma_get_peer_addr()`

            根据`cm_client_id`就能得到 peer addr。

    * `send_server_metadata_to_client()`

        * `process_work_completion_events()`

            并不是回调函数，是直接被调用的函数。

            * `ibv_get_cq_event()`

                在这里阻塞等待 cq channel 的消息。

                看起来一个 cq channel 中会有很多的 cq。

            * `ibv_req_notify_cq()`

                尝试拿到更多的 notification

                不懂啥意思。

            * `ibv_poll_cq()`

                从 cq 中拿消息进行处理。

    * `rdma_buffer_attr`的常用字段

        * `address`

        * `length`

        * `stag`

            这个`stag`好像说的是权限。

    * `main()`

        server 在哪阻塞？又在哪循环处理消息？

        在`rdma_get_cm_event()`处阻塞接收 clinet 连接。

        这个程序不循环处理消息，只接收一次消息。

        在 server `ibv_post_send()`后，client 才开始发送数据。

    * 大部分`rmda`开头的函数都是作者自定义实现的，只有`ibv_`开头的函数才是内置的。

        也不是，一部分 rdma 开头的函数是作者自己写的，另一部分是内置的。

* rdma client code note

    * `clinet_prepare_connection()`

        * `rdma_create_event_channel()`

            内置函数。为了创建 cq

            cm event channel 等同于 cq 的 channel 吗？

        * `rdma_create_id()`

            内置函数。创建 cm id。

        * `rdma_resolve_addr()`

            内置函数。绑定 cm id 和 local device。

        * `rdma_get_cm_event()`

            内置函数。这里已经用到前面创建的 channel 了。

        * 为什么在`process_rdma_cm_event()`中已经 ack event 了，出了函数又 ack 一次。

        * `rdma_resolve_route()`

            我的理解是先 ping 一下？

        * cm channel 不等同于 completion channel

            前者是用于建立连接的，后面是用于收发消息的。

            completion channel 中建立的 queue pair 才是 cq.

        * `ibv_alloc_pd()`

            内置函数。

        * `ibv_create_comp_channel()`

            内置函数。

        * `ibv_create_cq()`

            内置函数。

        * `ibv_req_notify_cq()`

            内置函数。

        * `rdma_create_qp()`

            内置函数，创建 queue pair。

        * `ibv_post_recv()`

            看来 clint 端在这里阻塞，server 端进行`ibv_post_send()`后才开继续执行程序。

    * `client_connect_to_server()`

        * `rdma_connect()`

            内置函数。根据 cm id 建立连接，建立完连接后，会填充一个`rdma_conn_param`的结构体。

    * `client_xchange_metadata_with_server()`

        `rdma_buffer_register`

    * `ibv_post_send()`发送的都是 work request (wr)
















            

        




        


