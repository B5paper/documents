* 跳表的 search 功能

    整个跳表的功能比较复杂，今天只看了`search()`函数。

    下面是对`search()`函数的解析：

    ```c
    bool search(int target) {
        SkiplistNode *curr = this->head;
        // 这里的 level 应该改成 num_levels 比较好
        for (int i = level - 1; i >= 0; i--) {
            // 如果当前节点的下一个节点存在，那么判断下一个节点是否小于 target
            // 若小于 target，继续往右搜索
            // 这样得到的当前节点 curr 就是在所有小于 target 的数中，最大的那个
            // 即 curr < target <= curr->forward
            while (curr->forward[i] && curr->forward[i]->val < target) {
                curr = curr->forward[i];
            }
            // 当搜索停止后，由于 for 的作用，i 会自然加 1
            // 因此在下一轮循环时，会跳到下一层搜索
        }
        // 此时 curr 已经搜索到了最底层，再向右走一个元素，
        // 这个元素要么等于，要么大于 target，当然也有可能是 NULL
        curr = curr->forward[0];
        if (curr && curr->val == target) {
            return true;
        } 
        return false;
    }
    ```

    自己盲写的一版：

    ```cpp
    bool search(int target)
    {
        SkiplistNode *cur = head;
        for (int cur_layer = level - 1; cur_layer >= 0; --cur_layer)
        {
            while (cur->forward[cur_layer]
                && cur->forward[cur_layer]->val < target)
            {
                cur = cur->forward[cur_layer];
            }
        }
        cur = cur->forward[0];
        if (!cur)
            return false;
        if (cur->val != target)
            return false;
        return true;
    }
    ```

    回头再研究下`add()`。

    对应的 leetcode 题目是`1206. 设计跳表`。

    ref: <https://oi-wiki.org/ds/skiplist/>

* 对跳表（skip list）的理解

    跳表有点像从海底长出来的海草，又有点像马里奥里的管道迷宫。节点有可能纵跨多层，最底层则包含所有元素。

    我们从最顶层开始向右搜索，每次遇到 right bound 就向下走一层（为什么总能保证在遇到 right bound 时，总是有向下的通道？），直到走到最底层。最底层的 right bound，要么正好是我们要找到数字，要么就说明我们要找的元素不存在。（为什么在最底层一定可以做出判断是否遇到？有没有可能在上面几层就遇到 target？）

* 51 单片机的开发环境

    看起来，以前的 keil 是付费的，现在的 keil 是免费的。keil 中并不携带 STC 公司芯片的信息，需要使用 STC-ISP 这个软件，把芯片模型库导入到 keil 中，keil 才会出现 STC 对应的选项。

    STC 似乎不生产 89C51，最低端的也到 89C52 了。

* c++ `find()`

    c++ 中的`find()`是线性搜索，在使用时需要加上`#include <algorithm>`头文件。

    example:

    `main.cpp`:

    ```cpp
    #include <algorithm>
    #include <iostream>
    #include <vector>
    #include <string>
    using namespace std;

    struct MyClass
    {
        int val;
        string name;

        MyClass(int val, string name):
            val(val), name(name) {}

        bool operator==(const MyClass &obj_2)
        {
            if (val == obj_2.val && name == obj_2.name)
                return true;
            return false;
        }
    };

    bool operator==(const MyClass &obj_1, const MyClass &obj_2)
    {
        if (obj_1.val == obj_2.val && obj_1.name == obj_2.name)
            return true;
        return false;
    }

    int main()
    {
        vector<int> arr{1, 2, 3, 4, 5, 6, 7, 8};
        vector<int>::iterator iter = find(arr.begin(), arr.end(), 3);
        if (iter != arr.end())
        {
            cout << "found object: " <<  *iter << endl;
        }

        vector<MyClass> vec{
            {5, "hehe"},
            {7, "haha"},
            {12, "byebye"}
        };
        MyClass obj_to_find{7, "haha"};
        vector<MyClass>::iterator my_iter = find(
            vec.begin(), vec.end(), obj_to_find
        );
        if (my_iter != vec.end())
        {
            cout << "found obj, val: " << my_iter->val << ", name: " << my_iter->name << endl;
        }
        return 0;
    }
    ```

    compie: `g++ -g main.cpp -o main`

    run: `./main`

    output:

    ```
    found object: 3
    found obj, val: 7, name: haha
    ```

    通常`find()`需要传入起始和结束的迭代器，第三个参数传入一个`val`，`find()`会线性搜索容器，若找到元素，则返回元素的迭代器；若未找到，则返回结束位置的迭代器。

    迭代器可以看作是指针，直接对迭代器解引用就可以得到值。

    如果是自定义的类型，`find()`的第三个参数可以传入左值对象（比如上面例子中的`obj_to_find`），也可以传入右值对象，比如`MyClass{7, "haha"}`或`MyClass(7, "haha")`。但是看`find()`的函数原型，并没有显示专门对右值的处理，目前不清楚他是怎么能接收右值参数的。

    对于自定义的类型，还需要实现`operator==()`。这个函数可以在类里实现，也可以作为一个全局函数，两者只要实现一个就可以。上面的 example 示范了这两种写法。如果两种实现都写了，那么会优先调用成员函数。

    在写`operator==()`时，其参数必须加`const`，不加会报错。

    实现了`operator==()`，不代表可以判断`obj_1 != obj_2`。

* c++ 代码中的`obj_1 == obj_2`会调用到`operator==()`，两个`struct`对象不能比大小，也不能默认按值判断相等。

* c++ 中，如果没有自定义的构造函数，那么只能使用`MyStruct{xxx, yyy}`来初始化对象，不能使用`MyStruct(xxx, yyy)`初始化对象。