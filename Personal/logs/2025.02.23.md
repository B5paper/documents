* 跳表的 search 功能

    整个跳表的功能比较复杂，今天只看了`search()`函数。

    下面是对`search()`函数的解析：

    ```c
    bool search(int target) {
        SkiplistNode *curr = this->head;
        // 这里的 level 应该改成 num_levels 比较好
        for (int i = level - 1; i >= 0; i--) {
            // 如果当前节点的下一个节点存在，那么判断下一个节点是否小于 target
            // 若小于 target，继续往右搜索
            // 这样得到的当前节点 curr 就是在所有小于 target 的数中，最大的那个
            // 即 curr < target <= curr->forward
            while (curr->forward[i] && curr->forward[i]->val < target) {
                curr = curr->forward[i];
            }
            // 当搜索停止后，由于 for 的作用，i 会自然加 1
            // 因此在下一轮循环时，会跳到下一层搜索
        }
        // 此时 curr 已经搜索到了最底层，再向右走一个元素，
        // 这个元素要么等于，要么大于 target，当然也有可能是 NULL
        curr = curr->forward[0];
        if (curr && curr->val == target) {
            return true;
        } 
        return false;
    }
    ```

    自己盲写的一版：

    ```cpp
    bool search(int target)
    {
        SkiplistNode *cur = head;
        for (int cur_layer = level - 1; cur_layer >= 0; --cur_layer)
        {
            while (cur->forward[cur_layer]
                && cur->forward[cur_layer]->val < target)
            {
                cur = cur->forward[cur_layer];
            }
        }
        cur = cur->forward[0];
        if (!cur)
            return false;
        if (cur->val != target)
            return false;
        return true;
    }
    ```

    回头再研究下`add()`。

    对应的 leetcode 题目是`1206. 设计跳表`。

    ref: <https://oi-wiki.org/ds/skiplist/>

* 对跳表（skip list）的理解

    跳表有点像从海底长出来的海草，又有点像马里奥里的管道迷宫。节点有可能纵跨多层，最底层则包含所有元素。

    我们从最顶层开始向右搜索，每次遇到 right bound 就向下走一层（为什么总能保证在遇到 right bound 时，总是有向下的通道？），直到走到最底层。最底层的 right bound，要么正好是我们要找到数字，要么就说明我们要找的元素不存在。（为什么在最底层一定可以做出判断是否遇到？有没有可能在上面几层就遇到 target？）

* 51 单片机的开发环境

    看起来，以前的 keil 是付费的，现在的 keil 是免费的。keil 中并不携带 STC 公司芯片的信息，需要使用 STC-ISP 这个软件，把芯片模型库导入到 keil 中，keil 才会出现 STC 对应的选项。

    STC 似乎不生产 89C51，最低端的也到 89C52 了。