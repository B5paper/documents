* [v] vim 如何 ctag 跳转？

    feedback:

    1. 调研 vim-gutentags

    1. 调研引用系统库（如 /usr/include）的标签

        `set tags=./tags,./TAGS,tags,TAGS,/path/to/other/tags`

* [v] `int major = register_chrdev(0, "hlc_dev", &fops);`失败时会返回什么？

* [v] `ioremap_wc()`

* [v] `dma_alloc_coherent()`

    feedback:

    1. `dma_map_single`

    1. DMA总线

    1. dma 在 cpu 中，还是在 device 中？

* [v] `ldconfig`

* [v] reorg project: `main.cpp`

    feedback:

    1. `remove_const_t`

    1. `remove_pointer_t`

    1. `is_pointer_v`

* [v] makefile 中，`$(VAR)`和`${VAR}`有什么不同？

    feedback:

    1. 调研 makefile 内置函数 `wildcard`, `subst`, `shell`

    1. 调研 makefile 中特殊的自动变量（如 `$@`, `$<`, `$^`）

    1. 调研 make 变量与 shell 变量

        * Make 变量 在规则的目标、依赖和整个 Makefile 的顶层使用 $(...) 来引用。

        * Shell 变量 在规则的命令部分（以 Tab 开头的行）中使用，但需要使用两个美元符号 $$ 来转义。

        ```makefile
        MY_MAKE_VAR = I am a Make variable

        test:
            # 这里引用的是 Make 变量，需要 $()
            @echo "Make var: $(MY_MAKE_VAR)"

            # 这里我们想在 Shell 中设置并使用一个 Shell 变量
            # 使用 $$ 来转义，这样 Make 会将其转换为单个 $ 传递给 Shell
            @export SHELL_VAR="I am a Shell variable"; \
            echo "Shell var: $$SHELL_VAR"

            # 一个更常见的例子：获取 Shell 命令的进程 ID
            @echo "The process ID in Make is: $(shell echo $$PPID)" # 嵌套调用：$$ 给 Shell, $PPID 是 Shell 变量
            @echo "The process ID in Shell is: $$PPID" # $$ 给 Shell, Shell 看到的是 $PPID
        ```

* [ ] 调研 nccl dump graph 的 xml
