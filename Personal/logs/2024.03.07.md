* vulkan 中`VkPipelineColorBlendStateCreateInfo`的含义

    `logicOpEnable`与`logicOp`的作用：

    > The application can enable a logical operation between the fragment’s color values and the existing value in the framebuffer attachment. This logical operation is applied prior to updating the framebuffer attachment. Logical operations are applied only for signed and unsigned integer and normalized integer framebuffers. Logical operations are not applied to floating-point or sRGB format color attachments.

    vulkan 支持在 fragment color 输出的结果，与当前已存在的 frame buffer 做一次按位逻辑操作，然后再把结果存到 frame buffer 里。

    这里的位操作只支持整数存储的图片数据， 不支持浮点点和 sRGB 存储的图片数据。

    `blendConstants`:

    Blend Factors 用于根据 alpha 值混合 fragment output color 和 framebuffer 的颜色。

    常见的模式有：

    ```cpp
    typedef enum VkBlendFactor {
        VK_BLEND_FACTOR_ZERO = 0,
        VK_BLEND_FACTOR_ONE = 1,
        VK_BLEND_FACTOR_SRC_COLOR = 2,
        VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
        VK_BLEND_FACTOR_DST_COLOR = 4,
        VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
        VK_BLEND_FACTOR_SRC_ALPHA = 6,
        VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
        VK_BLEND_FACTOR_DST_ALPHA = 8,
        VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
        VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
        VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
        VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
        VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
        VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
        VK_BLEND_FACTOR_SRC1_COLOR = 15,
        VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
        VK_BLEND_FACTOR_SRC1_ALPHA = 17,
        VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    } VkBlendFactor;
    ```

    其中的 constant 指的就是`blendConstants`指定的混合常数。

    具体是怎么混合的，仍然不清楚。

* `VkPipelineColorBlendAttachmentState`中`colorWriteMask`必须写上，无论`blendEnable`是否为`VK_FALSE`都不能省略。

* opencl synchronization functions

    * `barrier`

        ```cpp
        void barrier(cl_mem_fence_flags flags)
        ```

        > All work-items in a work-group executing the kernel on a compute unit must execute this function before any are allowed to continue execution beyond the barrier.

        parameters:

        * `CLK_LOCAL_MEM_FENCE`: The barrier function will either flush any variables stored in local memory or queue a memory fence to ensure correct ordering of memory operations to local memory.

            如果`barrier()`前面的代码不涉及到 global memory 的写入，就用这个

        * `CLK_GLOBAL_MEM_FENCE`： The barrier function will either flush any variables stored in global memory or queue a memory fence to ensure correct ordering of memory operations to global memory. This is needed when work- items in a work-group, for example, write to a buffer object in global memory and then read the updated data.

            如果`barrier()`前面的代码涉及到 global memory 的写入，并且需要同步，那么就用这个。

    * `async_work_group_copy()`

        syntax:

        ```cpp
        event_t async_work_group_copy(
            local gentype *dst,
            const global gentype *src,
            size_t num_gentypes,
            event_t event)

        event_t async_work_group_copy(global gentype *dst,
            const local gentype *src,
            size_t num_gentypes,
            event_t event)
        ```

        异步复制数据。函数的返回值`event`是用来让函数`wait_group_events()`使用的，等待事件列表完成。而参数中的`event`是用来让多个函数 share 的，也就是说多个函数都注册到这个 event 上。（不清楚这些个函数是串行执行还是并行，应该是并行）

    * `async_work_group_strided_copy`

        syntac:

        ```cpp
        event_t async_work_group_strided_copy(
            local gentype *dst,
            const global gentype *src,
            size_t num_gentypes,
            size_t src_stride,
            event_t event)

        event_t async_work_group_strided_copy(
            global gentype *dst,
            const local gentype *src,
            size_t num_gentypes,
            size_t dst_stride,
            event_t event)
        ```

        按`stride`去增加偏移量。其他的和`async_work_group_copy`相同。

    * `wait_group_events`

        syntax:

        ```cpp
        void wait_group_events(int num_events,
            event_t *event_list)
        ```

        Wait for events that identify the copy operations associated with `async_work_group_copy` and `async_work_group_strided_copy` functions to complete. The event objects specified in `event_list` will be released after the wait is performed.

        等待事件完成。

    * `prefetch`

        ```c
        void prefetch(const global gentype *p,
            size_t num_gentypes)
        ```

        Prefetch num_gentypes * sizeof(gentype) bytes into the global cache. The prefetch function is applied to a work-item in a work-group and does not affect the functional behavior of the kernel.

        先把一些数据放到缓存里，以提高命中率。

* regular expression

    看起来正则表达式描述的是确定有限状态机中的边，如果有$|$，那么就一个节点画出 2 条边；如果有$\cdot$，那么就一个节点连下一个节点；如果有$*$，那么就是一个终止节点，并且自己指向自己。

    将小的状态机合并成大的：从节点 1 向外引出多个 edge，分别对应每个小状态机的第一条 edge。

* C 语言允许`char**`隐式转换成`const char**`吗？


