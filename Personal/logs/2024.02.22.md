* 深度学习和数学最本质的区别是，深度学习只告诉你他的方法为什么行，不告诉你别人的方法为什么不行，而数学会同时告诉你这两者

* 感觉在 vulkan 的 debug messenger callback 函数中，前两个参数可以都设置为`flag`，不需要区分到 flag bits。

    因为 flag bits 是枚举类型，实际上的类型是`uint32_t`，而`VkFlag`也是`uint32_t`，因此实际上是通用的。

    callback 函数的返回值类型也可以设置成`VkResult`，返回`VK_SUCCESS`。这样比`VkBool32`加`VK_FALSE`更明确一些。

    只需要记住顺序，先是 severity，然后才是 message type

* vulkan 的 vk get physical device queue family properties() 返回的参数的类型却是 vk queue family properties。

    第一说明 queue family 是个只属于 physical device 的概念；
    
    第二，说明 vulkan 也觉得这个类型名实在是太长了，写全的话是 vk physical device queue family proeprties，快占半个屏幕了，没歧义的话能简化就简化

* cache: cmake 环境变量的用法

* vulkan 中有关 image view 和 frame buffer 的创建

    * 创建 image view

        ```cpp
        std::vector<VkImageView> swpch_img_views(swpch_img_count);
        VkImageViewCreateInfo img_view_crt_info{};
        img_view_crt_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        img_view_crt_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
        img_view_crt_info.format = VK_FORMAT_B8G8R8A8_SRGB;
        img_view_crt_info.components = {VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_IDENTITY,
            VK_COMPONENT_SWIZZLE_IDENTITY, VK_COMPONENT_SWIZZLE_IDENTITY};
        img_view_crt_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};
        VkResult result;
        for (int i = 0; i < swpch_img_count; ++i)
        {
            img_view_crt_info.image = swpch_imgs[i];
            result = vkCreateImageView(device, &img_view_crt_info, nullptr, &swpch_img_views[i]);
            if (result != VK_SUCCESS)
            {
                printf("fail to create image view, error code %d\n", result);
                exit(-1);
            }
        }
        ```

        `VkImage`其实包含了许多的数据区，每个数据区都是一张图片。image view 指的就是其中的一张图片。

        通常只需要指定 vkiamge 的通道位（aspect bit）， array level 和 mip level，就可以定位一个数据区。这些信息被放在`subresourceRange`中。

        `viewType`主要有 1D，2D，3D，cube 这几种。我们通常用的是 2D。

        `components`指的是是否需要把 rgba 通道改变顺序，比如改成 bgra。如果不需要改变的话，直接填 identity `VK_COMPONENT_SWIZZLE_IDENTITY`就可以了。swizzle 的意思是鸡尾酒，这里取的是混合成分的意思吗？

        `format`指的是 image 的 format，它与 surface 的 format 相同。常见的一个取值是`VK_FORMAT_B8G8R8A8_SRGB`。
    
    * 创建 frame buffer

        ```cpp
        VkFramebufferCreateInfo frame_buf_crt_info{};
        frame_buf_crt_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        frame_buf_crt_info.renderPass = render_pass;
        frame_buf_crt_info.attachmentCount = 1;
        frame_buf_crt_info.width = 700;
        frame_buf_crt_info.height = 500;
        frame_buf_crt_info.layers = 1;
        std::vector<VkFramebuffer> frame_bufs(swpch_img_count);
        for (int i = 0; i < swpch_img_count; ++i)
        {
            frame_buf_crt_info.pAttachments = &swpch_img_views[i];
            result = vkCreateFramebuffer(device, &frame_buf_crt_info, nullptr, &frame_bufs[i]);
            if (result != VK_SUCCESS)
            {
                printf("fail to create frame buffer, error code: %d\n", result);
                exit(-1);
            }
        }
        ```

        frame buffer 是交给 render pass 使用的，一个 framebuffer 可以有多个 image view，这些 image view 都被称为 attachment。

        目前不清楚这里的`layers`有什么作用。如果把 layer 填 2 或更大，该怎么取得不同 layer 的数据呢？

* compiler

    非确定有限自动机（NFA）是一种需要对从一个状态出发的多条标有相同符号的边进行选择的自动机。

    比如对于初始状态$s_0$，它向外有 2 条边，每条边的条件都是字母`a`，由此可以得到两个完全不同的终止条件。

    标有$\epsilon$的边可以在不接收输入字符的情况下进行状态转换。

* 每天离开工作区之前应该把 task 中的 feedback 整合到临时项目管理中