* 如果多人合作一个项目，那么从一开始就要多交流，否则容易后面对接不起来。

* `static`只能加在函数的实现前，不能加在函数的声明前。

    如果`static`加在头文件的函数声明前，那么将不再检查`xx.c`或`xx.cpp`中的内容，并认为这个函数只有函数头，没有函数体。

    example:

    ```cpp
    // lib_1.h
    static int add(int a, int b);

    // lib_1.cpp
    #include "lib_1.h"

    int add(int a, int b) {
        return a + b;
    }

    // lib_2.h
    int sum(int a, int b, int c);

    // lib_2.cpp
    #include "lib_1.h"
    #include "lib_2.h"

    int sum(int a, int b, int c) {
        return add(add(a, b), c);
    }

    // main.cpp
    #include "lib_1.h"
    #include "lib_2.h"
    #include "stdio.h"

    int main() {
        int a = 1, b = 2;
        int c = add(a, b);
        printf("%d + %d = %d\n", a, b, c);

        int d = sum(a, b, c);
        printf("%d + %d + %d = %d\n", a, b, c, d);
        return 0;
    }
    ```

    Makefile:

    ```makefile
    all: main

    lib_1.o: lib_1.h lib_1.cpp
    	g++ -g -c lib_1.cpp -o lib_1.o

    lib_2.o: lib_2.h lib_2.cpp
    	g++ -g -c lib_2.cpp -o lib_2.o

    main: main.cpp lib_1.o lib_2.o
    	g++ -g main.cpp lib_1.o lib_2.o -o main

    clean:
    	rm -f lib_1.o lib_2.o main
    ```

    `make` output:

    ```
    g++ -g -c lib_1.cpp -o lib_1.o
    g++ -g -c lib_2.cpp -o lib_2.o
    In file included from lib_2.cpp:1:
    lib_1.h:1:12: warning: ‘int add(int, int)’ used but never defined
        1 | static int add(int a, int b);
          |            ^~~
    g++ -g main_3.cpp lib_1.o lib_2.o -o main
    In file included from main_3.cpp:1:
    lib_1.h:1:12: warning: ‘int add(int, int)’ used but never defined
        1 | static int add(int a, int b);
          |            ^~~
    /usr/bin/ld: /tmp/cck01kxj.o: in function `main':
    /home/hlc/Documents/Projects/cpp_test/main_3.cpp:7: undefined reference to `add(int, int)'
    /usr/bin/ld: lib_2.o: in function `sum(int, int, int)':
    /home/hlc/Documents/Projects/cpp_test/lib_2.cpp:5: undefined reference to `add(int, int)'
    /usr/bin/ld: /home/hlc/Documents/Projects/cpp_test/lib_2.cpp:5: undefined reference to `add(int, int)'
    collect2: error: ld returned 1 exit status
    make: *** [Makefile:10: main] Error 1
    ```

* `vmalloc()`

    分配一块虚拟地址连续，物理地址不一定连续的内存。

    syntax:

    ```c
    #include <linux/vmalloc.h>

    void *vmalloc(unsigned long size);
    ```

    配对函数：`vfree()`

    初始值清零版本：`vzalloc()`

* `kvzalloc()`

    首先尝试像`kzalloc()`一样分配物理连续的内存。如果分配失败，它会自动回退到 `vzalloc()`的方式，分配虚拟连续的内存。并将内存内容初始化为 0.

    syntax:

    ```c
    #include <linux/slab.h>

    void *kzalloc(size, flags);
    ```

    配对函数：`kvfree()`

    感觉这个函数没啥用。什么情况需要优先使用连续物理内存，如果物理内存不连续也无所谓？想不到。

* kmalloc() 在内核空间分配的内存，如果在模块退出函数（module_exit）中没有被显式地使用 kfree() 释放，那么这些内存将永远地泄露，直到系统重启。

    `vmalloc()`同理。

* `getpid()`

    获取当前的进程 id（PID）。

    `getppid()`: 获取当前进程的父进程的进程ID (PPID)。

    除了系统启动时的第一个进程（init 或 systemd，PID 通常为 1），每个进程都有父进程。

    如果父进程先于子进程结束，子进程就会变成“孤儿进程”，并被 init 进程（PID 1）收养。此时，子进程调用 getppid() 将返回 1。

* `pci_alloc_irq_vectors()`

    为指定的 PCI 设备申请和分配一组中断向量（Interrupt Vectors）。

    syntax:

    ```c
    int pci_alloc_irq_vectors(struct pci_dev *dev, unsigned int min_vecs, unsigned int max_vecs, unsigned int flags);
    ```

    * `min_vecs`：驱动至少需要多少个中断向量。

    * `max_vecs`：驱动最多希望申请多少个中断向量。

    * `flags`：指定中断类型和行为的标志。最重要的标志是：

        * `PCI_IRQ_MSIX`：请求使用 MSI-X 中断。

        * `PCI_IRQ_MSI`：请求使用 MSI 中断。

        * `PCI_IRQ_LEGACY`：请求使用传统引脚中断（如 INTA#）。

        * `PCI_IRQ_ALL_TYPES`：尝试任何可用的类型（通常的用法）。

        * `PCI_IRQ_AFFINITY`：提示内核这些中断可以设置 CPU 亲和性（绑定到特定 CPU 核心）。

        各个 flag 可以使用`|`组合。

    return value:

    分配成功则返回 实际分配到的中断数量。分配失败则返回一个负的错误码。

    配对函数：`pci_free_irq_vectors()`

    example:

