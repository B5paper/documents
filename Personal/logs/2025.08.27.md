* 如果多人合作一个项目，那么从一开始就要多交流，否则容易后面对接不起来。

* `static`只能加在函数的实现前，不能加在函数的声明前。

    如果`static`加在头文件的函数声明前，那么将不再检查`xx.c`或`xx.cpp`中的内容，并认为这个函数只有函数头，没有函数体。

    example:

    ```cpp
    // lib_1.h
    static int add(int a, int b);

    // lib_1.cpp
    #include "lib_1.h"

    int add(int a, int b) {
        return a + b;
    }

    // lib_2.h
    int sum(int a, int b, int c);

    // lib_2.cpp
    #include "lib_1.h"
    #include "lib_2.h"

    int sum(int a, int b, int c) {
        return add(add(a, b), c);
    }

    // main.cpp
    #include "lib_1.h"
    #include "lib_2.h"
    #include "stdio.h"

    int main() {
        int a = 1, b = 2;
        int c = add(a, b);
        printf("%d + %d = %d\n", a, b, c);

        int d = sum(a, b, c);
        printf("%d + %d + %d = %d\n", a, b, c, d);
        return 0;
    }
    ```

    Makefile:

    ```makefile
    all: main

    lib_1.o: lib_1.h lib_1.cpp
    	g++ -g -c lib_1.cpp -o lib_1.o

    lib_2.o: lib_2.h lib_2.cpp
    	g++ -g -c lib_2.cpp -o lib_2.o

    main: main.cpp lib_1.o lib_2.o
    	g++ -g main.cpp lib_1.o lib_2.o -o main

    clean:
    	rm -f lib_1.o lib_2.o main
    ```

    `make` output:

    ```
    g++ -g -c lib_1.cpp -o lib_1.o
    g++ -g -c lib_2.cpp -o lib_2.o
    In file included from lib_2.cpp:1:
    lib_1.h:1:12: warning: ‘int add(int, int)’ used but never defined
        1 | static int add(int a, int b);
          |            ^~~
    g++ -g main_3.cpp lib_1.o lib_2.o -o main
    In file included from main_3.cpp:1:
    lib_1.h:1:12: warning: ‘int add(int, int)’ used but never defined
        1 | static int add(int a, int b);
          |            ^~~
    /usr/bin/ld: /tmp/cck01kxj.o: in function `main':
    /home/hlc/Documents/Projects/cpp_test/main_3.cpp:7: undefined reference to `add(int, int)'
    /usr/bin/ld: lib_2.o: in function `sum(int, int, int)':
    /home/hlc/Documents/Projects/cpp_test/lib_2.cpp:5: undefined reference to `add(int, int)'
    /usr/bin/ld: /home/hlc/Documents/Projects/cpp_test/lib_2.cpp:5: undefined reference to `add(int, int)'
    collect2: error: ld returned 1 exit status
    make: *** [Makefile:10: main] Error 1
    ```

* `vmalloc()`

    分配一块虚拟地址连续，物理地址不一定连续的内存。

    syntax:

    ```c
    #include <linux/vmalloc.h>

    void *vmalloc(unsigned long size);
    ```

    配对函数：`vfree()`

    初始值清零版本：`vzalloc()`

* `kvzalloc()`

    首先尝试像`kzalloc()`一样分配物理连续的内存。如果分配失败，它会自动回退到 `vzalloc()`的方式，分配虚拟连续的内存。并将内存内容初始化为 0.

    syntax:

    ```c
    #include <linux/slab.h>

    void *kzalloc(size, flags);
    ```

    配对函数：`kvfree()`

    感觉这个函数没啥用。什么情况需要优先使用连续物理内存，如果物理内存不连续也无所谓？想不到。

* kmalloc() 在内核空间分配的内存，如果在模块退出函数（module_exit）中没有被显式地使用 kfree() 释放，那么这些内存将永远地泄露，直到系统重启。

    `vmalloc()`同理。

* `getpid()`

    获取当前的进程 id（PID）。

    `getppid()`: 获取当前进程的父进程的进程ID (PPID)。

    除了系统启动时的第一个进程（init 或 systemd，PID 通常为 1），每个进程都有父进程。

    如果父进程先于子进程结束，子进程就会变成“孤儿进程”，并被 init 进程（PID 1）收养。此时，子进程调用 getppid() 将返回 1。

* `pci_alloc_irq_vectors()`

    为指定的 PCI 设备申请和分配一组中断向量（Interrupt Vectors）。

    syntax:

    ```c
    int pci_alloc_irq_vectors(struct pci_dev *dev, unsigned int min_vecs, unsigned int max_vecs, unsigned int flags);
    ```

    * `min_vecs`：驱动至少需要多少个中断向量。

    * `max_vecs`：驱动最多希望申请多少个中断向量。

    * `flags`：指定中断类型和行为的标志。最重要的标志是：

        * `PCI_IRQ_MSIX`：请求使用 MSI-X 中断。

        * `PCI_IRQ_MSI`：请求使用 MSI 中断。

        * `PCI_IRQ_LEGACY`：请求使用传统引脚中断（如 INTA#）。

        * `PCI_IRQ_ALL_TYPES`：尝试任何可用的类型（通常的用法）。

        * `PCI_IRQ_AFFINITY`：提示内核这些中断可以设置 CPU 亲和性（绑定到特定 CPU 核心）。

        各个 flag 可以使用`|`组合。你组合多个类型，内核会按性能从高到低的顺序（通常是 MSI-X -> MSI -> Legacy）自动选择可用的最佳类型。

    return value:

    分配成功则返回 实际分配到的中断数量。分配失败则返回一个负的错误码。

    配对函数：`pci_free_irq_vectors()`

    example:

    * 尝试所有中断类型，并提示亲和性：

        `int nvecs = pci_alloc_irq_vectors(pdev, 1, 32, PCI_IRQ_ALL_TYPES | PCI_IRQ_AFFINITY);`

        驱动表示它兼容任何硬件支持的中断模式，并且它设计为能够利用多CPU核心的优势。

    * 只尝试 MSI-X 或传统中断，不尝试 MSI

        `int nvecs = pci_alloc_irq_vectors(pdev, 1, 8, PCI_IRQ_MSIX | PCI_IRQ_LEGACY);`
        
        可能因为驱动在某些硬件上发现 MSI 实现有bug，或者功能需求上 MSI-X 是首选，如果不行则回退到最稳定的传统模式。

    * 只使用 MSI，并要求亲和性

        `int nvecs = pci_alloc_irq_vectors(pdev, 2, 2, PCI_IRQ_MSI | PCI_IRQ_AFFINITY);`

        只想使用 MSI 机制，并且希望中断能分布在不同的CPU上。

    example:

    ```c
    // 1. 分配中断向量（假设申请了4个）
    nvec = pci_alloc_irq_vectors(pdev, 4, 4, PCI_IRQ_MSIX);
    if (nvec < 0) {
        // 错误处理
    }

    // 2. 为每一个向量注册中断处理程序
    for (i = 0; i < nvec; i++) {
        // 注意：这里的 i 就是索引号
        ret = pci_request_irq(pdev, i, /* 索引i对应MSI-X表条目i */
                             my_interrupt_handler, // 中断处理函数
                             NULL, // dev_id
                             "my-driver:rx%d", i); // 中断名称
        if (ret) {
            // 错误处理
        }
    }
    ```

* MSI-X（Message Signaled Interrupts eXtended）是一种基于消息的中断机制。它允许设备（如网卡、GPU、NVMe SSD）通过向CPU写入一个特定的数据（消息）到特定的内存地址来请求中断，而不是使用传统的、基于专用引脚（IRQ线）的中断。

    系统软件（操作系统）会分配一块内存区域，称为 MSI-X Table。这个表中的每一项（Entry）都对应一个中断向量，包含：

    * 消息地址（Message Address）：中断消息要写入的目标地址。这个地址隐含了中断要发送给哪个CPU核心。

    * 消息数据（Message Data）：一个唯一的数据值，用来标识是哪个中断向量被触发。

    * 掩码位（Mask Bit）：用于临时禁用该中断。

    * Pending Bit：记录中断是否已发出但尚未被处理。

    虽然设备触发MSI-X的行为是一次内存写入，但整个系统（CPU、芯片组、内存控制器）被设计为能识别这次特殊的写入操作，并将其无缝地转换为一个中断信号送达CPU核心。

    MSI-X消息中指定的目标地址（Message Address） 并不指向普通的DRAM内存位置。它指向一个由CPU和芯片组预留的、特殊的物理地址范围。这个范围是专门用于处理消息信号中断的。

    芯片组通过内部的中断控制器（在现代x86系统中是APIC）架构，将一个“虚拟”的中断信号直接发送到步骤2a中确定的目标CPU核心。

    CPU核心收到这个信号后，会立即中断当前正在执行的指令流（当然，会在合理的边界处），并根据收到的向量号，去查找自己的中断描述符表（IDT），找到并执行对应的中断服务程序（ISR）。

    msix 中断并不是 cpu 轮询指定内存实现的，而是通过芯片组识别 pcie 事务类型实现的。
    
    msix 中断本质就是一次 pcie 事务（Transaction）。
    
    pcie 事务可能有很多类型：

    Memory Read

    Memory Write

    I/O Read

    I/O Write

    Message

    MSI 对应的事务为 Memory Write，而 msix 对应的事务为 Message (Message Signaled Interrupt)

    如果芯片组识别出来 pcie 事务是 message，又发现其写入的内存地址是为 MSI 中断信号预留的、特定的地址区域，那么就可以确认这是一个 msix 中断。