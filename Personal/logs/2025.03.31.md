* aggregate adj. 总数的，总计的，总体的 eg. aggregate class 聚合类

* 有关移位 + 类型转换

    ```cpp
    #include <stdio.h>
    #include <stdint.h>

    int main()
    {
        uint16_t a = 1;
        uint32_t b = a << 17;
        printf("b: %u\n", b);
        return 0;
    }
    ```

    查看反汇编，当`b`的类型为`uint32_t`时，会使用`movzx`先把`a`移动到 32 位寄存器`eax`中，然后再对寄存器`eax`移位。`movzx`指令的功能是用 0 填充高位，并送入寄存器，因此只适用于无符号整数。当`b`的类型为`uint16_t`时，则会使用普通`mov`指令将`a`送入寄存器。

    是否写成`uint32_t b = (uint32_t) a << 17;`，对汇编指令无影响。

    将 32 位数据转换成 16 数据同理：

    ```cpp
    #include <stdio.h>
    #include <stdint.h>

    int main()
    {
        uint32_t a = 1;
        uint16_t b = a << 14;
        printf("b: %u\n", b);
        return 0;
    }
    ```

    无论是否写成`uint16_t b = (uint32_t) a << 14;`，`a`的数据都会被直接按 16 字节加载到寄存器`eax`中，然后再进行移位。

    综上，我们移位时，最好不要发生类型转换，如果一定要转换，那么移位的位数不要超过 dst 变量的位宽。

    注：

    * 一个细节：当左移位的位数大于等于`dst`变量的位宽时，编译器生成的汇编会直接把数据`0`写入到`dst`中。