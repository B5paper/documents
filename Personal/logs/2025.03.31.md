* aggregate adj. 总数的，总计的，总体的 eg. aggregate class 聚合类

* 有关移位 + 类型转换

    ```cpp
    #include <stdio.h>
    #include <stdint.h>

    int main()
    {
        uint16_t a = 1;
        uint32_t b = a << 17;
        printf("b: %u\n", b);
        return 0;
    }
    ```

    查看反汇编，当`b`的类型为`uint32_t`时，会使用`movzx`先把`a`移动到 32 位寄存器`eax`中，然后再对寄存器`eax`移位。`movzx`指令的功能是用 0 填充高位，并送入寄存器，因此只适用于无符号整数。当`b`的类型为`uint16_t`时，则会使用普通`mov`指令将`a`送入寄存器。

    是否写成`uint32_t b = (uint32_t) a << 17;`，对汇编指令无影响。

    将 32 位数据转换成 16 数据同理：

    ```cpp
    #include <stdio.h>
    #include <stdint.h>

    int main()
    {
        uint32_t a = 1;
        uint16_t b = a << 14;
        printf("b: %u\n", b);
        return 0;
    }
    ```

    无论是否写成`uint16_t b = (uint32_t) a << 14;`，`a`的数据都会被直接按 16 字节加载到寄存器`eax`中，然后再进行移位。

    综上，我们移位时，最好不要发生类型转换，如果一定要转换，那么移位的位数不要超过 dst 变量的位宽。

    注：

    * 一个细节：当左移位的位数大于等于`dst`变量的位宽时，编译器生成的汇编会直接把数据`0`写入到`dst`中。

* lower bound, upper bound

    `lower_bound()`是找到**大于等于**指定元素的第一个元素，`upper_bound()`找到**大于**指定元素的第一个元素。

    ```cpp
    #include <vector>
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int find_lower_upper_bound(vector<int> &vec, int val)
    {
        auto iter = lower_bound(vec.begin(), vec.end(), val);
        if (iter == vec.end())
        {
            cout << "fail to find lower bound" << endl;
            return -1;
        }
        int idx = distance(vec.begin(), iter);
        cout << "lower bound idx: " << idx << ", val: " << *iter << endl;

        iter = upper_bound(vec.begin(), vec.end(), val);
        if (iter == vec.end())
        {
            cout << "fail to find upper bound" << endl;
            return -1;
        }
        idx = distance(vec.begin(), iter);
        cout << "upper bound idx: " << idx << ", val: " << *iter << endl;

        return 0;
    }

    int main()
    {
        vector<int> vec{1, 2, 3, 4, 4, 6, 7};
        for (int elm: vec)
            cout << elm << ", ";
        cout << endl << endl;

        int val = 4;
        cout << "val: " << val << endl;
        find_lower_upper_bound(vec, val);
        cout << endl;

        val = 5;
        cout << "val: " << val << endl;
        find_lower_upper_bound(vec, val);
        cout << endl;

        val = 7;
        cout << "val: " << val << endl;
        find_lower_upper_bound(vec, val);

        return 0;
    }
    ```

    output:

    ```
    1, 2, 3, 4, 4, 6, 7,

    val: 4
    lower bound idx: 3, val: 4
    upper bound idx: 5, val: 6

    val: 5
    lower bound idx: 5, val: 6
    upper bound idx: 5, val: 6

    val: 7
    lower bound idx: 6, val: 7
    fail to find upper bound
    ```

    注意，`lower_bound()`和`upper_bound()`都是使用二分查找法，要求原数组有序。

    问题：如果`vec`是从小到大排列，我想找到小于等于`val`的第一个数，以及小于`val`的第一个数，该怎么办？如果`vec`已经是从大到小排列，又该如何找大于等于`val`的第一个作业君，大于`val`的第一个数；以及小于等于`val`的第一个数，小于`val`的第一个数。

* c++ partial sort

    `partial_sort()`可以找到数组中前`n`个最大/最小的值，并对其进行排序。

    > Rearranges elements such that the range `[first, middle)` contains the sorted `middle − first` smallest elements in the range `[first, last)`.

    syntax:

    ```cpp
    template< class RandomIt >
    void partial_sort( RandomIt first, RandomIt middle, RandomIt last );

    template< class RandomIt, class Compare >
    void partial_sort( RandomIt first, RandomIt middle, RandomIt last, Compare comp );
    ```

    example:

    ```cpp
    #include <vector>
    #include <iostream>
    #include <algorithm>
    using namespace std;

    void print_vec(vector<int> &vec)
    {
        for (int i = 0; i < vec.size(); ++i)
        {
            cout << vec[i] << ", ";
        }
        cout << endl;
    }

    int main()
    {
        vector<int> vec{5, 4, 2, 1, 3};
        print_vec(vec);
        int n = 3;
        cout << "n = " << n << endl;
        partial_sort(vec.begin(), vec.begin() + n, vec.end());
        print_vec(vec);
        return 0;
    }
    ```

    output:

    ```
    5, 4, 2, 1, 3,
    n = 3
    1, 2, 3, 5, 4,
    ```

    可以看到 middle 的迭代器是不被包含的。当`n = 3`时，只对最小的 3 个数进行排序。

    `partial_sort()`也支持自定义 compare 函数：

    ```cpp
    #include <vector>
    #include <iostream>
    #include <algorithm>
    using namespace std;

    void print_vec(vector<int> &vec)
    {
        for (int i = 0; i < vec.size(); ++i)
        {
            cout << vec[i] << ", ";
        }
        cout << endl;
    }

    int main()
    {
        vector<int> vec{3, 1, 2, 5, 4};
        print_vec(vec);
        int n = 3;
        cout << "n = " << n << endl;
        partial_sort(vec.begin(), vec.begin() + n, vec.end(),
            [](int &a, int &b) {
                if (a > b)
                    return true;
                return false;
            }
        );
        print_vec(vec);
        return 0;
    }
    ```

    output:

    ```
    3, 1, 2, 5, 4,
    n = 3
    5, 4, 3, 1, 2,
    ```

    注：

    * 如果是比较简单的小于/大于功能，compare 使用的 lambda 表达式可以替换为`less()`或`greater()`。

        或者`less{}`，`greater{}`，用初始化列表创建匿名对象。

    问题：
    
    1. 如果想找到第`k`小/大的数，是否有算法比 partial sort 更快？

    1. 除了前面的两个 syntax，还有加入 policy 模板参数的 syntax，不知道干嘛用的

        ```cpp
        template< class ExecutionPolicy, class RandomIt >
        void partial_sort( ExecutionPolicy&& policy, RandomIt first, RandomIt middle, RandomIt last );

        template< class ExecutionPolicy, class RandomIt, class Compare >
        void partial_sort( ExecutionPolicy&& policy, RandomIt first, RandomIt middle, RandomIt last, Compare comp );
        ```

    1. 调研`nth_element()`, `partial_sort_copy()`, `stable_sort()`, `ranges::partial_sort()`

* 浮躁

    场景：地理上因为某块地有躁气，人们追求快而浮躁，就像在浮屠塔一样。此时有一个人初来乍到，被卷入纷争，不停地有人引诱，诈骗，躁动，疯狂，幸好这个人经受住了考验。离开此地后才发现这个地方向上冒着煞气or是个鬼城。这两个结局都挺不错的。

    人的精神世界来自于对物质的态度，来自于与自然的共处，来自于人与人之间的关系处理，来自与社会的联结，来自于自己的思想。精神世界的广阔程度与物质世界不相上下。精神世界经受的考验也与物质世界经受的考验（饥饿，温度，劳累等）相当。
