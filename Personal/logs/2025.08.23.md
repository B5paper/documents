* 新概念的理解

    两个重要标志：一，新概念可以被已有的旧概念解释；二，可以根据新概念对旧概念做出预测，最好是以前没有过的预测。

* `fork()`

    复制当前进程的资源，创建一个新的子进程。

    syntax:

    ```c
    #include <unistd.h>

    pid_t fork(void);
    ```

    如果返回值为 0，那么说明当前的进程已经来到了子进程，如果返回值为非 0，那么说明当前的进程仍是父进程。

    example:

    ```c
    #include <stdio.h>
    #include <unistd.h>

    int main() {
        pid_t pid = fork();

        if (pid < 0) {
            fprintf(stderr, "fail to fork\n");
            return -1;
        } else if (pid == 0) {  // pic == 0 means this is a child process
            printf("my pid: %d, my parent pid :%d\n", getpid(), getppid());
        } else {  // parent process
            printf("my pid: %d, my child pid: %d\n", getpid(), pid);
        }

        printf("a greeting from parent process and child process\n");
        return 0;
    }
    ```

    output:

    ```
    my pid: 886283, my child pid: 886284
    a greeting from parent process and child process
    my pid: 886284, my parent pid :886283
    a greeting from parent process and child process
    ```

    操作系统内核会为子进程创建一个新的 PCB，用于调度。

* `fork()`创建的是新的进程，不是新的线程，所以父进程与子进程的内存都是独立的

    example:

    ```c
    #include <stdio.h>
    #include <unistd.h>

    int main() {
        int val = 0;

        pid_t pid = fork();

        if (pid < 0) {
            fprintf(stderr, "fail to fork\n");
            return -1;
        } else if (pid == 0) {
            val = 456;
        } else {
            val = 123;
        }

        printf("val is %d\n", val);
        return 0;
    }
    ```

    output:

    ```
    val is 123
    val is 456
    ```

* 如果在 fork 前父进程打开了一个文件，拿到一个 fd，那么在 fork 后，父进程的 fd 和子进程的 fd 相同，并且共享同一组状态数据，比如 offset 等

    但是一个进程 close 了 fd，并不会使另一个进程 read 数据失败，因为 fd 采用引用计数机制。

    example:

    ```c
    #include <stdio.h>
    #include <fcntl.h>
    #include <unistd.h>

    int main() {
        int fd = open("msg.txt", O_RDONLY);
        if (fd < 0) {
            printf("fail to open file\n");
            return -1;
        }
        char buf[16] = {0};

        pid_t pid = fork();

        if (pid < 0) {
            fprintf(stderr, "fail to fork\n");
            return -1;
        } else if (pid > 0) {
            sleep(2);  // 主进程等待子进程读取文件数据
        }

        ssize_t bytes_read = read(fd, buf, 10);
        if (bytes_read < 10) {
            printf("fail to read\n");
            return -1;
        }

        printf("buf: [%s]\n", buf);

        if (pid == 0) {
            int ret = close(fd);
            if (ret != 0) {
                printf("fail to close fd\n");
                return -1;
            }
        } else {
            sleep(2);  // 主进程等子进程关闭 fd 后，再尝试读数据
            bytes_read = read(fd, buf, 5);
            buf[5] = '\0';
            printf("buf from parent process: [%s]\n", buf);
            int ret = close(fd);
            if (ret != 0) {
                printf("fail to close fd\n");
                return -1;
            }
        }

        return 0;
    }
    ```

    output:

    ```
    buf: [hello, wor]
    buf: [ld, nihao,]
    buf from parent process: [ zaij]
    ```

* `read(int fd, void *buf, size_t count);`读取的是 count 个字节，不会把`bus[count - 1]`设置为`\0`。

* `fsync()`

    将系统缓冲区中的内容写入到磁盘，阻塞等待。

    syntax:

    ```c
    #include <unistd.h>

    int fsync(int fd);
    ```

* fwrite() 相比系统调用 write() 增加了缓冲区，write() 在操作系统中也使用了缓冲区，这两个缓冲区还是一回事

    `fwrite()`的缓冲区是 C 运行时库（比如 glibc）设置的缓冲区，目的是减少系统调用。存在于进程的地址空间中，进程结束即消失。与此相关的`fflush()`本质是强制进行一次`write()`系统调用。

    `write()`的缓冲区 (page cache) 由操作系统提供，由所有进程、所有 fd 共享。

* `fcntl()`

    对文件描述符 fd 下发各种 control 命令。

    syntax:

    ```c
    #include <fcntl.h>

    int fcntl(int fd, int cmd, ... /* arg */ );
    ```

    常用功能（未验证）：

    * 复制文件描述符 (F_DUPFD, F_DUPFD_CLOEXEC)

        复制一个已有的文件描述符，创建一个新的描述符指向同一个文件。

        `fcntl(old_fd, F_DUPFD, new_fd);`

        比较智障的是，这个新复制的 new_fd 和 old_fd 共享同一个 fd struct，因此文件的 offset 仍是共享的。

    * 获取/设置文件描述符标志 (F_GETFD, F_SETFD)

        FD_CLOEXEC（Close-on-Execute），设置此标志后，当进程执行 exec() 系列函数加载新程序时，该文件描述符会被自动关闭，防止它被意外继承到新程序中。

        如果一个文件在打开时是 read only，那么后续不可以通过 fcntl() 改成 rdwr。fcntl() 的 F_SETFL 命令无法改变文件的访问模式（Access Mode）。

        可以改变的几个标记：

        O_APPEND：强制每次写入都追加到文件末尾。

        O_NONBLOCK：设置为非阻塞模式。

        O_ASYNC：启用信号驱动I/O。

        O_DIRECT：尝试最小化缓存效应。

    * 获取/设置文件状态标志 (F_GETFL, F_SETFL)

    * 管理文件锁 (F_GETLK, F_SETLK, F_SETLKW)

        作用：对文件区域施加建议性锁 (Advisory Lock)。

        F_GETLK：检查是否可以加锁。

        F_SETLK：尝试加锁（非阻塞，如果冲突立即返回错误）。

        F_SETLKW：尝试加锁（阻塞，如果冲突则等待直到锁可用）。

        这是一种“建议性”锁，意味着它只对同样使用 fcntl() 检查锁的进程有效。如果一个进程不检查锁直接读写，锁是无法阻止它的。

    * 信号驱动I/O (F_SETOWN, F_GETOWN, F_SETSIG, F_GETSIG)

        设置当文件描述符上发生I/O事件（例如数据可读）时，应该接收信号的进程或进程组。这是实现异步I/O的一种传统方式。

    整体看下来，`fcntl()`用处不大，处理的基本都是边角料情况。等用到了再说。

* `LIST_HEAD_INIT()`

    `LIST_HEAD_INIT()`展开为

    ```c
    #define LIST_HEAD_INIT(name) { &(name), &(name) }
    ```

    可以看到，主要是完成链表的静态初始化功能，将头节点指向自身。

    example:

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/list.h>
    #include <linux/slab.h>

    struct my_list_node {
        struct list_head list_head;
        int val;
    };

    struct list_head lst_head = LIST_HEAD_INIT(lst_head);

    int hello_init(void) {
        pr_info("in hello_init()...\n");
        struct my_list_node *new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 123;
        list_add(&new_node->list_head, &lst_head);
        new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 456;
        list_add(&new_node->list_head, &lst_head);
    	return 0;
    }

    void hello_exit(void) {
        pr_info("in hello_exit()...\n");
        struct my_list_node *cur_node, *tmp_node;
        list_for_each_entry_safe(cur_node, tmp_node, &lst_head, list_head) {
            pr_info("del node val: %d\n", cur_node->val);
            list_del(&cur_node->list_head);
            kfree(cur_node);
        }
    }

    module_init(hello_init);
    module_exit(hello_exit);
    MODULE_LICENSE("GPL");
    ```

    dmesg output:

    ```
    [ 2938.473855] in hello_init()...
    [ 2941.209560] in hello_exit()...
    [ 2941.209570] del node val: 456
    [ 2941.209575] del node val: 123
    ```

* `list_del_init()`

    删除完节点后，将此节点的 prev 和 next 指向自身。

    syntax:

    ```c
    #include <linux/list.h>

    void list_del_init(struct list_head *entry)
    ```

    example:

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/list.h>
    #include <linux/slab.h>

    struct my_list_node {
        struct list_head list_head;
        int val;
    };

    struct list_head lst_head = LIST_HEAD_INIT(lst_head);
    LIST_HEAD(lst_head_2);

    int hello_init(void) {
        pr_info("in hello_init()...\n");
        struct my_list_node *new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 123;
        list_add(&new_node->list_head, &lst_head);
        new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 456;
        list_add(&new_node->list_head, &lst_head);
    	return 0;
    }

    void hello_exit(void) {
        pr_info("in hello_exit()...\n");
        struct my_list_node *cur_node, *tmp_node;
        list_for_each_entry_safe(cur_node, tmp_node, &lst_head, list_head) {
            list_del_init(&cur_node->list_head);
            list_add(&cur_node->list_head, &lst_head_2);
        }
        
        list_for_each_entry_safe(cur_node, tmp_node, &lst_head_2, list_head) {
            pr_info("del node val: %d\n", cur_node->val);
            list_del(&cur_node->list_head);
            kfree(cur_node);
        }
    }

    module_init(hello_init);
    module_exit(hello_exit);
    MODULE_LICENSE("GPL");
    ```

    dmesg output:

    ```
    [ 4285.077823] in hello_init()...
    [ 4290.003627] in hello_exit()...
    [ 4290.003719] del node val: 123
    [ 4290.003754] del node val: 456
    ```

    这个函数通常用于将一个节点从一个链表中取出来，并准备好将它添加到另一个链表中。

    实测将上述代码中的`list_del_init()`替换成`list_del()`后，没有什么区别。

    `list_del()`将节点取出后，会将节点的`next`, `prev`设置为`LIST_POISON1`和`LIST_POISON2`；`list_del_init()`将节点取出后，会将节点的`next`, `prev`都指向自身。

* 将`struct list_head`内嵌到用户定义的`struct ListNode`中，可能是 linux c 没有泛型和模板的无奈之举

    如果内核直接实现

    ```c
    struct ListNode {
        struct ListNode *prev, *next;
        void *user_data;
        size_t user_data_len;
    }
    ```

    那么`kmalloc()`时无法把`user_data`的内存分出来，用户需要自己管理这块内存，而且还可能涉及到浅复制，深复制的问题。

    如果内核想实现

    ```cpp
    template<typename T>
    void list_add(T *list_head, T *new_node) {
        T *tmp_node = list_head->next;
        list_head->next = new_node;
        new_node->next = tmp_node;
        new_node->prev = list_head;
    }
    ```

    那么又没有模板机制。

    综合考虑，还是内嵌的方式最合适。

* `list_del_rcu()`

    RCU - Read-Copy-Update

    用于无锁删除链表中的节点。

    （未验证）

    多线程访问链表的情况下，`list_del()`在删除节点时，通常需要加锁保护。但是加锁会降低性能，如果想无锁删除节点，那么就需要用到`list_del_rcu()`。`list_del_rcu()`会先修改被删除节点前一个节点的 next 指针，然后调用 synchronize_rcu() 或 kfree_rcu() 等函数等待宽限期（Grace Period），确保所有在删除操作前开始的读临界区都结束后，才安全地释放该节点的内存。

    在宽限期结束前，可能仍有读者正在遍历链表并访问该节点的数据。由于 prev 指针未被修改，这些读者可以继续安全地向前遍历链表，而不会因为节点被删除而崩溃（不会遇到 LIST_POISON）。（为什么 reader 可以访问 prev 就不会崩溃？）

    适用于读多写少的链表。

    example:

    ```c
    // 假设一个RCU保护的链表
    struct my_data {
        int value;
        struct list_head list;
    };

    // 写者删除节点
    void delete_node(struct my_data *node)
    {
        spin_lock(&write_lock); // 写者之间仍需同步
        list_del_rcu(&node->list); // 1. 从链表逻辑删除
        spin_unlock(&write_lock);

        // 2. 等待所有读者离开宽限期
        synchronize_rcu(); 

        // 3. 现在安全地释放内存
        kfree(node);
    }

    // 读者遍历链表（无锁！）
    void reader(void)
    {
        struct my_data *node;

        rcu_read_lock(); // 标记进入RCU读临界区
        list_for_each_entry_rcu(node, &my_list, list) {
            // 安全地访问 node->value，即使它正被删除
            printk("%d\n", node->value);
        }
        rcu_read_unlock(); // 标记离开读临界区
    }
    ```

* 多路复用（select/poll/epoll）中的多路指的是独立的I/O流或连接通道，通常指指大量的网络 socket 连接，复用指的是复用同一个线程/进程。

    多路复用 - multiplexing

* `rsync`本身不可实时同步目录，只能配合`inotifywait`实现实时同步

    (未验证)

    1. 使用 bash 实现

        ```bash
        #!/bin/bash

        # 定义源目录和目标服务器目录
        SOURCE_DIR="/path/to/source/dir/"
        TARGET_DIR="/path/to/target/dir/"
        REMOTE_USER="username"
        REMOTE_HOST="remote_server_ip"

        # 开始监控 inotifywait
        inotifywait -mrq --timefmt '%Y-%m-%d %H:%M:%S' --format '%T %w%f %e' \
          -e create,delete,modify,move,attrib \
          ${SOURCE_DIR} | while read time file event
        do
          echo "-----"
          echo "Event: $event"
          echo "File: $file"
          echo "Time: $time"

          # 触发 rsync 同步
          # 注意：这里使用了 --delete 选项，如果源端删除了文件，目标端也会删除。
          # 如果不希望这样，请移除 --delete 选项。
          rsync -avz --delete ${SOURCE_DIR} ${REMOTE_USER}@${REMOTE_HOST}:${TARGET_DIR}

          # 可选：输出同步完成时间
          echo "Sync completed at: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "-----"
        done
        ```

        参数详解：

        inotifywait:

            -m: --monitor，持续监控，而不是触发一次就退出。

            -r: --recursive，递归监控目录。

            -q: --quiet，减少不必要的输出。

            --timefmt: 指定时间格式。

            --format: 指定事件输出格式。

            -e: 指定要监控的事件，最重要的一些事件包括：

                create (文件/目录创建)

                delete (文件/目录删除)

                modify (文件内容修改)

                move (文件/目录移动)

                attrib (文件属性变化，如权限、时间戳)

        rsync:

            -a: --archive，归档模式，保持所有文件属性，等同于 -rlptgoD。

            -v: --verbose，输出详细信息。

            -z: --compress，传输时压缩，节省带宽。

            --delete: 谨慎使用。让目标端和源端保持完全一致，源端删除的文件，目标端也会删除。

        运行：

        ```bash
        chmod +x live_sync.sh
        # 前台运行
        ./live_sync.sh

        # 或者放入后台运行，并将输出重定向到日志文件
        nohup ./live_sync.sh > live_sync.log 2>&1 &
        ```

    2. 使用`lsyncd`

    综合看来，`rsync`本身没法同步，自己写 bash 太麻烦，要不直接用`lsyncd`，要不直接用 nfs，或 sshfs。（有空可以调研下 nfs, sshfs, lsyncd 底层同步机制的区别）

* strace

    strace 可以记录一个进程在运行时与内核之间的所有系统调用（system calls）和接收到的信号（signals）

    example:

    ```bash
    strace ls
    ```

    常用方式（未验证）：

    * `strace <command>`：跟踪一个命令的执行。

    * `strace -p <pid>`：附着到一个正在运行的进程上进行跟踪。

    * `strace -e trace=<type>`：只跟踪特定类型的系统调用，如 strace -e trace=open,read ls 只跟踪 open 和 read 调用。

    * `strace -o output.txt`：将输出重定向到文件，便于分析。

    * `strace -c`：在程序结束后生成一个统计报告，显示各个系统调用的次数、时间和错误。

* `file_operations`中的`.owner`主要用于引用计数，防止内核模块在仍被进程使用（即其代码正在执行）时被意外卸载

    `struct module *owner`通常被设置为`THIS_MODULE`

    当进程打开一个设备文件时，内核内部会调用 try_module_get(module) 来尝试增加该模块的引用计数。

    当进程关闭设备文件时，内核会调用 module_put(module) 来减少模块的引用计数。

    当执行 rmmod 命令时，内核会检查目标模块的引用计数。如果计数大于 0（表示还有进程正在使用该模块提供的功能），卸载操作会失败并提示 Module XXX is in use。只有当引用计数为 0 时，卸载才会成功进行。

    linux 内核中有些 module 是永久存在的，不需要被卸载，为了区分哪些需要计数，哪些不需要，内核通过`struct module*`指针来判断。对于内置的 module，`.owner`为`NULL`。

* `kzalloc()`

    申请内存，并将内存置 0.

* `list_first_entry()`

    给定`struct list_head*`指针，拿到

    syntax:

    ```c
    #include <linux/list.h>

    list_first_entry(ptr, type, member)
    ```

    example:

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/list.h>
    #include <linux/slab.h>

    struct my_list_node {
        struct list_head list_head;
        int val;
    };

    struct list_head lst_head;

    int hello_init(void) {
        pr_info("in hello_init()...\n");
        INIT_LIST_HEAD(&lst_head);
        struct my_list_node *new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 123;
        list_add(&new_node->list_head, &lst_head);
        new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 456;
        list_add(&new_node->list_head, &lst_head);
        struct my_list_node *node = list_first_entry(&lst_head, struct my_list_node, list_head);
        pr_info("first entry val: %d\n", node->val);
    	return 0;
    }

    void hello_exit(void) {
        pr_info("in hello_exit()...\n");
        struct my_list_node *cur_node, *tmp_node;
        list_for_each_entry_safe(cur_node, tmp_node, &lst_head, list_head) {
            list_del(&cur_node->list_head);
            kfree(cur_node);
        }
    }

    module_init(hello_init);
    module_exit(hello_exit);
    MODULE_LICENSE("GPL");
    ```

    dmesg output:

    ```
    [13557.594168] in hello_init()...
    [13557.594275] first entry val: 456
    [13564.272870] in hello_exit()...
    ```

    与其对应的宏为`list_last_entry()`。

* `list_next_entry()`

    根据当前 node 指针，拿到下一个 node 的指针。

    ```syntax
    ptr = list_next_entry(pos, member)
    ```

    example:

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/list.h>
    #include <linux/slab.h>

    struct my_list_node {
        struct list_head list_head;
        int val;
    };

    struct list_head lst_head;

    int hello_init(void) {
        pr_info("in hello_init()...\n");
        INIT_LIST_HEAD(&lst_head);
        struct my_list_node *new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 123;
        list_add(&new_node->list_head, &lst_head);
        new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 456;
        list_add(&new_node->list_head, &lst_head);
        struct my_list_node *node = list_first_entry(&lst_head, struct my_list_node, list_head);
        pr_info("first entry val: %d\n", node->val);
        node = list_next_entry(node, list_head);
        pr_info("next entry val: %d\n", node->val);
    	return 0;
    }

    void hello_exit(void) {
        pr_info("in hello_exit()...\n");
        struct my_list_node *cur_node, *tmp_node;
        list_for_each_entry_safe(cur_node, tmp_node, &lst_head, list_head) {
            list_del(&cur_node->list_head);
            kfree(cur_node);
        }
    }

    module_init(hello_init);
    module_exit(hello_exit);
    MODULE_LICENSE("GPL");
    ```

    dmesg output:

    ```
    [16486.123036] in hello_init()...
    [16486.123155] first entry val: 456
    [16486.123160] next entry val: 123
    [16492.787828] in hello_exit()...
    ```

    可以看到，`list_first_entry()`传进去的是`list_head`，而`list_next_entry()`传进去的是我们自己的 node struct。

    与其对应的宏为`list_prev_entry()`。
