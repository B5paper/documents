* c 使用`a+`向文件中追加内容

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    int main()
    {
        FILE *f = fopen("aaa.txt", "a+");
        char *str = "hello, world\n";
        size_t str_len = strlen(str);  // 13
        printf("str len: %lu\n", str_len);
        fwrite(str, str_len, 1, f);
        fclose(f);
    }
    ```

* ptx note

    * `.param` state space 是可寻址（addressable）的，只读（read-only）的。

    * The kernel parameter variables are shared across all CTAs from all clusters within a grid.

        这里的 grid 只是编程上的概念，并不是硬件上的概念。在 grid 上共享，那么它在硬件的什么地方？在 global memory 上吗？

    * `ld.param`可以将 param 的数据加载到寄存器里，`mov`可以将 param 的地址加载到寄存器里

        examples:

        ```asm
        .entry foo ( .param .b32 N, .param .align 8 .b8 buffer[64] )
        {
            .reg .u32 %n;
            .reg .f64 %d;

            ld.param.u32 %n, [N];
            ld.param.f64 %d, [buffer];
            ...
        ```

        ```asm
        .entry bar ( .param .b32 len )
        {
            .reg .u32 %ptr, %n;

            mov.u32      %ptr, len;
            ld.param.u32 %n, [%ptr];
            ...
        ```

    * Kernel function parameters may represent normal data values, or they may hold addresses to objects in constant, global, local, or shared state spaces.

        `.param`变量可能会来自不同的地址空间，在 ptx 汇编中，需要提供它来自哪个 state space。

        但是上面的 example 并没有提供 state space，为什么？

    * The current implementation does not allow creation of generic pointers to constant variables (cvta.const) in programs that have pointers to constant buffers passed as kernel parameters.

        generic pointers 不允许指向常数变量，有专门的`cvta.const`指令创建指向 const 变量的指针。

    * `.ptr`可以为`.param`添加额外的属性（attribute），这里的属性主要有两种，一个是`.space`，另一个是`.align`。

        语法如下：

        ```asm
        .param .type .ptr .space .align N  varname
        .param .type .ptr        .align N  varname

        .space = { .const, .global, .local, .shared };
        ```

        `.align`表示 4 字节对齐（aligned to a 4 byte boundary.）。

        example:

        ```asm
        .entry foo ( .param .u32 param1,
                     .param .u32 .ptr.global.align 16 param2,
                     .param .u32 .ptr.const.align 8 param3,
                     .param .u32 .ptr.align 16 param4  // generic address
                                                       // pointer
        ) { .. }
        ```

        这个形式看起来比较像一个函数，`.param`标记了一个参数的开始。是否存在不是`.param`的参数？或者说，当一个参数不被`.param`标记时，是否会报错？

* nccl tmp

    * cu host alloc 的调用路径

        `ncclAsyncJobMain()` -> `ncclCommInitRankFunc()` -> `initTransportsRank()` -> `devCommSetup()` -> `devCommSetup()` -> `ncclCudaHostCalloc()`