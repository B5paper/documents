* `scipy.sparse.lil_matrix`

    scipy.sparse.lil_matrix 是 SciPy 中用于存储稀疏矩阵的一种数据结构，特别适用于逐步构建和修改稀疏矩阵的场景。

    LIL (List of Lists) 格式将稀疏矩阵存储为：

    * 行列表：每个元素对应矩阵的一行

    * 每行存储：两个列表，分别存储非零元素的列索引和值

    这种结构使得按行操作（添加、删除、修改元素）非常高效。

    **基本用法:**

    * 创建 LIL 矩阵

        ```py
        import numpy as np
        from scipy.sparse import lil_matrix

        # 方法1：指定形状创建空矩阵
        matrix = lil_matrix((3, 3))  # 3x3 矩阵

        # 方法2：从稠密数组创建
        dense_array = np.array([[1, 0, 0], [0, 0, 2], [0, 3, 0]])
        matrix = lil_matrix(dense_array)

        # 方法3：从其他稀疏格式转换
        from scipy.sparse import csr_matrix
        csr_mat = csr_matrix((3, 3))
        lil_mat = csr_mat.tolil()
        ```

    * 元素赋值和修改

        ```py
        # 创建 3x3 矩阵
        matrix = lil_matrix((3, 3))

        # 逐个元素赋值
        matrix[0, 0] = 1
        matrix[1, 2] = 2
        matrix[2, 1] = 3

        # 批量赋值
        matrix[0, [1, 2]] = [4, 5]  # 第0行，第1、2列
        matrix[[1, 2], 0] = [6, 7]  # 第1、2行，第0列

        print(matrix.toarray())
        # 输出：
        # [[1. 4. 5.]
        #  [6. 0. 2.]
        #  [7. 3. 0.]]
        ```

    * 访问矩阵数据

        ```py
        # 访问单个元素
        print(matrix[0, 0])  # 1.0

        # 访问整行
        print(matrix[0].toarray())  # [[1. 4. 5.]]

        # 获取非零元素信息
        print("行指针:", matrix.rows)     # 每行的列索引列表
        print("数据值:", matrix.data)     # 每行的数值列表

        # 转换为稠密数组
        dense = matrix.toarray()
        ```

    * 实际应用示例

        ```py
        # 示例：构建邻接矩阵
        n_nodes = 5
        adj_matrix = lil_matrix((n_nodes, n_nodes))

        # 添加边（无向图）
        edges = [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4)]
        for i, j in edges:
            adj_matrix[i, j] = 1
            adj_matrix[j, i] = 1  # 无向图对称

        print("邻接矩阵:")
        print(adj_matrix.toarray())

        # 转换为其他格式进行高效运算
        csr_adj = adj_matrix.tocsr()  # 转换为CSR格式进行矩阵运算
        ```

    * 格式转换

        ```py
        # 转换为其他稀疏格式
        csr_matrix = matrix.tocsr()   # 压缩稀疏行格式（高效计算）
        csc_matrix = matrix.tocsc()   # 压缩稀疏列格式（高效列操作）
        coo_matrix = matrix.tocoo()   # 坐标格式（快速构建）

        # 转换回稠密矩阵
        dense_matrix = matrix.toarray()
        ```

    **使用建议**

    * 构建阶段：使用 LIL 格式进行频繁的元素修改

    * 计算阶段：转换为 CSR/CSC 格式进行数学运算

    * 内存敏感：对于超大矩阵，考虑使用 COO 格式

* vscode 中 gdb pretty print

    ```json
    "configurations": [{
        "name": "(gdb) Launch",
        // ...
        "setupCommands": [
            {
                "description": "Enable pretty-printing for gdb",
                "text": "-enable-pretty-printing",
            },
            // ...
        ]
    }]
    ```

    必须设置`-enable-pretty-printing`这个才可以直接显示 string 的内容。否则显示的都是原始的指针。

* `#pragma`

    #pragma 是一个预处理器指令，其核心作用是向特定的编译器发出特殊的命令或指示，从而控制编译器在编译过程中的特定行为。

    在一个编译器（如GCC）中有效的 #pragma 指令，在另一个编译器（如MSVC）中可能完全无效，或者具有不同的含义。

    如果希望代码能在多种编译器上编译，需要为不同的编译器提供相应的 #pragma 指令，通常配合 #ifdef 等宏来判断编译器。

    **常见用途举例:**

    * 防止头文件被重复包含

        这是最经典、最跨平台的用法之一。虽然可以用 #ifndef、#define、#endif 宏来实现，但 #pragma once 更简洁。

        ```cpp
        // 在 header.h 的开头写上
        #pragma once
        // ... 头文件的内容
        ```

        作用：告诉编译器，这个文件只被包含一次。可以有效避免因头文件被多次包含而引发的重定义错误。

    * 警告管理

        在大型项目中，有时需要暂时禁用某些编译器警告。

        ```cpp
        // 保存当前的警告状态
        #pragma warning(push)
        // 禁用第 4996 号警告（例如：不安全的函数如 strcpy 的警告）
        #pragma warning(disable: 4996)
        // 这里写会触发警告的代码，比如使用 strcpy
        // ...
        // 恢复之前保存的警告状态
        #pragma warning(pop)
        ```

        作用：精准地控制编译器在特定代码段发出或忽略哪些警告，保持代码整洁。

    * 指定代码对齐方式

        控制结构体或变量的内存对齐方式，这对底层硬件操作或网络传输很重要。

        ```cpp
        // 指定按 1 字节对齐，取消填充字节
        #pragma pack(push, 1)
        struct MyStruct {
            char a;    // 1 byte
            int b;     // 4 bytes
            // 如果没有 #pragma pack，这里可能会有 3 字节的填充，总大小为 8 字节。
        };
        #pragma pack(pop) // 恢复之前的对齐方式
        ```

        作用：确保结构体在内存中的布局是紧凑且可预测的，总大小在这里是 1+4=5 字节。

    * 优化提示

        给编译器提供优化建议。

        ```cpp
        // 提示编译器这个循环的次数很少，值得做循环展开等优化
        #pragma loop(short_loops)
        for (int i = 0; i < 4; i++) {
            // ...
        }
        ```

    * 指定代码节

        将函数或数据放入特定的段（Section）。

        ```cpp
        // 将初始化代码放入名为 "INIT" 的段
        #pragma code_seg("INIT")
        void InitializeHardware() {
            // 硬件初始化代码
        }
        ```

        作用：在系统编程中，常用于控制不同功能的代码在内存中的布局。

* ?： 在量词（如 *）之后使用，表示“非贪婪”或“最小”模式。它会匹配尽可能少的字符，直到满足后续条件（即遇到 phrase\.）。

* torchvision.transforms 中常用的 augmentation 方法：

    * 图像预处理 & 基本变换

        ```py
        # Resize：调整图像尺寸
        transforms.Resize((256, 256))

        # CenterCrop / RandomCrop：中心/随机裁剪
        transforms.RandomCrop(224)

        # Pad：边缘填充
        transforms.Pad(50, fill=255)
        ```

    * 颜色 & 亮度变换

        ```py
        # ColorJitter：随机调整亮度、对比度、饱和度和色调
        transforms.ColorJitter(brightness=0.2, contrast=0.2, saturation=0.2, hue=0.1)

        # Grayscale / RandomGrayscale：转灰度图
        transforms.RandomGrayscale(p=0.1)

        # RandomAdjustSharpness / RandomAutocontrast：调整锐度、自动对比度
        ```

    * 几何变换

        ```py
        # RandomHorizontalFlip / RandomVerticalFlip：随机水平/垂直翻转
        transforms.RandomHorizontalFlip(p=0.5)

        # RandomRotation：随机旋转
        transforms.RandomRotation(degrees=30)

        # RandomAffine：随机仿射变换（平移、旋转、缩放、剪切）
        transforms.RandomAffine(degrees=0, translate=(0.1, 0.1))

        # RandomPerspective：随机透视变换
        ```

    * 模糊 & 噪声

        ```py
        # GaussianBlur：高斯模糊
        transforms.GaussianBlur(kernel_size=5)

        # RandomErasing：随机擦除（CutOut）
        transforms.RandomErasing(p=0.5)
        ```

    * 标准化 & 张量转换

        ```py
        # ToTensor：将PIL图像或NumPy数组转换为张量，并缩放到 [0,1]
        transforms.ToTensor()

        # Normalize：标准化（减均值、除标准差）
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ```

    * 组合变换

        使用 Compose 将多个变换组合：

        ```py
        transform = transforms.Compose([
            transforms.Resize(256),
            transforms.RandomCrop(224),
            transforms.RandomHorizontalFlip(),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ])
        ```

* 一些问题

    * 定义铺排，没有节奏

        讲完一个定义 A，马上讲下一个定义 B。在阅读定义 B 时，读者是否已经理解了定义 A？定义 A 和之前讲的定义 C, D, E 都有什么相似和不同？有什么联系？如果定义 A 的理解难度比定义 B 大，那么是否应该将定义 A 多设置些篇幅，让读者停留的时间更长一点？

    * 只有从前到后的叙述，没有倒推的分析

        我们为了解决什么问题才提出的定义 A？不用定义 A，用定义 B 行不行？定义 A 是谁最先提出来的，又是怎样发展成现在这个样子的？对定义 A 加一些条件，删一些条件，还能用吗？

        因为总是线性叙述，线性学习，所以正好印证了之前的推断，学习效率很低，学了一堆概念，但是不知道有什么用。

* `茉莉绿茶 + 糖`不好喝

    没有`桂花 + 红茶 + 糖`好喝。