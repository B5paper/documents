* 有关 graph 数据结构的渐进构造

    图由点（vertex）和边（edge）构成，点与点之间用有向边相连，只要能让这个信息存储起来，就可以处理图。

    如果基于点去构造，我们可以这样存储：

    ```cpp
    struct Vertex
    {
        vector<Vertex*> edges;
    };

    struct Graph
    {
        // 这里不能使用 vertor<Vertex> verts;
        // 因为 verts 的大小改变时，Vertex* 会改变，此时 vertex 中存储的 edges 都会失效
        vector<Vertex*> verts;
        Vertex* add_vert() {
            Vertex *vert = new Vertex;
            verts.push_back(vert);
            return vert;
        }
        ~Graph() {
            for (Vertex *vert_ptr: verts) {
                delete vert_ptr;
            }
        }
    };

    int main()
    {
        Graph graph;
        Vertex *vert = graph.add_vert();
        Vertex *vert_2 = graph.add_vert();
        vert.edges.push_back(vert_2);
        return 0;
    }
    ```

    这样的话，新增加 vert，只能按 edge 的依赖添加，比较麻烦。

    ```cpp
    int main()
    {
        Graph graph;
        for (int i = 0; i < 10; ++i)
        {
            graph.add_vert();
        }
        graph.verts[0]->edges.push_back(graph.verts[1]);
        return 0;
    }
    ```

    像这样，把所有 vert 都构建好，然后再添加 edge，就没有依赖的问题了。

    但是我们进一步想一下，既然都用索引了，我们存指针是否没有必要。

    以上是基于 vertex 构建的图，后面我们讨论基于 edge 构建的图。

* 不可能使用单个 path 存储 bfs 搜索到的路径

    由于 bfs 是由内层向外层一层一层搜索，并且外层不保存内层的信息，所以不可能使用单个 path 记录 bfs 的搜索结果。

    ```
    0 -> 1 -> 2
      -> 3 -> 4
    ```

    假如 0 有两条边，分别指向 1 和 3，我们想搜索`0 -> ... -> 2`的 path。首先把 0 的下一层节点放到 queue 里：`1, 3`，然后我们遍历 1 和 3 的下一个节点，注意，当 path 为`0 -> 3`时，新的 queue 为`2, 4`，此时我们再搜索 2，已经无法知道 2 的上一个节点是什么了，path 无法从`0 -> 3`修正到`0 -> 1 -> 2`。

    如果我们每次往 queue 里存储`pair(prev_vert, vert)`是否可以解决这个问题？不可以。例子：

    ```
    0 -> 1 -> 2 -> 3
      -> 4 -> 5 -> 6
    ```

    当 path 为 0 -> 4 -> 5 时，开始搜索 3，我们根据 queue 中的`pair(prev_vert, vert)`数据，得知 3 的上一个节点是 2，但是无法知道 2 的上一个节点是什么。path 中的 4 无论如何无法变成 1.

    由此可见，bfs 搜索时，要么只记录最短路径的节点数，要么就记录所有搜索的 path，这样才能返回具体的 path。

* 基于 vert + 指针的 graph，可读性太差

    ```cpp
    #include <string>
    #include <stdio.h>
    #include <iostream>
    #include <vector>
    #include <unordered_map>
    using namespace std;

    struct Vertex
    {
        vector<Vertex*> edges;
    };

    struct Graph
    {
        vector<Vertex*> verts;

        Vertex* add_vert() {
            Vertex *vert_ptr = new Vertex;
            verts.push_back(vert_ptr);
            return vert_ptr;
        }
        
        ~Graph() {
            for (Vertex *vert_ptr : verts) {
                delete vert_ptr;
            }
        }

        struct VertexPtrHash {
            size_t operator()(const pair<Vertex*, Vertex*> &src_dst) const
            {
                return hash<void*>()(src_dst.first) ^ hash<void*>()(src_dst.second);
            }
        };

        // <<src, dst>, path>
        unordered_map<pair<Vertex*, Vertex*>, vector<Vertex*>, VertexPtrHash> paths;
        int search_path_bfs(vector<Vertex*> **path_ptr, Vertex *src_vert, Vertex *dst_vert) {
            auto iter = paths.find({src_vert, dst_vert});
            if (iter != paths.end()) {
                *path_ptr = &iter->second;
                return 0;
            }
            vector<Vertex*> vert_queue_cur, vert_queue_nex;
            vert_queue_cur.push_back(src_vert);
            while (!vert_queue_cur.empty()) {
                for (int i = 0; i < vert_queue_cur.size(); ++i) {
                    Vertex *cur_vert = vert_queue_cur[i];
                    for (int j = 0; j < cur_vert->edges.size(); ++j) {
                        Vertex *nex_vert = cur_vert->edges[j];
                        if (paths.find({src_vert, nex_vert}) != paths.end())
                            continue;
                        vector<Vertex*> &path_src_to_cur = paths[{src_vert, cur_vert}];
                        vector<Vertex*> &path_src_to_nex = paths[{src_vert, nex_vert}];
                        path_src_to_nex = path_src_to_cur;
                        path_src_to_nex.push_back(nex_vert);
                        if (nex_vert == dst_vert) {
                            *path_ptr = &path_src_to_nex;
                            return 0;
                        }
                        vert_queue_nex.push_back(nex_vert);
                    }
                }
                vert_queue_cur = vert_queue_nex;
                vert_queue_nex.clear();
            }
            *path_ptr = nullptr;
            return -1;
        }
    };

    int main()
    {
        Graph graph;

        for (int i = 0; i < 7; ++i)
        {
            graph.add_vert();
        }
        graph.verts[0]->edges.push_back(graph.verts[1]);
        graph.verts[0]->edges.push_back(graph.verts[2]);
        graph.verts[0]->edges.push_back(graph.verts[3]);
        graph.verts[1]->edges.push_back(graph.verts[2]);
        graph.verts[1]->edges.push_back(graph.verts[4]);
        graph.verts[2]->edges.push_back(graph.verts[5]);
        graph.verts[3]->edges.push_back(graph.verts[5]);
        graph.verts[4]->edges.push_back(graph.verts[5]);
        graph.verts[5]->edges.push_back(graph.verts[6]);

        Vertex *src_vert = graph.verts[0];
        Vertex *dst_vert = graph.verts[6];
        vector<Vertex*> *path_ptr;
        int ret = graph.search_path_bfs(&path_ptr, src_vert, dst_vert);
        if (ret != 0) {
            printf("fail to find a path\n");
            return -1;
        }

        vector<Vertex*> &path = *path_ptr;
        printf("%p", src_vert);
        for (int i = 0; i < path.size(); ++i)
        {
            printf(" -> %p", path[i]);
        }
        putchar('\n');

        return 0;
    }
    ```

    output:

    ```
    (base) hlc@hlc-VirtualBox:~/Documents/Projects/cpp_test$ ./main
    0x6041d45d7eb0 -> 0x6041d45d7ed0 -> 0x6041d45d7fd0 -> 0x6041d45d7ff0
    (base) hlc@hlc-VirtualBox:~/Documents/Projects/cpp_test$ ./main
    0x5da664fc1eb0 -> 0x5da664fc1ed0 -> 0x5da664fc1fd0 -> 0x5da664fc1ff0
    ```

    可以看到，如果不存储额外信息，我们只能拿到 ptr，并且每次运行程序时会变化，对人类不友好。

    代码实现里的一些设计：

    * 使用`vector<Vertex*> edges`存储 edges，而不是`vector<Vertex>`，是为了使得 vertex 的指针由我们控制，不会随 vector 的扩容而改变。代价是我们需要手动 new 和 delete Vertex，好在工作量并不大，逻辑也简单。

        另外，这里的 edge 直接指向了下一个节点，如果我们需要存储一些边的权重之类的信息，那么这样的结构是做不到的。

    * 使用`vector<Vertex*> verts;`存储所有的 vert 指针。我们必须要有一个 container 来存储所有的指针，图不是树，不可能使用单个 root 就遍历所有节点。

    * 由于前面的数据结构是 vertex 指针，所以我们索性不使用数组`paths[i][j]`来快速定位 path 了，因为如果使用索引，我们还不如从一开始就对所有 vertex 使用索引。

        `unordered_map<pair<Vertex*, Vertex*>, vector<Vertex*>, VertexPtrHash> paths;`

        问题是如果使用了 vertex ptr，该如何存储能快速查找的 path 呢？似乎只有哈希表或红黑树了。这里我们选择哈希表。

        由于`pair<Vertex*, Vertex*>`是我们自定义的类型，所以我们还需要实现一个配套的 hash 函数：

        ```cpp
        struct VertexPtrHash {
            size_t operator()(const pair<Vertex*, Vertex*> &src_dst) const
            {
                return hash<void*>()(src_dst.first) ^ hash<void*>()(src_dst.second);
            }
        };
        ```

        `unordered_map<>`的尖括号内需要填类型，所以我们使用 struct 实现一个仿函数，作为类型。

    * `auto iter = paths.find({src_vert, dst_vert});`

        因为 bfs 搜索需要不断记录 path，所以我们使用记忆化搜索，如果之前搜索过了这条路径，就直接返回。

    * `vector<Vertex*> vert_queue_cur, vert_queue_nex;`

        使用`queue<>`并不会更好，queue 不支持索引，所以 debug 时不好定位，而且 queue 占的内存并不比 vector 小。

        或许使用 queue 的唯一好处是只需要一个 queue 就可以完成 bfs:

        ```cpp
        queue<Vertex*> que;
        que.push(src_vert);
        while (!que.empty())
        {
            Vertex *cur_vert = que.front();
            que.pop();
            for (auto nex_vert: cur_vert->edges)
            {
                // ...
                // if not searched and not in que
                que.push(nex_vert);
            }
        }
        ```

        如果不介意每次都从尾部开始搜索的话，其实 vector 也能做到这一点：

        ```cpp
        vector<Vertex*> que;
        que.push_back(src_vert);
        while (!que.empty())
        {
            Vertex *cur_vert = que.back();
            que.pop_back();
            for (auto nex_vert: cur_vert->edges)
            {
                // ...
                // if not searched and not in que
                que.push_back(nex_vert);
            }
        }
        ```

    * que 中有可能出现重复的 entry，因为只判断了是否 processed。但是不影响算法收敛

        ```cpp
        if (paths.find({src_vert, nex_vert}) != paths.end())
            continue;
        ```

    * `vector<Vertex*> &path_src_to_cur = paths[{src_vert, cur_vert}];`

        pair`{src_vert, cur_vert}`竟然也能作为 key，放在`[]`里索引。用习惯了 string 作 key，这种方式初看有点邪门。

    * 如果搜索到 dst_vert 了，那么我们就提前停止

        ```cpp
        if (nex_vert == dst_vert) {
            *path_ptr = &path_src_to_nex;
            return 0;
        }
        ```

        这样其实是 lazy search 的方式。如果实际场景是 init 时对时间不敏感，但是在 query 时对时间敏感，那么还不如在 init 时 search all paths，这样 query 单条 path 时就没有负担了。

        如果 graph 中无意义的顶点比较多，有意义的顶点只有有限个，那么可以使用 lazy search 的方式。

    * 由于返回值可能为空，所以不能返回引用，我们使用指针的指针 + return code 的方式来返回搜索结果

        ```cpp
        *path_ptr = nullptr;
        return -1;
        ```

    * `graph`的初始化比较繁琐，这个过程完全可以索引化

        ```cpp
        for (int i = 0; i < 7; ++i)
        {
            graph.add_vert();
        }
        graph.verts[0]->edges.push_back(graph.verts[1]);
        graph.verts[0]->edges.push_back(graph.verts[2]);
        graph.verts[0]->edges.push_back(graph.verts[3]);
        graph.verts[1]->edges.push_back(graph.verts[2]);
        graph.verts[1]->edges.push_back(graph.verts[4]);
        graph.verts[2]->edges.push_back(graph.verts[5]);
        graph.verts[3]->edges.push_back(graph.verts[5]);
        graph.verts[4]->edges.push_back(graph.verts[5]);
        graph.verts[5]->edges.push_back(graph.verts[6]);
        ```

        经过索引化后为：

        ```cpp
        vector<pair<int, int>> tmp_edges {
            {0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 4},
            {2, 5}, {3, 5}, {4, 5}, {5, 6}
        };

        for (pair<int, int> &edge: tmp_edges)
        {
            graph.verts[edge.first]->edges.push_back(graph.verts[edge.second]);
        }
        ```

        看起来，在初始化时，使用索引更方便。

    * 这种 print path　的方式挺好的，也不用额外判断是否到了最后一个 vertex:

        ```cpp
        vector<Vertex*> &path = *path_ptr;
        printf("%p", src_vert);
        for (int i = 0; i < path.size(); ++i)
        {
            printf(" -> %p", path[i]);
        }
        putchar('\n');
        ```

* bfs 中，重复搜索点的判断

    只有一个 entry 为 not searched (processed) and not in current queue and not in next queue 才能精确判断这个 entry 应该被 push 到 next queue 里。如果我们只判断了 not processed，queue 中会有重复，但是不影响结果的收敛性。

    example:

    ```
    0 -> 1
      -> 2

    1 -> 3
      -> 4

    2 -> 3
      -> 4
    ```

    现在我们 bfs 搜索`0 -> 3`和`0 -> 4`的 path，当搜索到 1 节点时，我们将 3, 4 加入 next queue。接下来搜索 2 节点，由于 3, 4 还没有被 processed，所以它们仍会被加入 next queue。这样 next queue 中的数据就变成了`[3, 4, 3, 4]`。

    ```cpp
    #include <vector>
    #include <iostream>
    using namespace std;

    int main()
    {
        // i means the i-th vertex
        // edges = graph[i] mean the edges of i-th vertex
        // nex_vert = edges[j] means the j-th edge is pointer to nex_vert-th vertex
        vector<vector<int>> graph {
            {1, 2},  // 0 -> 1, 0 -> 2
            {3, 4},  // 1 -> 3, 1 -> 4
            {3, 4},  // 2 -> 3, 2 -> 4
            {},
            {}
        };

        vector<int> cur_que, nex_que;
        vector<bool> vis(graph.size(), false);
        cur_que.push_back(0);
        int round_idx = 0;
        while (!cur_que.empty())
        {
            // print cur_que
            printf("round idx: %d\n", round_idx);
            for (int i = 0; i < cur_que.size(); ++i)
            {
                printf("%d, ", cur_que[i]);
            }
            putchar('\n');
            round_idx++;

            for (int i = 0; i < cur_que.size(); ++i)
            {
                int vert = cur_que[i];
                for (int j = 0; j < graph[vert].size(); ++j)
                {
                    int nex_vert = graph[vert][j];
                    if (!vis[nex_vert])
                    {
                        nex_que.push_back(nex_vert);
                    }
                }
                vis[vert] = true;
            }
            cur_que = nex_que;
            nex_que.clear();
        }

        return 0;
    }
    ```

    output:

    ```
    round idx: 0
    0, 
    round idx: 1
    1, 2, 
    round idx: 2
    3, 4, 3, 4,
    ```