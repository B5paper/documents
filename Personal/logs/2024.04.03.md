* slint 中不可以将 mainwindow 直接传给其他线程，用`arc + mutex`也不行。

    但是可以使用 weak ptr + event loop 来多线程传递消息。

    官方的 example 如下：

    ```rust
    slint::slint! { export component MyApp inherits Window { in property <int> foo; /* ... */ } }
    let handle = MyApp::new().unwrap();
    let handle_weak = handle.as_weak();
    let thread = std::thread::spawn(move || {
        // ... Do some computation in the thread
        let foo = 42;
        // now forward the data to the main thread using invoke_from_event_loop
        let handle_copy = handle_weak.clone();
        slint::invoke_from_event_loop(move || handle_copy.unwrap().set_foo(foo));
    });
    handle.run().unwrap();
    ```

    ref: <https://releases.slint.dev/1.5.1/docs/rust/slint/fn.invoke_from_event_loop.html>

* slint 可以在 rs 中使用`mainwindow.invoke_<func_name>(<params>)`调用一个在 slint 中定义的函数

    也可以使用`mainwindow.on_<callback_name>(<params>)`将 slint 中声明的函数映射到 rs 文件的定义中。

* slint 中，如果需要在 ui 和 rs 中间传递数据，必须使用 slint 内置定义的一些数据类型，比如`SharedString`。

    通常 rust 的内置数据类型可以使用`into()`自动转换过去。比如`"hello".to_string().into()`。

* rust: can't borrow from a `Weak`

    ref: <https://stackoverflow.com/questions/34821389/borrowing-from-weakt>

* 无论是 c++ 还是 rust，在标准库中都不能直接 terminate 一个线程。

    要么从让线程自己退出，要么让主进程退出。

    在 c++ 中强制`delete`一个`thread`对象，会导致主程序立即崩溃。

* rust 中`&mut <type>`，需要使用`*`解引用后才能得到值

    这一点和 c++ 不太一样，c++ 中的引用只是一个别名，不需要`*`解引用。

* slint 中如果 main window 所在的线程没有退出，那么 main window 在退出 event loop 后，窗口并不会消失。

    不清楚为什么。

* slint 中 function 要求定义函数体，callback 不要求定义函数体

* slint 中 Image 不可以跨线程，只能用`SharedPixelBuffer`存储数据跨线程，然后再在 slint 所在的线程里转换成`Image`。

    这一点在官方文档里有写。


