* SFINAE（Substitution Failure Is Not An Error）

* `std::enable_if_t<条件>`

    如果条件为 true，则 enable_if_t 有一个有效的类型（默认为 void）

    如果条件为 false，则 enable_if_t 没有定义类型，导致替换失败

    example:

    ```cpp
    template <typename T, typename P>
    struct LookupTable {
        template <typename Arg1, typename Arg2,
                  typename = std::enable_if_t<std::is_same_v<Arg1, const char*>>>
        LookupTable(Arg1 str, Arg2 value) {
            std::cout << "Constructor 1: first arg is const char* (" << str << ", " << value << ")\n";
        }
    }
    ```

    其中`typename = ...`是一个未命名的默认模板参数，当条件满足时：`typename = void`（有效）。当条件不满足时：替换失败，该模板被从重载集中移除。

    现代写法：

    ```cpp
    // C++20 的 requires 子句（更清晰）
    template <typename Arg1, typename Arg2>
    requires std::is_same_v<Arg1, const char*>
    void process(Arg1 str, Arg2 value);

    // 或者放在返回值类型上
    template <typename Arg1, typename Arg2>
    std::enable_if_t<std::is_same_v<Arg1, const char*>, void>
    process(Arg1 str, Arg2 value);
    ```

    说明：

    1. 如果将`void`换成`int`，可以这样写：

        ```cpp
        template <typename Arg1, typename Arg2,
                  typename = std::enable_if_t<std::is_same_v<Arg1, const char*>, int>>
        void process(Arg1 str, Arg2 value) {
            // 函数实现
        }
        ```

        还可以使用`using`:

        ```cpp
        // 定义类型别名
        template<bool Condition>
        using EnableIf = std::enable_if_t<Condition, int>;

        template <typename Arg1, typename Arg2,
                  typename = EnableIf<std::is_same_v<Arg1, const char*>>>
        void process(Arg1 str, Arg2 value) {
            std::cout << "String: " << str << ", Value: " << value << std::endl;
        }
        ```

    1. 由于构造函数不允许有返回类型，所以不能这样写：

        ```cpp
        #include <type_traits>
        #include <iostream>

        struct LookupTable {
            template<typename Arg1, typename Arg2>
            std::enable_if_t<std::is_same_v<Arg1, const char*>>
            LookupTable(Arg1 str, Arg2 value) {
                std::cout << "Constructor 1: first arg is const char* (" << str << ", " << value << ")\n";
            }
        };
        ```

        所以使用`typename =`是唯一正确的写法。

* 根据不同的参数类型选择不同的构造函数一例

    ```cpp
    #include <type_traits>
    #include <iostream>

    struct LookupTable {
        // (1) 第一个参数是 const char* 的构造函数
        template <typename Arg1, typename Arg2,
                  typename = std::enable_if_t<std::is_same_v<Arg1, const char*>>>
        LookupTable(Arg1 str, Arg2 value) {
            std::cout << "Constructor 1: first arg is const char* (" << str << ", " << value << ")\n";
        }

        // (2) 第二个参数是 const char* 的构造函数
        template <typename Arg1, typename Arg2,
                  typename = std::enable_if_t<std::is_same_v<Arg2, const char*>>,
                  typename = void> // 额外模板参数避免冲突
        LookupTable(Arg1 value, Arg2 str) {
            std::cout << "Constructor 2: second arg is const char* (" << value << ", " << str << ")\n";
        }
    };

    int main() {
        LookupTable t1("name", 42);
        LookupTable t2(100, "value");
        // LookupTable<int, float> t3(10, 20);    // 编译错误：没有匹配的构造函数
    }
    ```

    output:

    ```
    Constructor 1: first arg is const char* (name, 42)
    Constructor 2: second arg is const char* (100, value)
    ```

    这里使用`typename = `决定是否 enable 某个构造函数。又使用`typename = void>`避免了模板函数冲突。

* `pci_ioremap_wc_bar()`

    将一个 PCI 设备 BAR（基地址寄存器）所指定的 PCI 内存区域映射到内核的虚拟地址空间，并特别请求该映射为“写合并”（Write-Combining, WC）内存类型。

    syntax:

    ```c
    void __iomem *pci_ioremap_wc_bar(struct pci_dev *pdev, int bar);
    ```

    返回值：成功时返回一个 `__iomem` 类型的内核虚拟地址指针，指向映射区域的起始处。失败则返回 `NULL`。

    写合并（WC）: 这是一种弱内存序、高性能的映射模式。CPU 可能会将多个连续的写操作在缓存中“合并”成一个更大的写入事务，再一次性发送到总线上。

    对于帧缓冲区（Frame Buffer）或大量数据传输的设备（如高性能网卡、显卡），使用 WC 映射可以显著减少总线事务数量，极大提升写入带宽和性能。因为写入图像数据通常是连续的，合并后发送效率更高。

* `devm_kzalloc()`

    分配一块指定大小的内存，并将其初始化为零，同时将该内存的释放（free）操作与设备本身的生命周期进行绑定。

    `devm_`表示 device managed。

    syntax:

    ```c
    void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp);
    ```

    `flags`： 分配标志，用于控制分配行为（例如，GFP_KERNEL 表示在进程上下文中可睡眠等待，GFP_ATOMIC 表示在中断等原子上下文中分配）。

    当发生以下情况时，内核会自动释放这块内存：

    * 驱动被卸载（module unload）。

    * 设备被分离（device detach）。

    * 在分配过程中出现错误，导致设备探测（probe）失败。

* `kstrdup()`

    在内核空间（Kernel Space）中为指定的一个字符串（以 '\0' 结尾的 C 字符串）分配一块新的内存，并将原字符串的内容复制到这块新内存中。

    syntax:

    ```c
    #include <linux/string.h> // 需要包含的头文件

    char *kstrdup(const char *s, gfp_t gfp_mask);
    ```

    功能与`strdup()`类似。分配的内存在不再需要时，必须使用`kfree()`来释放。


* `gfp_mask`: Get Free Page mask

* `ldd`

    List Dynamic Dependencies

    主要功能：

    * 列出依赖：显示运行某个程序需要哪些共享库（.so 文件）。

    * 定位库文件：显示这些依赖库在文件系统中的具体路径。

    * 检查兼容性：检查是否存在某个依赖库，以及库的版本是否兼容。如果某个库找不到，它会显示 not found，这通常是程序无法启动的原因。

    syntax:

    ```bash
    ldd [选项] <文件名>
    ```

    ldd 本身并不是一个可执行程序，而是一个Shell脚本

    它的工作原理是设置适当的环境变量（如 LD_TRACE_LOADED_OBJECTS），然后调用目标程序。目标程序在这种特殊环境下启动时，并不会真正运行其主逻辑，而是会列出其所有依赖的共享库信息后退出。