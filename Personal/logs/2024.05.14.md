* 动态规划的一些心得

    从前向后推导要求可以更新多个位置，并且可以覆盖原来更新过的位置。

    但是一个位置是否更新不能影响到下一个位置，即不能与下一个位置有相关性，因为这样就引入了记忆状态。

    可以引入多个状态数组来进行相关性解耦。比如同时引入一个`int dp[2][n]`，其中`dp[0][n]`用来记录最优值，`dp[1][n]`用来记录某种状态（一个简易的有限状态机）。

* c++ 中函数指针支持`vector`等类型

    example:

    ```cpp
    int (*get_ans)(vector<int> &&) = get_ans_1;
    ```

* 假如写 4 = 3 + 1，那么 4 这个位置就应该是 -1

    然而实际上 4 = 2 + 2，所以 4 可以被分解

    但是问题来到了 5，如果我们从 4 跳到 5，一定是从 2 过来的，那么 5 一定被分解成 2 + 3

    现在到了 6，由于 5 最后留了 3，所以 6 必须被分解成 2 + 3 + 1，这样就一定会返回 -1。

    然而，6 其实可以被分解成 3 + 3。

    由此我们可以得出，不可能存在一个正向的方法实现动态规划。

    猜想：是否所有不只依赖当前状态的动态规划都无法写成正向的？

    猜想：如果一个正向的动态规划写法需要依赖之前的状态，那么是否无论如何增加状态也无法解耦？

        解耦：即只依赖当前索引 i 的数据，就可以推导出后面的最优值。

* 如果在写一个正向的动态规划的时候用到了以前的值，或者在确定以后的值时需要分类讨论，那么它的本质其实还是反向的动态规划。

    因为分类讨论本质还是在确定“未来”的未来值时，用到了“未来”的当前值的状态。那我还不如直接在未来全部用过去值，这样的结构更清晰明了。

    一个写正向动态规划写不下去的案例：`ref_14`。写到条件 5 的时候，想到 5 的两种分解情况，6 对应着能分解和不能分解的两种情况，意识到做不下去了。