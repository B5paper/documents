* 信息屏蔽

    如果新增的信息量过大，那么我们在假设空间中寻找样本点时，会因为要考虑的东西过多而难以构造样本点。或者即使构造出假设与猜想，也没有精力或能力去验证。这样会导致整个思维系统无法运行。此时我们必须进行信息屏蔽，每天只选择性地接受一些自己可以处理的信息。就算根据局部信息得到的结论是错的也没有关系，因为整个思维系统的纠错机制最终会将错误的结论排除掉。

* `ssh -f`

    如果`ssh -f`后边没有跟 command 命令，那么 ssh 会报错：

    > Cannot fork into background without a command to execute.

    但是有时候我们想让 ssh 放到后台，又希望它执行`-L`或`-R`之类的端口转发，又没有什么特别想执行的 command，此时可以配合`-N`选项实现这个目的.

    `ssh -fN -L 1234:127.0.0.1:1234 hlc@xx.xxx.xx.xx`

    目前不清楚这样做是否有 keep alive 的功能。

    如果只有`-f -L`，没有`-N`，那么同样会报错：

    > Cannot fork into background without a command to execute.

* crontab

    `crontab`可以定时执行一些命令，在 ubuntu 系统上默认装有。

    `crontab -e`编辑定时任务的配置文件。

    配置文件的格式：

    ```
    * * * * * command_to_execute
    │ │ │ │ │
    │ │ │ │ └── 星期几 (0-7, 0和7均代表周日)
    │ │ │ └──── 月份 (1-12)
    │ │ └────── 日 (1-31)
    │ └──────── 小时 (0-23)
    └────────── 分钟 (0-59)
    ```

    * `*`：任意值（如 `* * * * *` 表示每分钟）

    * `,`：分隔多个时间（如 `0,15,30 * * * *` 表示每小时的 0、15、30 分）

    * `-`：范围（如 `0 9-17 * * *` 表示每天 9点到17点整点）

    * `/`：间隔（如 `*/5 * * * *` 表示每 5 分钟）

    example:

    ```
    # 每分钟执行一次
    * * * * * date
    ```

    使用`crontab -e`编辑任务后无需重启服务，修改会自动生效。

    output:

    `/var/log/syslog`:

    ```
    Jul 31 16:08:23 hlc-VirtualBox crontab[3437117]: (hlc) BEGIN EDIT (hlc)
    Jul 31 16:08:26 hlc-VirtualBox crontab[3437117]: (hlc) REPLACE (hlc)
    Jul 31 16:08:26 hlc-VirtualBox crontab[3437117]: (hlc) END EDIT (hlc)
    Jul 31 16:09:01 hlc-VirtualBox cron[689]: (hlc) RELOAD (crontabs/hlc)
    Jul 31 16:09:01 hlc-VirtualBox CRON[3437888]: (hlc) CMD (date)
    Jul 31 16:09:01 hlc-VirtualBox CRON[3437887]: (CRON) info (No MTA installed, discarding output)
    ```

    cron 默认会通过邮件发送命令的输出，但系统没有安装邮件传输代理（MTA）（如 sendmail、postfix 或 exim4），所以输出被丢弃。

    通常会让 cron 的输出重定向到日志文件：

    `* * * * * date >> /tmp/cron_date.log 2>&1`

* crontab examples

    * `0 * * * * /path/script.sh`
        
        每小时整点执行

    * `*/10 * * * * date >> /tmp/log`
    
        每 10 分钟记录当前时间

    * `0 2 * * * /backup.sh`
    
        每天凌晨 2 点执行备份

    * `0 0 * * 1 tar -zcf /backup/weekly.tar.gz /data`
    
        每周一零点压缩备份

    * `@reboot /path/start_service.sh`
    
        系统启动时执行

    * `* * * * * /path/to/command`

        每分钟执行一次

    * `*/5 * * * * /path/to/command`

        每5分钟执行一次

    * `30 * * * * /path/to/command`

        每小时的第30分钟执行

    * `0 2 * * * /path/to/command`

        每天凌晨2点执行

    * `0 3 * * 1 /path/to/command`

        每周一凌晨3点执行

    * `0 12 1 * * /path/to/command`

        每月1号中午12点执行

    * `* * * * * /path/to/script.sh >> /var/log/script.log 2>&1`

        将输出追加到日志文件（避免邮件通知）

    * `* * * * * /path/to/command > /dev/null 2>&1`

        丢弃所有输出（静默执行）

    * `0 0 * * * rm -rf /tmp/*`

        每天凌晨清理临时文件

    * `0 2 * * 0 mysqldump -u root -pPASSWORD dbname > /backup/db.sql`

        每周日备份数据库

    * `*/30 * * * * /usr/sbin/ntpdate pool.ntp.org`

        每30分钟同步时间（需安装ntpdate）

    * `0 9 * * * echo "Daily meeting at 9:30!" | wall`

        每天9点提醒自己（写入终端）

    * `0 * * * * df -h > /home/user/disk_usage.log`

        每小时检查磁盘空间

    * `@reboot /path/to/startup_script.sh`

        系统重启后执行

    * `0 17 * * 1-5 echo "End of workday" | mail -s "Reminder" user@example.com`

        工作日（周一到周五）下午5点发邮件

    * `*/10 * * * * sleep $((RANDOM \% 60)) && /path/to/command`

        随机延迟执行（避免任务集中触发）

    * `0 9-18 * * 1-5 /path/to/work_script.sh`

        每周一到周五，上午9点到下午6点，每小时执行一次

    * `59 23 28-31 * * [ "$(date +\%d -d tomorrow)" = "01" ] && /path/to/monthly_task.sh`

        每月最后一天23:59执行
    
    * `* * * * * /path/to/command | mail -s "Cron Debug" your@email.com`

        通过日志或临时邮件检查任务是否运行


* crontab 其他常用命令

    * `crontab -l`
        
        列出当前用户的所有定时任务

        其实就是列出 config 文件的所有内容，类似于 cat。

    * `crontab -r`
    
        删除当前用户的所有定时任务（谨慎使用！）

    * `crontab -u user`
    
        管理员专用：管理其他用户的任务（如`-e`, `-l`, `-r`）

* nullopt 有点像 optional 版本的 nullptr

    ```cpp
    std::optional<int> opt1 = std::nullopt; // 初始化为空
    opt1 = 42;                             // 赋有效值
    opt1 = std::nullopt;                   // 重置为空

    if (opt1 == std::nullopt) { /* 处理无值情况 */ }
    // 或等价于：
    if (!opt1.has_value()) { /* 同上 */ }
    ```

    `nullopt`本质是空类型的常量：

    ```cpp
    struct nullopt_t { /* 空实现 */ };
    inline constexpr nullopt_t nullopt{}; // 全局常量
    ```

    `nullopt_t`是一个标记类型（Tag Type），仅用于表示“无值”状态，不存储任何数据。

    `nullopt`是该类型的常量实例。

    在`optional`模板类实现时，单独为 nullopt 做了条函数重载的通路：

    ```cpp
    template<typename T>
    class optional {
    public:
        // 从 nullopt 构造（设置为“无值”状态）
        optional(nullopt_t) noexcept : has_value_(false) {}

        // 从 nullopt 赋值
        optional& operator=(nullopt_t) noexcept {
            reset(); // 内部重置为无值
            return *this;
        }
    };
    ```

    思考：为什么不使用模板的特化，而是使用函数重载来实现这个功能？

