* 学习资源的调研主要用于完成下面几件事情

    1. 发现学习资源里，是否有需要做实验验证的地方，是否可以用实验验证他说的，是否有可以用实验澄清的模糊不清的表达

    2. 语言表达是否有歧义

    3. 未完待续

* 其实与 cache 对应的是工作区（working area），而工作区的整洁是 stack　的要求，不然各种回退操作都会混乱，没有办法快速定位到想要的资源

* 其实调研也是一种是 cache，是一种广度优先搜索，它安排了必须要回答的问题，优化了任务列表的结构，整合了小范围内的信息，防止有歧义在前，回答在后的情况发生

    调研不做实验，不使用实验对猜想做验证

* 需要一个指标来评价当天有多少时间是被任务系统接管的，就叫它接管率好了

    接管率从一定程度止反映了专心程度

* vulkan descriptor sets

    猜测：

    1. 一个 descriptor 指的是一块显存和　shader 中一个 location　的绑定

    2. 一个 descriptor set 指的是一个 shader 中不同位置（location）的资源绑定情况

        具体如何绑定，由 descriptor set layout 指定。

    3. 为了提高效率，descriptor set 都从一个 pool 中申请。pool 意味着大小是有限的，所以 descriptor set 的数量也是有限的。

* 使用`vkGetPhysicalDeviceSurfaceFormatsKHR()`拿到 swapchain image 的 format

    这个 format 可能有多个，我们主要使用的是`VK_FORMAT_B8G8R8A8_SRGB`。

* 一个 binding `VkDescriptorSetLayoutBinding` 只描述资源的位置（location），类型（texture, storage, sampler 等）。并不绑定实际的数据。

    一个 binding 只描述一个资源位置的情况。一个 layout 描述的是多个 binding。

* 如果不使用 descriptor binding，那么可以使用`vkCmdBindVertexBuffers()`进行绑定。这个函数的参数里指定了要绑定的位置。

* 没有单个 descriptor 的说法，只有 descriptor set 和 descriptor pool

* 在创建 descriptor layout binding 时，常用的`VkDescriptorType`:

    * `VK_DESCRIPTOR_TYPE_SAMPLER:`

    * `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`

        A sampled image is an image that can be used in conjunction with a sampler to provide filtered data to a shader.

        sampled image can not be written to.

    * `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`

        A storage image is an image that cannot be used with a sampler but can be written to.

    * `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`

        存放一些数据，不能被写入。

    * `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`

        存放一些数据，可以被写入。

    * `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`, `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`

        和 texel buffer 很像，只不过其中的数据需要 shader 中的 struct 来解释。

* 一个 shader 可以绑定多个 set，从 0 开始编号，比如 set 0, set 1, ...

    每个 set 又有多个 binding，从 0 开始编号，比如 binding 0, bindinig 1, ...

    一个常见的 shader 可能是这种的：

    ```glsl
    #version 450 core
    layout (set = 0, binding = 0) uniform sampler2DmyTexture;
    layout (set = 0, binding = 2) uniform sampler3DmyLut;
    layout (set = 1, binding = 0) uniform myTransforms
    {
        mat4 transform1;
        mat3 transform2;
    };
    void main(void)
    {
        // Do nothing!
    }
    ```

* `VkDescriptorSetLayoutBinding`中的`stageFlags`不知道写啥可以写`VK_SHADER_STAGE_ALL`，通用。

    其他的几个 stage 可以参考官网说明：<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkShaderStageFlagBits.html>

    这个 struct 中的`descriptorCount`表示一个 binding 处可以有多个 descriptor 资源，这个好像是使用偏移来区分不同的数据。

    比如每个 shader 拿到的是一个 20 个字节的数据，前 12 个字节表示的是 3 个 float 数，表示一个 rgb 的颜色。后面 8 个字节表示两个 float 数，表示一个 xy 的平面坐标。这样一个 binding 位置其实有两个 resource。

    目前还没找到 example，但是之前好像见到过，有空的话找找。

* `VkDescriptorSetLayoutCreateInfo`用的 flags 目前没什么用，直接设置成 0.

* `VkDescriptorPoolCreateInfo`中的`maxSets`是根据 frames in flight 的数量设置的。有多少个 frames 就将`maxSets`设置成几。

    目前还不清楚为什么要这样做。同一个 set 无法用在多个 render 过程中吗？

* `VkDescriptorPoolSize`规定了给不同类型的 descriptor 预留多少个位置。

    vulkan 文档里的解释是

    > descriptorCount is the number of descriptors of that type to allocate.

    目前仍不清楚这个参数的具体含义。

* 创建一个简单 descriptor set 的过程

    ```cpp
    VkDescriptorPoolCreateInfo desc_pool_crt_info{};
    desc_pool_crt_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    desc_pool_crt_info.flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
    desc_pool_crt_info.maxSets = 2;
    desc_pool_crt_info.poolSizeCount = 1;
    VkDescriptorPoolSize desc_pool_size{};
    desc_pool_size.type = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
    desc_pool_size.descriptorCount = 2;
    desc_pool_crt_info.pPoolSizes = &desc_pool_size;
    VkDescriptorPool desc_pool;
    VkResult result = vkCreateDescriptorPool(device, &desc_pool_crt_info, nullptr, &desc_pool);
    if (result != VK_SUCCESS)
    {
        printf("fail to create descriptor pool, error code: %d\n", result);
        exit(-1);
    }

    VkDescriptorSetLayout desc_set_layout;
    VkDescriptorSetLayoutCreateInfo desc_set_layout_crt_info{};
    desc_set_layout_crt_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    desc_set_layout_crt_info.bindingCount = 1;
    VkDescriptorSetLayoutBinding desc_set_layout_binding{};
    desc_set_layout_binding.binding = 0;
    desc_set_layout_binding.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
    desc_set_layout_binding.descriptorCount = 1;
    desc_set_layout_binding.stageFlags = VK_SHADER_STAGE_ALL;
    desc_set_layout_crt_info.pBindings = &desc_set_layout_binding;
    result = vkCreateDescriptorSetLayout(device, &desc_set_layout_crt_info, nullptr, &desc_set_layout);
    if (result != VK_SUCCESS)
    {
        printf("fail to create descriptor set layout, error code: %d\n", result);
        exit(-1);
    }

    VkDescriptorSet desc_set;
    VkDescriptorSetAllocateInfo desc_set_allo_info{};
    desc_set_allo_info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    desc_set_allo_info.pSetLayouts = &desc_set_layout;
    desc_set_allo_info.descriptorSetCount = 1;
    desc_set_allo_info.descriptorPool = desc_pool;
    result = vkAllocateDescriptorSets(device, &desc_set_allo_info, &desc_set);
    if (result != VK_SUCCESS)
    {
        printf("fail to allocate descriptor set, error code: %d\n", result);
        exit(-1);
    }
    ```

    此时还不够，descriptor set 还需要集成到 pipeline set layout 中，才能起作用。

* c++ 的 move 其实是移动了 memory allocator 的证据

    ```cpp
    #include <vector>
    #include <stdio.h>
    using namespace std;

    int main()
    {
        vector<int> arr_1{1, 2, 3, 4, 5};
        for (auto &num: arr_1)
            printf("%d, ", num);
        putchar('\n');

        vector<int> arr_2 = move(arr_1);
        for (int &num: arr_1)
            printf("%d, ", num);
        putchar('\n');
        return 0;
    }
    ```

    output:

    ```
    1, 2, 3, 4, 5, 

    ```

    上面这段代码只有第一次 printf 的时候有输出，第二次 printf 的时候没有输出，说明`arr_1`已经失效了。

    如果 print `arr_1.size()`，也会输出 0.