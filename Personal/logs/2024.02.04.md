* 缓存待完成的任务是一个非常好用的经验，但是并不能长时间使用，因为缓存不太消耗脑子，可以非常容易地获得短暂的满足，所以脑子一直处于放松的状态，时间一长就是在浪费时间。

* c++ extent

    `std::extent`是一个模板类，使用 traits 技术获得数组在某个维度的长度。

    ```cpp
    #include <iostream>

    int main()
    {
        std::cout << std::extent_v<int[3][4]> << std::endl;  // 3
        std::cout << std::extent_v<int[3][4], 0> << std::endl;  // 3
        std::cout << std::extent_v<int[3][4], 1> << std::endl;  // 4
        std::cout << std::extent<int[3][4], 1>::value << std::endl;  // 5
        return 0;
    }
    ```

    输出：

    ```
    3
    3
    4
    4
    ```

    `std::extent`可以和`decltype`结合起来使用，推测一个数组实例的维度长度：

    ```cpp
    #include <iostream>

    int main()
    {
        int arr[3][4];
        std::cout << std::extent_v<decltype(arr)> << std::endl; // 3
        using arr_type = decltype(arr);
        std::cout << std::extent_v<arr_type> << std::endl;  // 3
        return 0;
    }
    ```

    如果先取了索引，再拿 extent，那么会得到 0，因为索引只是一个 reference。比如`arr[0]`的类型，实际上是`int (&)[3]`。我们可以 remove 掉 reference，从而得到正确的 extent：

    ```cpp
    #include <iostream>

    int main()
    {
        int arr[3][4];
        std::cout << std::extent_v<decltype(arr[0])> << std::endl;  // 0
        std::cout << std::extent_v<std::remove_reference_t<decltype(arr[0])>> << std::endl;  // 4
        return 0;
    }
    ```

    如果将数组传递给函数参数，那么会丢失第一个维度的 extent：

    ```cpp
    #include <iostream>

    void print_arr_extent(int arr[3][4])
    {
        using t_0= std::remove_reference_t<decltype(arr)>;
        std::cout << std::extent_v<t_0> << std::endl;  // 0
        using t_1 = std::remove_reference_t<decltype(arr[0])>;
        std::cout << std::extent_v<t_1> << std::endl;  // 4
        using t_2 = decltype(arr[0]);
        std::cout << std::extent_v<t_2> << std::endl;  // 0
    }

    int main()
    {
        int arr[3][4];
        print_arr_extent(arr);
        return 0;
    }
    ```

    不清楚该怎么解决这个问题。

* 关于 qa 文件格式的改变

    使用`[idx]`标签标注从上往下的索引，用于唯一定位，从 0 开始。

    使用`[id]`标签标注一个哈希值，用于唯一定位。使用对当前时间的哈希即可，主要不重复就可以了。

    使用`[dep]`指定当前条目所依赖的条目，写法如下：

    ```
    [dep]
    <id> - <u_0>
    <id> - <u_0>
    ...
    ```

    因为`[id]`和`[u_0]`可能在文件里出现很多次，所以仅使用这两个无法快速精准定位。

* 给随机检测增加新功能

    * 使用`./main --update-idx <qa_file>`更新所有 unit 的 idx

        每次插入一个新的 unit 时，就使用这个命令更新所有的 idx

    * 使用`./main --generate-id`根据当前时间创建一个新的哈希值

    * 使用`./main --id-to-idx <id> <qa_file>`找到指定哈希值的索引

    * 在 vim 中根据正则表达式搜索指定索引所在的位置

    * 修复`--list`的 bug。

        在找到`[u_0]`后，只要找到下一个`[xxx]`模式就可以了，`[u_0]`的内容为`[u_0]`往后，`[xxx]`往前。

        dep:

        * 正则表达式

* 把 vim 加入到每日 qa 中