* c++ 中`mem_fn()`可以将类的成员函数提取出来，做成一个可调用对象

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <functional>
    using namespace std;

    struct A {
        int val;
        void print_msg(const string &msg) {
            printf("%s, %d\n", msg.c_str(), val);
            ++val;
        }
    };

    int main() {
        auto A_print = mem_fn(&A::print_msg);
        A obj;
        obj.val = 42;
        A_print(obj, "hello, world");
        A_print(obj, "hello, world");
        A_print(&obj, "hello, world");
        A_print(&obj, "hello, world");
        return 0;
    }
    ```

    output:

    ```
    hello, world, 42
    hello, world, 43
    hello, world, 44
    hello, world, 45
    ```

    `mem_fn`在`<functional>`头文件中。

    `mem_fn()`包装出来的函数，可接受原对象，可接受原对象的指针，还可接受智能指针。根据上面的例子可以看出，无论如何`mem_fn()`包装出来的函数都是按引用传递实例。

* `mem_fn()`在返回成员变量时，返回的是引用

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <functional>
    using namespace std;

    struct A {
        int val;
    };

    int main() {
        auto get_A_val = mem_fn(&A::val);
        A obj;
        obj.val = 42;
        int val = get_A_val(obj);
        printf("val: %d\n", val);

        int &val_ref = get_A_val(obj);
        val_ref = 123;
        printf("val: %d\n", obj.val);
        
        return 0;
    }
    ```

    output:

    ```
    val: 42
    val: 123
    ```

* gdb 可以使用`call`命令调用函数，`(gdb) call func(param_1, param_2)`

    被 call 的函数定义所在的文件必须使用`-g`编译才行。

    可以使用`call <var_name> = <val>`给变量赋值。如果不使用`call`，直接写`<var_name> = <val>`会报错。

* grep 开启`-E`时，可以使用`|`匹配多个模式。

    `grep -E haha\|hehe msg.txt`

    `grep -E 'haha|hehe' msg.txt`

    bash 会将`|`默认解释为管道，如果希望 bash 将`|`解释为字符`|`，那么要么在之前加`\`，要么使用单引号`''`。
    
    注：

    1. 标准的正则表达式支持`|`，比如 python 的`re`模块。

    1. `|`的前后不能有空格，或者说，空格不会被忽略。
