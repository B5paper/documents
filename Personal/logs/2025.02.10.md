* ptx tmp

    * 在 ptx 中使用多个 const bank

        ```asm
        .extern .const[2] .b32 const_buffer[];
        ```

        看起来是将`.const[2]`的地址赋给`const_buffer`。

        ```asm
        .extern .const[2] .b32 const_buffer[];
        ld.const[2].b32  %r1, [const_buffer+4]; // load second word
        ```

        这个看上去是从`const_buffer+4`处，取一个`.b32`值。看来即使有了地址，`.const[2]`这些 bank 信息还是不能省。

    * Use `ld.global`, `st.global`, and `atom.global` to access global variables.

    * The local state space (.local) is typically standard memory with cache. Use ld.local and st.local to access local variables.

        loadl memory 是缓存吗？为什么其他地方说和全局变量一样，是片外的？

    * 关于 .local memory，如果架构支持 stack，那么 .local memory 被存在 stack 中，如果没有 stack，那么 .local variable 被存在 fixed address 中，因此函数也不支持递归调用。

    * Additional sub-qualifiers ::entry or ::func can be specified on instructions with .param state space to indicate whether the address refers to kernel function parameter or device function parameter.

        看来`__global__` kernel 和`__device__` kernel 的作用还不一样。

        `::entry`和`::func`并没有默认情况，只有根据上下文指令而自动指定。比如`st.param`会对应到`st.param::func`，`isspacep.param`会对应到`isspacep.param::entry`。

    * `.param`可能会被映射到 register, stack 或 global memory 上，这一点我们无法确定，具体位置在哪需要参考 ABI 的实现。

* deb 安装包的创建方法

    见`ref_37`。构建方法：`dpkg-deb --build ./hello_world_hlc`，输出如下：

    ```
    dpkg-deb: building package 'hello-from-hlc' in 'hello_world_hlc.deb'.
    ```

    此时即可`sudo dpkg -i ./hello_world_hlc.deb`进行安装，输出如下：

    ```
    Selecting previously unselected package hello-from-hlc.
    (Reading database ... 277890 files and directories currently installed.)
    Preparing to unpack hello_world_hlc.deb ...
    Unpacking hello-from-hlc (0.2) ...
    Setting up hello-from-hlc (0.2) ...
    in post installation from hlc
    ```

    此时安装包中的文件已经复制到对应位置，我们可以直接执行：

    `echo_hello_hlc.sh`, output:

    ```
    hello world from hlc
    ```

    卸载：`sudo dpkg -r hello-from-hlc`，输出：

    ```
    (Reading database ... 277893 files and directories currently installed.)
    Removing hello-from-hlc (0.2) ...
    dpkg: warning: while removing hello-from-hlc, directory '/usr/local/bin' not empty so not removed
    ```

    卸载时，之前复制的文件会被删除。

    注：`control`文件中的 package name 不能有下划线`_`，但是可以有减号。

    debian 有官方文档详细描述安装包的格式：<https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-binarycontrolfiles>

* ptx asm, `ld`相关指令的注意事项

    `ld`一个字节的代码：

    ```cpp
    template<>
    __device__ __forceinline__ BytePack<1> ld_volatile_global<1>(uintptr_t *ptr)
    {
        uint32_t ans;
        asm("ld.volatile.global.b8 %0, [%1];" : "=r"(ans) : "l"(ptr));
        return *(BytePack<1>*) &ans;
    }
    ```

    由于这里实现的是`ld_volatile_global()`模板函数的一个特化，要求返回值类型和参数类型的**形式**要和原函数声明一样，因此返回值选用了`BytePack<ElmSize>`，这样可以返回不定长的值，而输入参数使用了`uniptr_t *`，由于指针的长度总是固定的（64 位），所以不需要变长类型，直接统一使用`uniptr_t*`了。

    而且`uniptr_t *`也是下面 asm 命令的要求，`"l"(ptr)`，ptr 的约束必须为`l`，不然编译通不过。

    函数中声明了一个`uint32_t ans;`的变量，这个也是 asm 的要求，`.b8`指令对应的`ans`必须为 32 位。不然编译不通过。因为是 32 位，所以 constraint 使用的是`r`。后面会详细讨论 constraint 相关。

    接下来看 asm 指令，`.b8`的`ld`指令，读 1 个字节，但是`ans`是 32 位，`ptr`是 64 位的指针。说明可能硬件上可能取 32 位数据的前 8 位当作 1 个字节来用。

    return 时使用了强制类型转换。直接`return (BytePack<1>) ans;`显然是编译不过去的。如果写成

    ```cpp
        BytePack<1> ret;
        ret.native = ans;
        return ret;
    ```

    这样又显得繁琐，并且创建了一个中间变量。所以最终选择直接做类型转换。