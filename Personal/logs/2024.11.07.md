* 笔记与中间结果

    有些需要记录的内容明显是中间结果而不是笔记，如果把中间结果当成笔记来记，那么在归类的时候就不知道该把归类到什么地方去。

    中间过程只是记录，不是结论，因此很难复用。这些不应该出现在笔记里。

* openshmem example atomic add

    `main.c`:

    ```c
    #include <stdio.h>
    #include <shmem.h>

    int g_val;

    int main()
    {
        shmem_init();
        int me = shmem_my_pe();

        g_val = 0;
        shmem_barrier_all();

        if (me == 0)
        {
            shmem_int_atomic_add(&g_val, 2, 1);
        }
        shmem_barrier_all();

        printf("%d: g_val = %d\n", me, g_val);

        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 2 ./main`

    output:

    ```
    0: g_val = 0
    1: g_val = 2
    ```

    看起来`shmem_int_atomic_add()`可以让指定 pe 上的指定 int 值加一个数。

    说明：

    1. 如果把这个函数替换成

        ```c
        if (me == 1)
        {
            g_val += 2;
        }
        ```

        那么有什么不同？

        答：注意到，原代码中`if (pe == 0)`表示当前的进程是 0，而`shmem_int_atomic_add()`里指定修改的是进程 1 里的数据。这个函数说明可以跨进程修改数据。

    2. 如果把`g_val`在`main()`函数内声明，那么程序会报错。说明全局变量默认就在 shmem 中，而局部变量一定是 private 的。

* openshmem example: variable accessibility test

    `main.c`:

    ```c
    #include <stdio.h>
    #include <shmem.h>

    long global_var;
    static int global_static_var;

    int main()
    {
        long local_var;
        static int local_static_var;

        shmem_init();
        int num_pes = shmem_n_pes();
        if (num_pes < 2)
        {
            puts("Please run at least 2 pes.\n");
            return -1;
        }
        printf("There are totally %d pes.\n", num_pes);
        int me = shmem_my_pe();

        int *shm_pvar = (int *) shmem_malloc(sizeof(int));

        if (me == 0)
        {
            if (shmem_addr_accessible(&global_var, 1))
                puts("pe 0 can get global var from pe 1.");
            else
                puts("pe 0 can NOT get global var from pe 1.");

            if (shmem_addr_accessible(&global_static_var, 1))
                puts("pe 0 can get global static var from pe 1.");
            else
                puts("pe 0 can NOT get global static var from pe 1.");

            if (shmem_addr_accessible(&local_var, 1))
                puts("pe 0 can get local var from pe 1.");
            else
                puts("pe 0 can NOT get local var from pe 1.");

            if (shmem_addr_accessible(&local_static_var, 1))
                puts("pe 0 can get local static var from pe 1.");
            else
                puts("pe 0 can NOT get local static var from pe 1.");            

            if (shmem_addr_accessible(shm_pvar, 1))
                puts("pe 0 can get shm_pvar from pe 1.");
            else
                puts("pe 0 can NOT get shm_pvar from pe 1.");
        }

        shmem_free(shm_pvar);
        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 2 ./main`

    output:

    ```
    There are totally 2 pes.
    pe 0 can get global var from pe 1.
    pe 0 can get global static var from pe 1.
    pe 0 can NOT get local var from pe 1.
    pe 0 can get local static var from pe 1.
    pe 0 can get shm_pvar from pe 1.
    There are totally 2 pes.
    ```

    看起来全局变量，static 局部变量，以及`shmem_malloc()`申请的内存都可以被跨 pe 访问，但是函数的局部变量不行。

* c 语言中 static 全局变量和不加 static 的全局变量有什么不同？

* `stdio.h`中的`puts(char *msg)`可以打印一个字符串并自动换行。

* openshmem example: fetch

    `main.c`:

    ```c
    #include <stdio.h>
    #include <shmem.h>

    int g_val;

    int main()
    {
        shmem_init();
        int me = shmem_my_pe();
        if (me == 0)
            g_val = 123;
        else if (me == 1)
            g_val = 234;
        printf("pe %d: g_val = %d\n", me, g_val);

        if (me == 0)
        {
            const int fetched = shmem_int_atomic_fetch(&g_val, 1);
            printf("pe %d: g_val = %d, fetched val = %d\n", me, g_val, fetched);
        }
        shmem_barrier_all();

        printf("pe %d: g_val = %d\n", me, g_val);

        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 2 ./main`

    output:

    ```
    pe 1: g_val = 234
    pe 0: g_val = 123
    pe 1: g_val = 234
    pe 0: g_val = 123, fetched val = 234
    pe 0: g_val = 123
    ```

    看起来 fetch 的作用就是从远程 pe 拿一个数据。

    这个例子可以看出`shmem_barrier_all()`只影响有内存依赖关系的代码的执行顺序，不影响其他代码（比如`printf`）的执行顺序。

    猜想：通常在修改内存值的代码后加一个 barrier，可以保证后面的数据都是正确的。

* openshmem example: set

    `main.c`:

    ```c
    #include <stdio.h>
    #include <shmem.h>

    int g_val;

    int main()
    {
        shmem_init();
        int me = shmem_my_pe();

        g_val = 123;
        shmem_barrier_all();

        if (me == 0)
        {
            shmem_int_atomic_set(&g_val, 456, 1);
        }
        shmem_barrier_all();

        printf("pe %d: g_val = %d\n", me, g_val);

        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 2 ./main`

    output:

    ```
    pe 1: g_val = 456
    pe 0: g_val = 123
    ```

    这个 example 说明 set 函数可以修改远程 pe 里的变量。

* openshmem example: amo

    ```c
    #include <shmem.h>
    #include <stdio.h>
    #include <stdlib.h>

    const int tries = 10000;

    #ifdef TEST64BIT
    typedef long locktype;

    #else /*  */
    typedef int locktype;

    #endif /*  */

    int main()
    {
        int tpe, other;
        long i;
        struct
        {
            locktype a;
            locktype b;
        } *twovars;
        int numfail = 0;
        shmem_init();
        tpe = 0;
        other = shmem_n_pes() - 1;
        twovars = shmem_malloc(sizeof(*twovars));
        if (shmem_my_pe() == 0) {
            printf("Element size: %ld bytes\n", sizeof(locktype));
            printf("Addresses: 1st element %p\n", (void *) &twovars->a);
            printf("           2nd element %p\n", (void *) &twovars->b);
            printf("Iterations: %d   target PE: %d   other active PE: %d\n",
                tries, tpe, other);
        }
        twovars->a = 0;
        twovars->b = 0;
        shmem_barrier_all();
        if (shmem_my_pe() == 0) {

            // put two values alternately to the 1st 32 bit word
            long expect, check;
            for (i = 0; i < tries; i++) {
                expect = 2 + i % 2;
                if (sizeof(locktype) == sizeof(int)) {
                    shmem_int_p((void *) &twovars->a, expect, tpe);
                    check = shmem_int_g((void *) &twovars->a, tpe);
                }
                else if (sizeof(locktype) == sizeof(long)) {
                    shmem_long_p((void *) &twovars->a, expect, tpe);
                    check = shmem_long_g((void *) &twovars->a, tpe);
                }
                if (check != expect) {
                    printf("error: iter %ld get returned %ld expected %ld\n", i,
                        check, expect);
                    numfail++;
                    if (numfail > 10) {
                        printf("FAIL\n");
                        abort();
                    }
                }
            }
            printf("PE %d done doing puts and gets\n", shmem_my_pe());
        }
        else if (shmem_my_pe() == other) {

            // keep on atomically incrementing the 2nd 32 bit word
            long oldval;
            for (i = 0; i < tries; i++) {
                if (sizeof(locktype) == sizeof(int)) {
                    oldval =
                        shmem_int_atomic_fetch_inc((void *) &twovars->b, tpe);
                }
                else if (sizeof(locktype) == sizeof(long)) {
                    oldval =
                        shmem_long_atomic_fetch_inc((void *) &twovars->b, tpe);
                }
                if (oldval != i) {
                    printf("error: iter %ld finc got %ld expect %ld\n", i,
                        oldval, i);
                    numfail++;
                    if (numfail > 10) {
                        printf("FAIL\n");
                        abort();
                    }
                }
            }
            printf("PE %d done doing fincs\n", shmem_my_pe());
        }
        shmem_barrier_all();
        if (numfail) {
            printf("FAIL\n");
        }
        shmem_barrier_all();
        if (shmem_my_pe() == 0) {
            printf("test complete\n");
        }
        shmem_finalize();
        return 0;
    }
    ```

    这个看着有点像综合数据正确性测试。pe 0 不断地向 pe 1 中轮替写入数字 2 和数字 3，然后再从 pe 1 中把数据拿回来看是否正确。pe 1 则不断把 pe 0 中的数字做加 1 操作，然后检查结果是否正确。

    output:

    ```
    Element size: 4 bytes
    PE 1 done doing fincs
    Addresses: 1st element 0xff0000d0
            2nd element 0xff0000d4
    Iterations: 10000   target PE: 0   other active PE: 1
    PE 0 done doing puts and gets
    test complete
    ```

* openshmem example: ring put

    `main.c`:

    ```c
    #include <stdio.h>
    #include <sys/utsname.h>
    #include <shmem.h>

    #define N 7

    int main(void)
    {
        struct utsname u;
        int su = uname(&u);
        if (su != 0)
        {
            printf("fail to get uname\n");
            return -1;
        }

        shmem_init();
        int me = shmem_my_pe();
        int npes = shmem_n_pes();

        long src[N];
        for (int i = 0; i < N; i += 1)
            src[i] = (long) me;

        long *dest = (long *) shmem_malloc(N * sizeof(long));
        int next_pe = (me + 1) % npes;
        shmem_long_put(dest, src, N, next_pe);
        shmem_barrier_all();

        printf("%d @ %s: dest: ", me, u.nodename);
        for (int i = 0; i < N; i += 1)
            printf("%ld, ", dest[i]);
        putchar('\n');

        shmem_free(dest);
        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 4 ./main`

    output:

    ```
    3 @ ubuntu2404: dest: 2, 2, 2, 2, 2, 2, 2, 
    1 @ ubuntu2404: dest: 0, 0, 0, 0, 0, 0, 0, 
    2 @ ubuntu2404: dest: 1, 1, 1, 1, 1, 1, 1, 
    0 @ ubuntu2404: dest: 3, 3, 3, 3, 3, 3, 3, 
    ```

    这个程序用`put`循环地将一个数组（一段内存）从当前 pe 搬移到下一个 pe。

    