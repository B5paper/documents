* 一个动态分配内存的矩阵乘法 c 语言程序 demo

    ```c
    #include <stdlib.h>
    #include <stdio.h>

    typedef enum bool
    {
        false = 0,
        true
    } bool;

    void alloc_matrix(float ***M, size_t nrow, size_t ncol, bool assign_rand_val)
    {
        *M = malloc(nrow * sizeof(float *));
        for (size_t i = 0; i < nrow; ++i)
            *(*M + i) = malloc(ncol * sizeof(float));

        if (assign_rand_val == false)
            return;

        for (size_t i = 0; i < nrow; ++i)
        {
            for (size_t j = 0; j < ncol; ++j)
            {
                // (*M)[i][j] = (float) (rand() % 5);
                *(*(*M + i) + j) = (float) (rand() % 5);
            }
        }
    }

    void free_matrix(float **M, size_t ncol)
    {
        for (size_t i = 0; i < ncol; ++i)
            free(M[i]);
        free(M);
    }

    void print_matrix(float **M, size_t nrow, size_t ncol)
    {
        for (size_t i = 0; i < nrow; ++i)
        {
            for (size_t j = 0; j < ncol; ++j)
            {
                printf("%.0f, ", *(*(M + i) + j));
            }
            putchar('\n');
        }
    }

    int main()
    {
        float **A, **B, **C;
        size_t nrow_A = 4, ncol_A = 2;
        size_t nrow_B = 2, ncol_B = 3;
        size_t nrow_C = nrow_A, ncol_C = ncol_B;

        alloc_matrix(&A, nrow_A, ncol_A, true);
        printf("matrix A:\n");
        print_matrix(A, nrow_A, ncol_A);
        putchar('\n');

        alloc_matrix(&B, nrow_B, ncol_B, true);
        printf("matrix B:\n");
        print_matrix(B, nrow_B, ncol_B);
        putchar('\n');

        alloc_matrix(&C, nrow_C, ncol_C, false);

        for (size_t row = 0; row < nrow_C; ++row)
        {
            for (size_t col = 0; col < ncol_C; ++col)
            {
                C[row][col] = 0;
                for (size_t k = 0; k < ncol_A; ++k)
                {
                    C[row][col] += A[row][k] * B[k][col];
                }
            }
        }

        printf("matrix C = A.dot(B):\n");
        print_matrix(C, nrow_C, ncol_C);

        return 0;
    }
    ```

    说明：

    1. 为什么`(*M)[i][j]`仍然可以访问到元素，但是以前的例子都是在给函数传参数的时候，使用`M[][3]`之类的方式，才能正常访问数组的元素，这两者有什么不同？

    2. 是否可以定义指向数组的指针，比如

        ```c
        int arr[3];
        int[] *parr = &arr;
        ```

    3. c 语言中的`rand()`函数在`stdlib.h`中声明。`size_t`类型在`stddef.h`中定义。
    
        由于`stdlib.h`包含了`stddef.h`，所以如果定义了`stdlib.h`，就不需要再写`#include <stddef.h>`了。

* cached tabs

    * How can I add a user as a new sudoer using the command line?

        <https://askubuntu.com/questions/7477/how-can-i-add-a-user-as-a-new-sudoer-using-the-command-line>

    * Certificate for gnome-remote-desktop

        <https://serverfault.com/questions/1160308/certificate-for-gnome-remote-desktop>

        有时间了学习一下 openssh 命令的用法

    * How do I disable Wayland to use RealVNC Connect? 

        <https://help.realvnc.com/hc/en-us/articles/4417193011857-How-do-I-disable-Wayland-to-use-RealVNC-Connect#is-wayland-supported--0-0>

        禁用 wayland 的方法

    * How to Disable Unattended-Upgrades on Ubuntu 24.04

        <https://ubuntushell.com/disable-unattended-upgrades-in-ubuntu/>

    * How Do I Check What PCI Devices Are Connected On My Linux System?

        <https://www.namehero.com/blog/how-do-i-check-what-pci-devices-are-connected-on-my-linux-system/>

    * How can I understand the device topology?

        <https://superuser.com/questions/1768544/how-can-i-understand-the-device-topology>

    * In Linux, is there a way to find out which PCI card is plugged into which PCI slot?

        <https://stackoverflow.com/questions/25908782/in-linux-is-there-a-way-to-find-out-which-pci-card-is-plugged-into-which-pci-sl>

* gnome 的 remote desktop 几乎只能通过图形化设置完成，在使用命令行设置时，`gnome-keyring`的配置十分复杂

* llvm hello world

    `main.cpp`:

    ```cpp
    int main()
    {
        return 42;
    }
    ```

    执行`clang++-11 -S -emit-llvm ./main.cpp`，会生成

    `main.ll`:

    ```
    ; ModuleID = './main.cpp'
    source_filename = "./main.cpp"
    target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
    target triple = "x86_64-pc-linux-gnu"

    ; Function Attrs: noinline norecurse nounwind optnone uwtable
    define dso_local i32 @main() #0 {
      %1 = alloca i32, align 4
      store i32 0, i32* %1, align 4
      ret i32 42
    }

    attributes #0 = { noinline norecurse nounwind optnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

    !llvm.module.flags = !{!0}
    !llvm.ident = !{!1}

    !0 = !{i32 1, !"wchar_size", i32 4}
    !1 = !{!"Ubuntu clang version 11.1.0-6"}

    ```

    执行`clang++-11 -o main main.ll`，可生成可执行程序`main`。

    运行`./main`，再执行`echo $?`，可以看到 main 程序的返回值为 42。

    执行`lli main.ll`，同样也可以生成 binary。

* 调研`select`的用法