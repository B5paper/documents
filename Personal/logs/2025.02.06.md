* cuda stream

    `__host__ ​cudaError_t cudaStreamCreate ( cudaStream_t* pStream ) `

    在当前 host thread 最新的 context 上创建一个 stream。

    如果当前 host thread 没有 context，那么在 device 的 primary context 上创建一个 stream，并将这个 context 作为当前 host thread 的 context.

    销毁 stream:

    `__host__ ​ __device__ ​cudaError_t cudaStreamDestroy ( cudaStream_t stream ) `
    
* 概念重定义

    对于一个所有概念都清晰定义的系统，如果剔除某个概念 A 的定义，只保留其他概念对 A 的使用，那么根据这些使用的描述，我们能从什么程度上反推出 A 的定义？

    example:

    > 为了获得高带宽，shared Memory被分成32（对应warp中的thread）个相等大小的内存块，他们可以被同时访问。不同的CC版本，shared memory以不同的模式映射到不同的块（稍后详解）。如果warp访问shared Memory，对于每个bank只访问不多于一个内存地址，那么只需要一次内存传输就可以了，否则需要多次传输，因此会降低内存带宽的使用。

    上面是某个博客的一段文字，其中用到了 bank 的概念，但是并没有给出 bank 的定义。我们是否能仅通过类似这样描述性的文字，推测出 bank 的定义或含义？

* 当`__shared__`在 kernel 外声明时，依然有基本功能：被`__shared__`修饰的数据，只在同一个 block 中相冋，并且只能被同一个 block 中的 thread 访问

    example:

    `main.cu`:

    ```cpp
    #include <cuda_runtime.h>
    #include <stdio.h>

    __shared__ int a;

    __global__ void my_kern()
    {
        if (threadIdx.x == 0)
        {
            a = blockIdx.x;
        }
        __syncthreads();
        if (threadIdx.x == 1)
        {
            printf("in block %d, a = %d\n", blockIdx.x, a);
        }
    }

    int main()
    {
        my_kern<<<2, 32>>>();
        cudaDeviceSynchronize();
        return 0;
    }
    ```

    compile: `nvcc main.cu -o main`

    run: `./main`

    output:

    ```
    in block 0, a = 0
    in block 1, a = 1
    ```

    可以看到，不同 block 访问到的 shared 数据不同。