1. 学习一下 c++ make uniquue

    可以自定义一个类型，然后使用 make unique 创建一个固定长度的数组。

    ```cpp
    // c++14
    auto constantContainer = std::make_unique<YourType []> ( size );

    // c++11
    std::unique_ptr<YourType[]> constantContainer {new YourType[ size ]};


    // Access
    constantContainer[ i ]
    ```

    有空了研究一下这段代码，分析一下利弊。

* 关于固定长度的数组，还可以这样写：

    ```cpp
    typedef std::array<int, 10> MyIntArray;
    using MyIntArray = std::array<int, 10>;.
    ```

    别人写的一些模板类也可以做到：

    ```cpp
    inline void nodeleter(void*) {}

    /// Array of T with ownership. Like \see std::unique_ptr<T[]> but with size tracking.
    /// @tparam T Element type.
    template <typename T>
    class unique_array : public std::unique_ptr<T[],void (*)(void*)>
    {   size_t Size;
    private:
        typedef std::unique_ptr<T[],void (*)(void*)> base;
    protected:
        unique_array(T* ptr, size_t size, void (*deleter)(void*)) noexcept : base(ptr, deleter), Size(size) {}
        void reset(T* ptr, size_t size) noexcept { base::reset(ptr); Size = size; }
    public:
        constexpr unique_array() noexcept : base(nullptr, operator delete[]), Size(0) {}
        explicit unique_array(size_t size) : base(new T[size], operator delete[]), Size(size) {}
        template <size_t N> unique_array(T(&arr)[N]) : base(arr, &nodeleter), Size(N) {}
        unique_array(unique_array<T>&& r) : base(move(r)), Size(r.Size) { r.Size = 0; }
        void reset(size_t size = 0) { base::reset(size ? new T[size] : nullptr); Size = size; }
        void swap(unique_array<T>&& other) noexcept { base::swap(other); std::swap(Size, other.Size); }
        void assign(const unique_array<T>& r) const { assert(Size == r.Size); std::copy(r.begin(), r.end(), begin()); }
        const unique_array<T>& operator =(const unique_array<T>& r) const { assign(r); return *this; }
        size_t size() const noexcept { return Size; }
        T* begin() const noexcept { return base::get(); }
        T* end() const noexcept { return begin() + Size; }
        T& operator[](size_t i) const { assert(i < Size); return base::operator[](i); }
        unique_array<T> slice(size_t start, size_t count) const noexcept
        {   assert(start + count <= Size); return unique_array<T>(begin() + start, count, &nodeleter); }
    };
    ```

    模板类：

    ```cpp
    #ifndef LEFTICUS_TOOLS_SIMPLE_STACK_VECTOR_HPP
    #define LEFTICUS_TOOLS_SIMPLE_STACK_VECTOR_HPP

    #include <array>
    #include <cstdint>
    #include <stdexcept>
    #include <vector>

    namespace lefticus::tools {


    // changes from std::vector
    //  * capacity if fixed at compile-time
    //  * it never allocates
    //  * items must be default constructible
    //  * items are never destroyed until the entire stack_vector
    //    is destroyed.
    //  * iterators are never invalidated
    //  * capacity() and max_size() are now static functions
    //  * should be fully C++17 usable within constexpr
    template<typename Contained, std::size_t Capacity> struct simple_stack_vector
    {
    using value_type = Contained;
    using data_type = std::array<value_type, Capacity>;
    using size_type = typename data_type::size_type;
    using difference_type = typename data_type::difference_type;
    using reference = value_type &;
    using const_reference = const value_type &;

    static_assert(std::is_default_constructible_v<Contained>);

    using iterator = typename data_type::iterator;
    using const_iterator = typename data_type::const_iterator;
    using reverse_iterator = typename data_type::reverse_iterator;
    using const_reverse_iterator = typename data_type::const_reverse_iterator;

    constexpr simple_stack_vector() = default;
    constexpr explicit simple_stack_vector(std::initializer_list<value_type> values)
    {
        for (const auto &value : values) { push_back(value); }
    }

    template<typename OtherContained, std::size_t OtherSize>
    constexpr explicit simple_stack_vector(const simple_stack_vector<OtherContained, OtherSize> &other)
    {
        for (const auto &value : other) { push_back(Contained{ value }); }
    }

    template<typename Type> constexpr explicit simple_stack_vector(const std::vector<Type> &values)
    {
        for (const auto &value : values) { push_back(Contained{ value }); }
    }

    template<typename Itr> constexpr simple_stack_vector(Itr begin, Itr end)
    {
        while (begin != end) {
        push_back(*begin);
        ++begin;
        }
    }

    [[nodiscard]] constexpr iterator begin() noexcept { return data_.begin(); }

    [[nodiscard]] constexpr const_iterator begin() const noexcept { return data_.cbegin(); }
    [[nodiscard]] constexpr const_iterator cbegin() const noexcept { return data_.cbegin(); }

    [[nodiscard]] constexpr iterator end() noexcept
    {
        return std::next(data_.begin(), static_cast<difference_type>(size_));
    }

    [[nodiscard]] constexpr const_iterator end() const noexcept
    {
        return std::next(data_.cbegin(), static_cast<difference_type>(size_));
    }

    [[nodiscard]] constexpr value_type &front() noexcept { return data_.front(); }
    [[nodiscard]] constexpr const value_type &front() const noexcept { return data_.front(); }
    [[nodiscard]] constexpr value_type &back() noexcept { return data_.back(); }
    [[nodiscard]] constexpr const value_type &back() const noexcept { return data_.back(); }

    [[nodiscard]] constexpr const_iterator cend() const noexcept { return end(); }

    [[nodiscard]] constexpr reverse_iterator rbegin() noexcept
    {
        return std::next(data_.rbegin(), static_cast<difference_type>(Capacity - size_));
    }

    [[nodiscard]] constexpr const_reverse_iterator rbegin() const noexcept
    {
        return std::next(data_.crbegin(), static_cast<difference_type>(Capacity - size_));
    }
    [[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept { return rbegin(); }

    [[nodiscard]] constexpr bool empty() const noexcept { return size_ == 0; }

    [[nodiscard]] constexpr reverse_iterator rend() noexcept { return data_.rend(); }

    [[nodiscard]] constexpr const_reverse_iterator rend() const noexcept { return data_.crend(); }

    [[nodiscard]] constexpr const_reverse_iterator crend() const noexcept { return data_.crend(); }

    template<typename Value> constexpr value_type &push_back(Value &&value)
    {
        if (size_ == Capacity) { throw std::length_error("push_back would exceed static capacity"); }
        data_[size_] = std::forward<Value>(value);
        return data_[size_++];
    }

    template<typename... Param> constexpr value_type &emplace_back(Param &&...param)
    {
        if (size_ == Capacity) { throw std::length_error("emplace_back would exceed static capacity"); }
        data_[size_] = value_type{ std::forward<Param>(param)... };
        return data_[size_++];
    }

    [[nodiscard]] constexpr value_type &operator[](const std::size_t idx) noexcept { return data_[idx]; }

    [[nodiscard]] constexpr const value_type &operator[](const std::size_t idx) const noexcept { return data_[idx]; }

    [[nodiscard]] constexpr value_type &at(const std::size_t idx)
    {
        if (idx > size_) { throw std::out_of_range("index past end of stack_vector"); }
        return data_[idx];
    }

    [[nodiscard]] constexpr const value_type &at(const std::size_t idx) const
    {
        if (idx > size_) { throw std::out_of_range("index past end of stack_vector"); }
        return data_[idx];
    }

    // resets the size to 0, but does not destroy any existing objects
    constexpr void clear() { size_ = 0; }


    // cppcheck-suppress functionStatic
    constexpr void reserve(size_type new_capacity)
    {
        if (new_capacity > Capacity) { throw std::length_error("new capacity would exceed max_size for stack_vector"); }
    }

    // cppcheck-suppress functionStatic
    [[nodiscard]] constexpr static size_type capacity() noexcept { return Capacity; }

    // cppcheck-suppress functionStatic
    [[nodiscard]] constexpr static size_type max_size() noexcept { return Capacity; }

    [[nodiscard]] constexpr size_type size() const noexcept { return size_; }


    constexpr void resize(const size_type new_size)
    {
        if (new_size <= size_) {
        size_ = new_size;
        } else {
        if (new_size > Capacity) {
            throw std::length_error("resize would exceed static capacity");
        } else {
            auto old_end = end();
            size_ = new_size;
            auto new_end = end();
            while (old_end != new_end) {
            *old_end = data_type{};
            ++old_end;
            }
        }
        }
    }

    constexpr void pop_back() noexcept { --size_; }

    // cppcheck-suppress functionStatic
    constexpr void shrink_to_fit() noexcept
    {
        // nothing to do here
    }


    private:
    // default initializing to make it more C++17 friendly
    data_type data_{};
    size_type size_{};
    };


    template<typename Contained, std::size_t LHSSize, std::size_t RHSSize>
    [[nodiscard]] constexpr bool operator==(const simple_stack_vector<Contained, LHSSize> &lhs,
    const simple_stack_vector<Contained, RHSSize> &rhs)
    {
    if (lhs.size() == rhs.size()) {
        for (std::size_t idx = 0; idx < lhs.size(); ++idx) {
        if (lhs[idx] != rhs[idx]) { return false; }
        }
        return true;
    }

    return false;
    }

    }// namespace lefticus::tools


    #endif
    ```

    学习一下`std::span`.

* c++ needs to learn

    * List-initialization (since C++11)

        <https://en.cppreference.com/w/cpp/language/list_initialization>

    * Default Parameters With Default Template Parameters Types

        <https://www.fluentcpp.com/2018/08/10/template-default-arguments-application-smart-iterators/>

    * Thinking in C++ Vol 2 - Practical Programming

        <https://www.linuxtopia.org/online_books/programming_books/c++_practical_programming/c++_practical_programming_107.html>

    * Tricks with Default Template Arguments

        <https://www.foonathan.net/2020/10/tricks-default-template-argument/>

    * Union declaration

        <https://en.cppreference.com/w/cpp/language/union>

    * Resolve "DSO missing from command line" error

        <https://zhangboyi.gitlab.io/post/2020-09-14-resolve-dso-missing-from-command-line-error/>
    
    * libpthread.so.0: error adding symbols: DSO missing from command line

        <https://stackoverflow.com/questions/19901934/libpthread-so-0-error-adding-symbols-dso-missing-from-command-line>

    * How can I clear an input buffer in C?

        <https://stackoverflow.com/questions/7898215/how-can-i-clear-an-input-buffer-in-c>

    * Clearing the buffer when using Getchar (there must be a better way!)

        <https://stackoverflow.com/questions/43954160/clearing-the-buffer-when-using-getchar-there-must-be-a-better-way>

    * Detect Operating System in C

        <https://iq.opengenus.org/detect-operating-system-in-c/>

* 有关c++框架的调试

    有些程序是 c++ 的框架程序，代码分为上下层两部分，上层以是抽象类和接口，下层是接口的实现。整个代码中用到了大量的虚函数。

    这种程序调试时的一些经验如下：

    * 对于一个基类对象，在调用它的虚函数时，使用静态分析代码+跳转可能找不到正确的虚函数，可以在程序运行时，使用 F11 step in 到虚函数里，就能找到正确的虚函数了。

    * 想要将下层实现的头文件包含到上层，然后强制将基类对象指针转换成继承类的指针，很有可能会编译失败。通常的解决方法为在基类中写个虚函数，然后自己在派生类里实现一下。

        如果基类里是纯虚函数，那么需要在所有的派生类里实现一遍。

        最后用基类指针去调用虚函数就可以了，c++会自动帮你找到派生类的虚函数。

    * 如果不熟悉项目的编译系统，可以尝试在`.cpp`文件里引入`.hpp`文件，把实现写到头文件里。

* 与 vulkan 相关的代码中，经常会用`return false;`表示成功。其实这里的 false 指的可能是 0，或者`VK_SUCCESS`。

    在检查函数的返回值时可以考虑到这点。

* vulkan 中 image layout 是否正确并不影响 command 的执行，但是 barrier 如果设置得不对，就会导致一个 shader 的输出还没被计算完，就被另外一个 shader 使用。

    由于 vulkan 中的 barrier 兼具 layout 转换和 memory barrier 的作用，所以 layout 随便填一填就行了，barrier 还是得设置。

* cache

    * c++

        * C++ Syncing threads in most elegant way

            <https://stackoverflow.com/questions/16277840/c-syncing-threads-in-most-elegant-way>

        * Three Simple Ways For C++ Thread Synchronization in C++11 and C++14

            <https://chrizog.com/cpp-thread-synchronization>

        * std::counting_semaphore, std::binary_semaphore

            <https://en.cppreference.com/w/cpp/thread/counting_semaphore>

        * C++ 多线程（七）：信号量 Semaphore 及 C++ 11 实现

            <https://zhuanlan.zhihu.com/p/512969481>

        * C++学习笔记：模板参数

            <https://blog.csdn.net/iuices/article/details/122872720>

        * 类模板三种类模板参数

            <https://blog.csdn.net/u014253011/article/details/80036801>

        * Function template

            <https://en.cppreference.com/w/cpp/language/function_template>

        * Friend Class and Function in C++

            <https://www.geeksforgeeks.org/friend-class-function-cpp/>

        * stringstream Class In C++ – Usage Examples And Applications

            <https://www.softwaretestinghelp.com/stringstream-class-in-cpp/>

        * Stringstream in C++

            <https://www.tutorialspoint.com/stringstream-in-cplusplus>

        * stringstream in C++ and its Applications

            <https://www.geeksforgeeks.org/stringstream-c-applications/>

        * Unnamed and inline namespaces

            <https://www.learncpp.com/cpp-tutorial/unnamed-and-inline-namespaces/>

        * Async.h - asynchronous, stackless subroutines

            <https://github.com/naasking/async.h>

        * Sample code for asynchronous programming in C

            <https://stackoverflow.com/questions/2108961/sample-code-for-asynchronous-programming-in-c>

        * Asynchronous Routines For C

            <https://hackaday.com/2019/09/24/asynchronous-routines-for-c/>

        * typedef in C++

            <https://www.geeksforgeeks.org/typedef-in-cpp/>

        * typedef specifier

            <https://en.cppreference.com/w/cpp/language/typedef>

        * override specifier (since C++11)

            <https://en.cppreference.com/w/cpp/language/override>

        * C++ Delegate模板类的设计

            <https://blog.csdn.net/weixin_50948630/article/details/132110710>

    * opengl

        * Tutorial 7 : Model loading
        
            <http://www.opengl-tutorial.org/beginners-tutorials/tutorial-7-model-loading/>

        * The Matrix and Quaternions FAQ

            <http://www.opengl-tutorial.org/assets/faq_quaternions/index.html>

        * Welcome to OpenGL

            <https://learnopengl.com/>

        * opengl读取obj兔子并贴图_OpenGL学习笔记(八)-纹理

            <https://blog.csdn.net/weixin_39925813/article/details/110901035>

        * free 3d model downloading

            <https://free3d.com/>

        *  LearnOpenGL-CN

            <https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/01%20OpenGL/>

        * GLSL 语言—矢量和矩阵 [ ] 运算符

            <https://cloud.tencent.com/developer/article/1504841>

        * 欢迎来到OpenGL的世界

            <https://learnopengl-cn.github.io/>

        * glumpy: opengl + numpy

            <https://github.com/glumpy/glumpy>

        * PyGLM: OpenGL Mathematics (GLM) library for Python

            <https://pypi.org/project/PyGLM/>

        * glumpy 1.2.1 

            <https://pypi.org/project/glumpy/>

        * VisPy

            <https://macrocosme.github.io/vispy-and-the-future-of-big-data-visualisation/>

        * 3d graphics

            <http://morpheo.inrialpes.fr/~franco/3dgraphics/index.html>

        * gltut for python

            <https://www.pygame.org/project-gltut+for+python-2797-.html>

        * GLSL Programming/Vector and Matrix Operations

            <https://en.wikibooks.org/wiki/GLSL_Programming/Vector_and_Matrix_Operations>

        * opengl 4.5

            <https://yaakuro.gitbook.io/opengl-4-5/>

        * Buffer Object

            <https://www.khronos.org/opengl/wiki/Buffer_Object>

        * glGetString — return a string describing the current GL connection

            <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetString.xhtml>

        * OpenGL® 4.5 Reference Pages 

            <https://registry.khronos.org/OpenGL-Refpages/gl4/>

        * ogl dev: modern opengl tutorials

            <https://ogldev.org/>

        * Download Computer Graphics With Opengl (3rd Edition) 

            <https://vdoc.pub/download/computer-graphics-with-opengl-3rd-edition-6dr3a2ql4vi0>

        * learn opengl

            <https://learnopengl.com/Lighting/Colors>

        * Modern OpenGL

            <https://glumpy.github.io/modern-gl.html>

        * OpenGL Programming/Scientific OpenGL Tutorial 03

            <https://en.wikibooks.org/wiki/OpenGL_Programming/Scientific_OpenGL_Tutorial_03>

        * glm Geometric functions

            <https://glm.g-truc.net/0.9.4/api/a00131.html>

        * awesome-opengl
        
            <https://github.com/eug/awesome-opengl>

        * 浅析OpenGL光照

            <https://www.cnblogs.com/javawebsoa/p/3243737.html>

        * GLSL Tutorial von Lighthouse3D

            <https://cgvr.cs.uni-bremen.de/teaching/cg2_07/literatur/glsl_tutorial/index.html>

        * Getting started with glsl

            <https://riptutorial.com/glsl>

        * OpenGL 101: Textures 

            <https://solarianprogrammer.com/2013/05/17/opengl-101-textures/>

        * How to debug a GLSL shader?

            <https://stackoverflow.com/questions/2508818/how-to-debug-a-glsl-shader>


* learn mmd

    <https://learnmmd.com/http:/learnmmd.com/create-mmd-model-color-morphs-using-pmxe/>

* 记录一次xf86vmode library not found问题

    <https://blog.csdn.net/qq1186351245/article/details/125300966>

* Saba: a mmd player

    <https://github.com/benikabocha/saba>

* Welcome to Skia: The 2D Graphics Library

    <https://skia.org/>
    
* compiler

    * glslang

        <https://github.com/KhronosGroup/glslang>

    * Introduction to bison

        <https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/120%20Introducing%20bison.pdf>

    * Question for pest parser example

        <https://users.rust-lang.org/t/question-for-pest-parser-example/82041>

    * pest

        <https://pest.rs/>

* vulkan-compute 

    <https://github.com/topics/vulkan-compute>

* Getting Started with Vulkan Compute Acceleration

    <https://www.khronos.org/blog/getting-started-with-vulkan-compute-acceleration>

* Arrow Types in LaTeX: A Complete List

    <https://latex-tutorial.com/arrow-latex/>


    

