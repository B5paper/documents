* `GRUB_CMDLINE_LINUX="console=ttyS0"`

    将系统的第一个串行端口（ttyS0） 设置为主要控制台（console）

    qemu 虚拟机中，在`/etc/default/grub`中修改`GRUB_CMDLINE_LINUX`为`GRUB_CMDLINE_LINUX="console=ttyS0"`，使配置生效：`sudo update-grub`，重启后可以看到 console 中显示整个开机过程的 log，随机进入登陆提示。部分输出如下：

    ```
    ...
    [  OK  ] Finished Permit User Sessions.
    systemd-user-sessions.service
             Starting Hold until boot process finishes up...
             Starting Terminate Plymouth Boot Screen...

    Ubuntu 22.04.4 LTS Ubuntu22 ttyS0

    Ubuntu22 login: 
    ```

    `console=`是一个内核参数，用于指定内核和系统消息（包括启动信息、登录提示、系统错误等）输出到哪个设备。

    `ttyS`是 Linux 中对串行端口（Serial Port，也叫 COM 端口）的命名。`ttyS0`对应第一个串行端口（即 Windows 系统中的 COM1 口）。

    还可以将`console=ttyS0`改为`console=ttyS0,115200n8`，其中

    * `115200`：波特率（Baud Rate），为 115200 bps（比特每秒），表示数据传输的速度。

    * `n`：奇偶校验（Parity），n 代表 “none”，即无奇偶校验。

    * `8`：数据位（Data Bits），为 8 个数据位。

* `-append 'console=ttyS0'`不能单独使用，必须和`-kernel`同时使用。

    否则 qemu 会报错：

    ```
    qemu-system-x86_64: -append only allowed with -kernel option
    ```

    典型使用场景：

    ```bash
    qemu-system-x86_64 \
      -kernel /path/to/vmlinuz \
      -initrd /path/to/initrd \
      -append "root=/dev/vda1 ro console=ttyS0" \
      -nographic
    ```

    这里的 -append "console=ttyS0" 和 -nographic 选项配合，将虚拟机的控制台重定向到当前终端（模拟了一个串口）。

* `alarm()`

    为当前进程设置一个定时器（闹钟），在指定的时间到期后，内核会向该进程发送一个 SIGALRM 信号。

    syntax:

    ```c
    #include <unistd.h>

    unsigned int alarm(unsigned int seconds);
    ```

    如果一个进程之前已经通过 alarm() 设置了一个尚未触发的闹钟，再次调用 alarm() 将会重置（覆盖） 之前的闹钟。

    函数的返回值是前一个闹钟的剩余秒数。如果之前没有设置闹钟，则返回0。

    SIGALRM 信号的默认操作是终止进程。通常，我们不会使用默认操作，而是使用 signal() 或 sigaction() 函数来捕获这个信号，并为其注册一个信号处理函数，以便在定时器到期时执行自定义的操作（例如超时处理、周期性任务等）。

    example:

    ```c
    #include <stdio.h>
    #include <unistd.h>
    #include <signal.h>

    // 信号处理函数
    void alarm_handler(int signum) {
        printf("Ring! Alarm received. Time's up!\n");
    }

    int main() {
        // 注册信号处理函数，捕获SIGALRM信号
        signal(SIGALRM, alarm_handler);

        printf("Setting alarm for 3 seconds...\n");
        alarm(3); // 设置3秒后发送SIGALRM信号

        // 暂停进程，等待信号
        pause();

        printf("Program continues after alarm.\n");
        return 0;
    }
    ```

    output:

    ```
    Setting alarm for 3 seconds...
    Ring! Alarm received. Time's up!
    Program continues after alarm.
    ```

    alarm() 的定时精度是秒，对于需要更高精度（如毫秒、微秒）的定时任务，应该使用 setitimer() 或更现代的 timer_create() 等函数。

* `subst`

    用于在 makefile 字符串中进行文本替换。它可以将一个字符串（或变量）中所有出现的指定子字符串，替换为另一个指定的子字符串。

    syntax:

    ```makefile
    $(subst FROM,TO,TEXT)
    ```

    * FROM：你希望被替换掉的子字符串。

    * TO：你希望用来替换 FROM 的新子字符串。

    * TEXT：需要进行替换操作的原始字符串或变量。

    注意：参数之间用逗号 , 分隔，并且不能有空格，否则空格会被当作字符串的一部分。

    example:

    ```makefile
    # 定义一个变量
    ORIGINAL = foo bar baz foo

    # 使用 subst 将所有的 "foo" 替换为 "qux"
    RESULT = $(subst foo,qux,$(ORIGINAL))

    all:
    	@echo "Original: $(ORIGINAL)"
    	@echo "Result:   $(RESULT)"
    ```

    output:

    ```
    Original: foo bar baz foo
    Result:   qux bar baz qux
    ```

    其中，`RESULT`还可以写成`RESULT = $(subst foo,qux,"foo bar baz foo")`, `RESULT = $(subst foo,qux,foo bar baz foo)`, 但是不能写成

    `RESULT = $(subst foo,qux, foo bar baz foo)`, 否则会多出一个空格：

    ```
    Original: foo bar baz foo
    Result:    qux bar baz qux
    ```

    常见应用场景:

    * 修改文件后缀

        这是 subst 最经典的用法之一，用于生成目标文件列表。

        ```makefile
        SOURCES = main.c utils.c helper.c
        # 将 .c 替换为 .o
        OBJECTS = $(subst .c,.o,$(SOURCES))

        all: $(OBJECTS)
            # ...

        # 这条规则会尝试编译 main.o, utils.o, helper.o
        ```

    * 调整路径格式

        例如，将空格路径转换为适合某些命令行工具的格式。

        ```makefile
        PATH_WITH_SPACES = /path/with\ spaces/file.txt
        # 将空格替换为转义空格（或其他字符）
        ESCAPED_PATH = $(subst \ ,\\ ,$(PATH_WITH_SPACES))
        ```

    * 简单的字符串修正

        任何需要批量修改字符串内容的地方。

        ```makefile
        MY_MSG = This is a test string.
        # 将所有的空格替换为连字符
        HYPHENATED = $(subst ,-,$(MY_MSG))
        # HYPHENATED 的值变为：This-is-a-test-string.
        ```

* vscode 快捷键

    * 移动到下一个词的开头	Ctrl + →

    * 移动到上一个词的开头	Ctrl + ←

    * 选择到下一个词的开头	Ctrl + Shift + →

    * 选择到上一个词的开头	Ctrl + Shift + ←

    * 删除前一个词	Ctrl + Backspace

    * 删除后一个词	Ctrl + Delete

    * 打开设置  Ctrl + ,

* `copy_from_user()`

    将数据从用户空间安全地复制到内核空间。

    syntax:

    ```c
    #include <linux/uaccess.h>

    unsigned long copy_from_user(void *to, const void __user *from, unsigned long n);
    ```

    parameters:

    * `to`: Destination address, in the kernel space

    * `from`: The source address in the user space

    * `n`: Number of bytes to copy

    Returns number of bytes that could not be copied. On success, this will be zero.

* `mdev_get_drvdata()`

    用于 VFIO Mediated Device (mdev) 框架的函数。它的主要作用是从一个 mdev_device 结构体中，获取驱动之前存储的私有数据指针。

    VFIO (Virtual Function I/O)： 是一个内核框架，允许用户空间程序（如虚拟机）安全、高效地直接访问硬件设备（即设备直通，Device Passthrough）。

    mdev (Mediated Device)： 是 VFIO 框架的一部分，用于实现设备模拟或分区。它允许一个物理设备（如图形卡、网络卡）被虚拟化成多个独立的虚拟设备，每个虚拟设备可以被分配给不同的虚拟机。

    syntax:

    ```c
    void *mdev_get_drvdata(struct mdev_device *mdev);
    ```

    参数： `mdev` - 指向要获取数据的 mdev_device 的指针。

    返回值： 成功时返回之前通过 mdev_set_drvdata() 设置的 void * 类型的私有数据指针；如果从未设置过，则可能返回 NULL。

    example:

    ```c
    // 1. 在设备创建时（例如在 'probe' 回调中）分配并设置私有数据
    static int my_mdev_probe(struct mdev_device *mdev)
    {
        struct my_private_data *data;

        data = kzalloc(sizeof(*data), GFP_KERNEL);
        if (!data)
            return -ENOMEM;

        // 初始化私有数据结构...
        data->parent_dev = mdev->parent->dev;
        // ... 其他初始化

        // 关键步骤：将私有数据指针存储到 mdev_device 中
        mdev_set_drvdata(mdev, data);

        return 0;
    }

    // 2. 在设备的其他操作函数中（如 ioctl），获取并使用私有数据
    static long my_mdev_ioctl(struct mdev_device *mdev, unsigned int cmd, unsigned long arg)
    {
        // 关键步骤：获取之前存储的私有数据
        struct my_private_data *data = mdev_get_drvdata(mdev);

        if (!data) // 安全检查
            return -EINVAL;

        // 现在可以使用 data 来访问这个特定设备的上下文信息了
        switch (cmd) {
            case MY_CMD:
                // 操作 data->some_field
                break;
            // ... 其他命令
            default:
                return -ENOTTY;
        }
        return 0;
    }

    // 3. 在设备销毁时（例如在 'remove' 回调中），获取数据并释放内存
    static void my_mdev_remove(struct mdev_device *mdev)
    {
        struct my_private_data *data = mdev_get_drvdata(mdev);

        // 清理私有数据可能占用的资源...
        
        // 释放私有数据内存
        kfree(data);
        
        // 可选：将 mdev 的 drvdata 设为 NULL
        mdev_set_drvdata(mdev, NULL);
    }
    ```

    配套函数：`mdev_set_drvdata()`

* `vector<unique_ptr<MyStruc>> vec`无法直接`push_back()`裸指针，但是可以`emplace_back()`

    example:

    ```cpp
    vector<unique_ptr<MyStruc>> vec;
    vec.push_back(new MyStruc);  // error
    vec.emplace_back(new MyStruc);  // OK
    ```
* 不默认保持中文输入法的另外一个原因

    有时候需要按`shift` + 鼠标滚轮横向滚动，但是`shift`又正好是切换中英文的，这样会导致每横向滚动一次，就在中英文中间切换一次。

* `readelf -l /bin/bash | grep interpreter`

    查找 /bin/bash 可执行文件所使用的动态链接器（interpreter）的路径。

    output:
    
    ```
          [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
    ```

    这表示：

    * `/bin/bash`依赖于动态链接器 /lib64/ld-linux-x86-64.so.2 来加载运行所需的共享库（如 libc.so）。

    * 系统内核在执行 /bin/bash 时，会先加载这个指定的动态链接器，再由它处理后续的库依赖和符号解析。

* ubuntu gnome 中 settings 里的 shortcuts 快捷键设置显示不全，可以使用命令行显示全部的快捷键

    example:

    * 向左/向右切换虚拟桌面

        gnome -> settings 中只列出了`super` + `PageUp` / `PageDown`，但是实际上还可以使用`Ctrl` + `Alt` + `ArrowLeft` / `ArrowRight` 切换，说明 settings 列出的信息不全。

        执行`gsettings get org.gnome.desktop.wm.keybindings switch-to-workspace-left`，输出为

        ```
        ['<Super>Page_Up', '<Super><Alt>Left', '<Control><Alt>Left']
        ```

        可以看到，这里的信息是全的。我们可以将其设置为只使用第一个：

        `gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-left "['<Super>Page_Up']"`

        此时便禁用掉了`Ctrl` + `Alt` + `LeftArrow`。

* 带自回归的 Encoder-Decoder 架构

    一种用于处理序列到序列（Seq2Seq） 任务的深度学习模型框架。它的核心思想是将一个输入序列（如一句英文句子）转换为一个输出序列（如对应的中文句子），并且输出序列的生成是逐步、自回归地进行的。

    * Encoder（编码器）：

        * 作用：读取并理解整个输入序列。

        * 工作方式：它接收整个输入序列（例如 “I love machine learning”），并通过神经网络（通常是 RNN, LSTM, GRU 或 Transformer）将其压缩成一个固定维度的上下文向量（Context Vector） 或一组隐藏状态。这个向量/状态集旨在包含输入序列的全部语义信息。

    * Decoder（解码器）：

        * 作用：根据编码器的信息和已生成的部分输出，逐步生成完整的输出序列。

        * 工作方式：解码器的生成过程是自回归的（Autoregressive）。这是最关键的一点。

            * 自回归：意味着在生成输出序列的每一个新词（或 token）时，都会将之前已经生成的所有词作为额外输入。

            * 具体步骤：

                1. 解码器从编码器得到的上下文向量和一個特殊的开始符（如 <start>） 开始。
                
                2. 它产生第一个输出词（如 “我”）。

                3. 然后，它将这个刚刚生成的词“我”（而不是真实的目标词）和当前的隐藏状态一起作为输入，来生成下一个词“爱”。

                4. 如此循环，每次生成都依赖于之前的输出，直到生成一个特殊的结束符（如 `<end>`） 表示生成为止。

    简单比喻：

    就像一个同声传译员。

    * Encoder：听完整句英文，并理解其含义。

    * Decoder：开始用中文翻译，每说一个词（“我”），都会参考自己刚才说的词和听到的英文原意，来决定下一个词说什么（“爱”），直到翻译完整个句子。

    相关的模型：

    * RNN-based Seq2Seq (2014)

        由 Sutskever 等人和 Bahdanau 等人提出。

        使用RNN或LSTM作为Encoder和Decoder的核心。最初的模型将整个输入序列压缩成一个固定的上下文向量，这在处理长序列时会造成信息瓶颈。

        改进：注意力机制（Attention Mechanism） 被引入（Bahdanau et al.），允许解码器在生成每个词时“回头看”编码器的所有隐藏状态，从而动态地获取最相关的信息，极大提升了长序列的处理能力。（注意：带注意力的Seq2Seq是极其重要的变体）

    * transformer (2017)

        由 Vaswani 等人在论文《Attention Is All You Need》中提出。

        完全基于自注意力机制（Self-Attention） 的模型，彻底抛弃了RNN。它仍然是Encoder-Decoder架构，但其编码和解码的方式发生了革命性变化。

        Encoder：由多层自注意力和前馈网络组成，并行处理整个输入序列。

        Decoder：同样是自回归的，但在自注意力层中加入了掩码（Mask），确保在生成位置 i 的词时，只能看到位置 1 到 i-1 的词，而不能看到“未来”的信息。

    * 基于Transformer的著名模型（都属于此架构）

        * GPT 系列：严格来说，GPT是只有Decoder的模型。它通过掩码自注意力实现自回归生成，可以看作是Decoder-only架构，但其核心思想——自回归生成——与Encoder-Decoder中的Decoder部分完全相同。

        * BART 和 T5：这些是经典的、真正的带自回归Decoder的Encoder-Decoder模型。它们在预训练时专门为此架构设计（如通过去噪、文本填充等任务），在摘要、翻译、问答等任务上表现卓越。

        * 现代大语言模型（LLMs）：如 ChatGPT 背后的模型，虽然其基础（GPT）是Decoder-only，但其通过指令微调（Instruction Tuning）和人类反馈强化学习（RLHF）学会了很多“理解-生成”的对话能力，其生成回复的过程就是典型的自回归方式。

    * 奠基性论文：

        * Seq2Seq 开创：Sutskever, I., Vinyals, O., & Le, Q. V. (2014). Sequence to sequence learning with neural networks. In NeurIPS. [必读]

        * 注意力机制：Bahdanau, D., Cho, K., & Bengio, Y. (2014). Neural machine translation by jointly learning to align and translate. arXiv preprint arXiv:1409.0473. [必读]

        * Transformer：Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., ... & Polosukhin, I. (2017). Attention is all you need. In NeurIPS. [必读中的必读]


