* 如果两个 struct 定义在不同的文件里，那么不可能在两个 struct 中互相包含对方的成员实体

    example:

    `header_1.h`:

    ```cpp
    #ifndef HEADER_1_H
    #define HEADER_1_H

    #include "header_2.h"

    struct A {
        int val_1;
        float val_2;
    };

    #endif
    ```

    `header_2.h`:

    ```cpp
    #ifndef HEADER_2_H
    #define HEADER_2_H

    #include "header_1.h"

    // struct A;

    struct B {
        int val_1;
        double val_2;
        A obj_a;
    };

    #endif
    ```

    `impl_1.cpp`:

    ```cpp
    #include "header_1.h"
    ```

    `impl_2.cpp`:

    ```cpp
    #include "header_2.h"
    ```

    `Makefile`:

    ```makefile
    all: impl_1.o impl_2.o

    impl_1.o: header_1.h impl_1.cpp
    	g++ -g -c impl_1.cpp -o impl_1.o

    impl_2.o: header_2.h impl_2.cpp
    	g++ -g -c impl_2.cpp -o impl_2.o
    ```

    run:

    `make`

    output:

    ```
    g++ -g -c impl_1.cpp -o impl_1.o
    In file included from header_1.h:4,
                     from impl_1.cpp:1:
    header_2.h:11:5: error: ‘A’ does not name a type
       11 |     A obj_a;
          |     ^
    make: *** [Makefile:4: impl_1.o] Error 1
    ```

    报错的过程如下：

    1. 根据 makefile 中的内容，先编译`impl_1.o`，此时会打开`impl_1.cpp`，读取`header_1.h`的内容

    2. 在`header_1.h`中，当执行到`#include "header_2.h"`时，跳转去读`header_2.h`的内容

    3. 在`header_2.h`中，又遇到了读取`header_1.h`的内容，但是由于有多重包含防范，所以不再读`header_1.h`的内容。继续往后走，`struct B`中定义了`A obj_a;`，编译器不知道这个`A`从哪来的，所以直接报错了。

    这种问题被称为结构体相互依赖（Mutual Dependency），通常解决方案是使用指针代替实体：

    `header_2.h`:

    ```cpp
    #ifndef HEADER_2_H
    #define HEADER_2_H

    #include "header_1.h"

    struct A;

    struct B {
        int val_1;
        double val_2;
        A *obj_a;
    };

    #endif
    ```

    此时即可通过编译。

    我们复盘下编译器的解析流程：

    1. 根据 makefile 中的内容，先编译`impl_1.o`，此时会打开`impl_1.cpp`，读取`header_1.h`的内容

    2. 在`header_1.h`中，当执行到`#include "header_2.h"`时，跳转去读`header_2.h`的内容

    3. `header_2.h`又包含了`header_1.h`，此时不再读取`header_1.h`的内容，继续往下走，`struct A;`告诉编译器`A`是一个`struct`，继续往下走，`A *obj_a;`表示`B`中有一个`A`的指针，`B`不需要知道`sizeof(A)`，只需要知道`A*`占 8 个字节就可以了。对`B`的解析至此结束，通过编译。

    `header_2.h`中声明`A`的行为`struct A;`叫前向声明（Forward Declaration）。

* 如果两个 struct 互相依赖，那么即使把它们放到同一个文件里，也无法通过编译

    `header_1.h`:

    ```cpp
    #ifndef HEADER_1_H
    #define HEADER_1_H

    struct B;

    struct A {
        int val_1;
        float val_2;
        B obj_b;
    };

    struct B {
        int val_1;
        double val_2;
        A obj_a;
    };

    #endif
    ```

    `impl_1.cpp`:

    ```cpp
    #include "header_1.h"
    ```

    compile:

    ```bash
    g++ -g -c impl_1.cpp -o impl_1.o
    ```

    compile output:

    ```
    In file included from impl_1.cpp:1:
    header_1.h:11:7: error: field ‘obj_b’ has incomplete type ‘B’
       11 |     B obj_b;
          |       ^~~~~
    header_1.h:4:8: note: forward declaration of ‘struct B’
        4 | struct B;
          |        ^
    make: *** [Makefile:4: impl_1.o] Error 1
    ```