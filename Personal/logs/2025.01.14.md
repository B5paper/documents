* 断点的行数和实际断到的函数不对应，猜想可能的原因是模板函数在展开时行数无法完全对应

* nccl tmp

    * waitPeer 的机制是怎样的？是死循环等待条件吗？

    * `connStepPtr = conn->head;`, `connStepPtr = conn->tail;`, 看起来`connStepPtr`是 conn 的链表, 这些都在`loadRecvConn()`被调用

    * 有可能 step 是异步处理，所以需要 volatile 加载数据

        至少说明 volatile load 并不是只用来加载 payload 数据

    * conn 是 struct ncclConnInfo 类型的对象，被赋值的地方为`conn = &peer->recv[connIndex];`

        问题：`peer`是什么？`peer->recv`在何时被赋值？

    * redop 就是 redfn，都在`src/device/reduce_kernel.h`里