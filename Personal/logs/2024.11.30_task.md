* [v] 调研`os.listdir()`

    14:52 ~ 15:09 (17 mins)

* [v] qa: 4 units

    15:11 ~ 16:10 (59 mins)

    正确率：3 / 4

    feedback:

    1. exam 在显示 unit 时，显示 idx, idx 以及其所对应的 qa 文件名

    2. 不创建 class 时,`/dev`文件夹下不显示设备文件。u0 为`请写出添加及删除 cdev 的最小代码。`的 u1 有问题，有时间了改一下。

* [v] reorg: documents 30 mins

    16:21 ~ 16:48

    feedback:

    1. 将 project pool 中常用到的 pdf 等 resources 打包成 zip，发送到邮箱里

    2. 为 stochastic exam 增加`--check <qa_file>`功能，检查是否每个 unit 都有 idx, id。

    deps:

    1. 找到贝叶斯网引论 pdf，上传到邮箱里

* [v] 调研 cuda 编程手册，尤其是 tile 相关的

    17:13 ~ 17:44 (31 mins)

    feedback:

    1. excel 擅长 eg. While the CPU is designed to excel at executing a sequence of operations, called a thread, as fast as possible and can execute a few tens of these threads in parallel, the GPU is designed to excel at executing thousands of them in parallel (amortizing the slower single-thread performance to achieve greater throughput).

    2. 调研 FORTRAN, DirectCompute, OpenACC.

    3. cuda programming guide website: <https://docs.nvidia.com/cuda/cuda-c-programming-guide/>

        目前看到了 2.2. Thread Hierarchy

        看起来，cuda programming 应该成为一个 project 或长期项目

        前面的内容与认知大体相同，没有什么很新的概念。

* [ ] 调研 cuda gdb

    17:53 ~ 18:10 (17 mins)

    feedback:

    1. 在 50 机器上写如下程序

        `main.cu`:

        ```cpp
        #include <cuda.h>
        #include <stdlib.h>
        #include <stdio.h>

        __global__ void vec_add(float *A, float *B, float *C)
        {
            int id = blockIdx.x;
            C[id] = A[id] + B[id];
        }

        int main()
        {
            float *h_A, *h_B, *h_C;
            h_A = (float*) malloc(8 * sizeof(float));
            h_B = (float*) malloc(8 * sizeof(float));
            h_C = (float*) malloc(8 * sizeof(float));
            for (int i = 0; i < 8; ++i)
            {
                h_A[i] = rand() % 10;
                h_B[i] = rand() % 10;
            }
            float *A, *B, *C;
            cudaMalloc(&A, 8 * sizeof(float));
            cudaMalloc(&B, 8 * sizeof(float));
            cudaMalloc(&C, 8 * sizeof(float));
            cudaMemcpy(A, h_A, 8 * sizeof(float), cudaMemcpyHostToDevice);
            cudaMemcpy(B, h_B, 8 * sizeof(float), cudaMemcpyHostToDevice);
            vec_add<<<8, 1>>>(A, B, C);
            cudaMemcpy(h_C, C, 8 * sizeof(float), cudaMemcpyDeviceToHost);
            for (int i = 0; i < 8; ++i)
            {
                printf("%.1f + %.1f = %.1f\n", h_A[i], h_B[i], h_C[i]);
            }
            return 0;
        }
        ```

        `Makefile`:

        ```makefile
        main: main.cu
        	nvcc -g -I../cuda-samples-12.1/Common -o main main.cu

        clean:
        	rm -f main
        ```

        在 vscode 中，使用如下`launch.json`:

        ```json
        {
            // Use IntelliSense to learn about possible attributes.
            // Hover to view descriptions of existing attributes.
            // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
            "version": "0.2.0",
            "configurations": [{
                "name": "CUDA C++: Launch",
                "type": "cuda-gdb",
                "request": "launch",
                "program": "${workspaceFolder}/main"
            }]
        }
        ```

        在`vec_add()`中设置断点后，F5 运行无法 hit 断点。目前不清楚原因。

* [ ] 调研<https://pytorch.org/tutorials/>