* vim 将 tab 转换为 4 个空格

    ```vim
    " 将 Tab 转换为空格
    set expandtab
    " 设置 Tab 宽度为 4 个空格
    set tabstop=4
    set shiftwidth=4
    set softtabstop=4
    ```

    各选项说明：

    * expandtab：输入 Tab 时插入空格

    * tabstop：一个 Tab 显示的宽度（字符数）

    * shiftwidth：自动缩进使用的宽度

    * softtabstop：按 Tab/Backspace 时光标移动的宽度

    临时转换当前文件:

    ```vim
    :set expandtab
    :%retab!
    ```

    * `%retab!`会将文件中所有 Tab 转换为空格

    只转换特定行:

    ```vim
    :10,20retab  " 转换第10-20行
    ```

    文件格式配置（针对特定文件类型）:

    ```vim
    autocmd FileType python setlocal expandtab tabstop=4 shiftwidth=4
    autocmd FileType javascript setlocal expandtab tabstop=2 shiftwidth=2
    ```

    检查当前设置:

    ```vim
    :set expandtab? tabstop? shiftwidth? softtabstop?
    ```

    反向转换（空格转Tab）:

    ```vim
    :set noexpandtab
    :%retab!
    ```

    在打开文件时自动转换:

    ```vim
    autocmd BufRead * set expandtab | %retab!
    ```

    建议： 在团队项目中，建议使用统一的 .editorconfig 文件来保证代码风格一致。

* vim 中的 `softtabstop`

    它控制按 Tab 键或 Backspace 键时光标移动的宽度。

    首先，只打开`:set softtabstop=4`，`tabstop`采用默认值`8`，不打开`expandtab`时，行为如下：

    ```
    hello, world
    ```

    光标在`h`前面，按 tab，插入 4 个空格：

    ```
        hello, world
    ```

    此时再按一下 tab，神奇的事情发生了，`h`前的 4 个空格被删掉，替换成了一个位宽为 8 的 tab 字符：

    ```
    	hello, world
    ```

    后面以此类推，交替插入空格和 tab：

    ```
    [  tab   ][....]hello, world
    [  tab   ][  tab   ]hello, world
    [  tab   ][  tab   ][....]hello, world
    ...
    ```

    按退格（backspace）时，这个顺序正好反过来：如果有完整的 tab，那么把 tab 拆成 8 个空格，然后再删掉 4 个空格；如果有 4 个空格，那么直接删掉 4 个空格。

    这个功能似乎没什么用，因为 tab 字符几乎总是会出现。对于代码，我们只需要空格，对于 makefile，我们只需要 tab。这种一会 tab 一会空格的功能，对两者都不适用。

    但是这个功能对于退格比较有用。假如我们只设置`set tabstop=4`，`set expandtab`，那么按 tab 时插入 4 个空格，但是按退格（backspace）时，只能一个一个地删空格。如果这个时候结合`set softtabstop=4`，那么前面的功能不变，退格可以一次删除 4 个空格。我们可以使用 tab 键和 backspace 键高效地控制缩进，非常方便。

* ai 对 softtabstop 的解释

    **softtabstop 的工作原理**

    * 场景 1：`softtabstop=4，expandtab=on`
    
        ```vim
        set softtabstop=4
        set expandtab
        ```

        按一次 Tab → 插入 4 个空格，光标移动 4 个字符

        按一次 Backspace → 删除 4 个空格，光标向左移动 4 个字符

    * 场景 2：`softtabstop=4，expandtab=off`

        ```vim
        set softtabstop=4
        set noexpandtab
        ```

        按一次 Tab：

        * 如果光标位置到下一个 tabstop 的距离 ≥ 4 → 插入 Tab 字符

        * 否则 → 插入空格补足到下一个 tabstop

    * 场景 3：`softtabstop=0（默认值）`

        ```vim
        set softtabstop=0
        ```

        Tab/Backspace 的行为完全由 `tabstop` 控制

        按 Tab 会直接跳到下一个 tabstop 边界

    使用 `:set list` 查看空格（显示为 `.`）和 Tab（显示为 `^I`）

    重要提示

    * softtabstop 只在 expandtab 开启时效果最明显

    * 如果 softtabstop > tabstop，Vim 会使用 tabstop 的值

    * 大多数现代项目中，三个值设置为相同是最佳实践

* 生成从指定日期开始的 N 天

    ```py
    from datetime import datetime, timedelta

    # 指定起始日期
    start_date = datetime(2024, 1, 1)

    # 生成未来5天（包括起始日）
    for i in range(5):
        current_date = start_date + timedelta(days=i)
        print(current_date.strftime('%Y-%m-%d'))
    ```

    output:

    ```
    2024-01-01
    2024-01-02
    2024-01-03
    2024-01-04
    2024-01-05
    ```

    同理，如果向前推日期的话，只需要减去`timedelta`就可以了。

    还可以使用 `date` 对象（只处理日期，不含时间）:

    ```py
    from datetime import date, timedelta

    # 使用date对象
    start_date = date(2024, 1, 1)

    # 生成未来5天
    for i in range(5):
        current_date = start_date + timedelta(days=i)
        print(current_date)

    # 向前推3天
    for i in range(1, 4):
        past_date = start_date - timedelta(days=i)
        print(past_date)
    ```

* python 函数中的 static 变量

    1. 使用函数属性（推荐）

        ```py
        def counter():
            if not hasattr(counter, "count"):
                counter.count = 0  # 初始化静态变量
            counter.count += 1
            return counter.count

        print(counter())  # 1
        print(counter())  # 2
        print(counter())  # 3
        print(f"静态变量值: {counter.count}")  # 可以直接访问
        ```

    2. 使用闭包

        ```py
        def make_counter():
            count = 0  # 闭包中的变量，类似于静态变量
            
            def counter():
                nonlocal count  # 声明为nonlocal以修改闭包变量
                count += 1
                return count
            
            return counter

        counter = make_counter()
        print(counter())  # 1
        print(counter())  # 2
        print(counter())  # 3
        ```

    3. 使用装饰器

        这个本质也是函数属性。

        ```py
        def static_vars(**kwargs):
            def decorate(func):
                for key, value in kwargs.items():
                    setattr(func, key, value)
                return func
            return decorate

        @static_vars(counter=0)
        def my_func():
            my_func.counter += 1
            return my_func.counter

        print(my_func())  # 1
        print(my_func())  # 2
        ```

        这个也可以写成：

        ```py
        def call_counter(func):
            def wrapper(*args, **kwargs):
                wrapper.calls += 1
                print(f"{func.__name__} 已被调用 {wrapper.calls} 次")
                return func(*args, **kwargs)
            
            wrapper.calls = 0  # 初始化计数器
            return wrapper

        @call_counter
        def greet(name):
            return f"Hello, {name}!"

        print(greet("Alice"))
        print(greet("Bob"))
        print(greet("Charlie"))
        # 输出:
        # greet 已被调用 1 次
        # Hello, Alice!
        # greet 已被调用 2 次
        # Hello, Bob!
        # greet 已被调用 3 次
        # Hello, Charlie!
        ```

    4. 使用类

        把函数看作一个 callable object。

        ```py
        class Counter:
            def __init__(self):
                self.count = 0
            
            def __call__(self):
                self.count += 1
                return self.count

        counter = Counter()
        print(counter())  # 1
        print(counter())  # 2
        ```

    注意事项

    * 线程安全：上述方法在单线程中工作良好，但在多线程环境下需要加锁

    * 可读性：使用函数属性是最直观的方式

    * 重置静态变量：可以直接访问并重置，如 func.static_var = new_value

* `\mathbf`将数学符号设置为正体粗体

    * 对希腊字母不生效

    * 希腊字母可以使用`\bm`设置为斜体粗体，比如`\bm{\alpha}`

    * 与文本模式中的 `\textbf` 不同，`\mathbf` 专用于数学模式。

    效果：

    $\mathbf{ABC}$, $\mathbf{abc}$, $\mathbf{123}$, $\mathbf{\alpha \beta \gamma}$, $\mathbf{+-*/}$, $\mathbf{你好}$
