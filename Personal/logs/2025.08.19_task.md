* [v] 调研`ip route get`

    feedback:

    1. 调研`ip rule`

* [v] 调研 mmap() 的匿名映射模式

    feedback:

    1. 调研`RLIMIT_DATA`

* [v] qa: linux driver 30 mins

    feedback:

    1. makefile 中，`$(VAR)`和`${VAR}`有什么不同？

    1. makefile 中，变量与定义间是否允许有空格？

        `KERNEL_DIR=/usr/xxx`

    1. makefile 中，如何达到`KERN_DIR=/lib/modules/$(uname -r)/build`这样的效果？

    1. `obj-m += hello.o`是什么含义？字符串`obj-m`添加空格后再添加`hello.o`？

    1. `printk("<1>""hello my module\n");`是否等价于`printk(KERN_INFO "xxx")`?

    1. `charp`在哪个头文件中？

    1. `param_get_charp()`, `param_ops_charp`, `param_set_charp`, `param_free_charp`这几个都是干嘛的？

    1. `module_param_call()`

    1. `module_param_named()`

    1. `module_param_string()`

    1. `module_param_array(m_arr, int, NULL, 0755);`, `755`报 warning

        ```
        [ 4358.400458] Attribute m_arr: Invalid permissions 0755
        ```

        为什么？

    1. 如果写成`module_param_array(m_arr, int, NULL, 0766);`，那么无法通过静态检查，从而通不过编译，为什么？

        `0766`不可以，`0755`可以。

    1. `register_chrdev_region()`与`register_chrdev()`有何不同？

    1. `unregister_module_notifier()`

    1. linux driver unit idx 3 增加查看 dev class 的方法

    1. `unlocked_ioctl`与`compat_ioctl`有何不同？

    1. 调研`read`, `read_iter`, `splice_read`

    1. `class_create_file()`

    1. unit idx 5，新版本 kernel 不需要`class_create()`里输入`THIS_MODULE`

    1. `pr_err_once()`

    1. `device_create_file()`

    1. `class_device_destructor()`

    1. `class_dev_iter`

    1. qa 里增加完整的 cdev + dev file 的 example

        ```c
        #include <linux/init.h>
        #include <linux/module.h>
        #include <linux/fs.h>
        #include <linux/cdev.h>
        #include <linux/device.h>

        int m_open(struct inode *, struct file *) {
            pr_info("in m_open()...\n");
            return 0;
        }

        int m_release(struct inode *, struct file *) {
            pr_info("in m_release()...\n");
            return 0;
        }

        ssize_t m_read(struct file *, char __user *, size_t, loff_t *) {
            pr_info("in m_read()...\n");
            return 0;
        }

        ssize_t m_write(struct file *, const char __user *, size_t, loff_t *) {
            pr_info("in m_write()...\n");
            return 0;
        }

        long m_unlocked_ioctl(struct file *, unsigned int, unsigned long) {
            pr_info("in m_unlocked_ioctl()...\n");
            return 0;
        }

        dev_t dev_num;
        const char *dev_region_name = "hlc dev";
        struct cdev chdev;
        const struct file_operations chdev_ops = {
            .open = m_open,
            .release = m_release,
            .read = m_read,
            .write = m_write,
            .unlocked_ioctl = m_unlocked_ioctl
        };
        struct class *dev_cls;
        struct device *dev;

        int hello_init(void) {
            pr_info("hello my module\n");
            int ret = alloc_chrdev_region(&dev_num, 0, 1, dev_region_name);
            if (ret != 0) {
                pr_info("fail to register chrdev region\n");
                return -1;
            }

            cdev_init(&chdev, &chdev_ops);
            ret = cdev_add(&chdev, dev_num, 1);
            if (ret != 0) {
                pr_info("fail to add cdev\n");
                goto CDEV_ADD_FAILED;
            }

            dev_cls = class_create("hlc dev cls");
            if (dev_cls == NULL) {
                pr_err("fail to create class\n");
                goto CLASS_CREATE_FAILED;
            }
            dev = device_create(dev_cls, NULL, dev_num, NULL, "hlc_dev");
            if (dev == NULL) {
                pr_err("fail to create device\n");
                goto DEVICE_CREATE_FAILED;
            }
            return 0;

        DEVICE_CREATE_FAILED:
            class_destroy(dev_cls);
        CLASS_CREATE_FAILED:
            cdev_del(&chdev);
        CDEV_ADD_FAILED:
            unregister_chrdev_region(dev_num, 1);
            return -1;
        }

        void hello_exit(void) {
            pr_info("exit my module\n");
            device_destroy(dev_cls, dev_num);
            class_destroy(dev_cls);
            cdev_del(&chdev);
            unregister_chrdev_region(dev_num, 1);
        }

        module_init(hello_init);
        module_exit(hello_exit);
        MODULE_LICENSE("GPL");
        ```

    1. `device_create()`与`device_add()`有何不同？

    1. `device_attach()`

    1. `linux/list_lru.h`, `linux/list_sort.h`

    1. `list_add_rcu()`, `list_lru_add()`, `list_add_tail()`

    1. `kmalloc_array()`, `kmalloc_caches()`

    1. `kmalloc()`未释放的内存，在 module 结束后会被释放吗？

        如果不能，该如何正确释放？

* [ ] 调研`pci_resource_start()`

* [ ] 调研`pci_enable_device()`作用

* [ ] 调研 qemu edu driver
