* `std::any`

    std::any 是 C++17 标准库中引入的一个容器，它的作用是提供一种类型安全的方式来存储和操作任意类型的单个值。

    向`std::any`容器中存储数据时，其元素类型必须满足可拷贝构造的要求。

    为了优化性能，小的对象会直接存储在 std::any 自身的对象空间中，而大的对象则会存储在堆上。

    常用操作：

    * 存放值 (Emplacement): std::any a = 42; 或 std::any a = std::string("Hello");

    * 判断是否有值: a.has_value()

    * 获取值 (Retrieval):

        * 安全获取 (推荐): 使用`std::any_cast<T>(my_any)`

            如果类型 T 正确，返回存储值的副本。

            如果类型不匹配，抛出 std::bad_any_cast。

        * 获取指针: 使用`std::any_cast<T>(&my_any)`

            如果类型 T 正确，返回一个指向存储值的指针 (T*)。

            如果类型不匹配，返回 nullptr（不会抛出异常）。

        * 获取引用：`std::any_cast<T&>(my_any)`

    * 销毁/重置值: a.reset() 或 a = std::any{}

    example:

    ```cpp
    #include <any>
    #include <iostream>
    #include <string>

    int main() {
        std::any anything;

        // 存储一个整数
        anything = 42;
        // 安全地取出并使用
        try {
            int value = std::any_cast<int>(anything);
            std::cout << "Integer: " << value << '\n'; // 输出: Integer: 42
        } catch (const std::bad_any_cast& e) {
            std::cout << "Wrong type!\n";
        }

        // 存储一个字符串
        anything = std::string("Hello World");
        // 通过指针方式安全地尝试获取
        if (auto ptr = std::any_cast<std::string>(&anything)) {
            std::cout << "String: " << *ptr << '\n'; // 输出: String: Hello World
        }

        // 尝试错误地获取
        try {
            double value = std::any_cast<double>(anything); // 这里存的是string，不是double
            std::cout << "Double: " << value << '\n';
        } catch (const std::bad_any_cast& e) {
            std::cout << "Caught expected exception: " << e.what() << '\n';
            // 输出: Caught expected exception: bad any_cast
        }

        return 0;
    }
    ```

    output:

    ```
    Integer: 42
    String: Hello World
    Caught expected exception: bad any_cast
    ```

    应用场景：

    * 可以放任何东西的容器（例如 `std::vector<std::any>`）

        `std::variant`更适合已知类型的集合

    * 框架开发中，接收用户定义的一个未知类型的对象。

    * 存储多种类型的值，比如 json 解析时的 int, double, string 等。

    注：

    1. 在取出值时，如果不知道其存储的类型，常用 try catch 法

        ```cpp
        void tryToPrint(const std::any& a) {
            if (a.has_value()) {
                // 尝试是int吗？
                if (int* intPtr = std::any_cast<int>(&a)) {
                    std::cout << "It's an int: " << *intPtr << std::endl;
                }
                // 尝试是double吗？
                else if (double* doublePtr = std::any_cast<double>(&a)) {
                    std::cout << "It's a double: " << *doublePtr << std::endl;
                }
                // 尝试是string吗？
                else if (std::string* stringPtr = std::any_cast<std::string>(&a)) {
                    std::cout << "It's a string: " << *stringPtr << std::endl;
                }
                else {
                    std::cout << "It's something else I don't know how to handle." << std::endl;
                }
            } else {
                std::cout << "It's empty." << std::endl;
            }
        }
        ```

    1. 如果已知 any 中的类型，可以让其在运行时和 enum 绑定

        ```cpp
        // 1. 定义一个枚举，列出所有可能的数据类型
        enum class DataType {
            Integer,
            Double,
            String,
            // 可以继续添加更多类型...
        };

        // 2. 创建一个结构体，将值和其类型标签捆绑在一起
        struct TaggedValue {
            DataType type;
            std::any value;
        };
        ```

        或者使用 variant 绑定：

        ```cpp
        // 类型标签现在是一个variant，它知道所有可能的类型
        using TypeInfo = std::variant<int, double, std::string>;

        struct VariantTaggedValue {
            TypeInfo type_info; // 这个variant本身也可以存储值，这里我们只用它做标签
            std::any value;
        };

        // 使用std::visit来访问type_info，进而指导any_cast
        ```

    1. `std::any`的接口没有提供 get_type() 这样的方法。要取出值，你必须通过`std::any_cast<T>`来"尝试"，或者像我们之前讨论的那样，通过外部信息来知道类型。

    1. std::any 有点像一块 buffer，可能直接存对象，也可能存对象的指针（Small Buffer Optimization (SBO) ），并且 std::any 还存了类似 type_info 的东西，可以在运行时确定类型

    1. 使用  auto ptr = any_cast<xxx>(&yyy) 时，如果 yyy 后面被释放了，那么 ptr 无效。当源 std::any 对象被销毁、被重置（reset()）或被赋新值时，它内部存储的对象也会被销毁，您之前获取的指针立即变为悬空指针。

        如果你需要数据的持久副本，应该使用 std::any_cast<T>(any_obj) 通过值来获取，这会返回一个全新的、独立的对象。

    1. auto val = any_cast<xxx>(yyy)，返回的 val 是值（副本），不是引用

        注意，`auto& ref = std::any_cast<std::string>(my_any); `会先创建副本，然后让引用绑定到副本上

        example:

        ```cpp
        std::any my_any = 42;

        // 1. 值拷贝（默认行为）
        int copy = std::any_cast<int>(my_any); // 返回 int（副本）

        // 2. 非常量引用
        int& ref = std::any_cast<int&>(my_any); // 返回 int&
        ref = 100; // 修改原始值

        // 3. 常量引用
        const int& const_ref = std::any_cast<const int&>(my_any); // 返回 const int&

        // 4. 右值引用（用于移动语义）
        int&& moved = std::any_cast<int&&>(std::move(my_any)); // 返回 int&&

        // 5. 指针版本（返回nullptr或指针，不会抛出异常）
        int* ptr = std::any_cast<int>(&my_any); // 返回 int* 或 nullptr
        if (ptr) {
            *ptr = 200; // 通过指针修改
        }
        ```

    1. 当使用 std::any any_1 = any_2; 时，会发生 deep copy

        当您写 std::any any_1 = any_2; 时，会发生以下过程：

        1. any_2 检查自己是否包含值（通过 has_value()）

        2. 如果包含值，它会创建其内部存储的对象的一个完整副本

        3. 类型信息和管理函数也会被复制

        4. any_1 现在拥有一个独立的、与 any_2 内容相同但完全分离的对象

        当拷贝发生时，std::any 会调用存储的拷贝函数来创建深度副本。

        example:

        ```cpp
        // 好的做法：使用移动语义避免不必要的拷贝
        std::any createLargeData() {
            std::vector<int> large_data(1000000);
            return large_data; // 这里会发生移动，而不是拷贝
        }

        int main() {
            std::any data = createLargeData(); // 移动构造，高效
            std::any data_copy = data; // 深拷贝，可能昂贵！
            
            // 如果确定不再需要原对象，使用移动
            std::any data_moved = std::move(data); // 移动构造，高效
        }
        ```

* `class_find_device()`

    在一个指定的设备类（struct class）中，根据提供的匹配条件，遍历并找到第一个匹配的设备

    syntax:

    ```c
    struct device *class_find_device(struct class *class,
                                     struct device *start,
                                     const void *data,
                                     int (*match)(struct device *, const void *));
    ```

    start: 从哪个设备开始遍历（通常传入 NULL 表示从链表头开始）。

    data: 传递给匹配函数的数据，用于比较（例如一个设备名称字符串、一个ID号等）。

    match: 你自定义的匹配函数指针。

    其中`match`为回调函数，当 dev 的数据匹配 data 时，返回 true (1)，否则返回 false (0).

    example:

    假设你有一个自定义的类 my_class，并且你知道某个设备的名称（例如 "my_special_device"），你想根据这个名字找到对应的设备指针。

    ```c
    static int my_match_by_name(struct device *dev, const void *data) {
        const char *name = data;
        // 检查设备的名字是否与传入的name相同
        return (dev->kobj.name != NULL) && (strcmp(dev->kobj.name, name) == 0);
    }

    struct device *dev;
    dev = class_find_device(my_class, NULL, "my_special_device", my_match_by_name);
    if (dev) {
        // 找到设备，可以进行操作
        // ...
        // 使用完后，通常需要调用 put_device() 来减少引用计数
        put_device(dev);
    } else {
        // 设备未找到
    }
    ```

    引用计数：class_find_device() 在找到设备后，会增加该设备的引用计数。这意味着你在使用完返回的设备指针后，必须调用 put_device() 来减少引用计数，否则该设备将永远无法被正确卸载，导致内存泄漏。

* 设备类 (struct class)

    在 Linux 设备模型中，设备被分类管理，例如所有的输入设备（键盘、鼠标）属于 input 类，所有的块设备（硬盘、U盘）属于 block 类，所有的网络设备属于 net 类。

    每个类都是一个 struct class 结构体，它包含了一个链表，链接着所有注册到该类的设备（struct device）。

* 如果一个 task 查 note 时发现之前调研过，那么就意味着该对 note 进行 qa 了。如果一个 task 在 project pool 中被提起两次，那么将其合并为一次，并放到 project tasks 的最上面。

* `pci_request_regions()`

    一次性申请 PCI 设备的所有有效资源区间（即所有有效的 BARs），是 `pci_request_region()`的“批处理”版本。

    syntax:

    ```c
    int pci_request_regions(struct pci_dev *pdev, const char *res_name);
    ```

    返回值：

    * `0`: 表示所有有效的资源区域都申请成功。

    * 非`0`（错误码）: 表示在申请任何一个BAR时失败。重要的是，如果失败，它会自动释放之前已经成功申请的所有BAR。这简化了错误处理。

    在大多数情况下，应优先使用 pci_request_regions()。除非你明确知道驱动只需要且应该只占用某一个特定BAR，否则使用批量申请更安全、更省事。

* 总线设备 (Bus Device)

    所有通过某种可枚举、有标准探测协议的总线连接到系统的设备。

    总线设备的总线都是有形的，这些设备通过物理上真实存在的、有明确标准的总线连接到处理器（CPU）。

    example:

    * PCI/PCIe：网卡、显卡、声卡、存储控制器等。

    * USB：U盘、键盘、鼠标、摄像头等。

    * I2C：各种传感器（温度、湿度）、EEPROM 存储器等。

    * SPI：Flash 存储器、显示屏控制器等。

    系统（内核）可以在启动时或运行时（热插拔）通过总线协议主动去枚举发现这些设备。例如，PCI 总线可以通过配置空间读取设备的厂商ID和设备ID。

    总线设备的驱动匹配模型：

    1. 总线驱动枚举设备，并创建 struct device（或其子结构，如 struct pci_dev, struct usb_device）。

    2. 设备注册到总线上。

    3. 内核将设备的标识符（如 PCI 的 VID/DID）与已注册的驱动提供的标识符列表进行比对。

    4. 找到匹配的驱动后，调用驱动的 probe 函数来初始化设备。

* 平台设备 (Platform Device)

    直接映射到系统地址空间、通常集成在处理器芯片内部或直接挂在本地总线上的设备。

    平台总线（platform_bus_type）是一个虚拟的总线，这个总线是内核创建的一个抽象，用于统一管理这些无法被自动发现的设备。

    CPU 无法通过扫描总线来发现它们。系统需要预先知道它们的存在。

    平台总线设备的详细信息（地址、中断号等）必须静态地提供给内核。提供方式主要有两种：

    1. 设备树 (Device Tree)：在现代嵌入式系统中（如 ARM、RISC-V），这是主流方式。Bootloader 会将一个描述硬件拓扑结构的设备树二进制文件（.dtb）传递给内核。内核解析后，会自动创建对应的平台设备。

    2. 板级文件 (Board File)：在旧的内核或x86系统中，通常在架构相关的C代码中硬编码 (platform_device_register())。

    platform device examples:

    * 处理器内部的UART控制器（串口）。

    * 系统内部的硬件定时器。

    * GPIO控制器。

    * 集成在SoC上的I2C控制器、SPI控制器本身（注意：这些控制器是平台设备，而挂在其上的从设备是I2C/SPI设备）。

    * 内存映射的LED或按键。

    平台设备的驱动匹配过程依赖于名称：

    1. 设备源（设备树或板级文件）会指定一个设备的名称（例如 "serial8250"）。

    2. 平台驱动会声明自己支持的设备名称（例如 "serial8250"）。

    3. 平台总线核心负责将同名设备和驱动进行匹配。

    4.  匹配成功后，调用驱动的 probe 函数。

* auxiliary bus

    （未验证）

    一个父设备（Physical Device）可以创建多个 auxiliary devices（辅助设备），但这些 auxiliary devices 都注册在同一个、内核全局唯一的 auxiliary bus（即 auxiliary_bus_type）上。

* `param_get_charp()`

    从一个内核模块参数中获取其字符串类型的值（即 char 指针类型的值），并返回这个指针的副本。

    syntax:

    ```c
    int param_get_charp(char *buffer, const struct kernel_param *kp);
    ```

    return val:

    返回成功写入到 buffer 中的字节数。如果发生错误，则返回一个负的错误代码。

    这个函数其实是一个回调函数：

    ```c
    struct kernel_param_ops param_ops_charp = {
        .set  = param_set_charp,
        .get  = param_get_charp,
        .free = param_free_charp,
    };
    ```

    * `.set = param_set_charp()`（设置参数时分配内存）

    * `.get = param_get_charp()`（读取参数时拷贝字符串）

    * `.free = param_free_charp()`（释放内存）

    该函数不会直接返回模块参数变量本身所存储的指针，而是会返回这个指针的一个 “副本”。它会为参数所指向的原始字符串重新分配一块内核内存，并将字符串内容复制到这块新内存中。因此在使用完成后，需要调用配对函数`param_free_charp()`释放内存。此函数本质就是调用了`kfree()`。

    `param_get_charp()`这个函数由内核自动调用，不需要用户手动调用。当用户从 sysfs 里读取参数（比如 cat /sys/module/mymodule/parameters/my_param）时，内核会自动调用。

    用户只需要写`module_param()`就可以了：

    ```c
    static char *my_param = "default";
    module_param(my_param, charp, 0644);
    ```

* `linux/kernel.h`的作用

    1. 常用宏定义

        包含很多内核开发里会用到的 通用宏，比如：

        * min(), max()

        * clamp(), roundup(), rounddown()

        * DIV_ROUND_UP() 等

        这些宏在写驱动或内核代码时非常常见。

    2. 打印函数

        提供了内核日志输出接口：

        * printk()

        * pr_info(), pr_err(), pr_warn() 等封装

        用来在内核日志（dmesg）里打印调试信息。

    3. 类型转换辅助

        一些和内核类型、数据处理相关的工具宏，比如：

        * container_of()（通过结构体成员指针得到整个结构体指针）。

    4. 内核通用函数声明

        包含一些在内核里常用的函数声明，例如：

        * simple_strtol(), simple_strtoul()（字符串转数字，已逐渐被 kstrto*() 系列替代）。

        * print_hex_dump()（调试时打印十六进制数据）。

* `MODULE_AUTHOR()`, `MODULE_DESCRIPTION()`, `MODULE_VERSION()`定义在`<linux/module.h>`里

    `<linux/module.h>`专门为内核模块提供接口：

    * 模块信息宏：MODULE_AUTHOR(), MODULE_DESCRIPTION(), MODULE_LICENSE(), MODULE_VERSION()

    * 模块入口/出口：module_init(), module_exit()

    * 模块依赖：MODULE_ALIAS(), MODULE_FIRMWARE() 等

    example:

    ```c
    #include <linux/module.h>   // MODULE_* 宏和 module_init/exit 在这里
    #include <linux/kernel.h>   // printk/pr_info, min/max 等

    MODULE_AUTHOR("Liucheng Hu");
    MODULE_DESCRIPTION("My first Linux kernel module");
    MODULE_VERSION("1.0");
    MODULE_LICENSE("GPL");

    static int __init my_module_init(void)
    {
        pr_info("Hello, kernel!\n");
        return 0;
    }

    static void __exit my_module_exit(void)
    {
        pr_info("Goodbye, kernel!\n");
    }

    module_init(my_module_init);
    module_exit(my_module_exit);
    ```

* `charp`定义在`<linux/moduleparam.h>`中