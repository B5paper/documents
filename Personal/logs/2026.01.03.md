* 如何让 vscode 显示所有隐藏的 unicode 字符

    插件：`Render Special Characters`

    未测试：

    * `Highlight Bad Chars`

* dmi

    一、含义

    * DMI，全称动向指数或趋向指标，由美国技术分析大师威尔斯·威尔德发明。它的核心功能是判断市场趋势的强弱和方向，尤其擅长识别市场是处于趋势市还是震荡市。

    * DMI不是一个单一指标，而是由四条线构成：

        * +DI（正趋向指标）：代表上升动向的力量。数值上升表明多方力量增强。

        * -DI（负趋向指标）：代表下降动向的力量。数值上升表明空方力量增强。

        * ADX（平均趋向指数）：代表趋势的强度。无论市场是上涨还是下跌，ADX值上升都表明当前趋势在加强（趋势性强）；ADX值下降表明趋势在减弱，市场可能进入盘整（震荡市）。

        * ADXR：ADX 的移动平均线，用于平滑 ADX，使其信号更稳定，但通常分析中 ADX 更常用。

    二、作用

    * 识别趋势方向：通过 +DI 和 -DI 的相对位置来判断。

    * 衡量趋势强度：通过ADX值来判断当前趋势是否值得交易。这是DMI最独特和核心的价值。

    * 捕捉趋势启动与转换信号：当 ADX 从低位开始掉头向上时，往往预示着新的趋势可能形成。

    * 过滤震荡行情：当 ADX 处于低位（例如低于25）时，表明市场缺乏趋势，此时应避免使用趋势跟踪策略，减少无效交易。

    三、用法

    1. 判断趋势方向

        * 多头信号：+DI 上穿 -DI，且 ADX 同步上升，是较强的买入信号。

        * 空头信号：-DI 上穿 +DI，且 ADX 同步上升，是较强的卖出信号。

    2. 衡量趋势强度（关键用法）

        * ADX 值 > 25（或 30）：表明市场存在明显的趋势（可能是上涨趋势，也可能是下跌趋势）。此时顺势交易的成功率较高。

        * ADX 值 < 25（或 20）：表明市场处于无趋势的震荡或盘整状态。此时应避免追涨杀跌，或采用高抛低吸的震荡策略。

        * ADX 从高位掉头向下：表明当前运行的趋势可能即将减弱或进入盘整，是趋势可能结束的预警信号。

    3. 寻找买卖点（经典组合用法）

        * 进场点：在ADX处于低位（如低于25）时，若+DI上穿-DI，同时ADX也开始掉头向上（“三线开花”），是潜在的多头趋势启动信号。

        * 出场/止盈点：

            * 在多头趋势中，当-DI从下方上穿+DI时，可作为趋势逆转的平仓信号。

            * 当 ADX 从高位（如高于50）开始掉头向下时，表明强劲趋势可能放缓，可作为部分止盈或警惕信号。

        * 趋势中的加仓点：在+DI > -DI的明确上升趋势中，当价格回调后再次上涨，同时ADX也保持在高位或再次上升，可能是一个良好的加仓时机。

    4. 极端值参考

        * 当 +DI 和 -DI 的数值都变得非常低（如均低于20）时，表明市场极度沉闷，新资金即将选择方向。

        * 当 ADX 值极高（如高于50甚至60）时，表明趋势运行得非常猛烈且可能接近极端，需警惕物极必反的回调风险。

    总结与注意事项

    * DMI的本质是“趋势过滤器”。它不预测价格具体能涨多高或跌多深，而是告诉你“现在有没有趋势”以及“趋势强不强”。

    * 滞后性：DMI基于一段时间（通常默认14日）的价格计算，因此有天然的滞后性。它确认趋势，但不领先于趋势。

    * 结合使用：在实战中，强烈建议将DMI与其他指标结合使用以提高胜率。例如：

        * 用移动平均线（MA） 判断基本方向。

        * 用DMI的ADX来确认该方向的趋势是否强劲、是否值得交易。

        * 用RSI、KDJ等震荡指标在趋势确认后寻找具体的超买超卖入场点。

    * 参数调整：默认周期14可以调整。缩短周期（如7）会使指标更灵敏但信号增多；拉长周期（如21）会使信号更稳定但更滞后。

    一句话概括：DMI是“趋势的强度计”，ADX告诉你“风有多大”，而+DI和-DI则告诉你“风往哪边吹”。只有当“风足够大”（ADX高）时，顺着风向（+DI/-DI交叉方向）交易才最有效。

* 还有哪些指标可以像ADX一样确认当前是趋势市还是震荡市

    当然有。判断市场状态（趋势市 vs. 震荡市）是技术分析中“择时”的关键一步，除了ADX，还有几个非常经典和有效的指标。下面我将它们分为不同类别进行介绍：

    一、专门衡量波动性与趋势强度的指标（最直接）

    * 平均真实波幅的衍生应用

        * 指标：ATR（Average True Range）

        * 用法：ATR本身衡量价格波动的剧烈程度。它不能直接区分趋势方向，但能衡量市场的“活跃度”。

            * 判断震荡市：当ATR值持续处于历史低位（例如近一年来的较低分位），且价格在一个区间内来回波动时，通常表明市场处于低波动率的震荡盘整状态。

            * 判断趋势市：当ATR值从低位开始稳步或快速攀升，往往预示着新趋势（无论是上涨还是下跌）正在启动或加强。价格突破伴随ATR放大，是一个可靠的趋势确认信号。

    * 布林带收缩与扩张

        * 指标：布林带

        * 用法：布林带的带宽（Band Width）直接反映了市场的波动率。

            * 判断震荡市：布林带上下轨持续收缩、带宽变窄，是典型的“波动率压缩”或“蓄势”形态，预示着市场即将选择方向，当前处于震荡市。

            * 判断趋势市：布林带上下轨开始向外扩张、带宽变宽，且价格紧贴上轨或下轨运行，是强烈的趋势市特征（上涨趋势沿上轨，下跌趋势沿下轨）。

    二、利用价格排列与均线关系的指标

    * 移动平均线排列与发散度

        * 指标：多根均线组合（如EMA10， EMA30， EMA60） 或 MACD

        * 用法：

            * 判断震荡市：短期、中期、长期均线高度纠缠、粘合在一起，价格围绕它们上下穿梭，没有明确的方向性。MACD 的 DIFF 和 DEA 线在零轴附近反复交叉，柱状线很短。

            * 判断趋势市：均线呈现明确的多头（短期>中期>长期）或空头（短期<中期<长期）排列，且均线之间距离发散。MACD的DIFF和DEA线远离零轴，柱状线持续放大或维持较长状态。

    三、基于统计与回归的指标

    * 线性回归通道

        * 指标：线性回归通道

        * 用法：该指标通过统计学方法绘制出价格运行的核心通道。

            * 判断震荡市：回归通道的斜率接近于 0（水平），通道宽度较窄，价格在通道上下沿之间规律性地震荡。

            * 判断趋势市：回归通道的斜率明显向上或向下，通道宽度适中或扩张，价格沿通道一侧（上涨沿上轨，下跌沿下轨）运行。

    四、综合型指标

    * 趋势与震荡一体化指标

        * 指标：Ichimoku Kinko Hyo

        * 用法：这是一个综合系统，其“云层”（Kumo）是判断趋势/震荡的绝佳工具。

            * 判断震荡市：价格在云层内部或附近上下穿梭，云层本身较薄或水平发展。此时趋势方向不明。

            * 判断趋势市：价格在云层上方（强势多头），且云层作为支撑；或价格在云层下方（强势空头），且云层作为压力。云层本身厚实且方向明确（上升或下降）。

    六、如何综合运用与实战建议

    * 没有一个指标是完美的。建议采用“主次结合，相互验证”的方法：

        * 构建一个简单的趋势/震荡过滤器系统：

            * 第一步：看趋势方向（用均线或趋势线）。

            * 第二步：看趋势强度/市场状态（用ADX或布林带带宽）：

                * 若ADX > 25 且上升，或布林带扩张 → 趋势市。此时应采用趋势跟踪策略：顺势交易，持有盈利头寸，使用移动止损。

                * 若ADX < 25 且下降，或布林带收缩 → 震荡市。此时应采用均值回归/区间策略：在支撑位买入，压力位卖出，高抛低吸，及时止盈。

            * 第三步：寻找具体买卖点（用RSI， KDJ， MACD金叉死叉等）。

        * 核心要点：

            * ADX/ATR/布林带宽是直接衡量“趋势是否存在”和“市场波动能量”的动量仪表。

            * 均线排列/云层位置是从价格结构上判断趋势的视觉化工具。

            * 最重要的原则是：在震荡市中禁用趋势策略，在趋势市中禁用震荡策略。 错误的市场状态判断是导致交易亏损的主要原因之一。

    总结：最常用且有效的“趋势市/震荡市”确认指标组合是：ADX + 布林带。ADX提供强度量化，布林带提供直观的视觉压缩与扩张信号。将这两个指标结合使用，能大大提高对市场状态判断的准确性。

* 股票指标中，是否可以认为adx穿越adxr的交叉点，就认为是趋势市或震荡市的开启？

    这是一个非常好的问题，触及了ADX/ADXR指标使用的核心。简单直接的回答是：不能单纯地认为ADX穿越ADXR的交叉点就是趋势市或震荡市的“开启”信号，它更多是一个“确认”或“强化”信号，且需要结合其他条件来综合判断。

    下面我们详细拆解一下：

    1. 理解ADX和ADXR的本质

        * ADX（平均趋向指数）：衡量趋势的强度，无论趋势是向上还是向下。ADX值越高（通常认为超过25），趋势越强；ADX值越低（如低于20），市场越处于无方向的震荡或盘整状态。

        * ADXR（平均趋向指数评级）：是ADX的“平滑”或“评估”值。通常计算方式是当前ADX与N周期前ADX的平均值（例如，(今日ADX + 14日前ADX)/2 ）。它反应了趋势强度的“持续性”或“稳定性”。

    2. ADX与ADXR交叉的传统意义

        * ADX上穿ADXR：这通常意味着当前的趋势强度在增强，并且强于过去一段时间的平均趋势强度。这可以理解为：

            * 趋势可能正在加速或得到强化。

            * 一个已经存在的趋势，其力度得到了确认。

        * ADX 下穿 ADXR：这通常意味着当前的趋势强度在减弱，并且弱于过去一段时间的平均趋势强度。这可以理解为：

            * 趋势可能正在失速或进入衰竭阶段。

            * 市场可能正在从趋势状态向震荡状态过渡。

    3. 为什么不能简单地将交叉点视为“开启”信号？

        * 滞后性：ADX和ADXR都是经过多次平滑计算的指标，具有显著的滞后性。当ADX上穿ADXR时，趋势可能已经运行了一段时间。

        * 缺乏方向信息：ADX只告诉我们趋势有多“强”，但不告诉我们趋势是“向上”还是“向下”。要判断方向，必须结合+DI和-DI指标。

            * 趋势市的开启：更可靠的信号是 +DI上穿-DI（同时ADX开始上升） 表示上升趋势可能开始；-DI上穿+DI（同时ADX开始上升） 表示下降趋势可能开始。ADX上穿ADXR可以作为一个额外的确认，表明这个新趋势有力度。

        * 阈值的重要性：在一个强烈震荡市中，ADX也可能短暂上穿ADXR，但两者的绝对值都很低（比如都在15附近）。这种“交叉”毫无意义，市场依然处于震荡。必须关注ADX是否站上关键水平（如20或25）。

        * 交叉的位置很关键：

            * 高位交叉：当ADX已经在高位（如>40）回落后再上穿ADXR，可能只是强劲趋势中的一个调整后的再加速，而非新趋势开启。

            * 低位交叉：在长期震荡后（ADX和ADXR都处于低位），ADX首次有效上穿ADXR并伴随+DI/-DI的金叉死叉，其预示“趋势开启”的意义更大。

    4. 更合理的应用框架

        要判断趋势市或震荡市的开启，应该采用以下组合条件：

        * A. 潜在“趋势市开启”的信号（例如上升趋势）：

            * 方向信号：+DI线 > -DI线（最好已经发生金叉）。

            * 强度确认：ADX线开始拐头向上。

            * 强化/持续确认：ADX线上穿ADXR线。

            * 阈值确认：ADX值大于20或25，且仍在上升。

            * 价格确认：价格本身突破了重要的阻力位或整理区间。

        * B. 潜在“震荡市开启”的信号：

            * 强度衰竭：ADX线从高位（>30）开始拐头向下。

            * 弱化确认：ADX线下穿ADXR线。

            * 阈值确认：ADX值回落至20以下。

            * 方向信号混乱：+DI线和-DI线频繁交叉，且彼此缠绕。

            * 价格确认：价格在某个区间内来回波动，缺乏明确方向。

    总结

    可以把ADX上穿ADXR视为“趋势力度正在加强并可能持续”的确认信号，把ADX下穿ADXR视为“趋势力度正在减弱并可能停滞”的警告信号。但它本身不是一个独立的“开仓”或“模式切换”的起点信号。

    最佳实践是：

    * 永远将ADX/ADXR与+DI/-DI结合使用，先看方向（+DI/-DI），再看强度（ADX），最后看持续性（ADXR交叉）。

    * 结合价格行为和技术形态（如支撑阻力、通道、三角形等）。指标是用来确认价格行为的，而不是领先于价格行为。

    * 将其作为过滤工具：例如，在ADX > 25且上升时，只交易+DI/-DI金叉/死叉的主趋势方向；在ADX < 20时，避免趋势跟踪策略，转而采用高抛低吸的震荡策略。

    因此，回到你的问题：ADX穿越ADXR的交叉点是一个有价值的“拼图”，但绝不是判断趋势市或震荡市开启的充分条件。 它需要在更完整的分析框架中发挥作用。

* 简述 Dask 和 apache spark 的用法

    Dask 和 Apache Spark 都是分布式计算框架，用于处理大规模数据，但设计理念和使用场景有所不同。以下是它们的用法简述：

    Dask

    特点

    * Python原生：与NumPy、Pandas、Scikit-learn等生态无缝集成。

    * 动态任务调度：适用于复杂、非线性的计算任务。

    * 灵活性：支持单机多核或分布式集群。

    核心用法

    * 并行化集合：

        * Dask Array：模拟NumPy，分块处理大型数组。

            ```python
            import dask.array as da
            x = da.random.random((10000, 10000), chunks=(1000, 1000))
            result = x.mean().compute()
            ```

        * Dask DataFrame：模拟Pandas，处理表格数据。

            ```python
            import dask.dataframe as dd
            df = dd.read_csv('large_file.csv')
            result = df.groupby('column').mean().compute()
            ```

        * 延迟执行（delayed）：

            ```python
            from dask import delayed
            @delayed
            def slow_function(x):
                return x * 2
            tasks = [slow_function(i) for i in range(10)]
            results = dask.compute(*tasks)
            ```

    机器学习（dask-ml）：

    ```python
    from dask_ml.linear_model import LogisticRegression
    model = LogisticRegression()
    model.fit(X_train, y_train)
    ```

    部署集群：

    ```python
    from dask.distributed import Client
    client = Client('scheduler-address:8786')  # 连接集群
    ```

    Apache Spark

    特点

    * JVM生态：基于Scala，支持Java、Python、R。

    * 内存计算：通过RDD/DataFrame实现高性能迭代计算。

    * 全栈式：支持SQL、流处理、机器学习、图计算。

    核心用法

    * 初始化SparkSession：

        ```python
        from pyspark.sql import SparkSession
        spark = SparkSession.builder.appName("example").getOrCreate()
        ```

    * 数据处理：

        * RDD（弹性分布式数据集）：

        ```python
        rdd = spark.sparkContext.parallelize([1, 2, 3])
        rdd.map(lambda x: x * 2).collect()
        ```

    * DataFrame（主要API）：

        ```python
        df = spark.read.csv('large_file.csv', header=True)
        df.groupBy('column').agg({'value': 'mean'}).show()
        ```

    * SQL 查询：

        ```python
        df.createOrReplaceTempView("table")
        spark.sql("SELECT * FROM table WHERE column > 0").show()
        ```

    * 流处理（Structured Streaming）：

        ```python
        stream_df = spark.readStream.format("kafka").option("subscribe", "topic").load()
        query = stream_df.writeStream.outputMode("append").start()
        ```

    * 机器学习（MLlib）：

        ```python
        from pyspark.ml.classification import LogisticRegression
        model = LogisticRegression().fit(train_df)
        ```

    对比总结

    | 维度 | Dask | Apache Spark |
    | - | - | - |
    | 语言生态 | Python原生 | JVM为主（支持Python/Java/Scala/R） |
    | 部署难度 | 较轻量，易上手 | 需配置集群（如YARN/K8s） |
    | 适用场景 | 中等数据、复杂工作流、Pandas扩展 | 超大数据、ETL流水线、全栈分析 |
    | 内存管理 | 依赖 Python GC | 自主内存优化（Tungsten引擎） |
    | 生态工具 | 集成 Python 科学栈 | Spark SQL/Streaming/MLlib/GraphX |

    选择建议

    * 若团队以Python为主，数据量在TB以下，且需要灵活的任务调度，选Dask。

    * 若处理PB级数据，需企业级稳定性和全栈分析（SQL/流/ML），选Spark。

* `vim -u`：启动时额外加载配置文件

    example:

    `vim -u ~/test_vimrc.vim`

    完全不加载默认配置，只加载指定文件:

    `vim -u ~/test_vimrc.vim -N`

    最小化启动（不加载任何配置）:

    `vim -u NONE -N`

* vim 启动后加载 Vimscript

    ```vim
    " 加载指定的 vimscript 文件
    :source ~/test_script.vim

    " 或者简写
    :so ~/test_script.vim
    ```

* bash 中的字符串引号逃逸

    `echo It's my work.`会显示语法错误：

    ```
    main.sh: line 4: unexpected EOF while looking for matching `''
    main.sh: line 5: syntax error: unexpected end of file
    ```

    因为 bash 认为`'`是标记了一个字符串的开始，但是没有找到另一个`'`标记字符串的结束。

    如果我们写成

    `echo 'It's my work.'`

    输出同样同上，因为 bash 匹配最近的两个`'`，即`'It's`中的这两个。导致 work 后的`'`未被匹配。

    即使加上转义也不行：`echo 'It\'s my work.'`，因为 bash 认为单引号括住的字符默认不转义，即字符串被分割为`'It\'`和`s my work.`，以及`'`开头的未完成字符串。

    双引号也不转义：

    `echo "It\'s my work."`

    输出为：

    ```
    It\'s my work.
    ```

    要想正确输出，只有两种办法：

    * `echo $'It\'s my work.'`

    * `echo "It's my work."`

    这点和 C 语言不太一样。

* git 配置命令别名

    ```
    # 设置别名
    git config --global alias.co checkout
    git config --global alias.br branch
    git config --global alias.ci commit
    git config --global alias.st status

    # 复杂别名
    git config --global alias.lg "log --oneline --graph --all"
    git config --global alias.unstage "reset HEAD --"
    git config --global alias.last "log -1 HEAD"
    ```

    example:

    `git st` = `git status`

* `git config --global core.editor "code --wait"`

    将 VS Code 设置为 Git 的全局默认文本编辑器

    * ore.editor：指定 Git 使用的文本编辑器

    * "code --wait"：

        * code：VS Code 的命令行启动命令

        * --wait：重要参数！让 Git 等待 VS Code 关闭后才继续执行

            执行 git commit（不带 -m）时：

            1. Git 会自动打开 VS Code

            2. 你编辑保存提交信息

            3. 关闭 VS Code 窗口后，Git 才会继续执行提交

            4. 如果没有 --wait，Git 会在打开 VS Code 后立即继续执行，导致提交信息为空

    如果你用其他编辑器：

    * Vim: vim

    * Nano: nano

    * Notepad++: "C:/Program Files/Notepad++/notepad++.exe" -multiInst -nosession

* git config 常见用法

    **差异比较配置**

    ```bash
    # 使用 difftool（如 vimdiff, vscode）
    git config --global diff.tool vimdiff
    git config --global difftool.prompt false

    # 更友好的 diff 输出
    git config --global diff.colorMoved zebra
    git config --global diff.algorithm patience  # 更智能的算法
    ```

    **合并与冲突解决**

    ```bash
    # 设置合并工具
    git config --global merge.tool vimdiff

    # 保持合并提交的原始分支信息
    git config --global merge.log true

    # 自动解决某些冲突
    git config --global pull.rebase true  # pull 时使用 rebase
    ```

    **提交模板与钩子**

    ```bash
    # 设置提交信息模板
    git config --global commit.template ~/.gitmessage.txt

    # 设置全局钩子目录
    git config --global core.hooksPath ~/.githooks
    ```

    **性能与行为优化**

    ```bash
    # 提高大仓库性能
    git config --global core.preloadindex true
    git config --global core.fscache true

    # 自动修正拼写错误
    git config --global help.autocorrect 1  # 1秒后自动执行

    # 禁用某些警告
    git config --global advice.detachedHead false

    # 设置默认分支名称
    git config --global init.defaultBranch main
    ```

    **SSH 与代理配置**

    ```bash
    # 指定 SSH 命令
    git config --global core.sshCommand "ssh -i ~/.ssh/id_rsa"

    # 设置 HTTP/HTTPS 代理
    git config --global http.proxy http://proxy.example.com:8080
    git config --global https.proxy https://proxy.example.com:8080
    ```

    **跨平台兼容性**

    ```bash
    # Windows 下处理行尾符
    git config --global core.autocrlf true  # Windows 推荐
    git config --global core.autocrlf input  # Linux/Mac 推荐

    # 文件系统大小写敏感
    git config --global core.ignorecase false
    ```

    **查看与管理配置**

    ```bash
    # 查看所有配置
    git config --list
    git config --list --show-origin  # 显示配置来源

    # 查看特定配置
    git config user.name
    git config --get-all alias.ci

    # 删除配置
    git config --global --unset alias.st
    git config --global --unset-all http.proxy

    # 编辑配置文件
    git config --global --edit
    ```

    **实用组合配置**

    ```bash
    # 开发者常用配置包
    git config --global core.editor "code --wait"
    git config --global color.ui auto
    git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
    git config --global pull.rebase true
    git config --global fetch.prune true  # 清理已删除的远程分支
    ```

    配置文件位置

    * 全局配置：~/.gitconfig 或 ~/.config/git/config

    * 系统配置：/etc/gitconfig

    * 仓库配置：.git/config

    这些配置可以根据个人工作习惯和团队规范进行调整，显著提升 Git 使用效率。

* vim split

    Vim Split（分屏）基本用法：

    1. 创建分屏

        ```vim
        :vsplit      # 垂直分屏（左右分割）
        :split       # 水平分屏（上下分割）
        :new         # 新窗口打开空白缓冲区
        :vsp [文件]  # 垂直分屏并打开文件
        :sp [文件]   # 水平分屏并打开文件
        ```

    2. 快捷键

        ```vim
        Ctrl+w s    # 水平分割当前窗口
        Ctrl+w v    # 垂直分割当前窗口
        Ctrl+w n    # 新窗口打开新文件
        Ctrl+w c    # 关闭当前窗口
        Ctrl+w q    # 关闭当前窗口（同 :q）
        Ctrl+w o    # 只保留当前窗口
        ```

    3. 窗口间导航

        ```vim
        Ctrl+w h    # 切换到左边窗口
        Ctrl+w j    # 切换到下边窗口
        Ctrl+w k    # 切换到上边窗口
        Ctrl+w l    # 切换到右边窗口
        Ctrl+w w    # 循环切换窗口
        Ctrl+w t    # 切换到顶部窗口
        Ctrl+w b    # 切换到底部窗口
        ```

    4. 调整窗口大小

        ```vim
        Ctrl+w =    # 所有窗口等宽等高
        Ctrl+w +    # 增加窗口高度
        Ctrl+w -    # 减少窗口高度
        Ctrl+w >    # 增加窗口宽度
        Ctrl+w <    # 减少窗口宽度
        :resize N   # 设置高度为 N 行
        :vertical resize N  # 设置宽度为 N 列
        ```

    5. 移动窗口

        ```vim
        Ctrl+w H    # 将当前窗口移到最左
        Ctrl+w J    # 将当前窗口移到最下
        Ctrl+w K    # 将当前窗口移到最上
        Ctrl+w L    # 将当前窗口移到最右
        Ctrl+w r    # 向右/向下旋转窗口
        Ctrl+w R    # 向左/向上旋转窗口
        Ctrl+w x    # 交换当前与下一个窗口
        ```

    6. 实用技巧

        ```vim
        # 在分屏间复制粘贴
        # 普通模式下可以互相复制粘贴

        # 多文件操作
        :vsp file1.txt file2.txt

        # 快速比较差异
        :diffsplit filename

        # 关闭其他所有窗口
        :only
        ```

    示例工作流：

    * vim main.py 打开主文件

    * :vsp utils.py 垂直分屏打开工具文件

    * Ctrl+w l 切换到右边窗口

    * :sp config.py 水平分屏打开配置文件

    * Ctrl+w k 回到主编辑区

* vim 设置一个分窗口跟随另一个分窗口滚动

    设置 Vim 分窗口同步滚动有以下几种方法：

    1. 临时同步滚动
    
        ```vim
        :set scrollbind        " 启用同步滚动
        :set noscrollbind      " 禁用同步滚动

        " 快捷命令
        :windo set scrollbind  " 所有窗口同步
        :windo set noscrollbind" 所有窗口取消同步
        ```

    2. 一键切换同步

        在 ~/.vimrc 中添加：
        
        ```vim
        " 切换同步滚动的快捷键
        nnoremap <leader>sb :set scrollbind!<CR>
        " 例如按 \sb 切换（默认leader是\）
        ```

    3. 自动同步特定文件类型

        ```vim
        " 比较文件时自动同步
        autocmd FileType diff set scrollbind

        " Markdown预览时同步
        autocmd FileType markdown set scrollbind
        ```

    4. 垂直和水平分屏的配置

        ```vim
        " 垂直分屏时同步滚动
        command! VsplitWithScroll 
            \ vsp | 
            \ set scrollbind |
            \ wincmd p  " 回到原窗口

        " 水平分屏时同步滚动  
        command! SplitWithScroll
            \ sp |
            \ set scrollbind |
            \ wincmd p

        " 快捷键映射
        nnoremap <leader>vs :VsplitWithScroll<CR>
        nnoremap <leader>hs :SplitWithScroll<CR>
        ```

    5. 智能同步插件

        使用插件可以获得更好的同步体验：

        vim-syncscroll（轻量级）

        ```vim
        " 安装后自动启用，支持非对称分屏
        " 自动检测分屏并同步滚动
        ```

        ScrollColors（比较时专用）

        ```vim
        " 用于比较两个文件版本时保持同步
        ```

    6. 手动同步命令

        ```vim
        " 创建一对同步的窗口
        :diffsplit file1.txt
        :vert diffsplit file2.txt
        " 这会自动启用 scrollbind

        " 保持光标位置同步
        :set cursorbind  " 光标也一起移动
        ```

    7. 实用工作流示例

        ```vim
        " 1. 比较两个文件
        :diffthis           " 在当前窗口启用比较模式
        :vsp file2.txt      " 垂直分屏
        :diffthis           " 在新窗口启用比较模式
        " 自动同步滚动！

        " 2. 查看代码和文档
        :e main.py
        :vsp
        :e documentation.md
        :set scrollbind
        " 现在滚动代码时文档也会滚动

        " 3. 编写和预览
        :e index.html
        :sp
        :e style.css
        :windo set scrollbind
        ```

    8. 注意事项

        * 同步滚动只对相同高度的内容有效

        * 如果窗口大小不同，滚动可能不完全对齐

        * 使用 :windo diffoff 退出比较模式时会取消同步

        * 同步滚动时，每个窗口的折叠（fold）状态是独立的

    9. 完整配置示例

        ```vim
        " ~/.vimrc
        " 快速切换同步滚动
        nnoremap <F3> :set scrollbind!<CR>:echo '同步滚动: ' . (&scrollbind ? '开启' : '关闭')<CR>

        " 比较模式自动同步
        augroup ScrollSync
            autocmd!
            autocmd BufEnter * if &diff | set scrollbind | endif
        augroup END

        " 创建同步窗口的命令
        command! -nargs=1 VSync vertical split <args> | set scrollbind | wincmd p
        command! -nargs=1 HSync split <args> | set scrollbind | wincmd p
        ```

    这样设置后，你可以很方便地让分窗口跟随滚动，特别适合：

    * 代码和文档对照

    * 不同版本文件比较

    * 多语言文件对照查看

* exp 中根据事实由少到多可以将内容分为几个级别

    * 想法 / idea

        虚无缥缈的想法、假设、灵感。

    * 现象

        做实验中值得记录的东西。观察到了什么？为什么会这样？为什么不是那样？

    * 暂定

        有局部实验证据和事实支撑的规律；暂时定下来的规则；一些好用的经验。

    * 稳定

        经过全局验证的规律；几乎不再变化的规则。这部分可以尝试写入笔记中。

    从上到下，变化速度越来越慢。

* dataloader 返回的是`[inputs, gts]`

    而 dataset 返回的是`(input, gt)`

    如果 dataset 返回的是`(x_1, x_2, x_3)`，dataloader 返回的会不会是`(x_1s, x_2s, x_3s)`？

* linear 模型，1 -> 32 -> 32 -> 1，lr 为 1e-2，epoch num 为 100，拟合 sin 曲线（一个周期）勉强还行。

    epoch num 为 10 则只能拟合 50％。

    似乎很难在 10 个 epoch 内完成拟合。
