* `set -e`: 任何命令返回非零（失败）状态时，立即退出脚本

    可以通过`set +e`关闭这一行为。

    example:

    ```bash
    set -e
    cd haha
    echo hello
    ```

    (`haha`文件夹不存在)

    output:

    ```
    main.sh: line 2: cd: haha: No such file or directory
    ```

    退出 bash 脚本后，`echo $?`的值为`1`。

    ```bash
    # set -e
    cd haha
    echo hello
    ```

    output:

    ```
    main.sh: line 2: cd: haha: No such file or directory
    hello
    ```

    `set -e`等价于`set -o errexit`。

* `set -u`: 遇到未定义的变量时，报错并退出（防止误用空变量）

    example:

    ```bash
    set -u
    echo "$my_var"
    echo "hello"
    ```

    output:

    ```
    main.sh: line 2: my_var: unbound variable
    ```

    ```bash
    # set -u
    echo "$my_var"
    echo "hello"
    ```

    output:

    ```

    hello
    ```

* `set -o pipefail`

    管道命令`|`中任意一个子命令失败时，整个管道返回非零状态。
    
    example:

    `main.sh`:

    ```bash
    set -o pipefail
    cd haha | echo "hello"
    echo $?
    ```

    run: `bash main.sh`

    output:

    ```
    main.sh: line 2: cd: haha: No such file or directory
    hello
    1
    ```

    如果不设置`pipefail`，则只返回最后一个命令的状态：

    ```bash
    # set -o pipefail
    cd haha | echo "hello"
    echo $?
    ```

    run: `bash main.sh`

    output:

    ```
    hello
    main.sh: line 2: cd: haha: No such file or directory
    0
    ```

    注意，`set -o pipefail`只改变了管道命令的返回值，并不会使 bash 脚本退出。

    `set +o pipefail`可以关闭这个参数。

* 如果`string_view`指向的对象被销毁，那么`string_view`的内容是未定义的：

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <iostream>
    using namespace std;

    string_view get_string_view()
    {
        string msg = "hello, world";
        return string_view(msg);
    }

    int main()
    {
        string_view strv = get_string_view();
        cout << strv << endl;
        return 0;
    }
    ```

    output:

    ```
    @��;�vH&�
    ```

* c++20 中的`string_view`不再是 read only，具体增加了什么功能不太清楚。

* `string_view`本质存储的是 begin pointer + length，并不是一个 null-terminated 的字符串，所以无法提供`.c_str()`。

    example:

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <iostream>
    using namespace std;

    int main()
    {
        string str {"hello, world"};
        string_view strv(str.c_str(), 5);
        cout << strv << endl;
        printf("strv: %s\n", strv.data());

        return 0;
    }
    ```

    output:

    ```
    hello
    strv: hello, world
    ```

    可以看到，`cout`能正常输出 string view 的内容，而`printf()`会寻找`\0`标记的字符串。

* `string_view`的`.compare()`方法与`strcmp()`用法一致；`.substr()`返回的仍是`string_view`。

    example:

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <iostream>
    using namespace std;

    int main()
    {
        string_view strv_1 {"hello"};
        string_view strv_2 {"hello"};
        int ret = strv_1.compare(strv_2);
        printf("ret: %d\n", ret);

        string_view strv {"hello, world"};
        string_view sub_strv = strv.substr(1, 5);
        cout << "strv: " << strv << endl;
        cout << "sub_strv: " << sub_strv << endl;

        return 0;
    }
    ```

    output:

    ```
    ret: 0
    strv: hello, world
    sub_strv: ello,
    ```

* c++ 中`override`表示此函数为覆盖基类的虚函数，编译器会检查此函数是否确实覆盖了基类虚函数，如果没有，则报错。`final`则表示此函数不应再被派生类的虚函数覆盖。

* 在 struct 内初始化的变量，既可以是 const 的，也可以是非 const 的，但是不能是 static 的。

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <iostream>
    using namespace std;

    struct MyType {
        string msg = "hello";
        const int val = 456;
    };

    int main()
    {
        MyType a;
        cout << a.msg << endl;
        cout << a.val << endl;
        return 0;
    }
    ```

    output:

    ```
    hello
    456
    ```

* `stoi()`与`strtol()`的区别

    `stoi()`是一个作用于`const string&`的 c++ 函数，在`<string>`头文件中。
    
    `strol()`是一个作用于 c style string 的 C 函数，在`<stdlib.h>`头文件中。

    example:

    ```cpp
    #include <stdio.h>
    #include <iostream>
    #include <stdlib.h>  // strtol()
    #include <string>  // std::stoi()
    using namespace std;

    int main()
    {
        const char *str = "123, 456";

        size_t idx;
        int val_1 = std::stoi(str, &idx, 10);
        printf("val_1: %d, idx: %lu\n", val_1, idx);

        char *end_ptr;
        int val_2 = strtol(str, &end_ptr, 10);
        printf("val_2: %d, end ch: %c\n", val_2, *end_ptr);

        return 0;
    }
    ```

    output:

    ```
    val_1: 123, idx: 3
    val_2: 123, end ch: ,
    ```

    两个函数都会从字符串起始位置开始尝试解析，直到遇到无效字符为止，返回遇到的第一个无效字符的位置。

    如果一个有效的数字都解析不出来，那么`std::stoi()`会报 exception 退出程序。`strtol()`会返回 0，但并不会报错，用户只能通过判断`end_ptr`与 start ptr 是否相等来判断是否正常解析。

* 16 进制字符串解析

    ```cpp
    #include <stdio.h>
    #include <iostream>
    #include <stdlib.h>  // strtol()
    #include <string>  // std::stoi()
    using namespace std;

    int main()
    {
        const char *str = "0x1234";

        size_t idx;
        int val_1 = std::stoi(str, &idx, 16);
        printf("val_1: %d, idx: %lu\n", val_1, idx);

        char *end_ptr;
        int val_2 = strtol(str, &end_ptr, 16);
        printf("val: %d, end ch: %c\n", val_2, *end_ptr);

        const char *str_2 = "1234";

        val_1 = std::stoi(str_2, &idx, 16);
        printf("val_1: %d, idx: %lu\n", val_1, idx);

        val_2 = strtol(str_2, &end_ptr, 16);
        printf("val: %d, end ch: %c\n", val_2, *end_ptr);

        return 0;
    }
    ```

    output:

    ```
    val_1: 4660, idx: 6
    val: 4660, end ch: 
    val_1: 4660, idx: 4
    val: 4660, end ch:
    ```

    `std::stoi()`和`strtol()`都可以正常解析带`0x`或不带`0x`的十六进制字符串。`x`对大小写不敏感，也可以写成`0X`。

    `stoi()`第 2 个参数返回解析结束时的索引，相当于`end_ptr`的作用。