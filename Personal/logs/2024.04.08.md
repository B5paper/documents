* 调研一下 zig

* Hanoi tower, 假设现在有 a, b, c 三个塔，a 上有 n 个盘子，上小下大，要求借助 c 把它们都移动到 b 上，并且要求在移动的过程中，必须保持所有的叠放都是上小下大。

    我们假设这个游戏已经到了最后一步，最后一步的情况是 a 上只剩底部一个最大的盘子，其余的 n - 1 个盘子都在 c 上，并且保持上小下大的特点。

    此时只需要把 a 上的最后一个盘子移动到 b 上，然后把 c 上的所有盘子移动到 b 上就可以了。

    此时我们把问题分解成了两个子问题：

    ```
    original problem: (n, 0, 0) -> (0, n, 0)
    child problem 1: (n, 0, 0) -> (1, 0, n-1) -> (0, 1, n-1)
    child problem 2: (0, 1, n-1) -> (0, n, 0)
    ```

    注意到子问题 1，它其实和原问题一样，只不过把 b 作为了缓冲区，总移动数量变成了 n - 1。

    子问题 2 中，a 作为了缓冲区，总移动数量仍然是 n - 1。

    这样就把一个总移动量为 n 的问题拆成了两个总移动量为 n - 1 的问题。当总移动量为 1 时，就可以直接移动了。

    代码：

    ```cpp
    #include <iostream>
    using namespace std;

    void hanoi(int n, int from, int to)
    {
        if (n == 1)
        {
            printf("move from %d to %d\n", from, to);
            return;
        }
        int another_idx;
        for (int i = 0; i < 3; ++i)
        {
            if (i == from || i == to)
                continue;
            another_idx = i;
            break;
        }
        hanoi(n-1, from, another_idx);
        printf("move from %d to %d\n", from, to);
        hanoi(n-1, another_idx, to);
    }

    int main()
    {
        hanoi(3, 0, 1);
        return 0;
    }
    ```

    output:

    ```
    move from 0 to 1
    move from 0 to 2
    move from 1 to 2
    move from 0 to 1
    move from 2 to 0
    move from 2 to 1
    move from 0 to 1
    ```

    书上给的 example:

    ```cpp
    #include <iostream>
    using namespace std;

    void hanoi(int n, int x, int y, int z)
    {
        if (n >= 1)
        {
            hanoi(n-1, x, z, y);
            printf("move from %d to %d\n", x, y);
            hanoi(n-1, z, y, x);
        }
    }

    int main()
    {
        hanoi(3, 0, 1, 2);
        return 0;
    }
    ```

    output:

    ```
    move from 0 to 1
    move from 0 to 2
    move from 1 to 2
    move from 0 to 1
    move from 2 to 0
    move from 2 to 1
    move from 0 to 1
    ```

    不清楚他是如何做到这么简洁的。