* 向上取整

    ```cpp
    #define DIVUP(x, y) \
        (((x)+(y)-1)/(y))

    int div_up(int x, int y) {
        return (x + y - 1) / y;
    }
    ```

    上述代码实现了 x / y 向上取整，如果 x 正好是 y 的整数倍，那么不向上取整。

    这个算法还挺巧妙的，如果写成
    
    ```cpp
    if (x % y == 0)
        res = x / y;
    else
        res = x / y + 1;
    ```

    那么就太复杂了，没有 (x + y - 1) / y 简单。目前不清楚这个算法是怎么想出来的。

* `ip route get <dst_ip>`可以显示访问`dst_ip`是从本机的哪个路由表出去

    example:

    ```
    (base) hlc@hlc-VirtualBox:~$ ip route get 223.5.5.5
    223.5.5.5 via 10.0.2.1 dev enp0s3 src 10.0.2.4 uid 1000 
        cache
    ```

    其中`via 10.0.2.1`表示网关（下一跳的地址），`dev enp0s3`表示使用的网卡设备，`src 10.0.2.4`表示源地址。

    `ip route get <dst_ip> from <src_ip>`可以指定源地址。

    ip route get 仅本地查询，不发送真实数据包。

* 非线性学习的 pivot

    假如一个线性的学习顺序是 A -> B -> C -> D -> E，但是接触概念时先接触到了 C，发现只能从 C 出发去解释 D, E，但是不知道怎么解释 C。

    此时有两种方式，一是从 C 出发，猜测前置概念 A, B，做出假设，并根据 C, D, E 相关的现象和推论验证 A, B 假设的正确性；另一种是顺藤摸瓜，找到 C 的源头 A, B，对学习顺序做一个 pivot，从 A 开始学起，把非线性的过程变成线性的。

* `mmap()`匿名映射

    匿名映射 Anonymous Mapping

    匿名映射不与磁盘文件关联，直接分配虚拟内存供进程使用

    example:

    ```cpp
    #include <sys/mman.h>
    #include <stdio.h>
    #include <string.h>

    int main() {
        void *buf = mmap(NULL, 1024, PROT_READ | PROT_WRITE,
            MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
        if (buf == NULL) {
            printf("fail to mmap\n");
            return -1;
        }

        strcpy((char*) buf, "hello, world");

        printf("msg: %s\n", (char*) buf);
      
        int ret = munmap(buf, 1024);
        if (ret != 0) {
            printf("fail to munmap\n");
            return -1;
        }
        return 0;
    }
    ```

    output:

    ```
    msg: hello, world
    ```

    这个似乎可以拿来替换`malloc()`，如果是 shared 模式还可以在进程间通信。

* kernel parameter 由于 user 是 root，所以实际上权限设置为`S_IRUSR | S_IWUSR`，普通用户仍无法读写

    ```c
    module_param(m_int, int, S_IRUSR | S_IWUSR);
    module_param(m_str, charp, S_IRUSR | S_IWUSR);
    module_param_array(m_arr, int, NULL, 0755);
    ```

    ```
    test@Ubuntu22:/sys/module/hello/parameters$ ls -lh
    total 0
    -rw-r--r-- 1 root root 4.0K  8月 19 14:48 m_arr
    -rw------- 1 root root 4.0K  8月 19 14:48 m_int
    -rw------- 1 root root 4.0K  8月 19 14:48 m_str
    ```

* kernel parameter array 元素个数越界与不足

    如果提供的元素个数超过数组 size，那么会报错：

    `int m_arr[3];`

    ```
    test@Ubuntu22:/sys/module/hello/parameters$ echo "1,2,3,4" | sudo tee ./m_arr 
    1,2,3,4
    tee: ./m_arr: Invalid argument
    ```

    如果提供的元素个数不足，那么剩余元素保持原来的值：

    ```
    test@Ubuntu22:/sys/module/hello/parameters$ echo "4,5" | sudo tee ./m_arr 
    4,5
    test@Ubuntu22:/sys/module/hello/parameters$ sudo cat m_arr 
    4,5,3
    ```

* `ssize_t`是`long`

* cdev 和`cdev_init()`, `cdev_add()`相关，涉及到 open, release, read, write, ioctl 等操作；device 和`class_create()`, `device_create()`相关，涉及到`/dev/xxxx`设备文件的创建。

    可以看出，cdev 和 device 本身没有依赖关系，它们通过设备号`dev_t dev_num`关联到一起。

* `list_add()`两个参数都是`struct list_head*`

* `struct list_head`是每次从尾部添加新节点，并不会每次遍历到最后一个节点

    example:

    ```c
    #include <linux/list.h>

    struct my_node {
        struct list_head node_head;
        int val;
    };

    struct list_head lst_head;

    int m_open(struct inode *, struct file *) {
        pr_info("in m_open()...\n");
        INIT_LIST_HEAD(&lst_head);
        for (int i = 0; i < 3; ++i) {
            struct my_node *new_node = kmalloc(sizeof(struct my_node), GFP_KERNEL);
            new_node->val = i;
            list_add(&new_node->node_head, &lst_head);
        }
        return 0;
    }

    int m_release(struct inode *, struct file *) {
        pr_info("in m_release()...\n");
        struct my_node *cur_node;
        int node_idx = 0;
        list_for_each_entry(cur_node, &lst_head, node_head) {
            pr_info("node %d, val: %d\n", node_idx++, cur_node->val);
        }

        return 0;
    }
    ```

    run: `sudo cat /dev/hlc_dev`

    dmesg output:

    ```
    [13574.844808] in m_open()...
    [13574.844916] in m_read()...
    [13574.844954] in m_release()...
    [13574.844956] node 0, val: 2
    [13574.844961] node 1, val: 1
    [13574.844964] node 2, val: 0
    ```