* vulkan `VkPipelineMultisampleStateCreateInfo`

	multisample 指的是抗锯齿，将一个像素中放置多个采样点，然后计算采样点是否在小三角形范围内，然后根据采样点的多少决定像素颜色的深浅。

	syntax:

	```c
	typedef struct VkPipelineMultisampleStateCreateInfo {
		VkStructureType                          sType;
		const void*                              pNext;
		VkPipelineMultisampleStateCreateFlags    flags;
		VkSampleCountFlagBits                    rasterizationSamples;
		VkBool32                                 sampleShadingEnable;
		float                                    minSampleShading;
		const VkSampleMask*                      pSampleMask;
		VkBool32                                 alphaToCoverageEnable;
		VkBool32                                 alphaToOneEnable;
	} VkPipelineMultisampleStateCreateInfo;
	```

	sample count:

	```c
	typedef enum VkSampleCountFlagBits {
		VK_SAMPLE_COUNT_1_BIT = 0x00000001,
		VK_SAMPLE_COUNT_2_BIT = 0x00000002,
		VK_SAMPLE_COUNT_4_BIT = 0x00000004,
		VK_SAMPLE_COUNT_8_BIT = 0x00000008,
		VK_SAMPLE_COUNT_16_BIT = 0x00000010,
		VK_SAMPLE_COUNT_32_BIT = 0x00000020,
		VK_SAMPLE_COUNT_64_BIT = 0x00000040,
	} VkSampleCountFlagBits;
	```

	其余的几个字段暂时不懂啥意思。

* cached tabs:

	* vulkan tutorial Multisampling
	
		<https://vulkan-tutorial.com/Multisampling>

* vulkan `VkAttachmentLoadOp`

	可选的值有这些：

	```c
	typedef enum VkAttachmentLoadOp {
		VK_ATTACHMENT_LOAD_OP_LOAD = 0,
		VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
		VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
	// Provided by VK_KHR_load_store_op_none
		VK_ATTACHMENT_LOAD_OP_NONE_KHR = 1000400000,
	// Provided by VK_EXT_load_store_op_none
		VK_ATTACHMENT_LOAD_OP_NONE_EXT = VK_ATTACHMENT_LOAD_OP_NONE_KHR,
	} VkAttachmentLoadOp;
	```

	猜测：`VK_ATTACHMENT_LOAD_OP_LOAD`是将 vkimage 的值设置成新 load 的 texture 的值。

	`VK_ATTACHMENT_LOAD_OP_CLEAR`是将 image 设置为指定值。

	`VK_ATTACHMENT_LOAD_OP_DONT_CARE`是不需要额外设置，只是将其作为缓冲区。

	`VK_ATTACHMENT_LOAD_OP_NONE_KHR`表示这个 image 没有 access 权限。一般不怎么用到。

* vulkan `VkAttachmentStoreOp`

	syntax:

	```c
	typedef enum VkAttachmentStoreOp {
		VK_ATTACHMENT_STORE_OP_STORE = 0,
		VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
	// Provided by VK_VERSION_1_3
		VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
	// Provided by VK_KHR_dynamic_rendering, VK_KHR_load_store_op_none
		VK_ATTACHMENT_STORE_OP_NONE_KHR = VK_ATTACHMENT_STORE_OP_NONE,
	// Provided by VK_QCOM_render_pass_store_ops
		VK_ATTACHMENT_STORE_OP_NONE_QCOM = VK_ATTACHMENT_STORE_OP_NONE,
	// Provided by VK_EXT_load_store_op_none
		VK_ATTACHMENT_STORE_OP_NONE_EXT = VK_ATTACHMENT_STORE_OP_NONE,
	} VkAttachmentStoreOp;
	```

	渲染完成后，结果是否需要写回 attachment 显存。

	`VK_ATTACHMENT_STORE_OP_STORE`指的是写回显存。

	`VK_ATTACHMENT_STORE_OP_DONT_CARE`是不写回。

	`VK_ATTACHMENT_STORE_OP_NONE`表示没有 access 权限。

	疑问：既然要写回显存，那么 render pass 渲染生成的图像，一开始是放在哪里呢？

* 在调研时，可以将笔记分成几个部分

	* 猜测（或者假设）

		给出自己的猜测，不需要验证

	* 疑问

		提出的问题

	* 验证

		对猜测的验证

	* 已经可以确定的笔记

		经过验证的猜测或假设，需要背会。

* python hash

	直接用`hash()`函数就可以计算出各个 python 内置对象的哈希值。

	example:

	```py
	a = 3
	s = 'hello, world'
	print(hash(a))
	print(hash(s))
	```

	output:

	```
	3
	1966604262258436456
	```

	每次运行程序，即使对相同的字符串，哈希值也不同。不清楚为什么。

* python regular expression

	example 1:

	```python
	import re
	txt = 'hello, world'
	pat_1 = re.compile('world')
	m = pat_1.search(txt)
	start_pos = m.start()
	end_pos = m.end()
	selected_txt = txt[start_pos:end_pos]
	print(selected_txt)  # world
	```

	python 中使用正则表达式可以使用`re`模块，其中`re.compile()`表示将正则表达式编译成一段小程序（应该是转换成有限状态机）。

	`pat_1.search()`表示从指定位置开始匹配，返回一个`Match`对象，`Match`对象保存了匹配结果，包括开始和结尾位置，group 情况之类的。

	`search()`区别于`match()`，`match()`表示从头开始匹配。

	example 2:

	```python
	txt = 'abcbacaccba'
	pat_2 = re.compile('a.{2}')
	for m in pat_2.finditer(txt):
		start_pos = m.start()
		end_pos = m.end()
		selected_txt = txt[start_pos:end_pos]
		print(selected_txt)  # [abc, aca]
	```

	这个例子中，使用`pat_2.finditer()`

	example 3:

	```python
	txt = \
	'''
	[unit]
	hello
	world
	[unit]
	hehe
	haha
	'''
	pat_3 = re.compile('\[unit\](.|\n)*?(?=\[unit\]|\Z)')
	for m in pat_3.finditer(txt):
		start_pos = m.start()
		end_pos = m.end()
		selected_txt = txt[start_pos:end_pos]
		print(selected_txt)
	```

	output:

	```
	[unit]
	hello
	world

	[unit]
	hehe
	haha
	```

	其中`(?=...)`表示匹配括号中的表达式，但是不选中。这个操作叫 forward lookahead。

	`*?`表示最近匹配，在所有符合条件的表达式中，找到最短的。

	可以使用这个网站对正则表达式 debug: <https://regex101.com/>

	目前不清楚`findall()`怎么个用法。

* python 获取内核时间

	```python
	import time
	time.process_time()
	time.thread_time()
	```

	这两个函数可以返回浮点数作为时间。经过测试，这俩函数的返回值基本都是递增的。可以放心用。

* python 正则表达式中有关汉字的处理

	一个匹配表达式是：

	```python
	patstr_hanzi = r'[\u4e00-\u9fff\u3400-\u4dbf\U00020000-\U0002a6df\U0002a700-\U0002ebef\U00030000-\U000323af\ufa0e\ufa0f\ufa11\ufa13\ufa14\ufa1f\ufa21\ufa23\ufa24\ufa27\ufa28\ufa29\u3006\u3007][\ufe00-\ufe0f\U000e0100-\U000e01ef]?'
	```

	其他的匹配方法可以参考这个回答：<https://stackoverflow.com/questions/2718196/find-all-chinese-text-in-a-string-using-python-and-regex>

* python 正则表达式中，方括号`[]`里不能有点号`.`，只能有`a-z`，数字，标点符号之类的。

	点号`.`可以匹配除了`\n`之外的任意一个字符。如果想匹配包括`\n`在内的所有字符，可以使用`(.|\n)`，用括号和或运算将这两个结合起来。

* python 正则中，可以使用`\A`匹配字符串的开头，使用`\Z`匹配末尾。

* python 常用的 format 语法

	```python
	txt1 = "My name is {fname}, I'm {age}".format(fname = "John", age = 36)
	txt2 = "My name is {0}, I'm {1}".format("John",36)
	txt3 = "My name is {}, I'm {}".format("John",36) 
	```