* 调研

    `create_workqueue`, `inb`, 
    
    `INIT_WORK`, `DECLARE_WORK`, `struct work_struct task;`, `queue_work`

* typical IRQ assignments for a PC

    | IRQ number | Device |
    | - | - |
    | 0 | System timer |
    | 1 | Keyboard (PS/2) |
    | 2 | Cascade from IRQ 9 |
    | 3 | COM port 2 or 4 |
    | 4 | COM port 1 or 3 |
    | 5 | Parallel (printer) port 2 or sound cards |
    | 6 | Floppy drive controller |
    | 7 | Parallel (printer) port 1 |
    | 8 | Real-time clock |
    | 9 | Video |
    | 10 | Open |
    | 11 | Open |
    | 12 | Mouse (PS/2) |
    | 13 | Coprocessor |
    | 14 | Primary IDE controller (hard drives) |
    | 15 | Secondary IDE controller (hard drives) |

    ref: <https://www.techtarget.com/whatis/definition/IRQ-interrupt-request>

* 一个可用的 irq 软中断程序，见`ref_15`

    在编译完，`insmod`之后，可以使用`sudo cat /dev/etx_device`触发中断，然后可以看到`dmesg`里显示：

    ```
    [12575.759721] intrp: loading out-of-tree module taints kernel.
    [12575.759724] intrp: module verification failed: signature and/or required key missing - tainting kernel
    [12575.760032] Major = 240 Minor = 0 
    [12575.760356] Device Driver Insert...Done!!!
    [12715.415083] Device File Opened...!!!
    [12715.415103] Read function
    [12715.415107] __common_interrupt: 1.59 No irq handler for vector
    [12715.415119] Device File Closed...!!!
    ```

    11 号中断是保留中断，没有默认用途，因此用户可以去自定义。

    代码中比较难理解的是`asm("int $0x3B");  // Corresponding to irq 11`这一句。

    我们可以打开`/usr/src/linux-headers-6.5.0-28-generic/arch/x86/include/asm/irq_vectors.h`文件，查到

    `#define FIRST_EXTERNAL_VECTOR           0x20`

    不清楚`#define IRQ0_VECTOR (FIRST_EXTERNAL_VECTOR + 0x10)`这一步是怎么来的。

    最后还需要加上我们的中断号`11`，即`0x20 + 0x10 + 11 = 0x3B`，

    这诚是`asm("int $0x3B");`的由来。

* `2589. 完成所有任务的最少时间`

    一个初步的想法：

    1. 这道题可以转化为，对于第`i`个区间，从集合`[start, end]`中选出一个最少含`duration`个元素的子集。假设有`n_i`个选法。

    2. 对于每个区间，选一个子集，然后对所有子集取并集，共有`n_0 * n_1 * ... * n_{N-1}`种取法。

    3. 取这$\Pi_0^{N-1} n_i$个并集中，元素最少的那个并集，其元素个数就是答案。