* `git cherry-pick`

    用于将指定的提交应用到当前分支。

    * 主要作用

        * 选择性地复制单个或多个提交到当前分支

        * 常用于修复bug、功能迁移，或者从其他分支提取特定改动

        * 不合并整个分支，只引入特定的提交

    * 基本用法

        ```bash
        # 1. 基本用法 - 应用单个提交
        git cherry-pick <commit-hash>

        # 2. 应用多个提交
        git cherry-pick <commit1> <commit2> <commit3>

        # 3. 应用连续的提交范围（左开右闭）
        git cherry-pick <start-commit>..<end-commit>

        # 4. 应用连续的提交范围（包含起始提交）
        git cherry-pick <start-commit>^..<end-commit>
        ```

    * 常用选项

        ```bash
        # 编辑提交信息
        git cherry-pick -e <commit>

        # 不自动提交，只更新工作区
        git cherry-pick -n <commit>

        # 解决冲突后继续
        git cherry-pick --continue

        # 放弃当前cherry-pick操作
        git cherry-pick --abort

        # 跳过当前提交
        git cherry-pick --skip
        ```

    * 工作流程示例

        ```bash
        # 1. 切换到目标分支
        git checkout main

        # 2. 从开发分支选择特定提交
        git cherry-pick abc123

        # 3. 如果有冲突，解决后继续
        # 解决冲突后...
        git add .
        git cherry-pick --continue
        ```

    * 典型应用场景

        * 修复bug：将修复提交从开发分支应用到生产分支

        * 功能移植：只移植某个功能相关的提交

        * 代码审查：只接受部分提交改动

        * 分支维护：在不同版本分支间同步特定修复

    * 注意事项

        * 每个`cherry-pick`都会创建新的提交（即使内容相同，提交ID也不同）

        * 可能产生冲突，需要手动解决

        * 顺序依赖的提交需要按顺序`cherry-pick`

        * 不适合大量提交的迁移（此时应考虑 merge 或 rebase）

    与 git merge 和 git rebase 不同，cherry-pick 提供了更精细的提交选择控制，让你能够精确地选择需要的改动应用到当前分支。

    example:

    ```
    (base) hlc@hlc-VirtualBox:~/Documents/Projects/git_test/repo-2$ git init
    Initialized empty Git repository in /home/hlc/Documents/Projects/git_test/repo-2/.git/
    (base) hlc@hlc-VirtualBox:~/Documents/Projects/git_test/repo-2$ git remote add origin ../repo-server/
    (base) hlc@hlc-VirtualBox:~/Documents/Projects/git_test/repo-2$ git checkout -b main
    Switched to a new branch 'main'
    (base) hlc@hlc-VirtualBox:~/Documents/Projects/git_test/repo-2$ git cherry-pick bdb04eac91dcc38477bd235ba6e1e8860e94c928 a7f9daf03e71290e94861ab5d3df42d05c5721f4
    fatal: bad object bdb04eac91dcc38477bd235ba6e1e8860e94c928
    (base) hlc@hlc-VirtualBox:~/Documents/Projects/git_test/repo-2$ git fetch
    remote: Enumerating objects: 9, done.
    remote: Counting objects: 100% (9/9), done.
    remote: Compressing objects: 100% (7/7), done.
    remote: Total 9 (delta 2), reused 0 (delta 0), pack-reused 0
    Unpacking objects: 100% (9/9), 727 bytes | 181.00 KiB/s, done.
    From ../repo-server
     * [new branch]      master     -> origin/master
     * [new tag]         v1.0       -> v1.0
     * [new tag]         v2.0       -> v2.0
    (base) hlc@hlc-VirtualBox:~/Documents/Projects/git_test/repo-2$ git cherry-pick bdb04eac91dcc38477bd235ba6e1e8860e94c928 a7f9daf03e71290e94861ab5d3df42d05c5721f4
    [main e88ad40] commit 1
     Date: Wed Dec 24 14:45:00 2025 +0800
     1 file changed, 0 insertions(+), 0 deletions(-)
     create mode 100644 file_1.txt
    [main 34dadd6] commit 3
     Date: Thu Dec 25 10:01:21 2025 +0800
     1 file changed, 0 insertions(+), 0 deletions(-)
     create mode 100644 file_3.txt
    (base) hlc@hlc-VirtualBox:~/Documents/Projects/git_test/repo-2$ git log --graph
    * commit 34dadd6973f7726b39a7a20975f520ed17041f5a (HEAD -> main)
    | Author: Liucheng Hu <lchu@siorigin.com>
    | Date:   Thu Dec 25 10:01:21 2025 +0800
    | 
    |     commit 3
    | 
    * commit e88ad401688c2033fa983b8507943661687a6b28
      Author: Liucheng Hu <lchu@siorigin.com>
      Date:   Wed Dec 24 14:45:00 2025 +0800
      
          commit 1 

    (base) hlc@hlc-VirtualBox:~/Documents/Projects/git_test/repo-2$ ls
    file_1.txt  file_3.txt
    ```

    注：

    1. 可以看到，必须 fetch 后才能 cherry-pick。

    1. cherry-pick 后，除了 commit hash 值和原版 commit 不同，剩下的都相同。

    1. 可以看到 cherry-pick 不是基于快照的，而是基于 diff 的。因为 file_2.txt 不在其中

* windows 下禁止 vim 生成 `xxx.un~` 文件和 `xxx~` 文件

    ```vim
    " 禁用备份文件（以 ~ 结尾的文件）
    set nobackup
    set nowritebackup

    " 禁用撤销文件（以 .un~ 结尾的文件）
    set noundofile
    ```

    * vim 生成的几种文件简介
    
        * 备份文件 `xxx~`： 写文件之前，先把原文件复制一份

            触发时机:

            * 执行 :w

            * backup 或 writebackup 开启时

            作用:

            * 防止写文件过程中崩溃 / 断电 / 磁盘错误

            * 写失败时，原内容还在 filename~

            写成功后：

            * backup 开启 → filename~ 会保留

            * 只开 writebackup → 写完就删

            相关配置：

            ```vim
            :set backup        " 是否保留 ~ 文件
            :set writebackup  " 是否写前临时备份
            :set nobackup
            :set nowritebackup
            ```

        * 交换文件 `xxx.swp`: 编辑过程中实时保存修改，用于崩溃恢复

            打开文件时立即创建

            作用:

            * 崩溃恢复（vim -r filename）

            * 防止同一文件被多个 Vim 实例同时修改

            特点:

            * 实时保存编辑状态

            * 正常退出 Vim 会自动删除

            * 非正常退出会残留

            看到它通常意味着:

            * 上次 Vim 崩了

            * 或该文件正在被另一个 Vim 打开

            相关配置：

            ```vim
            :set swapfile
            :set noswapfile
            :set directory?   " swap 文件存放目录
            ```

            * `.filename.swo` / `.swn` / `.swx` —— swap 冲突序号

                当 .swp 已存在：

                Vim 会尝试 .swo、.swn、.swx

        * 撤销文件 `xxx.un~`： 撤销历史记录（持久化撤销, 重启 Vim 后还可以执行`u`命令）

            需要启用 `undofile`功能，这个文件才能被创建。

            相关配置：

            ```vim
            :set undofile
            :set undodir?
            ```

    * 其它配置

        ```vim
        set backupdir=~/.vim/backup//  " 备份到特定目录
        set backupskip=/tmp/*,/private/tmp/*  " 跳过某些目录的备份

        set undodir=~/.vim/undo//
        set directory=~/.vim/swap//

        " 撤销历史（.un~文件）
        set undofile          " 持久化撤销历史到磁盘
        set undolevels=1000   " 内存中保留1000次撤销

        " 2. 配置定时清理
        autocmd VimLeave * !del /Q Z:\vim-backup\*
        " 退出时自动清理内存备份
        autocmd VimLeavePre * call CleanOldBackups(30) " 保留30天

        " 备份文件扩展名
        set backupext=.bak
        ```

    * 如果你只想对某些文件类型禁用，可以在 _vimrc 中添加：

        ```vim
        " 对特定目录禁用备份
        autocmd BufWritePre /path/to/directory/* set nobackup nowritebackup

        " 或者对特定文件类型禁用
        autocmd FileType txt,md set noundofile
        ```

    * 设置备份目录到特定位置，而不是当前目录：

        ```vim
        " 将备份文件集中到特定目录
        set backupdir=C:\vim_backups
        set directory=C:\vim_backups
        set undodir=C:\vim_undo

        " 如果目录不存在则创建
        if !isdirectory("C:\\vim_backups")
            silent !mkdir "C:\vim_backups"
        endif
        ```

    * 完全禁用所有备份相关功能

        ```vim
        " 一次性禁用所有备份相关文件
        set nobackup       " 不创建备份文件（*.~）
        set nowritebackup  " 写入时不创建备份
        set noswapfile     " 不创建.swp交换文件
        set noundofile     " 不创建.un~撤销文件
        ```

    * 折中方案

        ```vim
        " 将备份文件集中到固定目录，而不是污染当前目录
        set backupdir=~/.vim/backup//
        set directory=~/.vim/swap//
        set undodir=~/.vim/undo//

        " 确保目录存在
        if !isdirectory(expand("~/.vim/backup"))
            silent !mkdir ~/.vim/backup
        endif
        if !isdirectory(expand("~/.vim/undo"))
            silent !mkdir ~/.vim/undo
        endif
        ```

    * 自动清理脚本

        ```vim
        " 定期清理旧备份
        function! CleanOldBackups(days)
            let backup_dir = expand('~/.vim/backup')
            if isdirectory(backup_dir)
                " Windows 示例
                silent !forfiles /p backup_dir /s /m * /d -%a% /c "cmd /c del @path"
            endif
        endfunction

        autocmd VimLeave * call CleanOldBackups(7)  " 保留7天
        ```

* 为什么 linux 上正常关闭 vim 后不会留下 ~ 文件，而 windows 上会

    vim 在 linux 上默认不开启 backup，但是在 windows 上开启。

* vim 的恢复功能

    * 使用 vim -r filename 恢复交换文件

    * `:recover`

* 在 Vim 中比较差异

    ```vim
    vim -d report.txt report.txt~
    # 或进入 Vim 后
    :vert diffsplit report.txt~
    ```

* `.vimrc`生效时机

    在`.vimrc`保存后，重新启动 file_1 的 vim 编辑器即可。不需要关闭系统上所有的 vim。

    配置生效通常有以下三种情况：

    * 重新启动 Vim： 这是最稳妥的方法。当你关闭并重新打开 Vim 时，它会自动加载配置文件。

    * 手动执行 Source 命令： 在不退出 Vim 的情况下，可以通过命令让当前运行的 Vim 实例立即应用新配置：

        * 在 Vim 内部输入：:source ~/.vimrc（Linux）或 :source $VIM/_vimrc（Windows）。

            或`:so ~/.vimrc`, `:source $MYVIMRC`

    * 在 .vimrc 中设置自动指令（Autocmd）： 你可以添加一段代码，让 Vim 在检测到配置文件保存时自动执行 source 命令。

    特性	Linux / macOS	Windows
    默认文件名	.vimrc	_vimrc (通常) 或 .vimrc
    主配置路径	~/.vimrc (用户家目录)	C:\Users\用户名\_vimrc 或 Vim 安装目录
    路径变量	$HOME	$VIM 或 $HOME
    换行符	LF	CRLF

    ```vim
    " 按下 \ + s 立即重新加载配置
    nnoremap <leader>s :source $MYVIMRC<cr>
    ```

    有时候你 source 了文件，但发现外观没变。这通常是因为：

    * 插件需要重启： 某些插件（如代码补全、状态栏）在初始化时加载，简单的 source 可能无法重置它们的运行状态。

    * 缓存问题： 某些配色方案（Colorscheme）在切换时，旧的颜色属性可能残留在内存中，建议重新运行 :colorscheme 方案名。

* git commit 后发现 user 和 email 写错了，该如何补救

    * 只修改最近一次提交的作者信息

        `git commit --amend --author="正确的姓名 <正确的邮箱>"`

    * 修改最近一次提交的作者信息

        `git commit --amend --reset-author`

        这会使用你在 git config 中配置的用户名和邮箱。

    * 修改多个提交的作者信息

        ```bash
        # 修改最近3次提交
        git rebase -i HEAD~3 --exec "git commit --amend --reset-author --no-edit"
        ```

        或者使用更强大的方法：

        ```bash
        # 交互式 rebase，标记要修改的提交
        git rebase -i HEAD~3
        # 在编辑器中，将需要修改的提交前的 pick 改为 edit
        # 然后对每个标记为 edit 的提交执行：
        git commit --amend --author="正确的姓名 <正确的邮箱>"
        git rebase --continue
        ```

        如果需要修改整个仓库的历史记录，可以使用 git filter-branch：

        ```bash
        git filter-branch --env-filter '
        OLD_EMAIL="旧的邮箱"
        CORRECT_NAME="正确的姓名"
        CORRECT_EMAIL="正确的邮箱"
        if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]
        then
            export GIT_COMMITTER_NAME="$CORRECT_NAME"
            export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"
        fi
        if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]
        then
            export GIT_AUTHOR_NAME="$CORRECT_NAME"
            export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"
        fi
        ' --tag-name-filter cat -- --branches --tags
        ```

    * 如果已经推送到远程仓库，修改历史记录后需要使用 git push --force（谨慎使用）

* vscode 中 debug 时自动加载环境变量

    * 指定 envfile

        `"envFile": "${workspaceFolder}/.env"`

        注：

        1. `.env`是默认情况下就支持的吧？写`envFile`的时机是给`.env`換名字。

    * 使用 preLaunchTask

        适用于在 shell 脚本中配置环境变量。

        1. 创建 task (tasks.json)：

            ```json
            {
                "version": "2.0.0",
                "tasks": [
                    {
                        "label": "load-env",
                        "type": "shell",
                        "command": "source ${workspaceFolder}/env.sh && env > ${workspaceFolder}/.tmp.env",
                        "isBackground": false
                    }
                ]
            }
            ```

        2. 修改 launch.json：

            ```json
            {
                "version": "0.2.0",
                "configurations": [
                    {
                        "name": "Python: Debug",
                        "type": "python",
                        "request": "launch",
                        "program": "${file}",
                        "preLaunchTask": "load-env",
                        "envFile": "${workspaceFolder}/.tmp.env"
                    }
                ]
            }
            ```

* python 中比较 None 时应该使用 is 而不是 ==

* py 中，open file 的不同模式

    * a - 只追加模式

        ```python
        # 只能写入，不能读取
        with open('file.txt', 'a') as f:
            f.write('新内容\n')  # ok, 可以写入
            content = f.read()   # error, 会出错，不能读取
        ```

    * a+ - 追加和读取模式

        ```python
        # 可以读取和写入
        with open('file.txt', 'a+') as f:
            f.write('新内容\n')  # ✅ 可以写入
            
            # 读取前需要移动文件指针
            f.seek(0)  # 将指针移动到文件开头
            content = f.read()  # ✅ 可以读取
        ```

    * a 和 a+ 都可以在文件不存在时自动创建文件

    * 各种文件打开模式对比

        模式	描述	文件不存在时	可读	可写	指针位置
        r	只读	报错	✅	❌	开头
        r+	读写	报错	✅	✅	开头
        w	只写	创建	❌	✅	开头（清空内容）
        w+	读写	创建	✅	✅	开头（清空内容）
        a	追加	创建	❌	✅	末尾
        a+	追加读	创建	✅	✅	末尾（写），可移动（读）
        x	创建	创建，存在则报错	❌	✅	开头

    * 显式创建文件可以使用 x 模式（独占创建）

        ```python
        try:
            with open('new_file.txt', 'x') as f:
                f.write('创建新文件\n')
        except FileExistsError:
            print("文件已存在")
        ```

    * w 模式

        ```python
        # 如果文件存在会清空内容，不存在则创建
        with open('file.txt', 'w') as f:
            f.write('新内容\n')
        ```

    * 使用 pathlib（推荐）

        ```python
        from pathlib import Path

        # 创建空文件
        Path('new_file.txt').touch()

        # 创建并写入内容
        Path('new_file.txt').write_text('文件内容')
        ```

* 使用 a+ 打开文件时，读取是发生在文件末尾，需要移动指针到开头才能读取，写入时自动回到末尾

    （如果把指针放到文件头后，再追加写入，此时指针是在头还是在尾？猜测仍在末尾）

    这种设计保证了追加模式的核心特性：不会意外覆盖现有内容

* python 访问全局变量

    使用 global 关键字：

    ```python
    aaa = "我是全局变量"  # 全局变量

    def my_function(aaa):
        print("形参 aaa:", aaa)           # 访问形参
        print("全局变量 aaa:", globals()['aaa'])  # 方法1：使用 globals()
        
        # 或者先声明 global
        global aaa
        print("全局变量 aaa:", aaa)        # 方法2：使用 global 关键字

    my_function("我是形参")
    ```

    注意：在 Python 中，如果函数内部有同名的形参或局部变量，直接使用 global aaa 会有冲突。推荐使用 globals()['aaa']。

* c++ 访问全局变量

    使用作用域解析运算符 ::：

    ```cpp
    #include <iostream>
    using namespace std;

    string aaa = "我是全局变量";  // 全局变量

    void myFunction(string aaa) {
        cout << "形参 aaa: " << aaa << endl;        // 访问形参
        cout << "全局变量 aaa: " << ::aaa << endl;   // 使用 :: 访问全局变量
    }

    int main() {
        myFunction("我是形参");
        return 0;
    }
    ```
