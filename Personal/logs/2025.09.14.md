* `dma_map_single()`

    为一次 DMA 传输做准备，将一块 CPU 可访问的内存区域映射到设备可以访问的 DMA 地址空间。

    syntax:

    ```c
    #include <linux/dma-mapping.h>

    dma_addr_t dma_map_single(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir);

    void dma_unmap_single(struct device *dev, dma_addr_t dma_handle, size_t size, enum dma_data_direction dir);
    ```

    parameters:

    * `dev`: 指向设备结构体的指针。这个指针包含了DMA映射操作所需的硬件信息，例如设备所在的总线地址空间限制、是否具有IOMMU等。

    * `ptr`: 需要映射的内核虚拟地址。这通常是通过`kmalloc()`等内核函数分配的内存块的起始地址。

    * `size`: 需要映射的内存区域的大小（以字节为单位）。

    * `dir`: DMA 数据传输的方向。这是一个枚举类型，决定了内核如何处理缓存一致性。其取值通常为：

        * `DMA_TO_DEVICE`：数据从内存传输到设备（写操作）。

        * `DMA_FROM_DEVICE`：数据从设备传输到内存（读操作）。

        * `DMA_BIDIRECTIONAL`：数据可能双向传输。

        * `DMA_NONE`：仅用于调试，表明方向未知。

    返回值

    成功时返回映射后的`dma_addr_t` DMA 地址（总线地址）。

    如果映射失败（例如，参数无效或地址无法映射），函数可能会返回一个特殊的“错误”DMA地址（具体实现可能不同），或者在某些配置下触发BUG。

    CPU 访问内存使用的是虚拟地址（Virtual Address），经过 MMU（内存管理单元）转换后得到物理地址。而 DMA 设备通常工作在物理地址层面，但它看到的“物理地址”（我们称之为总线地址，Bus Address）有可能与 CPU 看到的物理地址不同（尤其是在有 IOMMU 的系统中）。

    `dma_map_single()`主要解决两个问题：

    1. 内地映射：将 cpu 使用的 va 和 dma handle 进行映射。cpu 使用的 va 由 kmalloc() 得到

    2. 维护缓存一致性

        * 对于设备要读取的内存（`DMA_FROM_DEVICE`），dma_map_single() 会刷洗（Flush）CPU Cache，确保设备读到的是内存中最新的数据。

        * 对于设备要写入的内存（`DMA_TO_DEVICE`），dma_map_single() 可能会作废（Invalidate）CPU Cache，确保设备写完后，CPU 下次读取时能从内存获取新数据，而不是旧的缓存数据。

    典型使用流程

    一个典型的 DMA 传输流程中，该函数的使用如下：

    1. 分配内存：使用 kmalloc() 等函数分配一块用于 DMA 缓冲区的内存。

    2. 准备数据：（如果是输出）CPU 将需要传输的数据填充到这块内存中。

    3. 映射：调用 dma_map_single(dev, addr, size, direction)。

        * dev：指向设备结构体的指针。

        * addr：第一步分配的内存的内核虚拟地址。

        * size：缓冲区大小。

        * direction：数据传输方向（如 DMA_TO_DEVICE, DMA_FROM_DEVICE, DMA_BIDIRECTIONAL）。

    4. 获取 DMA 地址：函数返回一个 dma_addr_t 类型的 DMA 地址。将这个地址写入设备的 DMA 控制器寄存器。

    5. 启动传输：通知设备可以从/向给定的 DMA 地址开始传输数据。

    6. 传输完成：设备产生中断，通知 CPU 传输完成。

    7. 解除映射：调用 dma_unmap_single() 解除映射。这会再次处理缓存一致性问题，并使得这块内存的映射关系失效。

    example:

    ```c
    // 必要的内核头文件
    #include <linux/kernel.h>
    #include <linux/module.h>
    #include <linux/init.h>

    // 设备模型相关
    #include <linux/device.h>       // 定义 struct device
    #include <linux/platform_device.h> // 如果是平台设备

    // DMA API 相关
    #include <linux/dma-mapping.h>  // 核心头文件，包含 dma_map_single 等
    // #include <linux/dma-direction.h> // 如果需要，但通常 dma-mapping.h 已包含

    // 其他可能需要的头文件，如用于内存分配的
    #include <linux/slab.h>         // 用于 kmalloc, kfree

    // ... 你的驱动代码 ...
    static int my_driver_dma_transfer(struct device *dev)
    {
        void *cpu_addr;
        dma_addr_t dma_handle;
        size_t size = 1024; // 1KB

        // 1. 分配内存
        cpu_addr = kmalloc(size, GFP_KERNEL);
        if (!cpu_addr)
            return -ENOMEM;

        // 2. 映射内存以用于DMA (传输到设备)
        dma_handle = dma_map_single(dev, cpu_addr, size, DMA_TO_DEVICE);
        if (dma_mapping_error(dev, dma_handle)) { // 推荐错误检查
            kfree(cpu_addr);
            return -ENOMEM;
        }

        // 3. 将 dma_handle 交给设备，启动DMA传输...
        // program_device_to_start_dma(dma_handle);

        // 4. (传输完成后) 解除映射
        // dma_unmap_single(dev, dma_handle, size, DMA_TO_DEVICE);

        // 5. 释放内存
        // kfree(cpu_addr);

        return 0;
    }
    ```

* `dma_mapping_error()`

    在使用 dma_map_single() 时，强烈建议使用 dma_mapping_error() 来检查映射是否成功，而不是直接判断返回值是否为0或NULL（因为DMA地址0可能是一个有效的物理地址）。

    ```c
    dma_addr_t dma_handle;
    dma_handle = dma_map_single(dev, ptr, size, dir);
    if (dma_mapping_error(dev, dma_handle)) {
        // 映射失败，处理错误
        return -ENOMEM; // 或其它错误码
    }
    // 映射成功，继续使用 dma_handle
    ```

* 网状知识结构

    有时候读 resource 可能会不理解概念，提出问题，但是这个问题可能会在 resource 的后面得到解答。这是否暗示知识体系必须是网状结构，才能理解复杂的概念网？

    阅读 resource 是一个以时间为轴的过程，而构建网状知识是一个以空间为轴的过程，说明用空间可以解决时间的前后依赖问题。

* `dma_alloc_coherent()`与`dma_map_single()`的区别

    dma_alloc_coherent() 用于“静态”或“长期”的共享缓冲区，而 dma_map_single() 用于“动态”或“短期”的流式DMA传输。

    `dma_alloc_coherent()`会配置这块内存为 uncacheable（不可缓存）来实现缓存一致性，代价是性能下降。通常只能分配较小的、物理连续的内存块（例如最多几个MB）（为什么？）
    
    dma_map_single() + kmalloc() 是流式映射，将一块普通的、由CPU高效使用的缓存内存，临时映射给设备用于一次DMA传输。传输完成后立即解除映射。一致性由软件（内核）在映射/解除映射时维护。适合大块内存。dma_map_single -> Flush Cache, dma_unmap_single -> Invalidate Cache.

    对于流式 dma，在 dma map 之后，dma unmap 之前，可能会有缓存不一致的情况。

* 缓存维护操作（Cache Flushing/Invalidating）

* `devm_ioremap_resource()`

    将一个设备（通常是硬件外设）的物理内存地址区域（例如寄存器组）映射到内核的虚拟地址空间，并自动管理该映射的生命周期。

    syntax:

    ```c
    #include <linux/device.h>   // 提供 struct device 的定义
    #include <linux/io.h>       // 提供 __iomem、IORESOURCE_MEM 等定义和函数声明

    void __iomem *devm_ioremap_resource(struct device *dev, const struct resource *res);
    ```

    params:

    * `struct device *dev`: 指向申请该资源映射的设备结构体的指针。这通常由平台驱动框架自动提供（例如在 probe 函数中，&pdev->dev）。

    * `const struct resource *res`: 指向要映射的硬件资源（resource 结构体）的指针。这个资源通常通过 platform_get_resource() 等函数从平台设备信息中获取。

    返回值：

    * 成功: 返回一个指向映射后内核虚拟地址空间的指针（void __iomem * 类型）。驱动程序后续通过此指针（配合 readl/writel 等函数）来访问硬件寄存器。

    * 失败: 返回 ERR_PTR(...)，即一个封装了错误码的指针。需要使用 IS_ERR() 和 PTR_ERR() 来检查和获取错误信息。

    example:

    ```c
    #include <linux/device.h>
    #include <linux/io.h>
    #include <linux/platform_device.h> // 用于 platform_get_resource

    struct my_private_data {
        void __iomem *reg_base;
    };

    static int my_driver_probe(struct platform_device *pdev)
    {
        struct device *dev = &pdev->dev;
        struct resource *res;
        struct my_private_data *priv;

        // 从平台设备获取内存资源（索引0）
        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
        if (!res) {
            dev_err(dev, "Failed to get MEM resource\n");
            return -EINVAL;
        }

        // 申请设备私有数据
        priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
        if (!priv)
            return -ENOMEM;

        // 核心步骤：映射设备的寄存器区域
        priv->reg_base = devm_ioremap_resource(dev, res);
        if (IS_ERR(priv->reg_base)) {
            dev_err(dev, "Failed to ioremap region\n");
            return PTR_ERR(priv->reg_base);
        }

        // 将私有数据存储到设备结构体中
        platform_set_drvdata(pdev, priv);

        // ... 后续的硬件初始化、中断注册等操作 ...
        // 可以通过 priv->reg_base 来访问寄存器，例如：
        // writel(0x12345678, priv->reg_base + SOME_REG_OFFSET);

        return 0;
    }
    // 注意：不需要在 remove 函数中手动 iounmap，devm_ 机制会自动处理。
    ```

* RAII (Resource Acquisition Is Initialization)，即资源获取即初始化，或者说利用对象的生命周期来自动管理资源。

* `gcc main.c -Wl,-rpath,'$ORIGIN/../libs'`

    $ORIGIN 是一个特殊的变量，它在运行时会被解析为可执行文件（ELF文件）自身所在的目录的绝对路径。

    命令中是`-Wl,-rpath,'$ORIGIN/../libs‘`。使用单引号（`'`） 至关重要，因为它防止 Shell（如 bash）在命令执行前就解释 $ORIGIN。我们需要将字面意义上的 $ORIGIN 这个字符串传递给链接器，并最终写入可执行文件，而不是在编译时就被 Shell 替换成某个值（如果 $ORIGIN 这个 Shell 变量未定义，它会被替换成空字符串）。

    -Wl,-rpath,'$ORIGIN/../libs’ 创建了一种可重定位（Relocatable） 的部署方案。只要可执行文件和 libs 文件夹的相对位置不变（例如，整个项目文件夹被移动到其他位置），程序就总能找到它依赖的库，无需手动设置 LD_LIBRARY_PATH。因为搜索路径是程序自身的一部分，不依赖于用户如何设置环境变量。这对于分发和部署程序非常有用，可以确保程序总能找到它自带的库。

* `at`

    安排一个任务在未来的某个特定时间点执行一次。

    ubuntu 系统中默认不安装`at`，需要手动安装：`sudo apt install at`

    syntax:

    ```bash
    at [选项] <时间设定>
    ```

    常用选项：

    * `-f <文件>`：从指定的文件中读取要执行的命令，而不是交互式输入。

        示例： `at -f /path/to/script.sh 10:00 AM`

    * `-l`：列出当前用户的所有待处理作业（等同于 atq 命令）。

        示例： at -l

    * `-r <作业ID>`或`-d <作业ID>`：删除一个指定的待处理作业（等同于 atrm 命令）。

        示例： at -r 5 (删除作业ID为5的任务)

    * `-m`：即使命令没有输出，也在任务完成后给用户发送邮件。

    * `-M`：即使命令有输出，也不给用户发送邮件。

    * `-t <时间>`：使用`[[CC]YY]MMDDhhmm[.ss]`格式指定时间（较不常用）。

        示例： `at -t 202507191430.00 (2025年7月19日14点30分00秒)`

    * `-v`：显示任务将被执行的时间，而不是仅仅将任务排入队列。

    * 时间设定

        * 简单时间格式：

            HH:MM - 在今天的指定时间执行。如果该时间已过，则顺延到明天。

                示例： at 14:30

            midnight, noon, teatime (通常是下午4点) - 使用预定义的单词。

        * 相对时间格式：

            now + <数量> <时间单位> - 从现在开始的一段时间后执行。

                时间单位： minutes, hours, days, weeks

                示例：

                    at now + 10 minutes (10分钟后)

                    at now + 2 hours (2小时后)

                    at now + 1 week (1周后)

        * 绝对时间格式：

            MMDDYY, MM/DD/YY, DD.MM.YY - 指定具体日期。

                示例：

                    at 11:00 PM 072025 (2025年7月20日晚上11点)

                    at 10am Jul 20 (7月20日上午10点)

                    at 2:00 tomorrow (明天凌晨2点)

        * 组合日期和时间：

            你可以将日期和时间组合起来。

                示例： at 3:30 PM next Friday (下周五下午3点半)

    example:

    * `at now + 10 minutes` (10分钟后)

    * `at 11:00 PM` (今晚11点)

    * `at 2:00 tomorrow` (明天凌晨2点)

    * `at 10:00 Jul 20` (7月20日上午10点)

    标准输入/交互式输入：通常你直接运行 at <TIME>，然后在其提示符下输入要执行的命令，按 Ctrl+D 结束输入。

    从文件读取：也可以使用 at -f script.sh <TIME> 来指定一个脚本文件在特定时间运行。

    examples:

    * 安排一个简单任务

        ```bash
        # 安排一个任务在下午2：30执行
        at 2:30 PM
        # 进入at提示符后，输入命令：
        at> echo "Hello from the past!" > ~/reminder.txt
        # 输入完毕后，按 Ctrl+D 来保存任务
        ```

    * 安排一个不久后的任务

        ```bash
        # 安排一个20分钟后的任务
        at now + 20 minutes
        at> shutdown -h now # 例如：20分钟后关机
        at> <EOT> # 按 Ctrl+D
        ```

    * 非交互模式

        ```bash
        # 将一个脚本文件中的命令安排在下午5点执行
        $ at -f /path/to/daily_cleanup.sh 5:00 PM
        job 7 at Tue Jul 18 17:00:00 2025
        ```

    * 使用管道（echo）

        ```bash
        # 通过管道将命令传递给at
        $ echo "shutdown -h now" | at now + 30 minutes
        job 8 at Tue Jul 18 15:45:00 2025
        ```

    `atq`：列出当前用户所有等待执行的 at 任务队列（root用户可以看到所有任务）。

    `atrm <job_id>`：删除一个已排队的 at 任务。例如 atrm 3 会删除作业编号为3的任务。

    注意事项:

    * 守护进程：at 命令的运行依赖于 atd 这个守护进程。请确保它正在运行（通常通过 systemctl status atd 检查）。

    * 执行环境：at 任务会在一个几乎最小化的 shell 环境中运行，只继承少量环境变量（如TERM, PATH, SHELL等）。如果你的命令依赖于特定的环境变量（如DISPLAY用于图形界面），可能需要在其内部重新设置。

    * 输出处理：任务的标准输出和标准错误默认会通过电子邮件发送给任务所有者（即安排任务的用户）。为了避免收邮件，最好在命令中明确重定向输出（如 >/dev/null 2>&1 或重定向到日志文件）。

    `at`命令中的时间指示符（如 AM, PM, tomorrow, midnight 等）是大小写不敏感的（case insensitive）。

    在交互环境中输入命令时，无法使用 tab 自动补全（比如文件名，目录下的文件等）。

    `at`指定的 command 执行后，无法随时中止，必须等 command 结束。

* 8259A

    8259A是一款可编程中断控制器。

    主要功能：

    * 中断请求的接收与优先级裁决

        * 8259A 拥有 8 条中断请求输入线（IRQ0-IRQ7），可以连接多个外部设备（如键盘、鼠标、定时器、硬盘控制器等）。

        * 当多个设备同时发出中断请求时，8259A 会根据预先设定的优先级规则（默认IRQ0最高，IRQ7最低）进行裁决，选出当前最重要的请求上报给CPU。

    * 向CPU发送中断信号

        * 裁决出最高优先级的中断后，8259A 会通过INT（Interrupt Request）引脚向CPU发出中断信号。

        * CPU响应后，会通过 INTA（Interrupt Acknowledge）引脚回送应答信号。

    * 提供中断类型码（中断向量）

        * 这是 8259A 最关键的功能之一。在 CPU 响应中断并查询中断来源时，8259A 会向数据总线提供一个8位的中断类型码。

        * CPU 根据这个号码，在中断向量表中找到对应中断服务程序的入口地址，从而跳转到正确的程序去执行。这意味着硬件中断源与软件处理程序通过8259A关联了起来。

    * 中断的屏蔽与管理

        * 可以通过编程设置中断屏蔽寄存器（IMR），单独允许或禁止（屏蔽）某个IRQ引脚上的中断请求，提供了灵活的中断管理能力。

        * 支持多种中断触发模式（如边沿触发、电平触发）和优先级循环模式等。

    * 级联扩展

        * 一片 8259A 只能管理 8 级中断。通过将多片 8259A 进行主从级联，可以扩展中断数量。例如，在 IBM PC/AT 中，使用一片主 8259A 和一片从 8259A，共同管理了 15 个硬件中断（IRQ0-IRQ15）。

* `g++ *.o main.cpp -o main`在 makefile 中的问题

    ```makefile
    main: *.o main.cpp
        g++ *.o main.cpp -o main
    ```

    存在的问题：

    1. command 中的`*.o`会作为 bash 命令展开，如果当前目录没有`.o`结尾的文件，那么会报错

        example:

        ```
        (base) hlc@hlc-VirtualBox:~$ ls *.aaa
        ls: cannot access '*.aaa': No such file or directory
        (base) hlc@hlc-VirtualBox:~$ echo $?
        2
        (base) hlc@hlc-VirtualBox:~$ touch b.aaa
        (base) hlc@hlc-VirtualBox:~$ ls *.aaa
        b.aaa
        (base) hlc@hlc-VirtualBox:~$ echo $?
        0
        ```

    1. target dependency 中的`*.o`会在 makefile 规则分析时展开，由于并没有`*.o`文件的 target，所以触发 makefile 的隐式规则，使用`g++ -c xxx.cpp -o xxx.o`生成`.o`文件。

        注意此时不会生成`g++ -c main.cpp -o main.o`文件。

        ```makefile
        all: main

        main: *.o main.cpp
        	g++ *.o main.cpp -o main

        clean:
        	rm -f *.o main
        ```

        project dir:

        ```
        (base) hlc@hlc-VirtualBox:~/Documents/Projects/makefile_test$ ls
        lib.cpp  lib.h  main.cpp  Makefile
        (base) hlc@hlc-VirtualBox:~/Documents/Projects/makefile_test$ make
        g++    -c -o *.o lib.cpp
        g++ *.o main.cpp -o main
        (base) hlc@hlc-VirtualBox:~/Documents/Projects/makefile_test$ ls
         lib.cpp   lib.h   main   main.cpp   Makefile  '*.o'
        ```

    1. makefile 的内置隐含规则会生成`'*.o'`文件

        make 的隐含规则为：

        ```makefile
        # Make内置的隐含规则（近似于）
        %.o: %.cpp
            $(CXX) $(CXXFLAGS) -c $< -o $@
        ```

        检测到`*.o`不存在，会执行：

        `g++ -c -o *.o *.cpp`

        根据 bash 的规则，`*.cpp`会展开为`lib.cpp`，而`-o *.o`保持 raw string，因此生成的文件也叫`'*.o'`。Shell只在命令参数中展开通配符，不在选项参数中展开。

* ibus 中，ctrl + / 可以改变词组上屏方式（直接上屏 / 按空格上屏）

* 平时还是把输入法归位到英文语言比较好，因为如果默读使用中文输入法，而切换到其他窗口又是中文状态，那么按快捷键会失效，或者类似于在游戏界面弹出中文候选框输入一堆中文。

* `readelf`的用法

    用于显示关于 ELF (Executable and Linkable Format) 格式目标文件的信息。

    ELF 是现代 Linux 系统上的一种文件格式，用于：

    * 可执行文件 (例如编译生成的`a.out`)

    * 共享库 (例如：libc.so.6)

    * 目标文件 (例如：file.o)

    * 核心转储文件 (core dumps)

    常用选项：

    * 查看文件头 (`-h`)

        这是最常用的选项之一。它显示了 ELF 文件的概要信息，包括：

        * 文件类型（可执行文件、共享库、目标文件等）

        * 目标机器的体系结构（如 x86-64, ARM）

        * 程序的入口点地址（Entry point）

        * 程序头表（Program Headers）和节头表（Section Headers）的起始位置和大小。

    * 查看节头信息 (`-S`)

        显示文件中所有的 “节” (Sections) 的信息。节是 ELF 文件的重要组成部分，例如：

        * `.text`： 存放可执行代码。

        * `.data`： 存放已初始化的全局变量和静态变量。

        * `.bss`： 存放未初始化的全局变量和静态变量。

        * `.rodata`： 存放只读数据（如字符串常量）。

        * `.symtab`： 符号表。

        * `.strtab`： 字符串表。

    * 查看程序头信息 (`-l`)

        显示 “段” (Segments) 或称为 程序头 (Program Headers) 的信息。段告诉操作系统或动态链接器如何将文件加载到内存中并执行。这对于理解程序运行时布局至关重要。

    * 查看符号表 (`-s`)

        显示文件中定义和引用的所有符号，如函数名、变量名。这对于解决“未定义引用”等链接错误非常有用。

    * 查看动态段信息 (`-d`)

        对于动态链接的可执行文件或共享库，此选项显示其依赖的共享库（如 libc.so.6）以及动态链接器需要的其他信息（如重定位信息、符号表地址等）。

    * 查看重定位信息 (`-r`)

        显示文件中需要重定位的条目信息，这在分析目标文件(.o)时尤其有用。

    * 查看节的内容 (`-x` 或 `-p`)

        以十六进制或其他格式转储指定节的具体内容。

    example:

    `readelf -h main`

    output:

    ```
    ELF Header:
      Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
      Class:                             ELF64
      Data:                              2's complement, little endian
      Version:                           1 (current)
      OS/ABI:                            UNIX - System V
      ABI Version:                       0
      Type:                              DYN (Position-Independent Executable file)
      Machine:                           Advanced Micro Devices X86-64
      Version:                           0x1
      Entry point address:               0x1060
      Start of program headers:          64 (bytes into file)
      Start of section headers:          14048 (bytes into file)
      Flags:                             0x0
      Size of this header:               64 (bytes)
      Size of program headers:           56 (bytes)
      Number of program headers:         13
      Size of section headers:           64 (bytes)
      Number of section headers:         31
      Section header string table index: 30
    ```

* 映射

    假如将世界作为一个复杂系统 W，是否存在另一个复杂系统 B，W 中发生的事 E，经过某种信号处理方式后，传递到 B，在 B 中会有相应的区域 A 被激活，表示事 E 发生。

    有点像世界模型，也有点像盗墓笔记中的张家古楼铜镜，所有人被缩小在镜子的影像里。

    系统 B 可以根据激活的 A 区域，继续去推演。

* epoll

    epoll 是 Linux 系统上一种高效的多路复用 I/O 机制，用于同时监控大量的文件描述符（如网络套接字），看它们是否可读、可写或出现异常。它非常适合处理高并发网络服务器。

    与其不断地轮询所有连接（像 select/poll 那样），epoll 采用了“事件通知”的方式。当内核检测到某个被监控的描述符就绪时，它会通知应用程序，从而避免了无效的检查。

    使用 epoll 的方法：

    1. 创建一个 epoll 实例 (epoll_create)

        ```c
        int epfd = epoll_create1(0); // 参数通常传0
        ```

        `epfd`是一个文件描述符，代表这个 epoll 实例。后续所有操作都要用到它。

    2. 管理 epoll 监控列表 (epoll_ctl)

        通过 epoll_ctl 向这个实例（epfd）中添加、修改或删除需要监控的文件描述符。

        ```c
        // 添加一个 socket fd 到监控列表中，关注其可读事件
        struct epoll_event event;
        event.events = EPOLLIN; // 监控可读事件
        event.data.fd = sockfd; // 当事件发生时，我们知道是哪个fd触发的

        epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &event);
        ```

        * `EPOLL_CTL_ADD`: 添加

        * `EPOLL_CTL_MOD`: 修改

        * `EPOLL_CTL_DEL`: 删除

        events 常用标志：

        * EPOLLIN: 文件描述符可读（有数据到来）

        * EPOLLOUT: 文件描述符可写

        * EPOLLET: 设置为边缘触发（Edge-Triggered）模式（默认为水平触发 Level-Triggered）

    3. 等待事件发生 (epoll_wait)

        调用 epoll_wait 来等待事件发生。这个函数会阻塞，直到有一个或多个被监控的描述符就绪。

        ```c
        #define MAX_EVENTS 10
        struct epoll_event events[MAX_EVENTS];

        // 等待事件发生，超时时间设为 -1 表示一直阻塞
        int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);

        // 处理所有就绪的事件
        for (int i = 0; i < nfds; i++) {
            if (events[i].events & EPOLLIN) { // 如果是可读事件
                int ready_fd = events[i].data.fd;
                // 对这个 ready_fd 进行读操作（如 recv, accept）
            }
            // 可以检查其他事件，如 EPOLLOUT
        }
        ```

        * epoll_wait 返回就绪的事件数量 nfds。

        * 事件数组 events 会被填充，我们可以遍历这个数组来处理所有就绪的 I/O 操作。

* epoll 的两种工作模式

    1. 水平触发 (Level-Triggered, LT) (默认模式)

        条件满足就持续通知：只要一个文件描述符还有数据可读，每次调用 epoll_wait 都会返回它的事件。

        优点：编码简单，不容易遗漏事件。

        注意：如果不读完数据，会一直被通知。

    2. 边缘触发 (Edge-Triggered, ET)

        状态变化时只通知一次：只有当文件描述符从不可读变为可读（即新数据到来）时，才会收到一次通知。

        优点：性能更高，减少了事件被重复触发的次数。

        要求：必须使用非阻塞 I/O，并且必须一次性把缓冲区里的数据全部读完（直到 read 返回 EAGAIN 错误），否则可能会永远丢失这次事件。

* epoll examples

    1. example 1

        ```c
        // 1. 创建 socket，bind，listen
        int listen_sock = setup_listening_socket();

        // 2. 创建 epoll 实例
        int epfd = epoll_create1(0);

        // 3. 将监听 socket 添加到 epoll，关注其可读事件（有新连接）
        struct epoll_event event;
        event.events = EPOLLIN;
        event.data.fd = listen_sock;
        epoll_ctl(epfd, EPOLL_CTL_ADD, listen_sock, &event);

        while (1) {
            // 4. 等待事件
            struct epoll_event events[MAX_EVENTS];
            int n = epoll_wait(epfd, events, MAX_EVENTS, -1);

            for (int i = 0; i < n; i++) {
                // 5. 处理事件
                if (events[i].data.fd == listen_sock) {
                    // 监听socket可读，说明有新连接到来
                    int conn_sock = accept(listen_sock, ...);
                    // 将新连接的 socket 也加入 epoll 监控
                    set_nonblocking(conn_sock); // ET模式必须设为非阻塞
                    event.events = EPOLLIN | EPOLLET; // 使用ET模式
                    event.data.fd = conn_sock;
                    epoll_ctl(epfd, EPOLL_CTL_ADD, conn_sock, &event);
                } else {
                    // 普通客户端socket可读，进行数据读写
                    handle_connection(events[i].data.fd);
                }
            }
        }
        ```

    2. example 2

        一个完整的、可编译运行的 epoll 示例，它是一个简单的回显（Echo）服务器。

        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        #include <arpa/inet.h>
        #include <sys/socket.h>
        #include <sys/epoll.h>
        #include <fcntl.h>
        #include <errno.h>

        #define PORT 8080
        #define MAX_EVENTS 10
        #define BUFFER_SIZE 1024

        // 设置文件描述符为非阻塞模式
        void set_nonblocking(int fd) {
            int flags = fcntl(fd, F_GETFL, 0);
            fcntl(fd, F_SETFL, flags | O_NONBLOCK);
        }

        // 创建监听socket
        int create_listen_socket() {
            int listen_fd;
            struct sockaddr_in server_addr;

            // 创建socket
            if ((listen_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                perror("socket");
                exit(EXIT_FAILURE);
            }

            // 设置SO_REUSEADDR选项
            int opt = 1;
            if (setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {
                perror("setsockopt");
                close(listen_fd);
                exit(EXIT_FAILURE);
            }

            // 绑定地址
            server_addr.sin_family = AF_INET;
            server_addr.sin_addr.s_addr = INADDR_ANY;
            server_addr.sin_port = htons(PORT);

            if (bind(listen_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
                perror("bind");
                close(listen_fd);
                exit(EXIT_FAILURE);
            }

            // 开始监听
            if (listen(listen_fd, SOMAXCONN) == -1) {
                perror("listen");
                close(listen_fd);
                exit(EXIT_FAILURE);
            }

            printf("Server listening on port %d...\n", PORT);
            return listen_fd;
        }

        // 处理客户端连接
        void handle_client(int client_fd) {
            char buffer[BUFFER_SIZE];
            ssize_t bytes_read;

            // 读取数据
            while ((bytes_read = read(client_fd, buffer, BUFFER_SIZE - 1)) > 0) {
                buffer[bytes_read] = '\0';
                printf("Received from client %d: %s", client_fd, buffer);
                
                // 回显数据
                if (write(client_fd, buffer, bytes_read) == -1) {
                    perror("write");
                    break;
                }
            }

            // 客户端断开连接或读取出错
            if (bytes_read == 0) {
                printf("Client %d disconnected\n", client_fd);
            } else if (bytes_read == -1) {
                if (errno != EAGAIN && errno != EWOULDBLOCK) {
                    perror("read");
                }
            }
        }

        int main() {
            int listen_fd, epoll_fd;
            struct epoll_event event, events[MAX_EVENTS];

            // 创建监听socket
            listen_fd = create_listen_socket();

            // 创建epoll实例
            if ((epoll_fd = epoll_create1(0)) == -1) {
                perror("epoll_create1");
                close(listen_fd);
                exit(EXIT_FAILURE);
            }

            // 添加监听socket到epoll，关注可读事件
            event.events = EPOLLIN;
            event.data.fd = listen_fd;
            if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &event) == -1) {
                perror("epoll_ctl");
                close(listen_fd);
                close(epoll_fd);
                exit(EXIT_FAILURE);
            }

            printf("Epoll server started. Waiting for connections...\n");

            while (1) {
                // 等待事件发生
                int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
                if (nfds == -1) {
                    perror("epoll_wait");
                    break;
                }

                // 处理所有就绪的事件
                for (int i = 0; i < nfds; i++) {
                    // 有新连接到来
                    if (events[i].data.fd == listen_fd) {
                        struct sockaddr_in client_addr;
                        socklen_t client_len = sizeof(client_addr);
                        int client_fd;

                        // 接受新连接
                        client_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_len);
                        if (client_fd == -1) {
                            perror("accept");
                            continue;
                        }

                        // 设置客户端socket为非阻塞模式
                        set_nonblocking(client_fd);

                        // 添加客户端socket到epoll，关注可读事件（使用边缘触发模式）
                        event.events = EPOLLIN | EPOLLET;
                        event.data.fd = client_fd;
                        if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &event) == -1) {
                            perror("epoll_ctl");
                            close(client_fd);
                            continue;
                        }

                        printf("New client connected: %d\n", client_fd);

                    } 
                    // 客户端socket可读
                    else if (events[i].events & EPOLLIN) {
                        handle_client(events[i].data.fd);
                        
                        // 注意：在实际应用中，你可能需要更复杂的连接管理
                        // 这里简单处理，读取完成后就关闭连接
                        printf("Closing connection for client %d\n", events[i].data.fd);
                        close(events[i].data.fd);
                    }
                }
            }

            // 清理资源
            close(listen_fd);
            close(epoll_fd);
            return 0;
        }
        ```

        compile: `gcc -o epoll_server epoll_server.c`

        run: `./epoll_server`

        test:

        ```bash
        # 使用 telnet 测试
        telnet localhost 8080

        # 或者使用 netcat
        nc localhost 8080

        # 或者使用多个终端同时连接测试
        ```

        输入一些文字，服务器会回显你输入的内容

* select / poll 底层机制并不是轮询（Busy Polling），只有在处理事件 fd 时才是线性查找

* Proteus prn. [ˈprotiəs, -ˌtjus] n. 希腊海神

* Pytorch - Index-based Operation

    * `index_add_()`

        Adds the given tensor elements to the self tensor along the order given in the matrix.

        syntax:

        ```py
        index_add_(dim, index, tensor) ---> Tensor
        ```

        params:

        * dim: dimension along which index to add. '0' stands for column and '1' stands for row.

        * index: indices of the tensor to select from. It can be LongTensor or IntTensor.

        * tensor: tensor containing the values to add.

        example:

        ```py
        import torch

        x = torch.zeros(5,5)
        te = torch.tensor([[1,3,5,7,9], [1,3,5,7,9], [1,3,5,7,9]], dtype=torch.float32)
        print('te shape: {}\n'.format(te.shape))
        index0 = torch.tensor([0, 2, 4])

        x.index_add_(0, index0, te) #adding tensor te to x along row of the given order
        print('x:\n{}'.format(x))
        ```

        output:

        ```
        te shape: torch.Size([3, 5])

        x:
        tensor([[1., 3., 5., 7., 9.],
                [0., 0., 0., 0., 0.],
                [1., 3., 5., 7., 9.],
                [0., 0., 0., 0., 0.],
                [1., 3., 5., 7., 9.]])
        ```

        可以看出，是让`te`中的三行数据分别叠加到`x`的`[0, 2, 4]`行上。

        example 2:

        ```py
        import torch

        y = torch.ones(5, 5) # unit vector
        index2 = torch.tensor([0, 1, 1, 1, 2])
        ten = torch.randn(1, 5)

        # adding values to y along the column with given order
        y.index_add_(1, index2, ten)
        print('y is: {}'.format(y))
        ```

        output:

        ```
        Traceback (most recent call last):
          File "/home/hlc/Documents/Projects/torch_test/main.py", line 8, in <module>
            y.index_add_(1, index2, ten)
        RuntimeError: source tensor shape must match self tensor shape, excluding the specified dimension. Got self.shape = [5, 5] source.shape = [1, 5]
        ```

        可以看出并没有发生 broadcasting。

        可以改成这样：

        ```py
        import torch

        y = torch.ones(5,5) # unit vector
        index2 = torch.tensor([0, 1, 1, 1, 2])
        ten = torch.randn(1, 5)
        ten = ten.expand(5, 5)
        print('ten is: {}'.format(ten))

        # adding values to y along the column with given order
        y.index_add_(1, index2, ten)
        print('y is: {}'.format(y))
        ```

        output:

        ```
        ten is: tensor([[ 0.1083, -0.3369, -0.7591, -0.2532, -0.4060],
                [ 0.1083, -0.3369, -0.7591, -0.2532, -0.4060],
                [ 0.1083, -0.3369, -0.7591, -0.2532, -0.4060],
                [ 0.1083, -0.3369, -0.7591, -0.2532, -0.4060],
                [ 0.1083, -0.3369, -0.7591, -0.2532, -0.4060]])
        y is: tensor([[ 1.1083, -0.3493,  0.5940,  1.0000,  1.0000],
                [ 1.1083, -0.3493,  0.5940,  1.0000,  1.0000],
                [ 1.1083, -0.3493,  0.5940,  1.0000,  1.0000],
                [ 1.1083, -0.3493,  0.5940,  1.0000,  1.0000],
                [ 1.1083, -0.3493,  0.5940,  1.0000,  1.0000]])
        ```

        可以看出，`[0, 1, 1, 1, 2]`表示将`ten`中的五列分别叠加到`y`的第 0, 1, 1, 1, 2 列。

* 目前是 AI 烧钱阶段，基本没有广告，后面肯定要给大模型植入广告，就像视频网站的片头广告一样。所以要抓紧时间，用好大模型快速学知识。到后面如果需要看广告才有 AI 回答，那效率就没有现在这么高了。

* `index_add()`

    It is the out-of place version of the function `index_add_()`.

    example:

    ```py
    import torch

    y = torch.ones(5,5)
    index2 = torch.tensor([0,1,1,1,2])
    ten = torch.randn(5,5)

    print("Indexed Matrix:\n",y.index_add(1,index2,ten))
    print ("Printing Indexed Matrix again:\n",y)
    ```

    output:

    ```
    Indexed Matrix:
     tensor([[ 1.1614,  2.1703,  1.5247,  1.0000,  1.0000],
            [-0.2930,  4.1282,  0.3124,  1.0000,  1.0000],
            [ 0.5624,  0.3906,  3.0302,  1.0000,  1.0000],
            [ 1.7235,  2.3990,  2.5070,  1.0000,  1.0000],
            [ 1.9170,  1.0716, -0.3112,  1.0000,  1.0000]])
    Printing Indexed Matrix again:
     tensor([[1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.],
            [1., 1., 1., 1., 1.]])
    ```

    可以看出`index_add()`不修改原 tensor 的数据。

* 大雨

    在剧情的末尾，应该有一场大雨，终止浮躁的人心。大雨浇到路面上，路面被冷却冒起滋滋的蒸汽。大雨整整下了一个秋天，大街上几乎所有的活动都停止了，人们终于回过神来。

* 获取 hugging face 的 imdb 数据集

    ```py
    from datasets import load_dataset
    dataset = load_dataset('imdb')
    print(dataset['train'][0])
    ```

    数据会被下载到`~/.cache/huggingface/datasets`中。imdb 数据集大小为 128 M。

* 不知道干什么也有可能是任务定得太大，不知道从何下手。把任务细化应该会好一点。

* 原以为知乎是理性讨论的，后来发现知乎只是表达欲强的人的聚集地。

* 并不是多想做某个方向，只是怕一直陷在一个方向。