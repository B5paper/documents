* leetcode node: 数组的最大美丽值

    看到这道题，首先想到的暴力解法是用回溯法拿到一个组合，然后计算这个组合中每个数对应的区间，比如`nums[i]`，其对应的区间为`[nums[i] - k, nums[i] + k]`。

    拿到所有的区间后，取交集，若交集存在，那么记录组合的元素个数为`len`，并尝试更新答案：`ans = max(ans, len);`。

    遍历组合时，先从元素个数为 1 的组合开始，然后不断增加元素个数，直到遍历到全集。

    这道题容易让人想到动态规划，因为这个问题其实相当于对于一个区间，我们是否选择把它加进来求交集。关于空位选择，总是让人想到背包问题。而背包问题就是用动态规划解的。

    但是这道题无法用动态规划解决。主要问题是难以找到一个合适的最优子问题。

    假如最优子问题是：若已知以`nums[i]`结尾的数组的解，如何求以`nums[i+1]`结尾的解？我们马上可以举出反例：`nums = [0, 0, 0, 1, 1, 1, 1]`，根据前 3 个元素，永远也无法得知全局的最优解。那么我们能不能以已知`start = nums[i], end = nums[j]`这段数组的解，去求其他子数组的最优解？也不能，比如`[0, 0, 1, 1, 1, 2, 2, 2, 2]`，知道`[nums[2], nums[4]]`的解为 3 对于全局最优解毫无帮助。

    这些想法还算比较常用的，暂时也想不到其他什么动态规划方法了。

    由此我们可以引申出一个问题：同样是树的展开，为什么有的问题可以使用动态规划解决，这种问题就不行？是否在树展开的过程中，某些条件不满足，导致了动态规划无法使用？

* uio driver

    uio 指的是 user space IO，可以在用户态访问设备内存。

    uio 主要通过 sysfs 和`/dev/uioX`和设备进行交互。

    可能会用到的 struct:

    ```cpp
    /**
    * struct uio_info - UIO device capabilities
    * @uio_dev:		the UIO device this info belongs to
    * @name:		device name
    * @version:		device driver version
    * @mem:		list of mappable memory regions, size==0 for end of list
    * @port:		list of port regions, size==0 for end of list
    * @irq:		interrupt number or UIO_IRQ_CUSTOM
    * @irq_flags:		flags for request_irq()
    * @priv:		optional private data
    * @handler:		the device's irq handler
    * @mmap:		mmap operation for this uio device
    * @open:		open operation for this uio device
    * @release:		release operation for this uio device
    * @irqcontrol:		disable/enable irqs when 0/1 is written to /dev/uioX
    */
    struct uio_info {
        struct uio_device	*uio_dev;
        const char		*name;
        const char		*version;
        struct uio_mem		mem[MAX_UIO_MAPS];
        struct uio_port		port[MAX_UIO_PORT_REGIONS];
        long			irq;
        unsigned long		irq_flags;
        void			*priv;
        irqreturn_t (*handler)(int irq, struct uio_info *dev_info);
        int (*mmap)(struct uio_info *info, struct vm_area_struct *vma);
        int (*open)(struct uio_info *info, struct inode *inode);
        int (*release)(struct uio_info *info, struct inode *inode);
        int (*irqcontrol)(struct uio_info *info, s32 irq_on);
    };
    
    /**
    * struct uio_mem - description of a UIO memory region
    * @name:		name of the memory region for identification
    * @addr:               address of the device's memory rounded to page
    * 			size (phys_addr is used since addr can be
    * 			logical, virtual, or physical & phys_addr_t
    * 			should always be large enough to handle any of
    * 			the address types)
    * @offs:               offset of device memory within the page
    * @size:		size of IO (multiple of page size)
    * @memtype:		type of memory addr points to
    * @internal_addr:	ioremap-ped version of addr, for driver internal use
    * @map:		for use by the UIO core only.
    */
    struct uio_mem {
        const char		*name;
        phys_addr_t		addr;
        unsigned long		offs;
        resource_size_t		size;
        int			memtype;
        void __iomem		*internal_addr;
        struct uio_map		*map;
    };
    
    #define MAX_UIO_MAPS	5
    
    struct uio_portio;
    
    /**
    * struct uio_port - description of a UIO port region
    * @name:		name of the port region for identification
    * @start:		start of port region
    * @size:		size of port region
    * @porttype:		type of port (see UIO_PORT_* below)
    * @portio:		for use by the UIO core only.
    */
    struct uio_port {
        const char		*name;
        unsigned long		start;
        unsigned long		size;
        int			porttype;
        struct uio_portio	*portio;
    };
    
    /* defines for uio_mem->memtype */
    #define UIO_MEM_NONE	0
    #define UIO_MEM_PHYS	1
    #define UIO_MEM_LOGICAL	2
    #define UIO_MEM_VIRTUAL 3
    
    /* defines for uio_port->porttype */
    #define UIO_PORT_NONE	0
    #define UIO_PORT_X86	1
    #define UIO_PORT_GPIO	2
    #define UIO_PORT_OTHER	3
    ```

    kernel module driver code:

    ```cpp
    #include <linux/module.h>
    #include <linux/uio_driver.h>
    #include <linux/fs.h>
    #include <linux/miscdevice.h>
    #include <linux/slab.h>
    #include <linux/mm.h>
    #include <linux/vmalloc.h>
    #include <linux/platform_device.h>
    
    #define DRV_NAME "uio_test"
    #define MEM_SIZE 0x1000
    
    /*
    struct uio_info 是 UIO 驱动中定义设备资源的数据结构，也是 UIO 驱动设备的主要参数之一，包括设备名称、设备版本、中断类型、内存映射等信息。
    下面是 struct uio_info 结构体的具体字段：
        const char* name: 设备名称，字符串类型，比如 "uio_mydevice"
        const char* version: 设备版本，字符串类型，比如 "1.01"
        int irq: 设备使用的中断号，中断类型可以是UIO_IRQ_NONE, UIO_IRQ_EDGE, UIO_IRQ_LEVEL。
        int irq_flags: 中断的处理方法
        struct uio_mem* mem: 包含所需的内存资源的数组，可以是多个内存区域，每个内存块包括物理地址start、大小size、权限memtype等信息。
        int memtype: 位于进程地址空间的内存区域的类型。可以是UIO_MEM_PHYS (物理内存)，UIO_MEM_LOGICAL (逻辑内存)，UIO_MEM_VIRTUAL (虚拟内存)。
        void (*irqcontrol)(struct uio_info*, bool): 指向向文件操作提供中断的函数。
        int (*open)(struct uio_info*, struct inode*): 打开设备的函数。
        int (*release)(struct uio_info*, struct inode*): 关闭设备的函数。
        int (*mmap)(struct uio_info*, struct vm_area_struct*): 内存映射的函数。
        int (*ioctl)(struct uio_info*, unsigned int command, unsigned long argument): 设备控制函数。
        int (*irqhandler)(struct uio_info*, int irqs): 中断处理函数，对于需要驱动处理的中断使用。
    */
    static struct uio_info uio_test = {
        .name = "uio_device",
        .version = "0.0.1",
        .irq = UIO_IRQ_NONE,
    };
    
    static void uio_release(struct device *dev)
    {
        struct uio_device *uio_dev = dev_get_drvdata(dev);
        uio_unregister_device(uio_dev->info);
        kfree(uio_dev);
    }
    
    static int uio_mmap(struct file *filp, struct vm_area_struct * vma)
    {
        /*
        vm_area_struct 结构体的主要成员变量如下：
        vm_start：虚拟内存区域的起始地址。
        vm_end：虚拟内存区域的结束地址。
        vm_next：链表中下一个虚拟内存区域的指针。
        vm_flags：虚拟内存区域的标志，用于指定该区域的访问权限、映射方式等信息。
        vm_page_prot：虚拟内存区域对应的物理内存页的保护属性。
        vm_ops：虚拟内存区域的操作函数指针，用于操作该区域的相关操作。
        vm_file：指向该虚拟内存区域对应的文件对象，如果该内存区域没有对应的文件，则为NULL。
        vm_private_data：指向该虚拟内存区域私有数据的指针，可以用于存储和传递一些附加信息。
        vm_area_struct结构体的主要作用是表示进程的虚拟内存空间，并为操作系统内存管理提供了一些必要的信息，
        如虚拟地址范围、保护属性、映射方式等。它也为进程提供了一些操作虚拟内存的接口，如访问、分配、释放等。在进程创建、分配内存、映射文件等操作时，
        都需要使用vm_area_struct结构体来描述进程虚拟内存的状态。
        */
    
        struct uio_info *info = filp->private_data;
        /*virt_to_page()将虚拟地址转换为一个指向相应页面描述符的指针，并使用page_to_pfn()获取该页面描述符对应的页框号*/
        unsigned long pfn = page_to_pfn(virt_to_page(info->mem[0].addr));
        /*PFN_PHYS()将页框号转换为相应的物理地址*/
        unsigned long phys = PFN_PHYS(pfn);
        /*uio_info结构体中第一个内存区域的大小*/
        unsigned long size = info->mem[0].size;
    
        /*
        remap_pfn_range函数用于将一段物理地址空间映射到进程的虚拟地址空间，并返回映射后的虚拟地址。
        vma 是 vm_area_struct 结构体指针，表示进程的一段虚拟地址空间。
        vma->vm_start 表示用户空间地址的起始地址。
        phys >> PAGE_SHIFT 表示设备地址的起始页号。PAGE_SHIFT 表示的是系统页面大小的偏移量，通常为12位（2 ^ 12 = 4KB）。
        这是因为物理地址的低 12 位表示页面的偏移量，需要去除才能得到页面的编号。 
        size 表示映射空间的大小。
        vma->vm_page_prot 表示页保护标志，具体指定对应页的访问权限。
        */
        if (remap_pfn_range(vma, vma->vm_start, phys >> PAGE_SHIFT, size, vma->vm_page_prot)) {
            return -EAGAIN;
        }
    
        return 0;
    }
    
    static const struct file_operations uio_fops = {
        .owner = THIS_MODULE,
        .mmap = uio_mmap,
    };
    
    char test_arr[PAGE_SIZE] = {0};
    
    static ssize_t get_uio_info(struct device *dev, struct device_attribute *attr, char *buf)
    {
        return snprintf(buf, PAGE_SIZE, "%s\n", test_arr);
    }
    
    static ssize_t set_uio_info(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count)
    {
        snprintf(test_arr, PAGE_SIZE, "%s\n", buf);
        return count;
    }
    
    static DEVICE_ATTR(uio_info, 0600, get_uio_info, set_uio_info);
    
    static struct attribute *uio_sysfs_attrs[] = {
        &dev_attr_uio_info.attr,
        NULL,
    };
    
    static struct attribute_group uio_attr_group = {
        .attrs = uio_sysfs_attrs,
    };
    
    static int uio_probe(struct platform_device *pdev)
    {
        struct uio_device *uio_dev;
        /*
        uio_device结构体是Linux内核中的一个结构体，用于表示用户空间IO设备
        struct uio_device {
        struct device dev; // 继承自struct device，表示内核中的设备
        struct uio_info *info; // 表示uio设备的信息
        struct list_head list; // 用于将uio_device结构体连接到uio设备链表中
        struct module *owner; // 表示该设备所属的内核模块
        int minor; // 表示uio设备的次设备号
        struct cdev cdev; // 表示该设备的字符设备描述符
        struct class *class; // 表示该设备所属的类别
        unsigned int event; // 表示该设备的事件标志
        int irq; // 表示该设备的中断号
        };
        */
        int err;
        void *p;
    
        uio_dev = kzalloc(sizeof(struct uio_device), GFP_KERNEL);
        if (uio_dev == NULL) {
            return -ENOMEM;
        }
    
        p = kmalloc(MEM_SIZE, GFP_KERNEL);
        strcpy(p, "123456");
        uio_test.mem[0].name = "uio_mem",
        uio_test.mem[0].addr = (unsigned long)p;
        uio_test.mem[0].memtype = UIO_MEM_LOGICAL;
        uio_test.mem[0].size = MEM_SIZE;
        uio_dev->info = &uio_test;
        uio_dev->dev.parent = &pdev->dev;
    
        err = uio_register_device(&pdev->dev, uio_dev->info);
        if (err) {
            kfree(uio_dev);
            return err;
        }
        if (sysfs_create_group(&pdev->dev.kobj, &uio_attr_group)) {
            printk(KERN_ERR "Cannot create sysfs for system uio\n");
            return err;
        }
    
        //dev_set_drvdata(pdev, uio_dev);
    
        return 0;
    }
    
    static int uio_remove(struct platform_device *pdev)
    {
        struct uio_device *uio_dev = platform_get_drvdata(pdev);
    
        sysfs_remove_group(&uio_dev->dev.kobj, &uio_attr_group);
        uio_unregister_device(uio_dev->info);
        //dev_set_drvdata(uio_dev, NULL);
        kfree(uio_dev);
    
        return 0;
    }
    
    static struct platform_device *uio_test_dev;
    static struct platform_driver uio_driver = {
        .probe = uio_probe,
        .remove = uio_remove,
        .driver = {
            .name = DRV_NAME,
        },
    
    };
    
    static int __init uio_init(void)
    {
        uio_test_dev = platform_device_register_simple(DRV_NAME, -1, NULL, 0);
        return platform_driver_register(&uio_driver);
    }
    
    static void __exit uio_exit(void)
    {
        platform_device_unregister(uio_test_dev);
        platform_driver_unregister(&uio_driver);
    }
    
    module_init(uio_init);
    module_exit(uio_exit);
    
    MODULE_AUTHOR("Arron Wu");
    MODULE_DESCRIPTION("UIO driver");
    MODULE_LICENSE("GPL");
    ```

    app code:

    ```cpp
    #include <stdio.h>
    #include <fcntl.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/mman.h>
    #include <errno.h>
    #include <string.h>
    
    #define UIO_DEV "/dev/uio0"  
    #define UIO_ADDR "/sys/class/uio/uio0/maps/map0/addr"  
    #define UIO_SIZE "/sys/class/uio/uio0/maps/map0/size"  
    
    static char uio_addr_buf[16], uio_size_buf[16];
    
    int main(void)
    {
        int uio_size;
        void* uio_addr, *access_address;
        
        int uio_fd = open(UIO_DEV, O_RDWR);
        int addr_fd = open(UIO_ADDR, O_RDONLY);
        int size_fd = open(UIO_SIZE, O_RDONLY);
        
        if( addr_fd < 0 || size_fd < 0 || uio_fd < 0) {  
            fprintf(stderr, "mmap: %s\n", strerror(errno));  
            exit(-1);  
        }
        read(addr_fd, uio_addr_buf, sizeof(uio_addr_buf));
        read(size_fd, uio_size_buf, sizeof(uio_size_buf));
        uio_addr = (void*)strtoul(uio_addr_buf, NULL, 0);
        uio_size = (int)strtol(uio_size_buf, NULL, 0);
        
        access_address = mmap(NULL, uio_size, PROT_READ | PROT_WRITE, MAP_SHARED, uio_fd, 0);
        if ( access_address == (void*) -1) {
            printf("mmap: %s\n", strerror(errno));
            exit(-1);
        }
        printf("The device address %p (lenth %d)\n" "logical address %p\n", uio_addr, uio_size, access_address);
        for(int i = 0; i<6; i++) {
            printf("%c", ((char *)access_address)[i]);
            ((char *)access_address)[i] += 1;
        }
        printf("\n");
        
        for(int i = 0; i<6; i++)
            printf("%c", ((char *)access_address)[i]);
        printf("\n");
        
        munmap(access_address, uio_size);
        return 0;
    }  
    ```

    ref: <https://blog.csdn.net/weixin_38452632/article/details/130947993>

* uio 的 kmd 主要做两件事

    1. 分配和记录设备需要的资源和注册UIO设备

    2. 实现必须在内核空间实现的中断处理函数

    其余的大部分操作都放到 umd 里实现。