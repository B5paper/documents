* 在向任务管理系统整理任务时，所有 deps 的任务放到当前任务的上面，所有 feedback 的任务放到当前任务的下面。这样比较重要的任务就会慢慢浮上来，不重要的任务会沉到下面去。

* 应该区分清楚调研任务和调研完成任务，调研任务只需要收集资料，弄清楚哪些是已知的，哪些是未知的，目前的阻力点在哪里，有哪些派生任务就可以了，通常是个可完成的任务。调研完成任务需要边调研边完成，通常是个长期任务，遇到 deps 需要先解决 deps 任务。

* c++ 中，如果一个构造函数被声明为`explicit`，那么就无法使用等号进行初始化，只能使用括号来初始化。

    ```cpp
    struct B;

    struct A {
        int val;
        A() {}
        explicit A(const B &b);
    };

    struct B {
        int val;
    };

    A::A(const B &b) {
        val = b.val;
    }

    int main() {
        A a;
        a.val = 123;
        B b;
        b.val = 456;

        A c = b;  // Error
        A d(b);  // OK

        return 0;
    }
    ```

    compiling output:

    ```
    main_5.cpp: In function ‘int main()’:
    main_5.cpp:23:11: error: conversion from ‘B’ to non-scalar type ‘A’ requested
       23 |     A c = b;  // Error
          |           ^
    make: *** [Makefile:4: main] Error 1
    ```

    如果不写`explicit`，则可正常通过编译：

    ```cpp
    struct B;

    struct A {
        int val;
        A() {}
        A(const B &b);
    };

    struct B {
        int val;
    };

    A::A(const B &b) {
        val = b.val;
    }

    int main() {
        A a;
        a.val = 123;
        B b;
        b.val = 456;

        A c = b;  // OK
        A d(b);  // OK

        return 0;
    }
    ```

* 从`string_view`构造`string`时，只能显式构造

    ```cpp
    #include <string>
    using namespace std;

    int main() {
        string_view my_strv = "hello, world";
        string my_str = my_strv;  // error
        string my_str_2(my_strv);  // ok
        string my_str_2{my_strv};  // ok
        return 0;
    }
    ```

    compiling output:

    ```
    main_5.cpp: In function ‘int main()’:
    main_5.cpp:6:21: error: conversion from ‘std::string_view’ {aka ‘std::basic_string_view<char>’} to non-scalar type ‘std::string’ {aka ‘std::__cxx11::basic_string<char>’} requested
        6 |     string my_str = my_strv;  // error
          |                     ^~~~~~~
    make: *** [Makefile:4: main] Error 1
    ```

    我们看 std 库中 string 的头文件，有下面几行：

    ```cpp
      /**
       *  @brief  Construct string from a string_view.
       *  @param  __t  Source object convertible to string view.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      template<typename _Tp, typename = _If_sv<_Tp, void>>
	_GLIBCXX20_CONSTEXPR
	explicit
	basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
	: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }
    ```

    可以看到，`explicit`关键字就是元凶。

    为什么要这样设计？用意和动机是什么？目前不清楚。

* `magic_enum`简介

    `magic_enum`是一个第三方 c++ 库，官网：<https://github.com/Neargye/magic_enum>

    这是个 header-only 的库，只需要 include 头文件就可以。

    `main.cpp`:

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <array>
    #include "magic_enum/magic_enum.hpp"
    using namespace std;

    enum Color {
        RED,
        YELLOW,
        GREEN,
        BLUE
    };

    int main() {
        // enum -> str
        string_view color_name = magic_enum::enum_name(GREEN);
        printf("color name: %s\n", color_name.data());

        // str -> enum
        const optional<Color> &my_color_opt =
            magic_enum::enum_cast<Color>("BLUE");
        if (!my_color_opt.has_value()) {
            printf("fail to find value\n");
            return -1;
        }
        const Color &color = my_color_opt.value();
        printf("BLUE val is %d\n", color);

        // get enum num
        size_t num_entry = magic_enum::enum_count<Color>();
        printf("Color num entry: %lu\n", num_entry);

        // traverse all enum entries
        // const array<Color, 4>&
        auto &colors = magic_enum::enum_values<Color>();
        for (int i = 0; i < colors.size(); ++i) {
            printf("%d, ", colors[i]);
        }
        putchar('\n');

        // traverse all enum entries by name str
        // const array<string_view, 4>&
        auto &entry_names = magic_enum::enum_names<Color>();
        for (int i = 0; i < entry_names.size(); ++i) {
            printf("%s, ", entry_names[i].data());
        }
        putchar('\n');

        // enum -> idx
        // const optional<size_t> &yellow_idx_opt = magic_enum::enum_index(YELLOW);
        const auto &yellow_idx_opt = magic_enum::enum_index(YELLOW);
        if (!yellow_idx_opt.has_value()) {
            printf("fail to find yellow\n");
            return -1;
        }
        printf("YELLOW idx: %lu\n", yellow_idx_opt.value());

        return 0;
    }
    ```

    `Makefile`:

    ```makefile
    INCLUDE=../magic_enum_test/magic_enum/include

    main: main.cpp
    	g++ -g main.cpp -I${INCLUDE} -o main
    ```

    compile: `make`

    run: `./main`

    output:

    ```
    color name: GREEN
    BLUE val is 3
    Color num entry: 4
    0, 1, 2, 3, 
    RED, YELLOW, GREEN, BLUE, 
    YELLOW idx: 1
    ```

    这几个都比较常用。

    说明：

    1. `magic_enum::enum_name()`只能返回`string_view`，不能返回`string`。

    1. 将 string 转换为 enum 时，`magic_enum::enum_cast<Color>("BLUE")`必须要使用`<EnumType>`指定 enum 的类型，这点比较好理解，仅从字符串无法拿到任何类型信息。

    1. `enum_cast<>()`的返回值是个`std::optional`。可以按值返回，如果要返回引用，那么只能返回 const 左值引用。这么麻烦还不如直接用`auto`。

    1. `enum_values<Color>()`返回的是一个`const array<Color, 4>&`，但是我们想要拿到的，正是这个模板参数 4，所以这里只能用`auto`来表示返回值类型。

        如果使用`auto`,则返回值。如果使用`auto&`，则返回 const 左值引用。

    1. `enum_names<Color>()`与`enum_values<Color>()`同理，返回的是一个包含`string_view`的`array`。

    1. `const auto &yellow_idx_opt = magic_enum::enum_index(YELLOW);`这里比较奇怪，`enum_index()`返回类型，使用`const optional<size_t> &`可以通过编译，使用`const auto&`也可以通过编译，但是使用`auto&`不行。目前不清楚为什么。

    整体看来，`magic_enum`的模板复杂度与它实现的功能不匹配，到项目里容易出错。能不用尽量不要使用。

* c++ `extent`简介

    `extent`可以获取数组指定维度的 length。

    ```cpp
    #include <stdio.h>
    #include <type_traits>
    using namespace std;

    int main() {
        int arr[3][4][5];
        int N_1 = extent_v<decltype(arr), 0>;
        int N_2 = extent_v<decltype(arr), 1>;
        int N_3 = extent_v<decltype(arr), 2>;
        int N_4 = extent_v<decltype(arr), 3>;
        int N_5 = extent_v<decltype(arr)>;
        printf("N_1: %d, N_2: %d, N_3: %d, N_4: %d, N_5: %d\n",
            N_1, N_2, N_3, N_4, N_5);

        return 0;
    }
    ```

    output:

    ```
    N_1: 3, N_2: 4, N_3: 5, N_4: 0, N_5: 3
    ```

    如果我想知道数组有几个维度，下面的代码是不行的：

    ```cpp
    vector<int> N_s;
    int dim_idx = 0;
    while (true) {
        int N = extent_v<decltype(arr), dim_idx>;  // error
        if (N == 0) {
            break;
        }
        N_s.push_back(N);
    }
    ```

    由于`dim_idx`是个变量，而模板只能接受常量，所以会编译报错。

    但是 c++ 仍然提供了几种方法拿到数组的维度数量，比如模板递归。