* c++ 中`string`插入一个字符时，不支持`str.insert(int pos, char c)`的形式，只支持`str.insert(iterator iter, char c)`，因此需要用这种方式插入字符：

    ```cpp
    #include <string>
    #include <iostream>
    using namespace std;

    int main()
    {
        string str{"helloworld"};
        int pos = 5;
        str.insert(str.begin() + pos, ' ');
        cout << str << endl;
        return 0;
    }
    ```

    output:

    ```
    hello world
    ```

    其原型为

    ```cpp
    iterator insert (const_iterator p, char c);
    ```

    `insert()`可以解释为，在迭代器`p`所在的元素之前插入`c`；也可以解释为，使得迭代器`p`位置处的字符为`c`，同时不破坏原字符串前后的有序关系。

    除了这种方式，还可以使用 fill 的方式：

    ```cpp
    string& insert (size_t pos,   size_t n, char c);
    iterator insert (const_iterator p, size_t n, char c);
    ```

    example:

    ```cpp
    #include <string>
    #include <iostream>
    using namespace std;

    int main()
    {
        string str{"helloworld"};
        int pos = 5;
        str.insert(pos, 1, ' ');
        cout << str << endl;
        pos = 11;
        str.insert(str.begin() + pos, 1, '!');
        cout << str << endl;
        return 0;
    }
    ```

    output:

    ```
    hello world
    hello world!
    ```

* `find_if()`

    syntax:

    ```cpp
    template<class InputIt, class UnaryPred>
    InputIt find_if(InputIt first, InputIt last, UnaryPred p);

    template<class ExecutionPolicy, class ForwardIt, class UnaryPred>
    ForwardIt find_if(ExecutionPolicy&& policy, ForwardIt first, ForwardIt last, UnaryPred p);
    ```

    可以看到，第 2 个 syntax 多了一个`policy`，目前不知道这个参数是干嘛用的。

    example:

    ```cpp
    #include <vector>
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int main()
    {
        vector<int> vec{2, 3, 1, 5, 4};
        int val = 5;
        auto iter = find_if(vec.begin(), vec.end(), [val](int &obj){
            if (obj == val)
                return true;
            return false;
        });
        if (iter == vec.end())
        {
            cout << "fail to find " << val << endl;
            return 0;
        }
        int pos = distance(vec.begin(), iter);
        cout << val << " is at index " << pos << endl;
        return 0;
    }
    ```

    output:

    ```
    5 is at index 3
    ```

    说明：

    * lambda 表达式中的`int &obj`可以写成`int obj`, `const int &obj`, `const int obj`，效果都一样的。

    * lambda 表达式的捕捉列表`[val]`可以写成`[&val]`, `[&]`, `[=]`

    * 如果`vec`中有多个符合要求元素，那么会返回找到的第 1 个元素的迭代器。

        如果需要找到所有符合要求的元素，可以这样写：

        ```cpp
        #include <vector>
        #include <iostream>
        #include <algorithm>
        using namespace std;

        int main()
        {
            vector<int> vec{2, 3, 5, 5, 4, 5};
            int val = 5;
            auto iter = find_if(vec.begin(), vec.end(), [&](int &obj) {
                if (obj == val)
                    return true;
                return false;
            });
            if (iter == vec.end())
            {
                cout << "fail to find " << val << endl;
                return 0;
            }
            int pos = distance(vec.begin(), iter);
            cout << val << " is at index " << pos << endl;
            while (true)
            {
                iter = find_if(iter + 1, vec.end(), [&](int &obj) {
                    if (obj == val)
                        return true;
                    return false;
                });
                if (iter == vec.end())
                    break;
                pos = distance(vec.begin(), iter);
                cout << val << " is at index " << pos << endl;
            }
            return 0;
        }
        ```

        output:

        ```
        5 is at index 2
        5 is at index 3
        5 is at index 5
        ```

        比较核心的一句是循环执行`iter = find_if(iter + 1, ...`，直到结尾。

    * `find_if()`可以处理任意具有迭代器的容器

        ```cpp
        #include <vector>
        #include <iostream>
        #include <algorithm>
        using namespace std;

        int main()
        {
            string str{"hello, world"};
            char ch = 'l';
            auto iter = find_if(str.begin(), str.end(), [=](char obj) {
                if (obj == ch)
                    return true;
                return false;
            });
            if (iter == str.end())
            {
                cout << "fail to find " << ch << endl;
                return 0;
            }
            int pos = distance(str.begin(), iter);
            cout << ch << " is at index " << pos << endl;
            while (true)
            {
                iter = find_if(iter + 1, str.end(), [=](char obj) {
                    if (obj == ch)
                        return true;
                    return false;
                });
                if (iter == str.end())
                    break;
                pos = distance(str.begin(), iter);
                cout << ch << " is at index " << pos << endl;
            }
            return 0;
        }
        ```

        output:

        ```
        l is at index 2
        l is at index 3
        l is at index 10
        ```

    * 问题：对于自定义的容器，该如何为其实现迭代器，并对接到`find()`等算法上？

* `find_if_not()`的使用逻辑与`find_if()`相似，只不过变成寻找第一个不满足条件的元素

    ```cpp
    #include <vector>
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int main()
    {
        vector<int> vec{2, 5, 3, 4, 5, 1};
        int val = 2;
        vector<int>::iterator iter = find_if_not(vec.begin(), vec.end(), [&](int obj){
            if (obj == val)
                return true;
            return false;
        });
        if (iter == vec.end())
        {
            cout << "fail to find the element not equal to " << val << endl;
            return 0;
        }
        int idx = distance(vec.begin(), iter);
        cout << "the elm " << *iter << " is not equal to " << val << ", idx: " << idx << endl;
        return 0;
    }
    ```

    output:

    ```
    the elm 5 is not equal to 2, idx: 1
    ```