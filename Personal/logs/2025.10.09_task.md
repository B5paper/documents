* [v] reorg: documents 30 mins 10.09

    10:42 ~ 11:14

    feedback:

    * [ ] 调研实现： qa 需要增加 ref 形式，如果 unit 里指定了 ref 文件夹，那么文件夹下找指定的 ref 文件，输出作为 u_1。这样可以减小 qa 文件的长度。

    * [ ] 如果只有 cdev，没有 device 设备文件节点，是否可以调用 cdev 绑定的 fops 驱动？

* [v] process 1 tab 10.09

    13:21 ~ 13:33

    feedback:

    * 对于上次没处理完的 process tab task，比如`[O]`或`[P]`，应该继续这个任务，对于 date，可以 append，比如`* [ ] xxxxx 10.08 10.09`。因为我们需要拿到它的 feedback 和 current progress 的数据。

* [v] 聚点，开集，闭区域，无界集

    13:34 ~ 14:17

* [v] 调研 ds 生成的一段代码

    14:24 ~ 14:29

    ```c
    // 计算缓冲区的虚拟地址
    void __iomem *device_buffer = dev->mmio_base + 0x1000;

    // 方法一：使用内核提供的IO函数（推荐，因为可移植且安全）
    // 写入一个32位字
    iowrite32(0x12345678, device_buffer);
    // 读取一个32位字
    u32 value = ioread32(device_buffer);

    // 批量写入一段数据（这就是你想要的“强行”操作）
    // src_buf 是你准备好的数据源（在主机内存里）
    // count 是你想写入的32位字的数量
    iowrite32_rep(device_buffer, src_buf, count);

    // 方法二：更“强行”的方式 - 直接解引用指针（需极度小心！）
    // 首先，确保映射时为“不缓存”或“写合并”模式，否则会出问题。
    // 通常用 pci_ioremap_bar() 默认是 ioremap()，这通常是安全的（无缓存）。
    // 但直接解引用 __iomem 指针编译器会报错，所以需要强制转换。

    // 强制转换为 volatile 指针，告诉编译器别优化，每次都要真的访问
    volatile u32 *hardware_buffer = (volatile u32 *)device_buffer;

    // 现在，你可以像普通数组一样操作了！
    hardware_buffer[0] = 0xAAAAAAAA; // 写入第一个字
    value = hardware_buffer[1];      // 读取第二个字

    // 甚至可以用memcpy（但确保目的地址是volatile且没有缓存问题！）
    // memcpy_toio() 是更安全的选择
    memcpy((void *)hardware_buffer, src_buf, count * 4);
    ```

* [v] `sysfs_remove_file()`

    14:29 ~ 15:15

    feedback:

    * [asso] `sysfs_create_group()`, `sysfs_remove_group()`

    * [asso] `devm_kobject_create_and_add()`

    * [asso] `devm_device_add_groups()`

* [v] 调研实现：选 unit 时，不能选 qa_record.txt 里面已经有的

    15:41 ~ 17:16

    feedback:

    * [ ] 调研 python 中文件操作的的 read(), readline() 和 readlines()

    * [ ] `parse_qa_record_file()`中检测 sub block 的类型时，直接检测`^[`然后读取`[xxx]`中的内容拿到 subblock 的类型

    * [ ] 改造`--randexam`为 subcommand 形式

* [v] reg `\b`, `\w`

    17:23 ～ 17:28

* [ ] Computer Vision with PyTorch

    <https://www.geeksforgeeks.org/deep-learning/computer-vision-with-pytorch/>

* [ ] `plt.figure(figsize=(10, 8))`

* [ ] n 维空间

* [ ] 设备树（Device Tree）

* [ ] `const string &nchannels_str`, `const string &`鼠标悬浮时不显示值，但是`string &`就可以，为什么