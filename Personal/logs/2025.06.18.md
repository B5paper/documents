* [new] 调研 c++ 的 enumerate

* vector 中的元素删除

    如果使用索引的话，可以在删除当前元素后，手动将索引减一。

    example:

    ```cpp
    #include <stdio.h>
    #include <vector>
    using namespace std;

    int main()
    {
        vector<int> vec{1, 2, 3, 4, 4, 4, 3};

        for (int i = 0; i < vec.size(); ++i)
        {
            if (vec[i] == 4) {
                vec.erase(vec.begin() + i);
                --i;
            }
        }

        for (int i = 0; i < vec.size(); ++i)
        {
            printf("%d, ", vec[i]);
        }
        putchar('\n');

        return 0;
    }
    ```

    output:

    ```
    1, 2, 3, 3,
    ```

    如果使用迭代器，那么必须使用 while 循环：

    ```cpp
    #include <stdio.h>
    #include <vector>
    using namespace std;

    int main()
    {
        vector<int> vec{1, 2, 3, 4, 4, 4, 3};

        auto it = vec.begin();
        while (it != vec.end())
        {
            if (*it == 4)
            {
                it = vec.erase(it);
                continue;
            }
            ++it;
        }

        for (int i = 0; i < vec.size(); ++i)
        {
            printf("%d, ", vec[i]);
        }
        putchar('\n');

        return 0;
    }
    ```

    output:

    ```
    1, 2, 3, 3,
    ```

    如果使用了 erase，那么就不需要再`++it`，其他情况都需要`++it`。这种处理方式或许也适合其他的容器，比如`map`。（如果 for 里使用`--it`，可能也可以支持 map？）

    如果使用 for 循环，因为并不总是需要`++it`，所以会出错：

    ```cpp
    #include <stdio.h>
    #include <vector>
    using namespace std;

    int main()
    {
        vector<int> vec{1, 2, 3, 4, 4, 4, 3};

        for (auto it = vec.begin(); it != vec.end(); ++it)
        {
            if (*it == 4) {
                it = vec.erase(it);
            }
        }

        for (int i = 0; i < vec.size(); ++i)
        {
            printf("%d, ", vec[i]);
        }
        putchar('\n');

        return 0;
    }
    ```

    output:

    ```
    1, 2, 3, 4, 3,
    ```

* 细节不同，全局相同的过程

* 必须使用 malloc / new 的场景：vert and edge，如果删除 vert，idx 发生改变，那么所有的 edge 都需要重新处理。只有 malloc / new 能保证地址不变。

    其实本质相当于一次解耦，如果使用 idx 1 -> idx 2 的方式，idx 1 是连续的，对外暴露，idx 2 是离散的（或者总是按顺序增大），作为一个 id 总是不变，那么在删除时，就可以保证删除一个 idx 2，其他的 idx 2 不变。

* 之前似乎讨论过使用 idx 比使用指针好，具体细节是什么？

* 如果设计了两个独立的 class，又需要两个 class 合作实现某个功能，那么目前先额外写一个全局函数来解决

    ```cpp
    struct A {

    };

    struct B {

    };

    int my_func(A &a, B &b) {
        // ...
    }
    ```

    每个 class 尽量只查询、修改自己维护的数据，不要访问其他 class 的数据。比如尽量不法要这样写：

    ```cpp
    struct B {
        void mem_func(A &a) {
            // ....
        }
    };
    ```