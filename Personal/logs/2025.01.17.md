* 基于 reduce copy 可以跑通的 all reduce

    见`ref_36`。

    output:

    ```
    the first 8 elms:
    cubuf_1: 1.0, 4.0, 3.0, 1.0, 5.0, 1.0, 4.0, 0.0, specialized as float
    cubuf_2: 3.0, 0.0, 2.0, 1.0, 1.0, 2.0, 5.0, 5.0, specialized as float
    after launch, the first 8 elms:
    cubuf_1: 4.0, 4.0, 5.0, 2.0, 6.0, 3.0, 9.0, 5.0, specialized as float
    cubuf_2: 4.0, 4.0, 5.0, 2.0, 6.0, 3.0, 9.0, 5.0, specialized as float
    in compare_buf_cubuf(), specialized as float
    in compare_buf_cubuf(), specialized as float
    all results are correct
    ```

    问题：

    1. 什么时候`Apply_Reduce::reduce()`中的 half 会被调用到？

    2. `MultimemSrcs`, `MultimemDsts`在何时被调用？

    3. 尝试将 Unroll 加上去，看是如何处理 hunk 的

    4. 16 字节的数据是如何被处理的？

    5. while 循环如何触发？while 中的 break 什么时候能删掉？

    6. `aligned`何时被触发？

    说明：

    1. `cvta_to_global()`目前看来没有对 va 地址作任何改变

* 可解构与复杂性

    假如一个复杂的模块可以被解构成子模块，那么我们就认为它是简单的，是复杂性可降解的。但是还存在一些模块，无法被解构为子模块，当我们想处理这样的模块时，必须把这个模块相关的所有内容都加载到缓存中，这样的模块越不可解构，复杂性越高。