* `irq_set_affinity_hint()`

    向系统提供一个“提示”（Hint），建议它将某个硬件的中断请求（IRQ）分配给特定的 CPU（或一组 CPU）来处理。

    它的目的通常是帮助用户空间的驱动程序或管理工具（而不是内核本身的驱动程序）来优化中断处理，尤其是在与支持 RSS (Receive Side Scaling) 或 RPS (Receive Packet Steering) 的高性能网卡配合使用时。

    中断亲和性是一种设置，允许管理员手动地将特定的中断绑定到特定的CPU核心上。这可以通过修改`/proc/irq/<IRQ_NUMBER>/smp_affinity`文件来实现。

    syntax:

    ```c
    #include <linux/interrupt.h>

    int irq_set_affinity_hint(unsigned int irq, const struct cpumask *m);
    ```

    * `const struct cpumask *m`

        含义: 一个指向 cpumask 的指针，该结构体指明了你希望提示中断在哪个（或哪些）CPU核心上运行。

        如何创建:

        * 使用 cpumask_of(cpu) 宏来创建一个指向特定CPU的掩码。

        * 例如：cpumask_of(0) 表示 CPU 0。

        也可以使用更高级的宏（如 cpumask_local_spread）来根据NUMA架构智能选择CPU，或者手动构建一个更复杂的掩码。

    返回值 (Return Value)

    * 0: 表示成功。

    * 非零值: 表示失败。错误码通常是 -EINVAL（无效参数）。

    example:

    ```c
    #include <linux/interrupt.h>
    #include <linux/cpu.h>

    /* 假设你的驱动已经获取到了这个中断号 */
    unsigned int my_irq_num;

    /* 设置亲和性提示到 CPU 0 */
    void setup_irq_hint(void)
    {
        int ret;
        const struct cpumask *cpu_mask = cpumask_of(0); // 创建指向 CPU 0 的掩码

        ret = irq_set_affinity_hint(my_irq_num, cpu_mask);
        if (ret) {
            pr_err("Failed to set affinity hint for IRQ %d, error: %d\n", my_irq_num, ret);
            /* 错误处理 */
        }
    }

    /* 在驱动卸载或设备移除时，通常需要清除提示 */
    void cleanup_irq_hint(void)
    {
        /* 
         * 通过传递一个全空的 cpumask 来清除之前的提示。
         * 这告诉内核“不再有特定提示”。
         * 注意：在某些旧内核中，传递 NULL 也可以，但使用 cpu_none_mask 是更明确的做法。
         */
        irq_set_affinity_hint(my_irq_num, cpu_none_mask);
    }
    ```

    已过时 (Deprecated)：在较新的 Linux 内核中（大约 5.11 版本之后），这个函数已被标记为过时。官方推荐使用更新的 irq_set_affinity() 接口以及 struct irq_affinity_desc 中的 flags 字段来提供更明确的管理策略（例如，设置 IRQ_AFFINITY_FLAG_MANAGED 标志），而不是使用这种模糊的“提示”。

* `	devm_ioremap()`

    将一段物理地址空间（通常是内存映射式设备的寄存器区域）映射到内核的虚拟地址空间，并且自动资源管理。

    syntax:

    ```c
    #include <linux/io.h>

    void __iomem *devm_ioremap(struct device *dev, resource_size_t offset, resource_size_t size);
    ```

    offset: 要映射的物理地址的起始偏移量（通常从设备资源（如 struct resource）中获取）。

    size: 要映射的地址区域的大小。

    资源管理（Managed - `devm_*`前缀）: 这是`devm_ioremap()`相对于传统 ioremap() 最关键的优势。devm_ 前缀意味着这个函数是“被托管的”或“自动资源管理的”。它将申请的资源（这里是指映射的虚拟地址区域）与特定的设备（struct device *dev）绑定。

    当该设备被卸载或者驱动模块被移除时，内核会自动调用反向操作（即 devm_iounmap()）来释放这个映射。程序员无需在代码的错误处理路径和驱动退出函数中显式地调用 iounmap()。

    `pci_ioremap()`专门用于 PCI/PCIe 设备, 通常与 pci_resource_start() 等PCI特定函数配对使用.  `devm_ioremap()`	通用于所有内存映射I/O设备, 通常与 `platform_get_resource()`等通用或平台函数配对使用.

* `pci_ioremap_bar()`

    查找 PCI 设备上指定 BAR 的地址空间, 并将该物理地址空间映射到内核虚拟地址空间。这也是一个托管版本，无需驱动程序手动调用 iounmap().

    syntax:

    ```c
    void __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar);
    ```

    example:

    ```c
    static int my_pci_driver_probe(struct pci_dev *pdev, const struct pci_device_id *id)
    {
        void __iomem *bar0_base;
        int ret;

        // 1. 启用PCI设备（获取总线主控权、分配IRQ等）
        ret = pci_enable_device(pdev);
        if (ret) {
            dev_err(&pdev->dev, "Failed to enable device\n");
            return ret;
        }

        // 2. 请求设备的资源区域（如内存区域）
        ret = pci_request_regions(pdev, "My PCI Driver");
        if (ret) {
            dev_err(&pdev->dev, "Failed to request regions\n");
            goto err_disable;
        }

        // 3. 一键式映射 BAR0
        bar0_base = pci_ioremap_bar(pdev, 0);
        if (!bar0_base) {
            dev_err(&pdev->dev, "Failed to ioremap BAR0\n");
            ret = -ENOMEM;
            goto err_release;
        }

        // 4. 现在可以使用 bar0_base 指针来访问 BAR0 的寄存器了
        // 例如：writel(0xFFFFFFFF, bar0_base + CTRL_REG_OFFSET);

        // ... 驱动的其他初始化操作（如申请中断等）...

        return 0;

    // 错误处理路径
    err_release:
        pci_release_regions(pdev);
    err_disable:
        pci_disable_device(pdev);
        return ret;
    }

    static void my_pci_driver_remove(struct pci_dev *pdev)
    {
        // ... 其他清理工作（如释放中断）...

        // 注意：这里不需要 iounmap(bar0_base)！
        // 内核会自动清理由 pci_ioremap_bar() 创建的映射

        pci_release_regions(pdev);
        pci_disable_device(pdev);
    }
    ```

    在没有 pci_ioremap_bar() 时，你需要这样做：

    ```c
    // 传统繁琐的方法
    bar0_base = pci_resource_start(pdev, 0); // 1. 获取物理地址
    bar0_len = pci_resource_len(pdev, 0);     // 2. 获取长度
    bar0_base = ioremap(bar0_start, bar0_len); // 3. 手动映射
    // 并且在 remove 函数中必须记得： iounmap(bar0_base);
    ```

    该函数主要用于映射 内存空间 类型的 BAR（即 IORESOURCE_MEM）。虽然它也能处理 I/O 空间类型的 BAR（IORESOURCE_IO），但对于 I/O 端口，通常更推荐使用 pci_iomap() 系列函数，或者直接使用 inb()/outb() 等 I/O 端口操作函数。

* pci_iomap() 是一个历史遗留的、为了兼容两种不同IO方式而设计的通用接口，但在当今以MMIO为主流的开发中，更专用的 pci_ioremap_bar() 往往是更好的选择。

* `platform_get_resource()`

    在 Linux 设备模型中，那些直接连接在处理器总线上的、相对简单的设备（如 GPIO 控制器、I2C 控制器、内存映射的设备等）通常被抽象为“平台设备”（platform_device）。

    一个设备要工作，需要内核知道它的“资源”，比如：

    * 内存地址范围（IORESOURCE_MEM）：设备寄存器映射到的物理地址和长度。

    * 中断号（IORESOURCE_IRQ）：设备使用的中断线编号。

    * DMA 通道（IORESOURCE_DMA）：设备使用的 DMA 通道号。

    这些资源信息通常在设备树（Device Tree）或ACPI表中定义，在系统启动时由内核解析并填充到对应的 platform_device 结构体中。

    syntax:

    ```c
    struct resource *platform_get_resource(struct platform_device *pdev,
                                          unsigned int type,
                                          unsigned int num);
    ```

    * `pdev`: 指向对应的平台设备结构体的指针，通常会在驱动的 probe 函数中传入。

    * `type`: 要查找的资源类型。常见的有：

        * `IORESOURCE_MEM` - 内存资源

        * `IORESOURCE_IRQ` - 中断资源

        * `IORESOURCE_DMA` - DMA资源

    * `num`: 该类型资源的索引号（从 0 开始）。例如，一个设备可能有两块内存映射区域，第一块索引为 0，第二块索引为 1。

    返回值:

    * 成功：返回指向 struct resource 的指针。

    * 失败或指定的资源不存在：返回 NULL。

    example:

    ```c
    static int my_driver_probe(struct platform_device *pdev)
    {
        struct resource *res;

        // 1. 获取第一个内存资源（索引0）
        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
        if (!res) {
            dev_err(&pdev->dev, "Failed to get MEM resource\n");
            return -EINVAL;
        }
        // 使用 res->start 和 res->end 获取地址范围

        // 2. 获取第一个中断资源（索引0）
        res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
        if (!res) {
            dev_err(&pdev->dev, "Failed to get IRQ resource\n");
            return -EINVAL;
        }
        int irq_num = res->start; // 中断号通常存放在 start 字段
        // 然后使用 request_irq() 申请这个中断

        // ... 其他初始化操作 ...
        return 0;
    }
    ```

    如果是中断，可以直接使用`platform_get_irq()`

* `resource_size()`

    计算一个`struct resource`所描述的硬件资源块的大小。

    syntax:

    ```c
    #include <linux/ioport.h> // 需要包含这个头文件

    resource_size(struct resource *res);
    ```

    参数:

        res: 指向 struct resource 的指针，通常是 platform_get_resource() 的返回值。

    返回值:

        返回该资源块的大小（以字节为单位）。

        如果传入的 res 是 NULL，行为是未定义的（通常会导致内核崩溃/Oops）。

    example:

    ```c
    static int my_driver_probe(struct platform_device *pdev)
    {
        struct resource *res;
        void __iomem *base_addr;

        // 1. 获取内存资源
        res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
        if (!res) {
            dev_err(&pdev->dev, "Failed to get MEM resource\n");
            return -EINVAL;
        }

        // 2. 使用 resource_size() 获取资源大小
        dev_info(&pdev->dev, "Resource start: 0x%llx, size: %lu bytes\n",
                 (unsigned long long)res->start, (unsigned long)resource_size(res));

        // 3. 申请并映射这段内存区域到内核的虚拟地址空间
        // 在调用 devm_ioremap_resource 时，内核内部也会使用 resource_size()
        base_addr = devm_ioremap_resource(&pdev->dev, res);
        if (IS_ERR(base_addr)) {
            return PTR_ERR(base_addr);
        }

        // 现在 base_addr 就是这段内存的起始虚拟地址，
        // 你可以通过 ioread32(base_addr + offset) 等方式访问硬件寄存器了。

        // ... 其他初始化操作 ...
        return 0;
    }
    ```

* `register_chrdev()`中填的`name`是设备号的名称，不是 dev 的名称。可以在`/proc/devices`中查看。

    主设备号数字从 1 开始编号。

* `register_chrdev()`的 example

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/pci.h>

    int hlc_open(struct inode *, struct file *) {
        pr_info("in hlc_open()...\n");
        return 0;
    }

    int hlc_release(struct inode *, struct file *) {
        pr_info("in hlc_release()...\n");
        return 0;
    }

    ssize_t hlc_read(struct file *, char __user *, size_t, loff_t *) {
        pr_info("in hlc_read()...\n");
        return 0;
    }

    ssize_t hlc_write(struct file *, const char __user *, size_t, loff_t *) {
        pr_info("in hlc_write()...\n");
        return 0;
    }

    long hlc_ioctl(struct file *, unsigned int, unsigned long) {
        pr_info("in hlc_ioctl()...\n");
        return 0;
    }

    const struct file_operations fops = {
        .open = hlc_open,
        .release = hlc_release,
        .read = hlc_read,
        .write = hlc_write,
        .unlocked_ioctl = hlc_ioctl
    };

    int dev_num_major;

    int init_mod(void) {
        pr_info("init hlc module...\n");
        dev_num_major = register_chrdev(0, "qemu_edu", &fops);
        if (dev_num_major <= 0) {
            pr_err("fail to register chrdev\n");
            goto ERR_REGISTER_CHRDEV;
        }
        return 0;

    ERR_REGISTER_CHRDEV:
        return -1;
    }

    void exit_mod(void) {
        pr_info("exit hlc module...\n");
        unregister_chrdev(dev_num_major, "hlc_dev");
    }

    module_init(init_mod);
    module_exit(exit_mod);
    MODULE_LICENSE("GPL");
    ```