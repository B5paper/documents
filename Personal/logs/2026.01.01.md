* matlab `length()`

    获取数组的最大维度长度。

    与其他函数对比：

    * size(A)：返回各维度尺寸（如 [m, n]）

    * numel(A)：返回元素总数

    * length(A)：返回最大维度长度

    注意事项：

    ```matlab
    % 特殊情况
    empty = [];
    len = length(empty);  % 返回 0

    % 标量被视为 1×1 数组
    scalar = 42;
    len = length(scalar);  % 返回 1
    ```

    建议：

    * 当需要特定维度长度时，使用 size(A, dim)

    * 当需要元素总数时，使用 numel(A)

    * length() 主要用于快速获取数组最大维度的长度，特别是在不确定数组维度但需要循环遍历时

* `format compact`

    减少命令行窗口中的空行输出。

    使用效果对比：
    
    默认模式（未设置）：

    ```matlab
    % 默认情况下：
    A = [1 2; 3 4];
    B = [5 6; 7 8];
    ```

    输出：

    ```text
    A =
         1     2
         3     4

    B =
         5     6
         7     8
    ```

    注意：每个变量输出后都有额外的空行

    紧凑模式：

    ```matlab
    format compact  % 设置紧凑显示
    A = [1 2; 3 4];
    B = [5 6; 7 8];
    ```

    输出：

    ```text
    A =
         1     2
         3     4
    B =
         5     6
         7     8
    ```

    相关命令：

    ```matlab
    format compact     % 启用紧凑显示
    format loose       % 恢复默认显示（带空行）
    format short       % 短格式（默认，小数点后4位）
    format long        % 长格式（更多小数位）
    format bank        % 货币格式（两位小数）
    format rat         % 有理分数格式
    format short e     % 短科学计数法
    ```

    注意事项：

    * format compact 设置是会话级别的，即设置后一直有效，直到 MATLAB 关闭或更改设置

* vim 函数规则

    > E128: Function name must start with a capital or "s:": add_star()

    注：

    1. 可以看出，如果用`s:`作为函数名前缀，那么有点像 C 语言中的`private`函数了。

* vim 的`:source xxx.vim`是在当前环境中执行`vim`脚本，之前定义的函数会被保留。

* vim function 不需要`function!`也能覆盖之前自己自定义的函数。

    不清楚如果不加`!`能不能覆盖 vim 内置函数。

* vim 中连接字符串时，`.`左右的空格可省略

    `echo 'line: '.line`

    似乎点`.`本身也可以被省略：

    `echo 'cur line: 'line`

    不清楚原因。

* vim 可以使用单引号作为字符串，也可以使用双引号

* vim 在 visual 下选择多行，进入命令模式时会自动添加`:'<,'>`，表示对每一行都调用一次后续的命令

    如果我们的函数按`:'<,'>call MyFunc()`方式调用时，对于每一行都会调用一次`MyFunc()`函数。

    可以在进入命令模式后，按`Ctrl` + `u`清除`'<,'>`。

* vim 可视模式下对 md 段落中有文字的行添加星号

    ```vim
    function AddAsterisk()
        let line = getline('.')
        if line !~ '\S'
            return 0
        endif
        let lnum = line('.')
        execute lnum . 'normal! ^i* '
        return 0
    endfunction

    vnoremap <leader>a :call AddAsterisk()<CR>
    ```

    可以按`\`, `a`触发函数调用。

* vim script 显示 visual 模式下选中的内容

    ```vim
    function ShowLines()
        let start_line = line("'<")
        let end_line = line("'>")
        echo "选中的行范围: " . start_line . " 到 " . end_line
        for lnum in range(start_line, end_line)
            let line = getline(lnum)
            echo 'cur line: ' . line
        endfor
        return 0
    endfunction
    ```

* git ignore

    1. 配置文件的层级结构

        Git 会从多个位置读取忽略规则，优先级从高到低：

        * .git/info/exclude - 仓库本地的忽略规则

        * 各个目录中的 .gitignore 文件

        * $GIT_DIR/exclude（已废弃）

        * 全局配置 core.excludesFile（默认 ~/.gitignore）

    2. 规则匹配机制

        * 模式匹配：支持简单的通配符模式

            * `*` 匹配任意字符串（不包括路径分隔符）

            * `?` 匹配单个字符

            * `[]` 匹配字符组

            * `**` 匹配任意目录层级

        * 路径处理：

            以 / 开头：相对于 .gitignore 文件所在目录

            以 / 结尾：只匹配目录

            无 /：匹配文件和目录

    3. 实现流程

        ```c
        // 简化的检查逻辑
        if (文件在索引中已存在)
            不被忽略（已跟踪文件优先）
        else
            遍历所有适用的 .gitignore 文件
            如果匹配到忽略规则：
                if (规则以 ! 开头)  // 否定规则
                    取消忽略
                else
                    标记为忽略
        ```

    4. 核心特性

        * 已跟踪文件不受影响：忽略规则只对未跟踪文件有效

        * 目录忽略：忽略目录时，其所有内容都会被忽略

        * 否定规则：用 ! 开头的规则可以覆盖之前的忽略

        * 模式递归：子目录中的 .gitignore 只影响该目录及其子目录

    5. 性能优化

        * 使用缓存机制存储已解析的忽略模式

        * 按需加载 .gitignore 文件

        * 索引状态优先检查

    示例流程

    ```text
    文件: project/src/temp.log
    检查顺序:
    1. 检查是否已在索引 → 否
    2. 检查 project/.gitignore → 无匹配
    3. 检查 project/src/.gitignore → 匹配 "*.log"
    4. 标记为忽略
    ```

* git ignore 与正则表达式的对比

    Git ignore 使用的是自己定义的一套简化模式匹配规则，不是基于正则表达式。比正则表达式简单得多。

    主要区别：

    1. 模式语法不同

        ```bash
        # Git ignore 模式示例
        *.log       # 简单的通配符
        temp/       # 目录匹配
        src/*.js    # 单层目录匹配
        **/test     # 任意层级匹配

        # 正则表达式（复杂且功能不同）
        ^.*\.log$
        temp/.*
        src/[^/]*\.js
        (.*/)?test
        ```

    2. 底层实现

        在 Git 源码中（dir.c、dir.h），主要使用以下结构：

        ```c
        struct path_pattern {
            const char *pattern;      // 原始模式字符串
            int nowildcardlen;        // 非通配符部分长度
            unsigned flags;           // 模式标志
            int patternlen;           // 模式长度
        };
        ```

        匹配逻辑在 fnmatch_icase 等相关函数中实现，但不是使用标准的正则引擎。

    3. 关键差异点

        | 特性 | Git Ignore | 正则表达式 |
        | - | - | - |
        | 通配符 * | 匹配除 / 外的任意字符 | 匹配任意字符 |
        | 通配符 ? | 匹配单个非 / 字符 | 匹配单个任意字符 |
        | [abc] | 字符组，不支持范围缩写 | 支持 [a-z] 等范围 |
        | ** | 特殊：跨目录匹配 | 无此特殊含义 |
        | 转义字符 | 很少，基本不需要转义 | 大量转义需求 |
        | 性能 | 轻量级，优化过的算法 | 相对较重 |

    4. 实际的匹配函数

        Git 使用自定义的 wildmatch 函数族，这是专门为文件名匹配设计的算法：

        ```c
        // 简化的匹配逻辑示意
        static int wildmatch(const char *pattern, const char *text,
                             unsigned int flags)
        {
            // 特殊的通配符处理逻辑
            // 针对 ** 的特殊处理
            // 针对路径分隔符的特殊处理
        }
        ```

    5. 为什么不用正则？

        性能：文件匹配需要高性能，正则表达式相对较重

        简单性：用户需要简单直观的语法

        可预测性：简化模式更容易理解和调试

        历史兼容：Git 早期版本的设计选择

    6. 特殊情况处理

        ```bash
        # Git ignore 的特殊语义
        *.py[co]    # 匹配 .pyc 或 .pyo（不是字符组范围！）
        # 这实际上匹配字面字符 [、c、o，而不是正则的字符组
        ```

    总结

    Git ignore 使用的是 专门设计的简化通配符系统，类似于 shell 的 glob 模式但有一些扩展（特别是 **）。这种设计在表达能力、性能和易用性之间取得了良好平衡，比正则表达式更适合文件忽略的场景。
