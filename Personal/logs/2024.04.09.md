* connection 非常重要

    必须有一些必做的任务，可以通向以前的问题，以前的缓存，以前的记忆，以前的工程。

    必须有一条路径通向过去。

    目前这些必做的任务就是 reorg 和 qa。

* 如果看到一个名词没有任何头绪，那么就去*调研*它

    比如当天的任务，如果没有头绪，那么就*调研***当天的任务**。

    比如某个项目，如果不知道怎么开展，那么就去*调研*这个项目。

    如果对于某个任务，忘了它是怎么开始的，想不起来和它相关的所有东西，那么就去调研这个任务。

* 串行的任务执行对提高效率非常重要，因为大脑频繁切换任务会降低效率

    可能训练汉语／英语文字阅读也是必要的。

    猜想：大脑的各个模块各个细胞都是通过规律的频率和谐地交互信息，才能达到高度专注的效果。切换任务会切换细胞之间互相配合的模式和频率，导致模式的调整，这个过程会导致注意力无法集中，处理问题的效率降低。

    使任务串行，一个非常大的挑战就是在规定的时间内使用手机，在执行任务时不看。

* c++ lambda and function pointer

    An example of lambda expression:

    ```cpp
    #include <stdio.h>

    int main()
    {
        auto print_val = [](int val) -> int {
            printf("hello, %d\n", val);
            return 1;
        };
        int rtv = print_val(3);
        printf("return value: %d\n", rtv);
        return 0;
    }
    ```

    output:

    ```
    hello, 3
    return value: 1
    ```

    the return value type of `-> int` is optional. You can miss it and the compiler will help you complete it.

    But you can't give a wrong type for return value. The compiler g++ will throw error if your return type hint is not identical to the real return value.

    The syntax of capture list:

    * `[ ]`: Capture nothing.

    * `[ = ]`: Capture everything by value. It gives only read access.

    * `[ & ]`: Capture everything by reference. It gives both read and write access.

    * `[ =, & x]`: Capture everything by value, and x variable by reference.

    * `[ =x, & ]`: Capture everything by reference, and x by value.

    function pointer:

    ```cpp
    #include <stdio.h>

    void print_ab(int a, int b) {
        printf("a = %d, b = %d\n", a, b);
    }

    int main()
    {
        void (*func)(int, int) = print_ab;
        func(1, 2);
        return 0;
    }
    ```

    output:

    ```
    a = 1, b = 2
    ```

    capture list example:

    ```cpp
    #include <stdio.h>

    int main()
    {
        int x = 0, a = 1, b = 2;
        auto test_fun = [=, &x]() {
            printf("%d + %d = %d\n", a, b, a + b);
            x++;
        };
        test_fun();
        printf("x is %d\n", x);
        return 0;
    }
    ```

    output:

    ```
    1 + 2 = 3
    x is 1
    ```

    A lambda function with a non-empty capture list can't be converted to a C-style function pointer.

* amd gpa usage

    example: initialize gpa

    `main.cpp`:

    ```cpp
    #include "gpu_performance_api/gpu_perf_api.h"
    #include "dlfcn.h"  // dlopen(), dlclose(), dlerr()
    #include <stdio.h>  // printf()
    #include <stdlib.h>  // exit()

    int main()
    {
        
        void *dl_X11 = dlopen("/usr/lib/x86_64-linux-gnu/libX11.so", RTLD_NOW | RTLD_GLOBAL);
        if (dl_X11 == NULL) {
            printf("fail to open libX11.so\n");
            const char *err_msg = dlerror();
            printf("error message:\n%s\n", err_msg);
            return -1;
        }

        void *dl_GPUPerfAPIGL = dlopen("/home/hlc/Softwares/amdgpa/3_15/Bin/Linx64/libGPUPerfAPIGL.so",
            RTLD_NOW);
        if (dl_GPUPerfAPIGL == NULL) {
            printf("fail to dlopen\n");
            const char *err_msg = dlerror();
            printf("error message:\n%s\n", err_msg);
            return -1;
        }
        dlclose(dl_X11);  // should close libX11 here?
        // guess: if we would not invoke x11 relative functions, closing dl_X11 here is OK.
        // and if we invoke some functions relative to X11 after closing the dl_X11,
        // then the program will be broken.

        GpaGetFuncTablePtrType GpaGetFuncTable = (GpaGetFuncTablePtrType) dlsym(dl_GPUPerfAPIGL, "GpaGetFuncTable");
        if (GpaGetFuncTable == NULL) {
            printf("fail to get func address of GpaGetFuncTable()\n");
            exit(-1);
        }
        printf("get func address: %p\n", GpaGetFuncTable);

        GpaFunctionTable gpa_func_table;
        GpaStatus status = GpaGetFuncTable(&gpa_func_table);
        if (status != GpaStatus::kGpaStatusOk)
        {
            printf("fail to gpa get functable GpaInitialize\n");
            return -1;
        }
        printf("successfully get gpa function table.\n");


        GpaInitializePtrType GpaInitialize = gpa_func_table.GpaInitialize;
        status = GpaInitialize(GpaInitializeBits::kGpaInitializeDefaultBit);
        if (status != kGpaStatusOk)
        {
            printf("fail to initialize gpa\n");
            return -1;
        }
        printf("successfully initialize gpa.\n");

        GpaDestroyPtrType GpaDestroy = gpa_func_table.GpaDestroy;
        dlclose(dl_GPUPerfAPIGL);
        return 0;
    }
    ```

    `Makefile`:

    ```Makefile
    main: main.cpp
        g++ -g main.cpp -I/home/hlc/Softwares/amdgpa/3_15/Include -o main
    ```

* 猜测：

    glx 才是 opengl 和 x window system 对接的接口。glew, glxew 都是对 glx 的封装。
