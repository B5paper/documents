* 不了解恶，不使用恶，就无法理解善。就像总是看一流作家的文学和音乐，觉得一般，但是看了听了二流作家的作品，才知道一流作品好在哪里。

* 内点

    如果存在点$P$的某个邻域$U(P)$，使得$U(P) \subset E$，则称$P$为$E$的内点。

    同理，还可以定义外点和边界点。

    注：

    1. 直观地理解，内点就是在点集$E$里面的点。它不在边界上，也不在点集外面。如果让我们去定义，我们可能怎么定义内点？我们可能定义：从内点出发作直线，如果任意直线都至少通过两次边界点，那么这个点就是内点。

        这样看来，我们就得先定义边界点，定义直线。如果一个点集无限大，似乎使用直线就失效了。不清楚内点这个定义是如何被定义得这么巧妙的。

    1. 点集$E$是否有可能是离散的？如果是离散的，这个定义还适用吗？

* 开集

    如果点集$E$的点都是$E$的内点，则称$E$为开集。

    注：

    1. 这是对点集$E$的一种分类。直观上理解，就是一块区域$E$只有内部，没有边界，没有外部。我们能否模仿开区间的定义去定义开集？

        假如让我们定义开集，我们如何定义？假设把所有的点分为三类，一类在外部，一类在边界，一类在内部。我们先定义边界是什么，然后如果有一团点在边界内部并且包含边界内部所有的点，那么这团点组成的点集就是开集。外部点同理，也可以组成一个开集。

        目前也不清楚这个定义是如何演化过来的。

* 闭区域

    开区域连同它的边界一起所构成的点集称为闭区域。

    example:

    * $[5, +\infty)$是闭区域。向外的无穷的连通也是连通。

    * $[5, 6] \cap [7, 8]$是闭集，但不是闭区域，因为它不连通。

    注：

    1. 点集可能是多个圆圈，即不连通的。单个圆圈（即连通区域）是开区域。这样看来，区域主要是用于区分多个圆圈的。点集这个概念比较大，使用区域再细化一下。

    1. 这里的概念开区域又依赖其他概念，知识密度很高。

    1. 开区域和闭区域是两种特殊的连通集，重点就是研究这种独立的小圆圈。开区域是否有可能为边界到无限远这块地方？

* 无界集

    一个集合如果不是有界集，就称这集合为无界集。

    注：

    1. 这个概念也依赖有界集的概念，密度很大。

    1. 有界集决定了这个点集取不到无限大

* 逻辑顺序与 routine 记忆的困难

    假如我们有概念 A, B, C，C 依赖 B，B 依赖 A， 最终要使用这些概念解决问题 D，。如果我们按照绝对的线性顺序，先讲 A，再讲 B，再讲 C，最后解决 D，那么在逻辑顺序上非常完美，但是在认知顺序上，我们先了解了 A，A 能干嘛？不知道，先记着。然后我们了解了 B，B 能干嘛？不知道。等我们记了一长串，终于能解决 D，时，前面的没有意义的记忆早忘完了。所以逻辑顺序上的概念，会在组成 routine 时，造成认知上的负担。

    一种可能的改进方法是，我们先讨论 D，给出一个朴素的」直观的解决方案，再不断往 A, B, C 上靠拢，细化这些概念。实在不能靠拢也无所谓。

    对于已经按逻辑顺序写成的资料，我们只能补救一下，比如在学 A 时，尝试在概念 A 上进行联想，和已知的熟悉的东西或概念联系起来，还可以提出测试小游戏，还可以不断举例子、举反例并分析和 A 的关系，还可以提问“如果让我设计这个概念，我可能会如何设计？”等。

* `sysfs_remove_file()`

    从 sysfs 文件系统中删除先前创建的文件。

    syntax:

    ```c
    void sysfs_remove_file(struct kobject *kobj, 
                          const struct attribute *attr);
    ```

    * 从指定的 kobject 对应的 sysfs 目录中删除属性文件

    * 清理相关的内核数据结构

    * 确保文件系统的一致性

    example:

    ```c
    // 示例：创建和删除 sysfs 文件
    static struct kobject *example_kobj;
    static struct attribute attr = {
        .name = "example_file",
        .mode = 0644,
    };

    // 创建设备时添加
    sysfs_create_file(example_kobj, &attr);

    // 清理设备时删除
    sysfs_remove_file(example_kobj, &attr);
    ```

    如果我们不手动调用这个函数，在 rmmod 时，操作系统不会帮我们清理。

    如果想让操作系统帮忙清理，可以使用`devm_sysfs_create_group();`。如果我们写的是模块级别的 sysfs 接口（无关联设备），那么就没法用这个方法了。

* 在GDB中，\b 和 \w 是用于寄存器值显示的特殊格式说明符：

    * `\b`: 按字节显示

        以十六进制格式显示寄存器的低 8 位（一个字节）

        只显示寄存器的最低字节内容

    * `\w`: 按字显示

        以十六进制格式显示寄存器的低 16 位（一个字）

        只显示寄存器的低两个字节

    example:

    ```
    # 显示EAX寄存器的完整值
    (gdb) p $eax
    $1 = 0x12345678

    # 只显示EAX的低字节（0x78）
    (gdb) p/x $eax \b
    $2 = 0x78

    # 只显示EAX的低16位（0x5678）
    (gdb) p/x $eax \w
    $3 = 0x5678
    ```

    `p/x`表示以十六进制显示，`p`表示以十进制显示。如果之前使用过 p/x，后续 p 可能保持十六进制格式。

    `p/t` → 二进制, `p/d` → 十进制