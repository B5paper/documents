* `git revert`可以以提交 commit 的形式向前回退一个 commit。

    `git revert HEAD`，必须要加上`HEAD`，否则无法 work。

    `git revert <commit-id>`可以 revert 到指定 commit 的前一个 commit。

    一个 revert 提交的 commit 也可以被 revert。

* 遗忘点

    每次 qa 时，把遗忘点记录下来，再针对遗忘点进行巩固，或许效果会好些。

    这些遗忘点可以作为 hint，在回忆时，优先看 hint，如果看 hint 回忆不起来，再看 material。

* `__syncwarp()`

    syntax:

    `void __syncwarp(unsigned mask=0xffffffff);`

    只是一个普通的基于 warp 的同步函数，没有什么特别的。`mask`用于指定进入同步的线程。

* `.reg .pred p;`是一个声明变量的语句，`.reg`表示是寄存器空间，`.pred`表示 predicate (谓词)，可能是用于条件分支的，相当于 if 语句。

    example:

    ```c
    if (i < n)
        j = j + 1;
    ```

    上面的 c 代码等价于下面这两种 ptx 代码：

    ```asm
          setp.lt.s32  p, i, n;    // p = (i < n)
    @p    add.s32      j, j, 1;    // if i < n, add 1 to j
    ```

    ```asm
          setp.lt.s32  p, i, n;    // compare i to n
    @!p   bra  L1;                 // if False, branch over
          add.s32      j, j, 1;
    L1:     ...
    ```

* `.step`用于比较大小，并将结果存放到指定寄存器中

    ```asm
    setp.lt.s32  p|q, a, b;  // p = (a < b); q = !(a < b);
    ```

* True 和 False 被称作 guard predicate

* `@{!}p    instruction;`被称作 Predicated execution.

    当`{!}p`为 true 时，才执行 instruction，否则不执行。

    example:

    ```asm
        setp.eq.f32  p,y,0;     // is y zero?
    @!p div.f32      ratio,x,y  // avoid division by zero

    @q  bra L23;                // conditional branch
    ```

* `bra`跳转

    ```asm
    @p   bra{.uni}  tgt;           // tgt is a label
         bra{.uni}  tgt;           // unconditional branch
    ```

    `bra.uni` is guaranteed to be non-divergent, i.e. all active threads in a warp that are currently executing this instruction have identical values for the guard predicate and branch target.

    这个可能的含义是当所有线程的`p`或`tgt`都一致时，才使用`.uni`。（什么时候`tgt`会不一致？如果`p`或`tgt`不一致，但是使用了`.uni`，会报什么错？）

    `bra`看起来像是 branch 的缩写。

* `bar{.cta}, barrier{.cta}`

    barrier

    同步 cta 中的线程。猜想：cta 为一种用于同步的资源，当线程运行到 barrier 后停下，当所有线程都运行到 barrier 后，由 cta 唤醒线程继续运行。每个 cta 有 16 个用于同步的资源，编号为 0 到 15.

    > The optional .cta qualifier simply indicates CTA-level applicability of the barrier and it doesn’t change the semantics of the instruction.

    看上去 cta 只是一个提示词，无论使用还是不使用都不影响功能。

    * `barrier{.cta}.sync{.aligned}      a{, b};`

        `.sync`表示当参与 barrier 的线程到达这条指令后，等待其他线程。

        `a`表示使用第几个 cta，可取值为 0 到 15.

        `b`表示有多少线程参与 barrier，这个数必须是 warp size 的整数倍。如果不指定`b`，则所有参与 barrier 的 thread 所在的 warp，都会进入 barrier。

        这里的`.aligned`与`.cta`同理，都只是一个提示词，不具备实际功能。

    * `barrier{.cta}.arrive{.aligned}    a, b;`

        与`.sync`相对，`.arrive`不会阻塞 thread。它似乎仅用于标记这里有个 barrier。

        官网举的例子是 producer-consumer 模型，整个过程分为两步：
        
        1. 一部分 thread 作为 producer 执行`barrier.arrive`，另一部分 thread 作为 consumer 执行`barrier.sync`等待 producer 生产出资源

        2. 刚才作为 producer 的 threads 执行`barrier.sync`等待 consumer 消耗资源，而刚才作为 consumer 的 threads 执行`barrier.arrive`消耗资源

        目前没有看到实际的 example。

        注意，在`.arrive`中，`b`必须指定。（为什么？）

    * `barrier{.cta}.red.popc{.aligned}.u32  d, a{, b}, {!}c;`

        `.red`表示 reduce，`.popc`表示 population-count，`d`表示目标寄存器，`c`表示谓词（predicate）。

        `.popc`表示统计`c`中有多少个 true，并把结果存储到寄存器`d`中。

    * `barrier{.cta}.red.op{.aligned}.pred   p, a{, b}, {!}c;`

        其中的`.op`可以为`.and`，也可以为`.or`，分别用于判断`c`是否全为 true，或只有部分为 true。将判断的结果存储到寄存器`p`中。