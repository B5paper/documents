* 了解了下每天上下班都路过的恒惴，作为一个主打创新药的公司，在知乎上被大部分人看衰，说得最多的理由是目前大部分药已经够用，寿命总体和营养、锻炼、作息、饮食等关系比较大，抗生素解决了大部分的问题，再研发新药，几乎看不到收益。另一个论点是，人的命不值研发新药的科研投入，假如一个人被动死了，法院可能判赔偿多少钱？二百万？三百万？许多人一辈子可能也挣不了三百万。那么我们投资几千万，几亿去研发一款新药，受众可能很少，也可能是那些一辈子都挣不了三百万的人。在制定法律时我们认为人是无价的，但是人一生能挣的钱可能也就几百万，甚至无法支撑创新药的研发，这种悲哀来源于何方？

* 以前非常向往 spacex 和智晖君，现在反而感觉他们都是在瞎搞。究竟是我变了，还是他们变了，还是我当时向往的只是自己幻想出来的形象，并不是真正的他们？

* 很久以前学嵌入式的时候，总感觉自己无所不能，电路，信号，功率，控制，信息处理，似乎什么都可以做到。后来学神经网络的时候，觉得自己似乎可以处理各种智能问题了，预测股市，解耦 PID，图片识别，拟合函数……现在看来，这些都是基础中的基础，在现实世界几乎什么都做不到。

* shared_ptr 引用计数增加的情况

    * 构造函数

        * 拷贝构造函数：当一个 shared_ptr 被另一个 shared_ptr 拷贝构造时，引用计数会增加。

            ```cpp
            std::shared_ptr<int> ptr1(new int(42));
            std::shared_ptr<int> ptr2(ptr1);  // 引用计数增加
            ```

        * 移动构造函数：虽然移动构造函数不会增加引用计数，但它会将所有权从一个 shared_ptr 转移到另一个 shared_ptr，原 shared_ptr 会被置空。

            ```cpp
            std::shared_ptr<int> ptr1(new int(42));
            std::shared_ptr<int> ptr2(std::move(ptr1));  // ptr1 被置空，ptr2 接管对象
            ```

    * 赋值操作符

        * 拷贝赋值操作符：当一个 shared_ptr 被另一个 shared_ptr 赋值时，引用计数会增加。

            ```cpp
            std::shared_ptr<int> ptr1(new int(42));
            std::shared_ptr<int> ptr2;
            ptr2 = ptr1;  // 引用计数增加
            ```

        * 移动赋值操作符：虽然移动赋值操作符不会增加引用计数，但它会将所有权从一个 shared_ptr 转移到另一个 shared_ptr，原 shared_ptr 会被置空。

            ```cpp
            std::shared_ptr<int> ptr1(new int(42));
            std::shared_ptr<int> ptr2;
            ptr2 = std::move(ptr1);  // ptr1 被置空，ptr2 接管对象
            ```

    * 返回值

        * 函数返回 shared_ptr：当一个函数返回 shared_ptr 时，如果返回值被另一个 shared_ptr 接收，引用计数会增加。

            ```cpp
            std::shared_ptr<int> create_ptr() {
                return std::make_shared<int>(42);
            }

            std::shared_ptr<int> ptr = create_ptr();  // 引用计数增加
            ```

    * 传递参数

        * 按值传递 shared_ptr：当一个 shared_ptr 作为参数按值传递给函数时，引用计数会增加。

            ```cpp
            void process_ptr(std::shared_ptr<int> ptr) {
                // 引用计数增加
            }

            std::shared_ptr<int> ptr1(new int(42));
            process_ptr(ptr1);  // 引用计数增加
            ```

    * 使用 std::make_shared

        * 创建 shared_ptr：使用 std::make_shared 创建 shared_ptr 时，引用计数会初始化为 1。

            ```cpp
            std::shared_ptr<int> ptr = std::make_shared<int>(42);  // 引用计数为 1
            ```

    * 使用 std::static_pointer_cast, std::dynamic_pointer_cast, std::const_pointer_cast

        * 类型转换：使用这些类型转换函数时，如果转换成功，引用计数会增加。

            ```cpp
            std::shared_ptr<Base> base_ptr = std::make_shared<Derived>();
            std::shared_ptr<Derived> derived_ptr = std::dynamic_pointer_cast<Derived>(base_ptr);  // 引用计数增加
            ```

    * 使用 std::enable_shared_from_this

        * 获取 shared_ptr：如果一个类继承自 std::enable_shared_from_this，并且通过 shared_from_this() 获取 shared_ptr，引用计数会增加。

            ```cpp
            class MyClass : public std::enable_shared_from_this<MyClass> {
            public:
                std::shared_ptr<MyClass> get_ptr() {
                    return shared_from_this();  // 引用计数增加
                }
            };

            std::shared_ptr<MyClass> ptr = std::make_shared<MyClass>();
            std::shared_ptr<MyClass> ptr2 = ptr->get_ptr();  // 引用计数增加
            ```

* 桂花 + 正山小种泡出来的茶，加零卡糖，比较香甜

* 对于学习新概念，目前的笔记模式已经足够。但是如果需要探索，做许多实验，保存思路，保存许多 project，那么又该如何管理？不能只靠 reference resources。

    或者问题更明确一些：如何减少/处理 refernce resource 里的东西？ 

* 内联汇编

    * GCC/Clang（GNU 风格）

        `asm [volatile] ( “汇编模板” : “输出操作数” : “输入操作数” : “Clobbered 寄存器” );`
        
    * MSVC (Microsoft 风格)

        `__asm { 汇编指令 }`

    examples:

    * gpu-style example

        ```c
        #include <stdio.h>

        int add_numbers(int a, int b) {
            int sum;
            // 内联汇编开始
            asm volatile (
                "addl %%ebx, %%eax;"   // 汇编模板：将 ebx 加到 eax
                : "=a" (sum)           // 输出操作数：将 eax 的值输出到变量 sum
                : "a" (a), "b" (b)     // 输入操作数：将 a 放入 eax, 将 b 放入 ebx
                // Clobbered 列表：这里没有显式修改其他寄存器，所以省略
            );
            return sum;
        }

        int main() {
            int result = add_numbers(10, 25);
            printf("The result is: %d\n", result); // 输出： The result is: 35
            return 0;
        }
        ```

        output:

        ```
        The result is: 35
        ```

        代码解释：

        * `asm volatile (...)`: `volatile`关键字告诉编译器不要优化这段汇编代码，确保它按书写顺序执行。

        * 汇编模板`"addl %%ebx, %%eax;"`:

            * 这是实际的汇编指令。addl 表示 “add long”（32位加法）。

            * 在 GNU 语法中，为了区分操作数和寄存器，寄存器名前需要两个 % 符号（%%eax）。单个 % 用于操作数。

        * 输出操作数: `“=a” (sum)`:

            * 格式为 "约束" (变量)。

            * `=a`表示：

                * `=`代表这是一个输出操作数（只写）。

                * `a`是一个约束，要求将变量放入`eax`寄存器。

            * `(sum)`是 C 语言中的变量，结果将从`eax`寄存器写回到这个变量。

        * 输入操作数 : `“a” (a), “b” (b)`:

            格式同上。

            * `“a” (a)`：将变量`a`的值放入`eax`寄存器。

            * `“b” (b)`：将变量`b`的值放入`ebx`寄存器。

            * 编译器负责在汇编代码执行前，将 C 语言变量`a`和`b`的值加载到指定的寄存器中。

* vim-gutentags

    Vim-Gutentags 是一个 Vim 插件，它的核心功能是自动化管理 Vim 的标签文件（tags files）。

    在没有 Gutentags 之前，开发者通常需要手动运行 ctags -R . 来生成标签文件，并且在项目代码更新后，还需要重新运行该命令来更新标签，否则索引就会过时。这个过程非常繁琐且容易忘记。

    Gutentags 的解决方案:

    * 自动生成：当你用 Vim 在项目根目录（通过 .git, .hg, .svn 等版本控制目录识别）打开一个文件时，Gutentags 会自动在后台为你运行 ctags 命令来生成标签文件（通常是 ./tags 或 ./.git/tags）。

    * 自动更新：当你保存（write）一个文件后，Gutentags 会在后台静默地、异步地只更新刚才修改的那个文件的标签，而不是重新生成整个项目。这极大地提升了效率，避免了大型项目生成标签时造成的 Vim 卡顿。

    * 自动管理：你完全无需手动干预整个过程。它“Just Works”。

    主要特点:

    * 后台异步运行：使用 Vim 的 job 功能（或其它兼容插件）在后台运行 ctags，不会阻塞你的编辑操作。

    * 增量更新：只更新改变的文件，速度极快。

    * 智能项目管理：自动识别项目根目录，并为每个项目单独管理标签文件。

    * 高度可定制：你可以配置使用哪种 ctags 工具、标签文件存放位置、哪些文件需要被索引等。

    * 支持多种标签生成工具：默认支持 ctags 和 etags，通过配置也可以支持其它工具。

    安装：

    * 方法一，使用 Vim-Plug

        在`~/.vimrc`文件中添加：

        ```vim
        Plug 'ludovicchabant/vim-gutentags'
        ```

        重启 Vim 并执行：

        ```
        :PlugInstall
        ```

    * 方法二，使用 Vundle

        在`~/.vimrc`文件中添加：

        ```vim
        Plugin 'ludovicchabant/vim-gutentags'
        ```

        重启 Vim 并执行：

        ```
        :PluginInstall
        ```

* 科研式 project 的特点

    1. 综合，跨学科
    
    2. 资源繁多
    
    3. 线索/思路相比学科更开放，更复杂，方向经常会有变动

    目前先按常规 project 的方式管理。

    对于贴大量代码的对比实验，目前先在 proj 目录里创建单独的子文件夹。

* `iowrite32_rep()`

    将一块数据（由多个 32 位字组成）连续、高效地写入一个内存映射的 I/O（MMIO）设备寄存器或端口。

    它操作的对象不是普通的内存，而是被映射到内存空间的设备寄存器。这些寄存器控制着硬件设备（如网卡、显卡、磁盘控制器等）的行为或用于与设备交换数据。

    io： 代表输入/输出（Input/Output）。

    write： 代表“写”操作。

    32： 代表每次操作的数据单元是 32 位（即 4 字节的一个“字”）。

    _rep： 是 “repeat” 的缩写，代表这个操作是重复的、批量的。

    ```c
    #include <linux/io.h>

    void iowrite32_rep(const volatile void __iomem *addr, const void *buf, unsigned long count);
    ```

    addr: 要写入的设备寄存器的基础地址（内存映射地址）。

    buf: 源数据缓冲区的地址，即你要发送给设备的数据所在的内存位置。

    count: 要写入的 32 位字的数量，即重复的次数。

    example:

    ```c
    #include <linux/io.h>
    #include <linux/types.h>

    /* 假设我们有一个设备，其数据端口被映射到内存地址 my_device_port */
    static void __iomem *my_device_port;

    /* 我们要发送的数据 */
    u32 data_buffer[] = {0x12345678, 0x9ABCDEF0, 0x11111111, 0x22222222};

    void send_data_to_device(void)
    {
        /* 将4个32位字从 data_buffer 连续写入到 my_device_port */
        iowrite32_rep(my_device_port, data_buffer, 4);

        /* 
         * 等效于（但效率远高于）：
         * iowrite32(data_buffer[0], my_device_port);
         * iowrite32(data_buffer[1], my_device_port + 4); // 地址通常按字节偏移
         * iowrite32(data_buffer[2], my_device_port + 8);
         * iowrite32(data_buffer[3], my_device_port + 12);
         */
    }
    ```

    工作流程：

    当你调用 iowrite32_rep(addr, buf, count) 时，它会：

    1. 从内存中的 buf 位置开始读取数据。

    2. 将第一个 32 位数据写入 addr 指定的设备地址。

    3. 根据设备的总线特性，可能会自动将地址递增到下一个相邻的寄存器位置（或者使用同一个地址，这取决于设备的设计）。

    4. 重复这个过程，直到成功写完了 count 个 32 位数据。

    使用 iowrite32_rep() 比在循环中多次调用 iowrite32() 效率更高。因为它允许内核或底层架构使用更优化的方式来完成批量传输，例如使用处理器的缓存预取或更高效的总线指令（如 x86 架构上的 MOVS 指令配合 REP 前缀）。

    在需要向设备传输大量数据时（例如，向网卡发送一个数据包，或向磁盘控制器发送一系列指令参数），使用 _rep 版本的函数可以显著提升性能并减少代码量。
