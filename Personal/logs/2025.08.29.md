* `list_splice()`

    通过修改指针，将一个链表合并到另一个链表。

    syntax:

    ```c
    void list_splice(struct list_head *list, struct list_head *head);

    void list_splice_init(struct list_head *list, struct list_head *head);
    ```

    将链表`list`整体添加到`head`链表的前面。

    比如

    ```
    list: 2 1 0
    head: 5 4 3

    after splice:
    list: empty
    head: 2 1 0 5 4 3
    ```

    `list_splice_init()`在修改完链表指针后，将`list`进行 init。

    example:

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/list.h>
    #include <linux/vmalloc.h>

    struct ListNode {
        struct list_head list_head;
        int val;
    };

    struct list_head lst_1;
    struct list_head lst_2;

    int init_mod(void) {
        pr_info("init hlc module...\n");

        INIT_LIST_HEAD(&lst_1);
        INIT_LIST_HEAD(&lst_2);

        for (int i = 0; i < 3; ++i) {
            struct ListNode *new_node = vmalloc(sizeof(struct ListNode));
            new_node->val = i;
            list_add(&new_node->list_head, &lst_1);
        }

        for (int i = 3; i < 6; ++i) {
            struct ListNode *new_node = vmalloc(sizeof(struct ListNode));
            new_node->val = i;
            list_add(&new_node->list_head, &lst_2);
        }

        struct ListNode *cur_node;
        pr_info("list 1:\n");
        list_for_each_entry(cur_node, &lst_1, list_head) {
            pr_info("node val: %d\n", cur_node->val);
        }

        pr_info("list 2:\n");
        list_for_each_entry(cur_node, &lst_2, list_head) {
            pr_info("node val: %d\n", cur_node->val);
        }

        list_splice_init(&lst_1, &lst_2);
        pr_info("after list splice:\n");

        pr_info("list 1:\n");
        list_for_each_entry(cur_node, &lst_1, list_head) {
            pr_info("node val: %d\n", cur_node->val);
        }

        pr_info("list 2:\n");
        list_for_each_entry(cur_node, &lst_2, list_head) {
            pr_info("node val: %d\n", cur_node->val);
        }
        
        return 0;
    }

    void exit_mod(void) {
        pr_info("exit hlc module...\n");

        struct ListNode *cur_node, *tmp_node;
        list_for_each_entry_safe(cur_node, tmp_node, &lst_1, list_head) {
            list_del(&cur_node->list_head);
            vfree(cur_node);
        }

        list_for_each_entry_safe(cur_node, tmp_node, &lst_2, list_head) {
            list_del(&cur_node->list_head);
            vfree(cur_node);
        }
    }

    module_init(init_mod);
    module_exit(exit_mod);
    MODULE_LICENSE("GPL");
    ```

    dmesg output:

    ```
    [  354.895541] init hlc module...
    [  354.895569] list 1:
    [  354.895572] node val: 2
    [  354.895576] node val: 1
    [  354.895578] node val: 0
    [  354.895580] list 2:
    [  354.895582] node val: 5
    [  354.895583] node val: 4
    [  354.895585] node val: 3
    [  354.895587] after list splice:
    [  354.895589] list 1:
    [  354.895591] list 2:
    [  354.895592] node val: 2
    [  354.895594] node val: 1
    [  354.895596] node val: 0
    [  354.895598] node val: 5
    [  354.895600] node val: 4
    [  354.895602] node val: 3
    [  431.783673] exit hlc module...
    ```

    注：

    1. 如果不调用`list_splice_init()`，而调用`list_splice()`，那么 dmesg 输出会死循环

        ```
        [  784.259569] init hlc module...
        [  784.259599] list 1:
        [  784.259602] node val: 2
        [  784.259606] node val: 1
        [  784.259608] node val: 0
        [  784.259610] list 2:
        [  784.259612] node val: 5
        [  784.259614] node val: 4
        [  784.259616] node val: 3
        [  784.259618] after list splice:
        [  784.259620] list 1:
        [  784.259621] node val: 2
        [  784.259623] node val: 1
        [  784.259625] node val: 0
        [  784.259627] node val: 5
        [  784.259629] node val: 4
        [  784.259631] node val: 3
        [  784.259633] node val: 1074016256
        [  784.259636] node val: 2
        [  784.259638] node val: 1
        [  784.259640] node val: 0
        [  784.259642] node val: 5
        [  784.259644] node val: 4
        [  784.259646] node val: 3
        [  784.259647] node val: 1074016256
        ...
        ```

        从 list 1 的 head 出发，进入 list 2 的节点，遍历到 list 2 的结尾，发现 list 2 的结尾指向 list 2 的 head，并不是 list 1 的 head，程序以为没有回到 list 1 的开始，所以强行认为 list 2 head 是某个 struct Node 的成员，解析到了一个无效 val `1074016256`，并继续从头开始在环中遍历。

    1. 如果将`list_splice_init()`替换为`list_splice_tail_init()`，则输出为

        ```
        [ 1316.980085] init hlc module...
        [ 1316.980110] list 1:
        [ 1316.980113] node val: 2
        [ 1316.980117] node val: 1
        [ 1316.980120] node val: 0
        [ 1316.980122] list 2:
        [ 1316.980123] node val: 5
        [ 1316.980125] node val: 4
        [ 1316.980127] node val: 3
        [ 1316.980129] after list splice tail:
        [ 1316.980132] list 1:
        [ 1316.980133] list 2:
        [ 1316.980135] node val: 5
        [ 1316.980137] node val: 4
        [ 1316.980139] node val: 3
        [ 1316.980141] node val: 2
        [ 1316.980142] node val: 1
        [ 1316.980144] node val: 0
        [ 1363.336242] exit hlc module...
        ```

        如果使用`list_splice_tail()`，也会出现循环输出的情况。