* tsp problem greedy algorithm

    python version:

    ```python
    #!/home/hlc/miniconda3/envs/torch/bin/python

    import numpy as np
    import matplotlib.pyplot as plt

    # Greedy TSP算法
    def greedy_tsp(distance_matrix, start_point):
        n = len(distance_matrix)
        visit_mask = [False] * n
        path = [start_point]
        visit_mask[start_point] = True
        current_point = start_point
        total_distance = 0  # 初始化总路径长度
        
        while len(path) < n:
            next_point = None
            min_dist = float('inf')
            # n 定义为顶点的数量，由于每个顶点都与其他顶点有边，所以 n 又拿来作为边数
            for i in range(n):
                # 这里并没有用 i != self_idx 来跳过自身顶点，而是提前把自身顶点
                # 放到了 visit_mask 里，然后根据 visit_mask 去跳过顶点，
                # 这样也连带把自身顶点也跳过了
                if not visit_mask[i] and distance_matrix[current_point][i] < min_dist:
                    min_dist = distance_matrix[current_point][i]
                    next_point = i
            # 每次都从当前顶点的所有边中，选出到未经过顶点的最短的边
            path.append(next_point)
            visit_mask[next_point] = True
            total_distance += min_dist  # 累加路径长度
            current_point = next_point
        
        # 返回起点，并累加最后一段的距离
        total_distance += distance_matrix[current_point][start_point]
        path.append(start_point)  
        
        return path, total_distance

    # 绘制路径
    def draw_tsp_path_with_distances(path, distance_matrix, start_point):
        # 生成节点的坐标，均匀分布在圆上
        n = len(distance_matrix)
        theta = np.linspace(0, 2 * np.pi, n, endpoint=False)
        radius = 10
        x = radius * np.cos(theta)
        y = radius * np.sin(theta)

        plt.figure(figsize=(12, 12))  # 图像放大至12x12
        
        # 绘制节点，扩大节点大小
        plt.scatter(x, y, c='lightblue', s=3000, edgecolors='black', zorder=2)  # 节点扩大3倍
        
        # 标注节点编号，扩大字号
        for i in range(n):
            plt.text(x[i], y[i], str(i), fontsize=36, ha='center', va='center', color='black')  # 字号扩大3倍
        
        # 绘制路径并标注距离
        for i in range(len(path) - 1):
            start, end = path[i], path[i+1]
            plt.plot([x[start], x[end]], [y[start], y[end]], 'r-', lw=6, zorder=1)  # 线宽扩大3倍
            
            # 计算线的中点，标注距离
            mid_x = (x[start] + x[end]) / 2
            mid_y = (y[start] + y[end]) / 2
            dist = distance_matrix[start][end]
            plt.text(mid_x, mid_y, f'{dist}', fontsize=30, color='blue', ha='center', va='center')  # 距离标注字号扩大3倍
        
        # 标注起点，扩大节点大小
        plt.scatter(x[start_point], y[start_point], c='red', s=3000, edgecolors='black', zorder=3)  # 起点扩大3倍
        
        plt.title("TSP Path with Distances (Scaled)", fontsize=24)  # 标题字号扩大
        plt.gca().set_aspect('equal', adjustable='box')
        plt.axis('off')  # 关闭坐标轴
        plt.show()

    def main():
        # 距离矩阵
        distance_matrix = [
            [0, 11, 8.4, 5.2, 4.8, 2.6],
            [11, 0, 7.4, 4.2, 10.2, 12],
            [8.4, 7.4, 0, 3.2, 6.4, 11],
            [5.2, 4.2, 3.2, 0, 6, 7.8],
            [4.8, 10.2, 6.4, 6, 0, 10.2],
            [2.6, 12, 11, 7.8, 10.2, 0]
        ]

        # 开始点为0
        start_point = 0
        tour_path, tour_length = greedy_tsp(distance_matrix, start_point)

        print("访问路径:", tour_path)
        print("路径总长度:", tour_length)

        # 绘制TSP路径
        draw_tsp_path_with_distances(tour_path, distance_matrix, start_point)  # 包括最后一个回到起点的0

    if __name__ == '__main__':
        main()

    ```

    output:

    ```
    访问路径: [0, 5, 3, 2, 4, 1, 0]
    路径总长度: 41.2
    ```

    另外还输出一张 graph 图片。

    说明：

    * `draw_tsp_path_with_distances()`画图函数比较有意思，没用到第三方的 layout 工具，是作者自己实现的一个简单圆形 layout。

    * 如果在 greedy 时不选最短的，而选前 2 最短的，该如何写代码？是否可以达到比原来更好的效果？

* cuda 的跨进程 vram 访问

    见`ref_39`

    compile: `make`

    run:

    `./server`

    `./client`

    output:

    `server`:

    ```
    1, 4, 3, 1, 5, 1, 4, 0, specialized as int
    sizeof handle: 64
    cubuf: 0x7f53f1a00000
    ```

    `client`:

    ```
    cubuf 0x7f7fb9a00000
    1, 4, 3, 1, 5, 1, 4, 0, specialized as int
    cubuf 2: 0x7f7fb9c00000
    1, 4, 3, 1, 5, 1, 4, 0, specialized as int
    ```

    可以看到 cuda 的 mem handle 是一个 64 字节的数据结构。在一个进程里申请的 memory 到另一个进程里使用时，需要以 handle 导入的方式拿到 va。不同进程里，同一块 memory 的 va 不相同。使用 handle 拿到的 va，仍然具有 device p2p y访存的能力，但是需要提前把 p2p 开关打开。

    其中比较关键的两个函数为：`cudaIpcGetMemHandle()`, `cudaIpcOpenMemHandle()`。