* vulkan pipeline input assembly 指的好像是跳过一部分 index buffer 中的数据

	syntax:

	```cpp
	typedef struct VkPipelineInputAssemblyStateCreateInfo {
		VkStructureType                            sType;
		const void*                                pNext;
		VkPipelineInputAssemblyStateCreateFlags    flags;
		VkPrimitiveTopology                        topology;
		VkBool32                                   primitiveRestartEnable;
	} VkPipelineInputAssemblyStateCreateInfo;
	```

	官方文档是这么写的：

	> Each draw is made up of zero or more vertices and zero or more instances, which are processed by the device and result in the assembly of primitives.

	> Restarting the assembly of primitives discards the most recent index values if those elements formed an incomplete primitive, and restarts the primitive assembly using the subsequent indices
	
	具体是怎么做的目前仍不太清楚。

	目前仍不太清楚原理。

	通常我们选的`topology`为`VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST`。

* opencl build-in functions

	syntax:

	```c
	int atomic_add(volatile global int *p, int val)
	```

	Read the 32-bit value (referred to as old) stored at the location pointed by p. Compute (old + val) and store the result at the location pointed by p. The function returns old.

	类似的函数还有

	```c
	int atomic_sub(volatile global int *p, int val)

	int atomic_inc(volatile global int *p)
	int atomic_dec(volatile global int *p)
	```

	其余的几个看函数名就能猜出来意思，这里就不多写了。

	其他的一些 atomic 函数：

	* `atomic_xchg`

		syntax:

		```c
		int	atomic_xchg(volatile global int *p, int val)
		```

		> Swap the old stored at location p with new value given by val. The function returns old.

	* `atomic_cmpxchg`

		syntax:

		```c
		int atomic_cmpxchg(volatile global int *p, int cmp, int val)
		```

		Read the 32-bit value (referred to as old) stored at the location pointed by p. Compute (old == cmp) ? val : old and store the result at the location pointed by p. The function returns old.

	* `atomic_min`

		syntax:

		```c
		int atomic_min(volatile global int *p, int val)
		```

		Read the 32-bit value (referred to as old) stored at the location pointed by p. Compute min(old, val) and store the result at the location pointed by p. The function returns old.

		相似的函数：

		```c
		int atomic_max(volatile global int *p, int val)
		```

	* `atomic_and`

		syntax:

		```c
		int atomic_and(volatile global int *p, int val)
		```

		Read the 32-bit value (referred to as old) stored at the location pointed by p. Compute (old & val) and store the result at the location pointed by p. The function returns old.

		其他几个相似的函数：

		```c
		int atomic_or(volatile global int *p, int val)
		int atomic_xor(volatile global int *p, int val)
		```

* compiler nfa

	nfa 指的是非确定有限状态机。

	每一个正则表达式都可以很容易地转换成一个 nfa，因此 nfa 很有用。

	只需要将一个 nfa 转换成一个 dfa，就可以完成词法解析的任务。

	在使用 nfa 处理字符串时，我们需要猜测接下来执行哪条边。
	
	有一些算法可以总是猜对执行哪条边，方法是遍历一遍字符串，看看局部的转换条件是否被包含在 nfa 中。

	lex 可以将正则表达式转换成执行相应的代码。

	flex 节省了 dfa 需要存储的状态，从而可以运行得更快。
