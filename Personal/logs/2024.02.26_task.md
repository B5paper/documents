1. [v] cache tabs 15 mins

    11:20 ~ 11:29

2. [V] 整理任务管理系统 30 mins

    11:30 ~ 11:52

    feedback:

    1. 临时项目管理中的项目不应该超过 7 个

        不然就管理不过来了

3. [v] 随机 qa 4 个，30 mins

    feedback:

    1. 开发机上的 opencl 似乎不能正常工作了，有时间了修一下

    2. 尝试用这段代码拿 vulkan 的 physical device 的 queue family properties，

        ```cpp
        for (int i = 0; i < phy_dev_cnt; ++i)
        {
            vkGetPhysicalDeviceQueueFamilyProperties(phy_devs[i], &queue_family_cnt, nullptr);
            queue_familys.resize(queue_family_cnt);
            vkGetPhysicalDeviceQueueFamilyProperties(phy_devs[i], &queue_family_cnt, queue_familys.data());
            printf("%d-th physical device has %d queue families:\n", i, queue_family_cnt);
            for (int j = 0; j < queue_family_cnt; ++j)
            {
                printf("    %d: queue count: %d, queue falgs: %d, time stamp: %d\n", j, queue_familys[j].queueCount,
                    queue_familys[j].queueCount, queue_familys[j].timestampValidBits);
            }
        }
        ```

        输出：

        ```
        0-th physical device has 3 queue families:
            0: queue count: 1, queue falgs: 1, time stamp: 64
            1: queue count: 4, queue falgs: 4, time stamp: 64
            2: queue count: 1, queue falgs: 1, time stamp: 64
        ```

        为什么 0 号 queue family 和 2 号 queue family 是一模一样的？

4. [v] Compiler 整理正则表达式的知识点，解释书上给出的 example 30 mins

    14:54 ~ 16:27

    feedback:

    1. 接下来看正则表达式的缩写，图 2-2

        看完这个我觉得就差不多了。

5. [v] 写一道图论题

6. [v] vulkan vertex buffer, index buffer

    16:31 ~ 17:40

    feedback:

    当前的进度：

    ```cpp
    #include "../simple_vulkan/simple_vk.hpp"

    int main()
    {
        glfwInit();
        VkInstance inst;
        create_vk_instance(inst);
        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        GLFWwindow *window = glfwCreateWindow(700, 500, "hello", nullptr, nullptr);
        VkSurfaceKHR surf;
        glfwCreateWindowSurface(inst, window, nullptr, &surf);
        VkPhysicalDevice phy_dev;
        uint32_t queue_family_idx;
        select_vk_physical_device(phy_dev, queue_family_idx, queue_family_idx, inst, surf);
        VkDevice device;
        VkQueue queue;
        create_vk_device(device, queue, queue, phy_dev, queue_family_idx, queue_family_idx);
        VkSwapchainKHR swpch;
        create_vk_swapchain(swpch, device, surf, queue_family_idx);
        VkRenderPass render_pass = create_render_pass(VK_FORMAT_B8G8R8A8_SRGB, device);
        VkPipeline pipeline = create_pipeline("./vert_2.spv", "frag_2.spv", 0, {0, 0}, device, {700, 500}, render_pass);
        
        uint32_t swpch_img_count;
        vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, nullptr);
        std::vector<VkImage> swpch_imgs(swpch_img_count);
        vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, swpch_imgs.data());

        std::vector<VkImageView> swpch_img_views(swpch_img_count);
        VkImageViewCreateInfo img_view_crt_info{};
        img_view_crt_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        img_view_crt_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
        img_view_crt_info.format = VK_FORMAT_B8G8R8A8_SRGB;
        img_view_crt_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};
        VkResult result;
        for (int i = 0; i < swpch_img_count; ++i)
        {
            img_view_crt_info.image = swpch_imgs[i];
            result = vkCreateImageView(device, &img_view_crt_info, nullptr, &swpch_img_views[i]);
            if (result != VK_SUCCESS)
            {
                printf("fail to create image view, error code %d\n", result);
                exit(-1);
            }
        }

        VkFramebufferCreateInfo frame_buf_crt_info{};
        frame_buf_crt_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        frame_buf_crt_info.renderPass = render_pass;
        frame_buf_crt_info.attachmentCount = 1;
        frame_buf_crt_info.width = 700;
        frame_buf_crt_info.height = 500;
        frame_buf_crt_info.layers = 1;
        std::vector<VkFramebuffer> frame_bufs(swpch_img_count);
        for (int i = 0; i < swpch_img_count; ++i)
        {
            frame_buf_crt_info.pAttachments = &swpch_img_views[i];
            result = vkCreateFramebuffer(device, &frame_buf_crt_info, nullptr, &frame_bufs[i]);
            if (result != VK_SUCCESS)
            {
                printf("fail to create frame buffer, error code: %d\n", result);
                exit(-1);
            }
        }

        VkCommandPool cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
        cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
        VkCommandBuffer cmd_buf;
        VkCommandBufferAllocateInfo cmd_buf_alc_info{};
        cmd_buf_alc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        cmd_buf_alc_info.commandBufferCount = 1;
        cmd_buf_alc_info.commandPool = cmd_pool;
        cmd_buf_alc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        result = vkAllocateCommandBuffers(device, &cmd_buf_alc_info, &cmd_buf);
        if (result != VK_SUCCESS)
        {
            printf("fail to allocate command buffer\n");
            exit(-1);
        }

        float vtxs[9] = {
            -0.5, 0, 0,
            0, 0.5, 0,
            0.5, 0, 0
        };
        VkBuffer vtx_buf;
        VkDeviceMemory vtx_buf_mem;
        create_vk_buffer(vtx_buf, vtx_buf_mem, phy_dev, device, 3 * 3 * sizeof(float), VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
        float *p_mem_data = nullptr;
        result = vkMapMemory(device, vtx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
        memcpy(p_mem_data, vtxs, sizeof(vtxs));
        vkUnmapMemory(device, vtx_buf_mem);

        uint32_t idxs[3] = {0, 1, 2};
        VkBuffer idx_buf;
        VkDeviceMemory idx_buf_mem;
        create_vk_buffer(idx_buf, idx_buf_mem, phy_dev, device, sizeof(idxs), VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
        vkMapMemory(device, idx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
        memcpy(p_mem_data, idxs, sizeof(idxs));
        vkUnmapMemory(device, idx_buf_mem);
        
        VkCommandBufferBeginInfo cmd_buf_beg_info{};
        cmd_buf_beg_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        cmd_buf_beg_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
        vkBeginCommandBuffer(cmd_buf, &cmd_buf_beg_info);
        VkDeviceSize offset = 0;
        vkCmdBindVertexBuffers(cmd_buf, 0, 1, &vtx_buf, &offset);
        vkCmdBindIndexBuffer(cmd_buf, idx_buf, 0, VK_INDEX_TYPE_UINT32);
        vkEndCommandBuffer(cmd_buf);
        return 0;
    }
    ```

    下次可以直接从这里开始。

7. [v] 调研编译器

    feedback:

    cached tasks:

    1. 习题 2.1, 2.2 可以做了

    2. 学习图 2-3，解释，背会

    3. 解释图 2-4

    4. 调研 nfa, nfa 转 dfa，lex