* uio 的目录`/sys/class/uio/uio0`

* umd driver work flow

    1. 内核空间 UIO 设备驱动程序必须在用户空间驱动程序启动之前加载（如果使用模块）
    
    2. 启动用户空间应用程序并打开 UIO 设备文件（/dev/uioX 其中 X 为 0、1、2 ...）

        从用户空间来看，UIO 设备是文件系统中的一个设备节点，就像任何其他设备一样

    3. 设备内存地址信息从相关的sysfs目录中找到，只需要大小
    
    4. 通过调用UIO驱动的mmap()函数将设备内存映射到进程地址空间
    
    5. 应用程序访问设备硬件来控制设备
    
    6. 通过调用 munmap() 取消映射设备内存
    
    7. UIO设备文件关闭

    ref: <https://zhuanlan.zhihu.com/p/556002063>

* uio umd driver example code:

    ```cpp
    #define UIO_SIZE "/sys/class/uio/uio0/maps/map0/size"

    int main( int argc, char ** argv)
    {
        int              uio_fd;
        无符号整数    uio_size;
        文件 *大小_fp;
        无效            *基地址；

        /*
        * 1. 打开 UIO 设备，使其可以使用
        */
        uio_fd = open( "/dev/uio0" , O_RDWR);

        /*
        * 2. 从大小 sysfs 文件中获取内存区域的大小
        *    属性
        */
        size_fp = fopen(UIO_SIZE, O_RDONLY);
        fscanf(size_fp, " 0x%08X " , & uio_size);

        /*
        * 3. 将设备寄存器映射到进程地址空间，以便它们
        *    可直接访问
        */
        base_address =mmap(NULL, uio_size,
                            PROT_READ| PROT_WRITE,
                            MAP_SHARED, uio_fd, 0 );

        // 现在可以访问硬件 ...

        /*
        * 4. 取消映射设备寄存器以完成
        */
        munmap(base_address, uio_size);

        ...
    }
    ```

* uio kmd example:

    ```cpp
    /*

    * This is simple demon of uio driver.

    * Version 1

    *Compile:
    *    Save this file name it simple.c
    *    #echo "obj -m := simple.o" > Makefile
    *    #make -Wall -C /lib/modules/'uname -r'/build M='pwd' modules
    *Load the module:
    *    #modprobe uio
    *    #insmod simple.ko
    */

    #include <linux/module.h>
    #include <linux/platform_device.h>
    #include <linux/uio_driver.h>
    #include <linux/slab.h>


    /*struct uio_info { 
        struct uio_device   *uio_dev; // 在__uio_register_device中初始化
        const char      *name; // 调用__uio_register_device之前必须初始化
        const char      *version; //调用__uio_register_device之前必须初始化
        struct uio_mem      mem[MAX_UIO_MAPS];
        struct uio_port     port[MAX_UIO_PORT_REGIONS];
        long            irq; //分配给uio设备的中断号，调用__uio_register_device之前必须初始化
        unsigned long       irq_flags;// 调用__uio_register_device之前必须初始化
        void            *priv; //
        irqreturn_t (*handler)(int irq, struct uio_info *dev_info); //uio_interrupt中调用，用于中断处理
        
        // 调用__uio_register_device之前必须初始化
        int (*mmap)(struct uio_info *info, struct vm_area_struct *vma); //在uio_mmap中被调用，
                                                            
        // 执行设备打开特定操作
        int (*open)(struct uio_info *info, struct inode *inode);//在uio_open中被调用，执行设备打开特定操作
        int (*release)(struct uio_info *info, struct inode *inode);//在uio_device中被调用，执行设备打开特定操作
        int (*irqcontrol)(struct uio_info *info, s32 irq_on);//在uio_write方法中被调用，执行用户驱动的
        
        //特定操作。
    };*/


    struct uio_info kpart_info = {  
            .name = "kpart",  
            .version = "0.1",  
            .irq = UIO_IRQ_NONE,  
    }; 
    static int drv_kpart_probe(struct device *dev);
    static int drv_kpart_remove(struct device *dev);
    static struct device_driver uio_dummy_driver = {
        .name = "kpart",
        .bus = &platform_bus_type,
        .probe = drv_kpart_probe,
        .remove = drv_kpart_remove,
    };

    static int drv_kpart_probe(struct device *dev)
    {
        printk("drv_kpart_probe(%p)\n",dev);
        kpart_info.mem[0].addr = (unsigned long) kmalloc(1024,GFP_KERNEL);
        
        if(kpart_info.mem[0].addr == 0)
            return -ENOMEM;
        kpart_info.mem[0].memtype = UIO_MEM_LOGICAL;
        kpart_info.mem[0].size = 1024;

        if(uio_register_device(dev,&kpart_info))
            return -ENODEV;
        return 0;
    }

    static int drv_kpart_remove(struct device *dev)
    {
        uio_unregister_device(&kpart_info);
        return 0;
    }

    static struct platform_device * uio_dummy_device;

    static int __init uio_kpart_init(void)
    {
        uio_dummy_device = platform_device_register_simple("kpart",-1,NULL,0);
        return driver_register(&uio_dummy_driver);
    }

    static void __exit uio_kpart_exit(void)
    {
        platform_device_unregister(uio_dummy_device);
        driver_unregister(&uio_dummy_driver);
    }

    module_init(uio_kpart_init);
    module_exit(uio_kpart_exit);

    MODULE_LICENSE("GPL");
    MODULE_AUTHOR("IGB_UIO_TEST");
    MODULE_DESCRIPTION("UIO dummy driver");
    ```

    ref: <https://zhuanlan.zhihu.com/p/555333046>

* uio umd example code

    ```cpp
    #include <stdio.h>
    #include <fcntl.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/mman.h>
    #include <errno.h>

    #define UIO_DEV "/dev/uio0"
    #define UIO_ADDR "/sys/class/uio/uio0/maps/map0/addr"
    #define UIO_SIZE "/sys/class/uio/uio0/maps/map0/size"

    static char uio_addr_buf[16]={0};
    static char uio_size_buf[16]={0};

    int main(void)
    {
        int uio_fd,addr_fd,size_fd;
        int uio_size;
        void *uio_addr, *access_address;
        int n=0;
        uio_fd = open(UIO_DEV,O_RDWR);
        addr_fd = open(UIO_ADDR,O_RDONLY);
        size_fd = open(UIO_SIZE,O_RDONLY);
        if(addr_fd < 0 || size_fd < 0 || uio_fd < 0){
            fprintf(stderr,"mmap:%s\n",strerror(errno));
            exit(-1);
        }

        n=read(addr_fd,uio_addr_buf,sizeof(uio_addr_buf));
        if(n<0){
            fprintf(stderr, "%s\n", strerror(errno));
            exit(-1);
        }
        n=read(size_fd,uio_size_buf,sizeof(uio_size_buf));
        if(n<0){
            fprintf(stderr, "%s\n", strerror(errno));
            exit(-1);
        }
        uio_addr = (void*)strtoul(uio_addr_buf,NULL,0);
        uio_size = (int)strtol(uio_size_buf,NULL,0);

        access_address = mmap(NULL,uio_size,PROT_READ | PROT_WRITE,
                                MAP_SHARED,uio_fd,0);
        if(access_address == (void*)-1){
            fprintf(stderr,"mmap:%s\n",strerror(errno));
            exit(-1);
        }

        printf("The device address %p (lenth %d)\n"
            "can be accessed over\n"
            "logical address %p\n",uio_addr,uio_size,access_address);
    /*
        access_address = (void*)(long)mremap(access_address, getpagesize(),uio_size + getpagesize()+ 11111, MAP_SHARED);

        if(access_address == (void*)-1){
            fprintf(stderr,"mremap: %s\n",strerror(errno));
            exit(-1);
        }

        printf(">>>AFTER REMAP:""logical address %p\n",access_address);
    */
        return 0;
    }
    ```

* 对于一个新手来说，该如何入门dpdk ?

    <https://www.zhihu.com/question/39309195/answer/2993073221>

* 虚拟化 vfio 和UIO 区别

    <https://zhuanlan.zhihu.com/p/544076987>

    这篇对 iommu 讲得挺深入的

* 深入理解 Linux 调度（GPU）虚拟化

    <https://www.sohu.com/a/494587210_121124377>

    介绍了一些背景，写得挺不错的，通俗易懂。有时间了把复制下来。