* 可以尝试每次都让挑选出来的任务放到 task tag 的最上面，这样慢慢不重要的任务就会下沉

* ssh 直接执行远程命令

    `ssh <user>@<host> <command>`可以在登陆的时候直接在远程机器上执行命令，不显示欢迎信息。

    example:

    `ssh <user>@<host> ls`

    output:

    ```
    04_local_res.cpp
    Data
    Desktop
    Documents
    Downloads
    link_mnt_hlc_to_Data.sh
    mlnx_perftest_log.txt
    Music
    nfs_shared
    nvshmem_srcs.tar.gz
    Pictures
    Public
    snap
    Softwares
    Templates
    use-proxy.sh
    Videos
    Videos-link
    ```

    如果 command 里有空格，可以用双引号包起：

    `ssh <user>@<host> "ls /tmp"`

    如果使用**双引号**括起的命令里有变量`$VAR_NAME`，那么会被解析为本地变量。如果想将其解析为远程主机上的变量，那么需要使用**单引号**将 command 括起：

    `ssh <user>@<host> 'echo $VAR_NAME'`

    如果要执行多条命令，那么可以使用和 bash 相似的技巧：

    * 用分号分隔：`ssh user@host "cmd1; cmd2"`

    * 逻辑控制：`ssh user@host "ls /tmp && echo success || echo fail"`
    
* 解析`ps -ef`

    ps 指的是 process status

    `-e`：显示所有进程（包括其他用户的进程）。

    `-f`：以完整格式（full-format）输出详细信息。

    example:

    ```
    (base) hlc@hlc-VirtualBox:~$ ps -ef
    UID          PID    PPID  C STIME TTY          TIME CMD
    root           1       0  0 09:50 ?        00:00:01 /sbin/init splash
    root           2       0  0 09:50 ?        00:00:00 [kthreadd]
    root           3       2  0 09:50 ?        00:00:00 [pool_workqueue_release]
    root           4       2  0 09:50 ?        00:00:00 [kworker/R-rcu_g]
    root           5       2  0 09:50 ?        00:00:00 [kworker/R-rcu_p]
    root           6       2  0 09:50 ?        00:00:00 [kworker/R-slub_]
    root           7       2  0 09:50 ?        00:00:00 [kworker/R-netns]
    ...
    ```

    UID：进程所属用户。

    PID：进程的唯一ID。

    PPID：父进程ID。

    C：CPU占用率。

    STIME：进程启动时间。

    TTY：启动进程的终端（?表示与终端无关，如守护进程）。

    TIME：进程占用CPU总时间。

    CMD：进程对应的完整命令或程序路径。

* centos 加入 sudo 权限

    `usermod -aG wheel 用户名`

    在 centos 中，`wheel`组有 sudo 权限。

* `sudo yum check-update`相当于`sudo apt update`

* `/proc/<PID>/environ`是一个在内存中的文件，以只读的形式存储了指定 PID 进程在启用时的环境变量信息

    example:

    `cat /proc/3273/environ`

    output:

    ```
    SYSTEMD_EXEC_PID=2451SSH_AUTH_SOCK=/run/user/1000/keyring/sshSESSION_MANAGER=local/hlc-VirtualBox:@/tmp/.ICE-unix/2235,unix/hlc-VirtualBox:/tmp/.ICE-unix/2235GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/16e4c141_024c_4318_9398_96a803c31884LANG=en_US.UTF-8XDG_CURRENT_DESKTOP=ubuntu:GNOMEPWD=/home/hlcWAYLAND_DISPLAY=wayland-0LC_IDENTIFICATION=zh_CN.UTF-8IM_CONFIG_PHASE=1...
    ```

    其形式为`key=value`，环境变量之间使用`\0`间隔。

    此文件为只读属性，无法修改。

    可以将`\0`替换为`\n`，便于阅读：

    `cat /proc/<PID>/environ | tr '\0' '\n'`

    output:

    ```
    SYSTEMD_EXEC_PID=2451
    SSH_AUTH_SOCK=/run/user/1000/keyring/ssh
    SESSION_MANAGER=local/hlc-VirtualBox:@/tmp/.ICE-unix/2235,unix/hlc-VirtualBox:/tmp/.ICE-unix/2235
    GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/16e4c141_024c_4318_9398_96a803c31884
    LANG=en_US.UTF-8
    XDG_CURRENT_DESKTOP=ubuntu:GNOME
    PWD=/home/hlc
    WAYLAND_DISPLAY=wayland-0
    LC_IDENTIFICATION=zh_CN.UTF-8
    IM_CONFIG_PHASE=1
    ...
    ```

    说明：

    1. `/proc/<PID>/environ`不是实时的，如果在程序中运行`setenv()`，那么此文件内容不会被改变。

    1. 仅允许进程所有者或 root 用户读取（权限为`-r--------`）

        这样看来，这个文件的用处似乎不大？

* `grep -F`表示不进行正则解析

    example:

    `grep -F "hello" content.txt`

    只查找`hello`字符串。

    `grep -F "a.*b" content.txt`

    匹配`a.*b`字符串。

    `grep -F`等价于`fgrep`。

* `cmake FetchContent_Declare`

    `FetchContent`可以从 github 直接源代码进行编译安装。

    usage:

    1. 声明依赖

        ```cmake
        include(FetchContent)  # 引入 FetchContent 模块

        FetchContent_Declare(
          <依赖名称>               # 自定义的依赖标识（如 googletest、fmt）
          GIT_REPOSITORY <url>    # Git 仓库地址
          GIT_TAG <commit/tag>    # 指定版本（如 v1.0.0、main）
          # 其他可选参数（如下载方式、更新策略等）
        )
        ```

    2. 下载并加载依赖

        ```cmake
        FetchContent_MakeAvailable(googletest)  # 下载并添加到构建
        ```

    3. 使用依赖

        ```cmake
        target_link_libraries(my_app PRIVATE gtest_main)
        ```

    `FetchContent_MakeAvailable()`会自动调用`add_subdirectory()`，使依赖库的`CMakeLists.txt`成为主项目的一部分，编译过程与主项目一致。

    看起来，FetchContent 要求目标仓库最好也是一个 cmake 项目，如果不是，那么它最好以源码的形式就可以用，比如 header only 项目，可解释语言的项目（js, python）等。FetchContent 不参与编译的过程。

* c++ 中聚合类与初始化

    如果一个类定义了构造函数，那么就无法自动初始化。

    example:

    ```cpp
    #include <string>
    using namespace std;

    struct A {
        string a;
        int b;
    };

    int main() {
        A obj_1({"hello", 123});
        A obj_2{"hello", 123};
        return 0;
    }
    ```

    上面是个聚合类，两种方式都可以正常初始化。

    ```cpp
    #include <string>
    using namespace std;

    struct A {
        string a;
        int b;

        A() {}
    };

    int main() {
        A obj_1({"hello", 123});  // error
        A obj_2{"hello", 123};  // error
        return 0;
    }
    ```

    由于没有对应的构造函数，上面的两种方式都会编译失败。

    ```cpp
    #include <string>
    using namespace std;

    struct A {
        string a;
        int b;

        A() {}
        A(string aa, int bb): a(aa), b(bb) {}
    };

    int main() {
        A obj_1({"hello", 123});
        A obj_2{"hello", 123};
        return 0;
    }
    ```

    上面补充了对应的构造函数，所以可以通过编译。

    `A obj_1({"hello", 123});`的含义应该是先用`{}`去生成一个匿名对象，再把这个匿名对象通过移动构造函数传给`obj_1`。所以本质还是聚合类的初始化，并不是`{}`作为 initializer list 可以存放不同类型的元素。

* rsync 可以使用`--partial`断点续传

    `--append`用于给已经传输完成的文件只传输追加内容，比如 log。

    `--progress`可以显示进度。

    `-P`等同于`--partial --progress`

    `--timeout=30`可以自动重试，不需要人为重新开始。

    scp 无断点续传功能。

    `wget`可以使用`-c`断点续传。

* gdb 中`p $rax`可以查看函数的返回值。

    `p $`返回上一个有返回值函数的返回值，如果上一个有返回值的语句是个表达式，那么返回表达式的结果。
