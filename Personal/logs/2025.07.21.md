* 如果一个任务是完成状态，那么它的 feedback 任务应该放到它的下面，如果一个任务是 P 或 O 状态，那么它的 feedback / deps 任务应该放到它的上面。

* `getenv()`, `setenv()`, `unsetenv()`用法

    这几个函数都是 c 语言中与环境变量相关的函数，在`<stdlib.h>`头文件中。

    syntax:

    ```cpp
    #include <stdlib.h>
    char *getenv(const char *name);
    int unsetenv(const char *name);
    int setenv(const char *name, const char *value, int overwrite);
    ```

    * `name`： 环境变量名。

    * `value`： 要设置的值。

    * `overwrite`： 若为 1，覆盖已存在的变量；若为 0，不覆盖。

    返回值： 成功返回`0`，失败返回`-1`。

    example:

    ```cpp
    #include <stdlib.h>
    #include <stdio.h>

    int main() {
        int ret = setenv("GREETING_MSG", "hello, world", 0);
        if (ret != 0) {
            printf("fail to set env\n");
            return -1;
        }
        const char *greeting_msg = getenv("GREETING_MSG");
        printf("greeting msg: %s\n", greeting_msg);

        ret = setenv("GREETING_MSG", "nihao", 0);
        if (ret != 0) {
            printf("fail to set env\n");
            return -1;
        }
        greeting_msg = getenv("GREETING_MSG");
        printf("greeting msg: %s\n", greeting_msg);

        ret = setenv("GREETING_MSG", "nihao", 1);
        if (ret != 0) {
            printf("fail to set env\n");
            return -1;
        }
        greeting_msg = getenv("GREETING_MSG");
        printf("greeting msg: %s\n", greeting_msg);

        return 0;
    }
    ```

    output:

    ```
    greeting msg: hello, world
    greeting msg: hello, world
    greeting msg: nihao
    ```

    这几个函数都是 POSIX 扩展，不是 C 标准，需确保系统支持。

* 可变参数宏

    ```cpp
    #include <stdio.h>

    #define INFO(...) printf(__VA_ARGS__)
    #define MSG(msg, val, ...) printf(__VA_ARGS__, msg, val)
    // #define DBG(val_1, ..., val_2) printf(__VA_ARGS__, val_1, val_2);  // error

    int main() {
        INFO("hello, world, %d\n", 123);
        MSG("nihao", 456, "msg: %s, %d\n");
        return 0;
    }
    ```

    output:

    ```
    hello, world, 123
    msg: nihao, 456
    ```

    其中`__VA_ARGS__`表示将`...`中的内容全部转移到当前位置。

    `...`只能作为最后一个参数，不能作为中间参数或第一个参数。

    `...`不能为空，如果可能为空，需要使用`##__VA_ARGS__`（GNU 扩展）或`__VA_OPT__`（C++20 支持）。

* 编译器内置宏`__FILE__`, `__LINE__`，分别表示当前文件名和行号

* `sudo -v`用于延长 sudo 的密码缓存时间

    `sudo`第一次缓存密码的时间为 15 分钟，执行`sudo -v`会重置这个计时器。

    这里的`-v`代表 validate

    通常在脚本开头检查权限，防止脚本因为 sudo 密码问题中断：

    ```bash
    if ! sudo -v; then
        echo "Error: No sudo access or incorrect password."
        exit 1
    fi
    ```

    `sudo -k`可以清空密码缓存。执行`sudo -k`不需要 sudo 密码。

* `rsync --delete`

    删除目标目录中多余的文件，使其与源目录完全一致。

* `getline()`简介

    `getline()`是 C 的一个 gpu 扩展函数，用于动态申请内存从文件或`stdin`读数据。

    `getline()`在`<stdio.h>`头文件中。

    example:

    ```c
    #include <stdio.h>
    #include <stdlib.h>

    int main() {
        char *line = NULL;
        size_t buffer_size = 0;
        ssize_t n_bytes = getline(&line, &buffer_size, stdin);
        printf("buffer size: %lu\n", buffer_size);
        printf("echo bytes: %ld, %s", n_bytes, line);
        free(line);
        return 0;
    }
    ```

    input:

    ```
    hello
    ```

    output:

    ```
    buffer size: 120
    echo bytes: 6, hello
    ```

    当`getline()`读到文件结尾（EOF）时，会返回`-1`。

    如果发现行的长度大于 120 个字节，那么`getline()`会调用`realloc()`改变 buffer size。

    `getline()`会保留行末尾的`\n`。

    用户必须手动`free(line);`释放内存。