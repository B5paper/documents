* [v] 调研`fork()`

    feedback:

    1. 调研`std::mutex`, `std::async`

    1. 调研`exec()`

    1. 调研`getpid()`, `getppid()`

    1. 调研`dup()`

* [v] 调研`fsync()`, `fcntl()`

    feedback:

    1. 调研`fdatasync()`

    1. `setvbuf()`, `setbuf()`

    1. `sync()`

    1. `fflush()`是否基本等价于调用系统调用`write()`？

    1. 页面缓存（Page Cache）

    1. radix tree

    1. `dup2()`

* [v] 调研`LIST_HEAD_INIT()`

* [v] 调研`list_del_init()`, `list_del_rcu()`, `list_lru_del()`

    feedback:

    1. `LIST_POISON1`, `LIST_POISON2`

    1. 调研如何多线程读写同一个链表，比如一个线程在循环遍历，另一个在随机添加/删除节点。

    1. 调研 rcu 链表

    1. 调研`list_lru.h`, `struct list_lru`, `list_lru_del()`

* [v] 调研多路复用（select/poll/epoll）中的多路是什么含义

    feedback:

    1. 调研`epoll`的用法

* [v] 调研 rsync 如何实时同步文件

    如果其中有个目录是远程目录，那么可以同步文件吗？

    feedback:

    1. 调研`ssh-copy-id -i`

    1. 调研`lsyncd`

        这个工具似乎是 inotifywait 和 rsync 的结合，是个比较成熟的工具。

* [v] 调研`strace`

    feedback:

    1. `openat()`

* [v] 调研`file_operations`中`.owner`有什么用

* [v] 调研`kzalloc`, `kfree`

    feedback:

    1. `kzalloc_node()`

    1. `kvzalloc()`

    1. `kfree_rcu()`

    1. `kfree_bulk()`

    1. `kfree_const()`

    1. `kfree_sensitive()`

    1. `kvfree()`

* [v] 调研`list_first_entry()`, `list_next_entry()`

    feedback:

    1. `container_of()`

    1. `list_next()`

    1. `list_empty()`

    1. `list_entry()`

* [new] 调研`fprintf(stderr, "Fork failed!\n");`是否可以`fprintf(stdout, xxx)`，如果`fprintf(stdin, xxx)`会发生什么？

