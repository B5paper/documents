* scp 使用跳板机

    如果在 ~/.ssh/config 中定义了跳板机，可以这样使用:

    ```bash
    scp -J myjump localfile.txt targetserver:/remote/path/
    ```

    其中 myjump 是在 SSH 配置中定义的跳板机别名。

    如果跳板机使用非标准端口，可以使用`-J user@host:port`格式.

    对于更复杂的跳转，可以使用逗号分隔多个跳板机: `-J user1@host1,user2@host2`.

    scp 也可以使用 proxy command:

    ```bash
    scp -o ProxyCommand="ssh -W %h:%p jumpuser@jumpserver.example.com" localfile.txt targetuser@targetserver.example.com:/remote/path/
    ```

    如果 target host 使用了非标准端口，即可以直接指定：

    ```bash
    scp -J jumpuser@jumpserver.example.com localfile.txt targetuser@targetserver.example.com:2345:/remote/path/
    ```

    也可以使用`-P`命令指定：

    ```bash
    scp -P 2345 -J jumpuser@jumpserver.example.com localfile.txt targetuser@targetserver.example.com:/remote/path/
    ```

    如果跳板机使用了非标准端口，那么只能直接指定：

    ```bash
    scp -J jumpuser@jumpserver.example.com:2222 localfile.txt targetuser@targetserver.example.com:/remote/path/
    ```

    如果使用 ssh config 文件，那么配置起来比较清晰：

    ```conf
    # ~/.ssh/config
    Host jumpserver
        HostName jumpserver.example.com
        User jumpuser
        Port 2222

    Host targetserver
        HostName targetserver.example.com
        User targetuser
        Port 2345
        ProxyJump jumpserver
    ```

    在连接的时候只需要执行：

    ```bash
    scp localfile.txt targetserver:/remote/path/
    ```

    如果使用 proxy command，那么可以使用：

    ```bash
    scp -P 2345 -o ProxyCommand="ssh -p 2222 -W %h:%p jumpuser@jumpserver.example.com" localfile.txt targetuser@targetserver.example.com:/remote/path/
    ```

* 想了想，除了 entry 和 routine 两种笔记方式，还有 planner 和 random walk 两种概念

    planner 即按照提前规划好的方式进行调研，random walk 是来兴致后的主题调研，主要依赖已经存储的知识和即时查的新知识，以及过程中的探索（观察、发现、总结）。

    这个过程有点像非线性学习，但是非线性学习也可以用在 planner 里，而这里的非线性学习，更像是极度放松情况下，想到哪走到哪的漫步。

* 对 python 中的 list 进行 unique

    1. 使用 set()（最常用）

        ```py
        my_list = [1, 2, 2, 3, 4, 4, 5]
        unique_list = list(set(my_list))
        print(unique_list)  # 输出：[1, 2, 3, 4, 5]
        ```

        注意：这种方法会打乱原列表的顺序。

    2. 使用 dict.fromkeys()（保持顺序）

        ```py
        my_list = [1, 2, 2, 3, 4, 4, 5]
        unique_list = list(dict.fromkeys(my_list))
        print(unique_list)  # 输出：[1, 2, 3, 4, 5]
        ```

    3. 使用循环（保持顺序）

        ```py
        my_list = [1, 2, 2, 3, 4, 4, 5]
        unique_list = []
        for item in my_list:
            if item not in unique_list:
                unique_list.append(item)
        print(unique_list)  # 输出：[1, 2, 3, 4, 5]
        ```

    4. 使用列表推导式（保持顺序）

        ```py
        my_list = [1, 2, 2, 3, 4, 4, 5]
        unique_list = []
        [unique_list.append(x) for x in my_list if x not in unique_list]
        print(unique_list)  # 输出：[1, 2, 3, 4, 5]
        ```

    5. 使用 collections.OrderedDict（保持顺序）

        ```py
        from collections import OrderedDict
        my_list = [1, 2, 2, 3, 4, 4, 5]
        unique_list = list(OrderedDict.fromkeys(my_list))
        print(unique_list)  # 输出：[1, 2, 3, 4, 5]
        ```

    6. 使用 pandas（适用于复杂数据结构）

        ```py
        import pandas as pd
        my_list = [1, 2, 2, 3, 4, 4, 5]
        unique_list = pd.Series(my_list).drop_duplicates().tolist()
        print(unique_list)  # 输出：[1, 2, 3, 4, 5]
        ```

    性能比较：

    * 最快：set()（但不保持顺序）

    * 保持顺序且较快：dict.fromkeys()

    * 最慢：循环方法

* 量化交易常见概念

    数据：Tushare, Baostock, AkShare 或券商API。

    风控模块 (Risk Management Module) - 系统的刹车：

    * 单笔风险：例如，任何一笔交易的最大亏损不超过总资金的2%。

    * 总仓位限制：例如，在震荡市中（ADX<25），总仓位不超过30%。

    * 最大回撤止损：如前所述，总资金回撤8%，系统强制平仓并停止交易。

    * 异常监控：如程序连续发出N个错误信号、或与市场断开连接时，如何应对。

* Alpha

    微小的、短暂的定价错误

    与市场无关

    很多量化基金（尤其是对冲基金）的目标是无论牛熊都要赚钱。这就需要他们找到不依赖市场方向的“Alpha”。

* 市场冲击成本

    * 小资金（例如：< 100万人民币）：您的买卖单像一滴水汇入大海，对股价几乎没有影响，可以按理想价格成交。

    * 中等资金（例如：100万 - 5000万）：您的单子开始变成一股水流。在买入时你会推高价格，导致平均成交价高于预期；在卖出时你会打压价格，导致平均成交价低于预期。这额外的成本，我们称之为 “冲击成本”。

        * 需要精选标的，专注于每日成交金额大于5亿、流动性好的股票。

        * 需要将大单拆分为小单，在全天分时段交易，以平滑冲击成本。

        * 收益开始衰减，但通过精细执行仍能盈利。

    * 大资金（例如：> 5000万）：您的单子像一艘大船开进小池塘。您会发现，根本无法在不剧烈影响价格的情况下建立或平掉头寸。策略的入场和出场点被自己的操作完全扭曲，预期利润被冲击成本完全吞噬，策略就此失效。

        * 标的池急剧缩小，只能交易大盘股、指数ETF或一篮子股票。

        * 必须使用复杂的交易算法（如VWAP、TWAP）来执行订单。

        * 冲击成本巨大，策略的预期年化收益可能接近甚至低于冲击成本，策略基本失效。

    一个简单的经验法则：

    * 您的单笔交易金额，最好不要超过该股票过去20个交易日平均日成交金额的1%。否则，冲击成本就会变得显著。

        举例：如果一只股票日均成交额为10亿人民币，那么您单笔下单的金额最好不要超过1000万。根据您策略中“分层仓位”的比例，就可以反推出您的总资金容量上限。

* 基金机构也有自己的苦恼，首先他们必须保持仓位，不能空仓像我一样投资自己，其次他们的资金盘对市场会产生冲击

* `ToTensor()`

    1. 数据类型转换：ToTensor() 将 PIL Image 或 numpy.ndarray 转换为 PyTorch Tensor，后续的 transforms 都需要在 Tensor 上操作

    2. 通道顺序：将 H×W×C 转换为 C×H×W，符合 PyTorch 的期望格式

    3. 数值范围：将 [0, 255] 的整数或 [0, 1] 的浮点数转换为 [0.0, 1.0] 的浮点数

    变换前后数据 shape 对比：

    ```py
    # 对于 RGB 图像
    (H, W, C) = (224, 224, 3)
    # 变换后
    (C, H, W) = (3, 224, 224)

    # 对于灰度图像  
    (H, W) = (224, 224)  # 或 (H, W, 1)
    # 变换后
    (1, H, W) = (1, 224, 224)
    ```

* `transforms.Normalize()`

    example:

    `transforms.Normalize((0.5,), (0.5,))`作用如下：

    ```py
    # 对于每个像素值：
    normalized_pixel = (pixel - mean) / std

    # 具体到你的例子：
    normalized_pixel = (pixel - 0.5) / 0.5
    ```

    如果 RGB 三个通道的 mean 和 std 相同，那么可以写成：

    ```py
    transforms.Normalize(mean, std)
    ```

    如果是多通道图像，那么可以写成：

    ```py
    # RGB 图像归一化
    transform = transforms.Compose([
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.5, 0.5, 0.5],  # R, G, B 通道的均值
                             std=[0.5, 0.5, 0.5])   # R, G, B 通道的标准差
    ])
    ```

    为什么要归一化？

    * 训练稳定性：将数据缩放到相似的范围，避免梯度爆炸

    * 收敛速度：帮助优化器更快收敛

    * 模型性能：很多模型假设输入数据是零均值的

    * 数值精度：在 [-1, 1] 范围内计算更稳定