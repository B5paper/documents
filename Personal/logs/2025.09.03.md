* 强调条件限定的前提是能联想到多个方向的例子，甚至反例

    比如“我们在修订法律时总是考虑完美执行的情况，但是毕竟法律需要人去执行，所以最终的效果并不只有条文的效力，还有人的参与”。“毕竟法律需要人去执行”，这个说法十年前可能是对的，但在今天可能有 AI 参与了，翻阅相似案件，做出判决，都有可能是 AI 去执行，那么这个限定条件的强调，其实是考虑到了人和 AI 这两种可能性。

* `request_irq()`

    内核注册一个中断处理程序（中断服务例程，ISR）

    syntax:

    ```c
    int request_irq(unsigned int irq,
                    irq_handler_t handler,
                    unsigned long flags,
                    const char *name,
                    void *dev_id);
    ```

    返回值：

    * 成功时返回 0。

    * 失败时返回一个错误码（负值），如 -EBUSY（中断线已被占用且不可共享）。

    中断标志设置: 通过 flags 参数设置中断的行为特性，常见的标志包括：

    * `IRQF_SHARED`：允许与其他驱动程序共享同一条中断线。这在中断资源紧张的系统（如基于 PCI 的系统）中很常见。

    * `IRQF_ONESHOT`：中断在处理完毕后需要重新显式启用（用于线程化中断）。

    * `IRQF_TIMER`：标记这是一个定时器中断，系统可能会对其进行特殊处理（如不会被暂停）。

    * `IRQF_IRQPOLL`：用于共享中断中的轮询处理。

    配对函数：`free_irq()`

* `unlocked_ioctl`与`compat_ioctl`有何不同

    syntax:

    ```c
	long (*unlocked_ioctl) (struct file *filp, unsigned int cmd, unsigned long arg);

    long (*compat_ioctl) (struct file *filp, unsigned int cmd, unsigned long arg);
    ```

    unlocked_ioctl：现代的标准方法，用于处理所有常规的 ioctl 调用。它的主要特点是不再持有 Big Kernel Lock (BKL)，因此得名 “unlocked”。

    compat_ioctl：兼容性方法，专门用于为32位应用程序在64位内核上提供兼容性支持。

* 关于头文件中函数声明的 static

    如果`add()`的声明和定义如下：

    ```cpp
    // lib_1.h
    #ifndef LIB_1_H
    #define LIB_1_H

    static int add(int a, int b);

    #endif

    // lib_1.cpp
    #include "lib_1.h"

    int add(int a, int b) {
        return a + b;
    }
    ```

    那么在编译`g++ -c lib_1.cpp -o lib_1.o`时，`add()`函数的实现会变成不可见的。

    此时别的库去 include `lib_1.h`，比如

    ```cpp
    // lib_2.h
    #ifndef LIB_2_H
    #define LIB_2_H

    int sum(int a, int b, int c);

    #endif

    // lib_2.cpp
    #include "lib_2.h"
    #include "lib_1.h"

    int add(int a, int b);

    int sum(int a, int b, int c) {
        return add(add(a, b), c);
    }
    ```

    编译`g++ -c lib_2.cpp -o lib_2.o`时会 warning `add()`没有函数体：

    ```
    g++ -g main_3.cpp lib_1.o lib_2.o -o main
    In file included from main_3.cpp:1:
    lib_1.h:4:12: warning: ‘int add(int, int)’ used but never defined
        4 | static int add(int a, int b);
          |            ^~~
    ```

    由于编译`lib_2.o`没有涉及到 link 过程，所以到这里仍能生成`lib_2.o`.

    到了编译`main`时，涉及到 link 过程:

    ```cpp
    // main.cpp
    #include "lib_1.h"
    #include "lib_2.h"
    #include "stdio.h"

    int main() {
        int a = 1, b = 2;
        int c = add(a, b);
        printf("%d + %d = %d\n", a, b, c);

        int d = sum(a, b, c);
        printf("%d + %d + %d = %d\n", a, b, c, d);
        return 0;
    }
    ```

    `g++ main.cpp lib_1.o lib_2.o -o main`，会发现仍然找不到`add()`的定义，从而报错：

    ```
    g++ -g main.cpp lib_1.o lib_2.o -o main
    In file included from main.cpp:1:
    lib_1.h:4:12: warning: ‘int add(int, int)’ used but never defined
        4 | static int add(int a, int b);
          |            ^~~
    /usr/bin/ld: /tmp/ccMTEjk1.o: in function `main':
    /home/hlc/Documents/Projects/cpp_test/main.cpp:7: undefined reference to `add(int, int)'
    /usr/bin/ld: lib_2.o: in function `sum(int, int, int)':
    /home/hlc/Documents/Projects/cpp_test/lib_2.cpp:7: undefined reference to `add(int, int)'
    /usr/bin/ld: /home/hlc/Documents/Projects/cpp_test/lib_2.cpp:7: undefined reference to `add(int, int)'
    collect2: error: ld returned 1 exit status
    make: *** [Makefile:10: main] Error 1
    ```

    因此可以得出结论，`static`函数只影响编译对应`.c` / `.cpp`文件的`.o`。

    那么我们一口气把所有 cpp 文件都合一起编译链接会怎样？`g++ lib_1.cpp lib_2.cpp main_3.cpp -o main`的输出仍然报错。看来这个命令有可能只是先生成`.o`，再链接`.o`和`main`的简写版，并不能简化编译过程。