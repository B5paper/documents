* sed

    examples:

    * 文件处理

        ```bash
        # 替换文件内容并保存（-i选项）
        sed -i 's/foo/bar/g' file.txt

        # 备份原文件并替换
        sed -i.bak 's/foo/bar/g' file.txt

        # 删除HTML标签
        sed 's/<[^>]*>//g' file.html
        ```

    * 文本转换

        ```bash
        # 将DOS换行符(CRLF)转换为UNIX换行符(LF)
        sed 's/\r$//' file.txt

        # 在每行行首添加内容
        sed 's/^/# /' file.txt

        # 在每行行尾添加内容
        sed 's/$/ --- EOF/' file.txt
        ```

    * 高级用法

        ```bash
        # 使用正则表达式分组
        echo "abc123" | sed 's/\([a-z]*\)[0-9]*/\1/g'

        # 多点编辑（多个命令）
        sed -e 's/foo/bar/g' -e '/baz/d' file.txt

        # 使用其他分隔符（当路径包含/时）
        sed 's|/usr/local|/opt|g' file.txt
        ```

* connect bot 本身并没有 -o ServerAliveInterval 的功能，长时间不发送数据，会导致自动断开连接

* sed 中，大部分命令需要使用单引号`''`包裹起来，防止 bash 预处理

    比如要替换点号`.`，需要写成`sed 's/\./new_char/ file.txt'`

* sed 中的正则表达式

    在 `s/old/new/` 中，old 会被 sed 解释为基本正则表达式（BRE，Basic Regular Expression）。

    这意味着：

    * 一些特殊字符需要转义才能使用其正则含义（如 `\+`、`\?`、`\{m,n\}`）

    * `^`、`$`、`.`、`*`、`[ ]` 等与正则表达式中含义相同

    * 如果要使用扩展正则表达式（ERE），需要加 `-E` 或 `-r` 选项

    new 部分不是正则表达式：new 是替换文本，但有特殊含义：

    * & 表示匹配到的整个内容

    * \1、\2 等表示捕获组（如果 old 中用了 \(\)）

    * \ 用于转义特殊字符或引入特殊序列

    example:

    ```bash
    # 基本正则表达式（默认）
    sed 's/^old/new/'      # ^ 是正则锚点
    sed 's/old\./new/'     # \. 匹配字面点号
    sed 's/\(old\)/\1/'    # \(\) 是捕获组

    # 扩展正则表达式（-E 选项）
    sed -E 's/old+/new/'   # + 直接表示"一个或多个"
    sed -E 's/(old)/\1/'   # () 直接是捕获组
    ```

    如果文本包含 /，可以换其他分隔符：`s#old#new#`，`sed 's|old|new|g' test.txt`

* `sed -i <pattern> <file>`会直接修改原文件

* sed 实际应用场景

    ```bash
    # 提取IP地址
    ifconfig | sed -n '/inet /p' | sed 's/.*inet //' | sed 's/ netmask.*//'

    # 格式化日志文件
    sed -n '/ERROR/p' app.log | sed 's/ERROR/\\033[31mERROR\\033[0m/'

    # 批量重命名文件
    ls *.txt | sed 's/\(.*\)\.txt/mv "&" "\1.html"/' | sh
    ```

    常用选项

    * -n：安静模式，只显示处理后的行

    * -i：直接修改文件

    * -e：执行多个sed命令

    * -r：使用扩展正则表达式

* 梯度权重

    在 PyTorch 中，y.backward() 的参数表示的是梯度权重（gradient weights），也称为 v 或 grad_output。

    y.backward(gradient) 中的 gradient 参数表示 y 对自身的梯度，即 ∂y/∂y。在标量情况下通常默认为 1，但在张量情况下需要显式指定。

    如果 `y` 是向量（多维）时，torch 会自动构造一个 sum 表达式，`y' = w_1 * y_1 + w_2 * y_2 + ... + w_n * y_n`，最终求导是对 `y'` 求导。

    `y.backward(v)`计算的是`∂(v·y)/∂x = vᵀ · ∂y/∂x`。

    当 y 是多维张量时，PyTorch 确实会：

        自动构造一个标量函数：y' = w₁·y₁ + w₂·y₂ + ... + wₙ·yₙ

        使用你提供的权重：w = [w₁, w₂, ..., wₙ] 就是 backward() 中的参数

        对 y' 求导：最终计算的是 ∂y'/∂x，而不是直接计算 ∂y/∂x

    example:

    ```py
    from hlc_utils import *

    x = t.tensor([1, 2, 3], dtype=t.float, requires_grad=True)
    y = x**2
    y.backward(t.tensor([1, 1, 1]))
    print('y:', y)
    print('x.grad:', x.grad)

    x.grad.zero_()
    y = x**2
    y[0].backward()
    # y[1].backward()  # error, 计算图只能 backward 一次
    # y[2].backward()
    print('y:', y)
    print('x.grad:', x.grad)
    ```

    output:

    ```
    y: tensor([1., 4., 9.], grad_fn=<PowBackward0>)
    x.grad: tensor([2., 4., 6.])
    y: tensor([1., 4., 9.], grad_fn=<PowBackward0>)
    x.grad: tensor([2., 0., 0.])
    ```

    还可以调用`t.autograd.backward()`:

    ```py
    x = t.tensor([1, 2, 3], dtype=t.float, requires_grad=True)
    y = x**2
    t.autograd.backward([y[0], y[1]])
    print('y:', y)
    print('x.grad:', x.grad)
    ```

    output:

    ```
    y: tensor([1., 4., 9.], grad_fn=<PowBackward0>)
    x.grad: tensor([2., 4., 6.])
    y: tensor([1., 4., 9.], grad_fn=<PowBackward0>)
    x.grad: tensor([2., 4., 0.])
    ```

* FreeRDP2

    FreeRDP 是一个开源的 RDP 客户端和服务器端库。`freerdp2-x11`和`freerdp2-wayland`是它的命令行工具`xfreerdp`的两个后端。

    * `freerdp2-x11`

        这是 RDP 客户端 在 X11 显示系统下的主程序。你用它来连接远程的 Windows 机器或其他 RDP 服务器。

    * `freerdp2-wayland`

        同样是 RDP 客户端，它使用 Wayland 原生接口进行渲染，而不是 X11。

    * `freerdp2-shadow-x11`

        这是 FreeRDP 的 “影子服务器” 或 “桌面共享” 组件。它用于将本机的 X11 桌面会话共享出去，供其他 RDP 客户端连接。

        它捕获当前 X11 显示器的输出，将其作为一个 RDP 会话对外提供。其他用户可以使用任意的 RDP 客户端（如 Windows 自带的 mstsc.exe、Android 客户端、或 xfreerdp 本身）来接入你的当前桌面。

        它不是客户端，而是一个服务端。但它不创建新的桌面会话，只是“投影”现有会话。

        通常通过命令行启动，例如 xfreerdp-shadow-subsystem。

    通常 xfreerdp 可以自动选择后端，但是我们也可手动指定后端：

    ```bash
    # 强制使用 X11 后端（即使在 Wayland 会话中）
    xfreerdp /b:x11 ...

    # 强制使用 Wayland 后端
    xfreerdp /b:wayland ...
    ```

* `xrdp`

    这是一个 独立的、完整的 RDP 服务器 软件。它运行在 Linux 系统上，等待来自 RDP 客户端的连接请求。

    为了提供桌面，`xrdp` 需要依赖一个后端的图形会话管理器。最常见的是：

    * Xvnc：xrdp 会启动一个 VNC 服务器（如 TigerVNC、X11VNC）来承载桌面，然后 xrdp 在 RDP 和 VNC 协议之间进行转换。这是最常见的配置。

    * Xorg：较新的版本支持使用一个专门的 Xorg 会话作为后端（xrdp-xorg 模块），性能比 VNC 模式更好。

    与 FreeRDP 模块的核心区别：

    * xrdp 是一个常驻的系统服务（systemd 服务），监听 3389 端口，允许多个用户建立独立的、全新的桌面会话（登录屏幕 -> 输入用户名密码 -> 进入一个独立的桌面环境）。

    * freerdp2-shadow-x11 是一个临时工具，用于共享已经登录的、正在使用的现有桌面会话。它不提供登录管理器，不创建新会话。

* 查看当前 session 是 x11 还是 wayland

    `echo $XDG_SESSION_TYPE`

    output:

    `wayland`

* 1D 卷积