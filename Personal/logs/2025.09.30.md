* 每日任务模板初始版，完成版

    初始版：

    ```md
    * [ ] reorg: documents 30 mins

    * [ ] reorg: projects 30 mins

    * [ ] qa: 2 units 30 mins

    * [ ] cache tabs 30 mins

    * [ ] process tabs 30 mins

    * [ ] process 1 tab

    * [ ] task 1 xx mins

    * [ ] task 2 xx mins

    * [ ] qa: review 30 mins
    ```

    完成版：

    ```md
    * [ ] reorg: documents 30 mins 09.17

        10:13 ~ 10:25

    * [ ] reorg: projects 30 mins 09.17

        10:13 ~ 10:25

    * [ ] qa: 2 units 30 mins 09.17

        10:13 ~ 10:25

        正确率： 1 / 2

    * [ ] cache tabs 30 mins 09.17

    * [ ] process tabs 30 mins 09.17

    * [ ] process 1 tab 09.17

    * [ ] task 1 xx mins

    * [ ] task 2 xx mins

    * [ ] qa: review 30 mins
    ```

* `#if ! MY_MACRO`

    检查宏 MY_MACRO 是否未定义或值为0，如果满足条件，则编译其后的代码。

    `!`与变量之间也可以没有空格：`#if !MY_MACRO`

    等价于`#if !defined(MY_MACRO) || MY_MACRO == 0`

* `@echo "The process ID in Make is: $(shell echo $$PPID)"`

    显示当前执行 make 进程的父进程 ID

    其中，`$$`被转义为`$`, `$PPID`是 shell 变量，表示父进程 ID。

    如果直接使用单个美元符号，`@echo "PID: $(shell echo $PPID)"`，那么会：

    1. make 首先展开：$P 被 make 当作变量 P 的引用

    2. make 看到 $P：尝试展开 make 变量 P（如果未定义就是空）

    3. 最终执行：echo （空字符串）+ PID

    make 不区分单双引号，都当作普通字符

* 常用的 loss

    ```py
    #import nn module
    import torch.nn as nn
    mse_loss_fn = nn.MSELoss()

    loss = mse_loss_fn(predicted_value, target)
    #predicted value is what the model is predicting 
    #target is the actual value
    ```

    * L1 loss

        The L1 loss function also called Mean Absolute Error (MAE) computes the average of the sum of absolute differences between the predicted and the actual values.

        Formula: 

        $\mathcal L_{L1} (y, \hat y) = \frac 1 n \sum_{i=1}^n \lvert y_i - \hat y_i\rvert$

        Here,

        * $n$ represents the total number of observations or samples

        * $y_i$ represents the actual or observed value for the i-th sample,

        * $\hat y_i$ represents the predicted or estimated value for the i-th sample.

        L1 loss is mostly used for regression problems and is more robust to outliers.

        syntax:

        ```py
        torch.nn.L1Loss(size_average=None, reduce=None, reduction='mean')
        ```

        example:

        ```py
        import torch
        from torch import nn

        #initialising the loss function
        loss = nn.L1Loss()
        #randomly initialising the input and the target value...input is considered as predicted value here.
        input = torch.randn(2, 4, requires_grad=True)
        target = torch.randn(2, 4)
        #passing both the values inside the loss function.
        output = loss(input, target)
        #backpropagation
        output.backward()
        print(output)
        ```

        output:

        ```
        tensor(1.1041, grad_fn=<MeanBackward0>)
        ```

        Advantage:

        * MAE is more robust to outliers compared to Mean Squared Error (MSE) because it takes the absolute difference, reducing the impact of extremely large errors.

        * The MAE loss is straightforward to interpret as it represents the average magnitude of errors, making it easier to communicate the model's performance to stakeholders.

        Disadvantage:

        * MAE treats all errors equally, regardless of their magnitude. This can be a disadvantage in cases where distinguishing between small and large errors is important.

        * The gradient of MAE is a constant value, which can slow down convergence during optimization, especially in comparison to MSE, where the gradient decreases as the error decreases.

* `Eigen::SparseMatrix`

    Eigen::SparseMatrix 是 Eigen 库中用于表示和操作稀疏矩阵的模板类。

    install:

    `sudo apt install libeigen3-dev`

    头文件被安装在：`/usr/include/eigen3`

    这似乎是一个 header-only 的模板库，所以没有库文件。

    example:

    ```cpp
    #include <eigen3/Eigen/Sparse>
    #include <cstdio>
    #include <vector>

    int main() {
        // 创建稀疏矩阵
        Eigen::SparseMatrix<double> mat(1000, 1000);

        // 使用 triplet 插入非零元素
        std::vector<Eigen::Triplet<double>> triplets;
        triplets.push_back({0, 0, 3.14});  // (行, 列, 值)
        triplets.push_back({1, 2, 2.71});

        mat.setFromTriplets(triplets.begin(), triplets.end());

        // 稀疏矩阵运算
        Eigen::SparseMatrix<double> mat2 = mat * mat.transpose();
        
        return 0;
    }
    ```

    当矩阵密度 < 5% 时，Eigen::SparseMatrix 在内存和计算效率上显著优于稠密矩阵。

* `pci_read_config_dword()`

    pci_read_config_dword() 是一个用于读取 PCI/PCIe 设备配置空间中一个双字（32 位）数据的函数。

    PCI/PCIe 设备的配置空间是一个标准化的寄存器区域，包含设备ID、厂商ID、资源分配（BAR）、设备类别等重要信息。

    syntax:

    ```c
    #include <linux/pci.h>

    int pci_read_config_dword(struct pci_dev *pdev, int offset, u32 *value);
    ```

    * pdev：指向 PCI 设备结构体 pci_dev 的指针

    * offset：要读取的配置空间偏移地址（字节偏移）

    * value：输出参数，用于存储读取到的32位数据

    返回值：

    成功时返回 0, 失败时返回错误码

    * example 1:

        ```c
        #include <linux/pci.h>

        struct pci_dev *pdev;
        u32 config_value;
        int ret;

        // 读取设备ID和厂商ID（偏移0x00）
        ret = pci_read_config_dword(pdev, 0x00, &config_value);
        if (ret == 0) {
            u16 vendor_id = config_value & 0xFFFF;
            u16 device_id = (config_value >> 16) & 0xFFFF;
            printk("Vendor: 0x%04x, Device: 0x%04x\n", vendor_id, device_id);
        }

        // 读取BAR0（偏移0x10）
        pci_read_config_dword(pdev, PCI_BASE_ADDRESS_0, &config_value);
        ```

    * example 2:

        ```c
        // 高级方式：使用专用函数
        int msi_cap = pci_find_capability(pdev, PCI_CAP_ID_MSI);
        if (msi_cap) {
            // 然后用 pci_read_config_dword 读取具体寄存器
            pci_read_config_dword(pdev, msi_cap + PCI_MSI_ADDRESS_LO, &address_lo);
        }

        // 底层方式：手动遍历（不推荐）
        u8 pos = PCI_CAPABILITY_LIST;
        pci_read_config_byte(pdev, pos, &pos);
        while (pos) {
            pci_read_config_dword(pdev, pos, &header);
            if ((header & 0xFF) == PCI_CAP_ID_MSI) {
                break; // 找到 MSI Capability
            }
            pci_read_config_byte(pdev, pos + 1, &pos); // 下一个
        }
        ```

    函数家族：

    ```c
    // 读取字节（8位）
    int pci_read_config_byte(struct pci_dev *pdev, int offset, u8 *value);

    // 读取字（16位）  
    int pci_read_config_word(struct pci_dev *pdev, int offset, u16 *value);

    // 写入双字（32位）
    int pci_write_config_dword(struct pci_dev *pdev, int offset, u32 value);
    ```

* `pci_find_ext_capability()`

    pci_find_ext_capability() 是用于查找 PCIe 设备扩展能力（Extended Capability） 的函数。

    syntax:

    ```c
    #include <linux/pci.h>

    int pci_find_ext_capability(struct pci_dev *dev, int cap);
    ```

    常见的 PCIe 特有的高级功能：

    * 高级错误报告（AER） - PCI_EXT_CAP_ID_AER

    * 虚拟通道（VC） - PCI_EXT_CAP_ID_VC

    * 设备序列号 - PCI_EXT_CAP_ID_DSN

    * 电源预算 - PCI_EXT_CAP_ID_PWR

    * 多功能 - PCI_EXT_CAP_ID_MFVC

    与 pci_find_capability() 的区别:

    | 特性 | pci_find_capability() | pci_find_ext_capability() |
    | - | - | - |
    | 能力类型 | 传统 PCI 能力 | PCIe 扩展能力 |
    | 搜索范围 | 0x40-0xFF | 0x100-0xFFF |
    | 链表结构 | 单字节 Next 指针 | 双字节 Next 指针 |
    | 典型能力 | MSI、MSI-X、电源管理 | AER、VC、设备序列号 |

* `const ncclTopoGraph *const *const graphs;`

    各层 const 的含义：

    ```c
    const ncclTopoGraph *const *const graphs;

    // 1. 不能修改 graphs 指针本身（最右边的 const）
    graphs = other_graphs;  // ❌ 错误

    // 2. 不能修改 graphs 指向的指针数组中的指针（中间的 const）
    graphs[0] = other_graph_ptr;  // ❌ 错误

    // 3. 不能通过指针修改 ncclTopoGraph 对象的内容（最左边的 const）
    graphs[0]->some_field = value;  // ❌ 错误
    ```

* 如果 ssh 只指定`-N`，不指定`-f`，那么不会进入 remote host 的登陆界面

    输出如下：

    ```
    (base) hlc@hlc-VirtualBox:~$ ssh -N <user>@<host>


    ```

    正常情况下会有登陆提示：

    ```
    (base) hlc@hlc-VirtualBox:~$ ssh <user>@<host>
    Last login: Fri Sep 19 13:23:07 2025 from 10.129.8.115
    hlc@lab-sw1:~$ 

    ```

* `re.findall()`的作用

    example:

    ```py
    import re

    text = 'hello, world'
    pat = r'l+l'
    ret = re.findall(pat, text)
    print(ret)  # ['ll']

    text = 'name: zhangsan, age: 14; name: liming, age: 15; name: wangwu, age: 16;'
    pat = r'name: \w+, age: \d+;'
    ret = re.findall(pat, text)
    print(ret)  # ['name: zhangsan, age: 14;', 'name: liming, age: 15;', 'name: wangwu, age: 16;'

    # 使用 () 提取出想要的具体数值
    pat = r'name: (\w+), age: (\d+);'
    ret = re.findall(pat, text)
    print(ret)  # [('zhangsan', '14'), ('liming', '15'), ('wangwu', '16')]
    ```

    重要特性:

    1. 非重叠匹配

        ```py
        text = "aaa"
        matches = re.findall(r'aa', text)
        print(matches)  # ['aa'] 只匹配一次，不重叠
        ```

    1. 空匹配处理

        ```py
        text = "a1b2c"
        matches = re.findall(r'\d*', text)
        print(matches)  # ['', '1', '', '2', ''] 包含空匹配
        ```

    1. 使用 flags 参数

        ```py
        text = "Hello WORLD"
        # 忽略大小写
        matches = re.findall(r'hello', text, re.IGNORECASE)
        print(matches)  # ['Hello']
        ```

    与相似函数的区别:

    | 函数 | 返回值 | 用途 |
    | `re.findall()` | 列表，所有匹配的字符串或元组 | 提取所有匹配内容 |
    | `re.finditer()` | 迭代器，返回匹配对象 | 需要匹配的详细信息 |
    | `re.search()` | 第一个匹配的匹配对象 | 只找第一个匹配 |
    | `re.match()` | 开头匹配的匹配对象 | 只匹配字符串开头 |

    example:

    ```py
    # 提取日志中的IP地址
    log = "192.168.1.1 - GET /home, 10.0.0.1 - POST /login"
    ips = re.findall(r'\b(?:\d{1,3}\.){3}\d{1,3}\b', log)
    print(ips)  # ['192.168.1.1', '10.0.0.1']

    # 提取HTML标签内容
    html = "<h1>标题</h1><p>段落内容</p>"
    contents = re.findall(r'<[^>]+>(.*?)</[^>]+>', html)
    print(contents)  # ['标题', '段落内容']
    ```