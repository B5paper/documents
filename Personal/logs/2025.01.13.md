* nccl tmp

    * `ld_volatile_global()`在`Primitives::loadStepValue()`中被调用

    * 每个 chunk 中包含有多个 slice，每个 slice, 中包含有多个 step，每个 step 又有 stepSize

    * load step value 是否和这里的 step 有关系？

    * waitPeer()  ->  here 3, 4, 5, 7

    * `st_relaxed_sys_global()`由`postPeer()`调用

    * `genericOp()`的 DirectSend1, DirectRecv1, Send, Recv 只可能取 0 或 1

        当 send 或 direct send 时，SrcBuf 为 Input，当 send from output 时，SrcBuf 为 Output。无论是哪一种 send，DstBuf 总为 -1。

        当 copy send / direct copy send 时，SrcBuf 和 DstBuf 都会被填，分别被填 Input 和 Output。
        
        看来 Input 和 Output 分别指明了 SrcBuf 和 DstBuf 的用途，并没有其他特别的含义。问题：这样模板化有什么好处？

        Input 和 Output 在 Primitives 类中被写死。无论是哪种协议，Input 总为 0，Output 总为 1.

        当 recvSend 时，SrcBuf 和 DstBuf 都是 -1，看起来是不做缓存，接收到数据后直接再传输出去？

    * DirectSend 一定是 Send，Send 不一定是 DirectSend。Recv 同理。

* 推理 nccl 有点像玩扫雷

* 未知概念的非线性搜索范围

    一个初步的方案：假如概念 1 没有理解，可以暂时跳过，继续看后面的东西。假如看到了概念 2，概念 2 依赖于概念 1，概念 3 也依赖概念 1，但是概念 3 与概念 2 是独立的，那么可以借助概念 2 和 3 理解概念 1. 假如概念 4 依赖概念 2，而概念 2 还没弄明白，那么就应该停止了。

* 电脑前集中注意力的方法

    1. 解释看到的每一个词语/代码变量的意思，如果可以解释，那么解释一句话/一行代码是什么意思。如果又可以解释，那么尝试解释一段话/一段代码的含义以及为什么要写这段话/这段代码。

    2. 如果在解释的过程中遇到困难，那么尝试去解决问题

    3. 如果代码都可以解释，那么尝试复现代码，重写一遍
    
