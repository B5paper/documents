* nccl tmp

    * `ld_volatile_global()`在`Primitives::loadStepValue()`中被调用

    * 每个 chunk 中包含有多个 slice，每个 slice, 中包含有多个 step，每个 step 又有 stepSize

    * load step value 是否和这里的 step 有关系？

    * waitPeer()  ->  here 3, 4, 5, 7

    * `st_relaxed_sys_global()`由`postPeer()`调用

    * `genericOp()`的 DirectSend1, DirectRecv1, Send, Recv 只可能取 0 或 1

        当 send 或 direct send 时，SrcBuf 为 Input，当 send from output 时，SrcBuf 为 Output。无论是哪一种 send，DstBuf 总为 -1。

        当 copy send / direct copy send 时，SrcBuf 和 DstBuf 都会被填，分别被填 Input 和 Output。
        
        看来 Input 和 Output 分别指明了 SrcBuf 和 DstBuf 的用途，并没有其他特别的含义。问题：这样模板化有什么好处？

        Input 和 Output 在 Primitives 类中被写死。无论是哪种协议，Input 总为 0，Output 总为 1.

        当 recvSend 时，SrcBuf 和 DstBuf 都是 -1，看起来是不做缓存，接收到数据后直接再传输出去？

    * DirectSend 一定是 Send，Send 不一定是 DirectSend。Recv 同理。

* 推理 nccl 有点像玩扫雷