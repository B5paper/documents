* 有关效率的进度

    创建任务管理系统 -> 通过系统来提升效率 -> 在同样的时间内完成超越别组的任务 -> 等待其他组/人的进度 -> 挤出些许自由时间 -> 进行算法的调研和验证 -> 做出创新

    目前看来，这条设想进行得不错。

* 有关算法创新的进度

    选择一个需要大量 coding 的工作，锻炼 coding 能力，实现脑中所想皆可用代码验证（目前选择了驱动） -> 进行算法创新

    目前看来这条设想也是对的。确实有了大量 coding 的机会，但是又不仅限于增删查改，许多中等算法题目得到了应用，非常不错。

* cpp decltype

    `auto`要求变量必须初始化，而`decltype`不要求。因为`auto`是根据变量的初始值来推导出变量类型的，而`decltype`可以写成下面的形式：

    ```cpp
    decltype(exp) varname;
    ```

    当`decltype`作用于函数时，函数并没有被调用：

    ```cpp
    #include <iostream>
    using namespace std;

    int my_func(int a, int b)
    {
        printf("in my_func()...\n");
        return a + b;
    }

    int main()
    {
        decltype(my_func(1, 2)) c = 123;
        printf("c = %d\n", c);
        return 0;
    }
    ```

    output:

    ```
    c = 123
    ```

    如果使用`()`包裹一个变量，或者在`decltype()`中填返回左值的表达式，就会被推导成引用：

    ```cpp
    #include <iostream>
    using namespace std;

    int main()
    {
        int a = 1, b = 2;
        // decltype((a)) c = 3;  // error, c is a int&
        // decltype(b = a + b) c = 3;  // error, c is a int&
        decltype(3) c = 3;  // ok, c is a int
        decltype(a + b) d = 3;  // ok, d is a int
        decltype((a + b)) e = 3;  // ok, e is a int
        return 0;
    }
    ```

* cpp 初始化 struct / class 中的 static 变量时，必须这样写：

    ```cpp
    #include <iostream>
    using namespace std;

    struct MyStruc
    {
        static int aaa;
    };

    int MyStruc::aaa = 123;

    int main()
    {
        printf("aaa: %d\n", MyStruc::aaa);
        return 0;
    }
    ```

    output:

    ```
    aaa: 123
    ```

