* graph 中的 vertex 不加 id 属性不好序列化

    如果 vertex 间只有指针指来指去，那么在序列化的时候，就无法分辨两个 vertex 是否相同。

* 只要`unique_ptr`被销毁，都会释放它管理的指针

    ```cpp
    #include <memory>
    #include <stdio.h>
    #include <vector>
    using namespace std;

    int main() {
        int *val = new int;
        *val = 123;
        {
            unique_ptr<int> ptr(val);
        }
        printf("val: %d\n", *val);  // 2057505187

        val = new int;
        *val = 456;
        {
            vector<unique_ptr<int>> vec;
            vec.push_back(unique_ptr<int>(val));
        }
        printf("val: %d\n", *val);  // -63012009

        return 0;
    }
    ```

    可以看到，无论是直接创建`unique_ptr`，还是在`vector`中添加`unique_ptr`，只要`unique_ptr`被析构，它就会释放指针。

* `make_unique()`

    `make_unique()`会自动调用`new`，因此我们只需要传入构造函数的参数就可以了。

    ```cpp
    // C++14 后推荐使用 make_unique（更安全，避免显式 new）
    unique_ptr<int> ptr2 = std::make_unique<int>(100);
    ```

* `unique_ptr`的特点

    1. 不能复制：`unique_ptr`禁止拷贝构造和拷贝赋值（保证独占性）。

    2. 可以移动：通过`std::move`转移所有权。

        ```cpp
        auto ptr3 = std::move(ptr1);  // ptr1 变为 nullptr，所有权转移给 ptr3
        ```

    资源的释放与重置：

    ```cpp
    ptr3.reset();           // 释放资源并将 ptr3 置为 nullptr
    ptr3.reset(new int(5)); // 释放旧资源，管理新资源
    ```

    资源访问：

    ```cpp
    if (ptr2) {                     // 检查是否持有资源
        std::cout << *ptr2 << "\n"; // 解引用访问数据
        std::cout << ptr2.get() << "\n"; // 获取原始指针（谨慎使用）
    }
    ```

    ```cpp
    ptr.release()  // 返回原始指针并放弃管理权（需手动释放）。
    ```

* `unique_ptr`自定义删除器

    默认使用 delete 释放资源，但支持自定义删除器（如文件句柄、C 风格数组等）：

    ```cpp
    // 使用 lambda 自定义删除器
    auto fileDeleter = [](FILE* f) { fclose(f); };
    std::unique_ptr<FILE, decltype(fileDeleter)> filePtr(fopen("test.txt", "r"), fileDeleter);

    // 管理动态数组（自动调用 delete[]）
    std::unique_ptr<int[]> arrPtr(new int[10]{1, 2, 3});
    ```

* AXI-DMA

    AXI（Advanced eXtensible Interface）

    axi 是 ARM 提出的片上互连协议，用于 fpga 和 soc。比如 FPGA 与处理器（如 ARM Cortex）之间的数据搬运。

* PCI-DMA

    PCI/PCIe（Peripheral Component Interconnect Express）

    需要 低延迟、芯片内通信 → AXI-DMA。

    需要 高带宽、跨设备通信 → PCI-DMA。

* git stash 可临时保存工作区和暂存区中的更改，不产生 commit

    `git stash`等价于`git stash push -m "可选说明文字"  # 推荐添加备注方便识别`

    查看 stash 记录：`git stash list`

    恢复最近一次的 stash（并保留 stash 记录）: `git stash apply`

    恢复指定某条记录：`git stash apply stash@{n}  # n 为 stash 编号`

    恢复并删除对应的 stash 记录: `git stash pop stash@{n}  # 默认弹出最近的（stash@{0}）
    
    只保存工作目录的修改（不包含已暂存的文件）：`git stash push --keep-index`

    包含未跟踪的文件（如新创建的文件）：`git stash -u  # 或 --include-untracked`

    删除某条 stash 记录：
    
    `git stash drop stash@{n}  # 删除指定记录`

    `git stash clear           # 清空所有 stash`

    查看 stash 的改动内容：`git stash show stash@{n} -p  # -p 显示详细差异`

* `git stash`常用场景

    * 切换分支时保存未提交的修改：

        ```bash
        git stash
        git checkout other-branch
        # 处理其他任务后回到原分支
        git checkout original-branch
        git stash pop
        ```

* 多次 git stash 所发生的

    当连续执行多次 git stash 后，stash 栈中会按顺序存储多次暂存的记录（最新的是 stash@{0}，之前的是 stash@{1}、stash@{2} 等）。

    stash 栈的变化：

    * `git stash apply stash@{1}`：仅应用改动，stash@{1} 仍保留在栈中。

    * `git stash pop stash@{1}`：应用改动并删除 stash@{1}，后续的 stash@{0} 会重新编号为 stash@{0}。

    由于 git stash 后，工作目录总是会会恢复最后一次 commit 的内容，所以多次 stash 的操作互相独立，五不干扰，没有依赖关系。

    如果执行多次 git stash pop，那么 stash 的内容会互相叠加，如果有冲突，需要用户处理冲突。

* git stash 只暂存两个地方的文件

    1. 已经使用 git add 添加过的文件

    2. 在 working directory 中，并且之前有 tracing 的文件

    如果一个文件是新创建的，并且没有使用 git add 添加到 staging area，那么 git stash 不会暂存这个文件。

    （如果一个文件既被 git add 添加到了 staging are，又被在 working directory 中做了修改，那么 git stash 存储后，在 git stash pop 时会恢复两个区域的记录吗，还是只恢复一个？）

* git stash show 与 git stash list

    `git stash show`只显示最后一次 stash 的文件修改增删行数信息。`git stash list`会列出所有 stash 的修改记录。
