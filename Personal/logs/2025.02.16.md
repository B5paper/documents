* 有关元素的递推性质

    将每个元素替换为右侧最大元素

    给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。

    完成所有替换操作后，请你返回这个数组。

    示例 1：

    输入：arr = [17,18,5,4,6,1]
    输出：[18,6,6,6,1,-1]
    解释：
    - 下标 0 的元素 --> 右侧最大元素是下标 1 的元素 (18)
    - 下标 1 的元素 --> 右侧最大元素是下标 4 的元素 (6)
    - 下标 2 的元素 --> 右侧最大元素是下标 4 的元素 (6)
    - 下标 3 的元素 --> 右侧最大元素是下标 4 的元素 (6)
    - 下标 4 的元素 --> 右侧最大元素是下标 5 的元素 (1)
    - 下标 5 的元素 --> 右侧没有其他元素，替换为 -1
    示例 2：

    输入：arr = [400]
    输出：[-1]
    解释：下标 0 的元素右侧没有其他元素。
    

    提示：

    1 <= arr.length <= 104
    1 <= arr[i] <= 105

    代码：

    1. 自己写的

        ```cpp
        class Solution {
        public:
            vector<int> replaceElements(vector<int>& arr) {
                int max_val = -1;
                vector<int> ans(arr.size());
                for (int i = arr.size() - 1; i >= 0; --i)
                {
                    ans[i] = max_val;
                    if (arr[i] > max_val)
                    {
                        max_val = arr[i];
                    }
                }
                return ans;
            }
        };
        ```

    1. 官方答案

        ```cpp
        class Solution {
        public:
            vector<int> replaceElements(vector<int>& arr) {
                int n = arr.size();
                vector<int> ans(n);
                ans[n - 1] = -1;
                for (int i = n - 2; i >= 0; --i) {
                    ans[i] = max(ans[i + 1], arr[i + 1]);
                }
                return ans;
            }
        };
        ```

    题目本身并不难，也很容易做对。但是注意到官方答案并没有使用单独一个变量`max_val`，而是使用了`max(ans[i + 1], arr[i + 1])`这样的递推式。

    是否有可能在其他题目中，某个数组的元素满足某种性质，从而可以使用递推关系得到简便的答案，我们不得而知。现在我们来看当前这道题：`ans[i+1]`本身就表示了`arr[i+2]`及之后的所有数的最大值，让它和`arr[i+1]`比较，便能得到`arr[i+1]`及之后的所有数的最大值。`ans[i]`表示的正好是`arr[i+1]`及之后的所有数的最大值，因此可由`max(ans[i+1], arr[i+1])`得到。

    接下来考虑边界，当`arr[i+1]`为最后一个元素时，`ans[i+1]`为`-1`，`ans[i]`可以正常计算，没有问题。但此时`i`最大取值为`arr.size() - 2`，不能取到最后一个。若`ans[i]`为最后一个元素，后面的`i+1`肯定越界，因此`i`不能取到最后一个。这样`ans[i]`作为最后一个元素时，必须单独计算。幸好题目直接指定其为`-1`。

    可以看出来，整个过程还是比较费脑子的。