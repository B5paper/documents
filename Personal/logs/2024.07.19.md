* `ibv_get_device_list()`

    这个函数定义在`rdma-core/libibverbs/device.c`文件中，函数的原型是：

    ```c
    LATEST_SYMVER_FUNC(ibv_get_device_list, 1_1, "IBVERBS_1.1",
            struct ibv_device **,
            int *num)
    {
        // ...
    }
    ```

    可以看到它用宏的方式定义了版本号之类的，直接就是一个 abi 接口。

    这个函数主要调用了`ibverbs_get_device_list()`，其定义在`rdma-core/libibverbs/init.c`文件中，函数原型是：

    ```c
    int ibverbs_get_device_list(struct list_head *device_list);
    ```

    这个函数的代码主要逻辑如下：

    1. 通过`find_sysfs_devs_nl()`去 sysfs 中找 device

        这个过程会获取 driver id

    2. 如果没有找到 device，那么调用`find_sysfs_devs()`继续去 sysfs 中找 device

    3. 调用`try_all_drivers()`去匹配合适的 umd driver

    4. 如果没有匹配成功，那么就调用`load_drivers()`加载所有已知的 driver
    
    5. 最后再次调用`try_all_drivers()`去匹配 driver

* `load_drivers()`的代码逻辑

    `load_drivers()`定义在`rdma-core/libibverbs/dynamic_driver.c`中，函数原型为：

    ```c
    void load_drivers(void);
    ```

    可以看到，它不接收任何参数。说明它只在固定路径找驱动。

    函数逻辑：

    1. 调用`read_config();`，在宏`IBV_CONFIG_DIR`指定的路径读取 config 文件列表

        `IBV_CONFIG_DIR`宏被定义在`rdma-core/build/include/config.h`中。

        默认的路径在`rdma-core/build/etc/libibverbs.d`下，文件列表为：

        ```
        hlc@hlc-VirtualBox:~/Documents/Projects/rdma-core/build/etc/libibverbs.d$ ls
        bnxt_re.driver    hns.driver         mlx5.driver    siw.driver
        cxgb4.driver      ipathverbs.driver  mthca.driver   sonc.driver
        efa.driver        irdma.driver       ocrdma.driver  vmw_pvrdma.driver
        erdma.driver      mana.driver        qedr.driver
        hfi1verbs.driver  mlx4.driver        rxe.driver
        ```

        文件内容也都比较简单：

        ```
        hlc@hlc-VirtualBox:~/Documents/Projects/rdma-core/build/etc/libibverbs.d$ cat mlx5.driver 
        driver /home/hlc/Documents/Projects/rdma-core/build/lib/libmlx5
        hlc@hlc-VirtualBox:~/Documents/Projects/rdma-core/build/etc/libibverbs.d$ cat mana.driver 
        driver /home/hlc/Documents/Projects/rdma-core/build/lib/libmana
        ```

        这些文件都是在`rdma-core`项目 build 的时候自动生成的。

        读取的结果会被放在全局链表`driver_name_list`中。

    2. 遍历 name list，对每个 entry 调用`load_driver()`，使用`dlopen()`加载各家驱动的`.so`文件

        这个函数定义在`rdma-core/libibverbs/dynamic_driver.c`中，目前的定义为

        ```c
        #define VERBS_PROVIDER_SUFFIX "-rdmav34.so"
        ```

        这里会使用宏`VERBS_PROVIDER_SUFFIX`对 so 文件名再做一次修饰。比如`libsonc`会变成`libsonc-rdmav34.so`

        宏定义在`rdma-core/build/include/config.h`中。

* `try_all_drivers()`的代码逻辑

    `try_all_drivers()`定义在`rdma-core/libibverbs/init.c`中，函数原型为

    ```c
    static void try_all_drivers(struct list_head *sysfs_list,
                    struct list_head *device_list,
                    unsigned int *num_devices);
    ```

    函数逻辑：

    1. 遍历所有的 sysfs 入口，对于每个 sysfs entry，都调用`try_drivers()`

    `try_drivers()`定义在`rdma-core/libibverbs/init.c`中，函数原型为：

    ```c
    static struct verbs_device *try_drivers(struct verbs_sysfs_dev *sysfs_dev);
    ```

    代码逻辑：

    1. 遍历所有的 driver，如果 sysfs dev 的 driver id 不为`RDMA_DRIVER_UNKNOWN`，那么先调用`match_driver_id()`去匹配 driver，如果匹配失败，才调用`try_driver()`去匹配

    2. 如果 sysfs dev 的 driver id 为`RDMA_DRIVER_UNKNOWN`，那么在遍历 driver 时，直接通过`try_driver()`进行匹配

    这里的 driver id 是之前在`find_sysfs_devs_nl()`里获取的。

* `try_driver()`的逻辑

    `try_driver()`定义在`dma-core/libibverbs/init.c`中，函数原型为：

    ```c
    static struct verbs_device *try_driver(const struct verbs_device_ops *ops, struct verbs_sysfs_dev *sysfs_dev);
    ```

    函数逻辑：
    
    1. `match_device()`

        查看 driver 和 device 是否匹配，如果匹配失败就直接退出

    2. 如果匹配成功，则调用 umd driver 中的`alloc_device()`为`struct verbs_device *vdev;`分配内存。并将 ops 对接到`vdev`上：

        ```c
        struct verbs_device *vdev;
        vdev = ops->alloc_device(sysfs_dev);
        vdev->ops = ops;
        ```

    后面的事基本不需要我们操心了，我们只需要知道到这里为止，我们的 ops 就能被调用就可以了。

* 调研`asprintf()`