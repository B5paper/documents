* pthread cond 中，如果先 signal，再 wait，那么 signal 是无效的。

    `main.c`:

    ```c
    #include <pthread.h>
    #include <stdio.h>
    #include <unistd.h>

    pthread_mutex_t mtx;
    pthread_cond_t cond;

    void* thread_func(void *arg)
    {
        printf("in thread_func()...\n");
        pthread_mutex_lock(&mtx);
        pthread_cond_signal(&cond);
        pthread_mutex_unlock(&mtx);
        printf("exit thread_func().\n");
        return NULL;
    }

    int main()
    {
        pthread_mutex_init(&mtx, NULL);
        pthread_cond_init(&cond, NULL);

        pthread_t thd;
        pthread_create(&thd, NULL, thread_func, NULL);

        printf("start sleep ...\n");
        sleep(2);
        printf("end sleep.\n");

        pthread_mutex_lock(&mtx);
        pthread_cond_wait(&cond, &mtx);
        pthread_mutex_unlock(&mtx);

        pthread_join(thd, NULL);

        pthread_cond_destroy(&cond);
        pthread_mutex_destroy(&mtx);
        return 0;
    }
    ```

    compile: `gcc -g main.c -o main`

    run: `./main`

    output:

    ```
    start sleep ...
    in thread_func()...
    exit thread_func().
    end sleep.

    ```

    程序会在这里卡住。可见正常的执行顺序应该是必须保证先 wait，后 signal。
