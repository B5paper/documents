* 每份笔记中应该专门开一个 examples 区域，整理详细的 example

    在笔记正文中出现的 example 只需要专注详解原理就行了，可以只是代码片段，也可以不检查返回值，不进行错误处理。

    example 区域中的 example，需要在追求简洁的基础上，增加一些返回值判断和错误处理，有完整可编译运行的代码，并且有运行的输出。

    问题：qa 中的代码片段该归属于哪一种？

* openmpi send recv code example

    `main.c`:

    ```c
    #include <mpi.h>
    #include <stdio.h>
    #include <string.h>

    int main()
    {
        int ret = MPI_Init(NULL, NULL);
        if (ret != 0)
        {
            printf("fail to init mpi, ret: %d\n", ret);
            return -1;
        }
        printf("[OK] init mpi.\n");

        int world_size;
        ret = MPI_Comm_size(MPI_COMM_WORLD, &world_size);
        if (ret != 0)
        {
            printf("fail to get comm world isze, ret: %d\n", ret);
            return -1;
        }
        printf("[OK] get world size: %d.\n", world_size);

        int rank;
        ret = MPI_Comm_rank(MPI_COMM_WORLD, &rank);
        if (ret != 0)
        {
            printf("fail to get rank, ret: %d\n", ret);
            return -1;
        }
        printf("[OK] get rank: %d.\n", rank);

        char buf[20] = {0};
        if (rank == 0)
        {
            char *msg = "hello from rank 0";
            size_t msg_len = strlen(msg);
            size_t min_len;
            if (msg_len > 19)
                min_len = 19;
            else
                min_len = msg_len;
            strncpy(buf, msg, min_len);
            ret = MPI_Send(buf, 20, MPI_CHAR, 1, 0, MPI_COMM_WORLD);
            if (ret != 0)
            {
                printf("fail to send data, ret: %d\n", ret);
                return -1;
            }
            printf("[OK] send buf to rank 1:\n" "\t%s\n", buf);
        }
        else if (rank == 1)
        {
            ret = MPI_Recv(buf, 20, MPI_CHAR, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            if (ret != 0)
            {
                printf("fail to recv data, ret: %d\n", ret);
                return -1;
            }
            printf("[OK] recv buf from rank 0:\n" "\t%s\n", buf);
        }
        else
        {
            printf("unknown rank: %d\n", rank);
            return -1;
        }

        ret = MPI_Finalize();
        if (ret != 0)
        {
            printf("fail to finalize mpi, ret: %d\n", ret);
            return -1;
        }
        printf("[OK] finalize mpi.\n");
        
        return 0;
    }
    ```

    `Makefile`:

    ```makefile
    main: main.c
        mpicc -g main.c -o main

    clean:
        rm -f main
    ```

    compile: `make`

    run: `mpirun -n 2 --host 10.0.2.4,10.0.2.15 ./main`

    output:

    ```
    [OK] init mpi.
    [OK] get world size: 2.
    [OK] get rank: 0.
    [OK] init mpi.
    [OK] get world size: 2.
    [OK] get rank: 1.
    [OK] send buf to rank 1:
        hello from rank 0
    [OK] recv buf from rank 0:
        hello from rank 0
    [OK] finalize mpi.
    [OK] finalize mpi.
    ```

    说明：

    * 代码中`printf("[OK] send buf to rank 1:\n" "\t%s\n", buf);`将两行的 printf 合成一行写，是因为两台 node 的 printf 并没有执行顺序的保证，为了避免输出混乱，就把 buf 和 prompt 使用同一个 printf 输出了。
    
        如果将 printf 写成下面的形式：

        ```c
        // ...
                printf("[OK] send buf to rank 1:\n");
                printf("\t%s\n", buf);
        // ...
                printf("[OK] recv buf from rank 0:\n");
                printf("\t%s\n", buf);
        // ...
        ```

        那么运行程序可能会得到下面的输出：

        ```
        [OK] init mpi.
        [OK] get world size: 2.
        [OK] get rank: 1.
        [OK] recv buf from rank 0:
        [OK] init mpi.
        [OK] get world size: 2.
        [OK] get rank: 0.
        [OK] send buf to rank 1:
            hello from rank 0
            hello from rank 0
        [OK] finalize mpi.
        [OK] finalize mpi.
        ```

* mpi status example code

    `main.c`:

    ```c
    #include <mpi.h>
    #include <stdio.h>
    #include <string.h>

    int main()
    {
        int ret = MPI_Init(NULL, NULL);
        if (ret != 0)
        {
            printf("fail to init mpi, ret: %d\n", ret);
            return -1;
        }
        printf("[OK] init mpi.\n");

        int world_size;
        ret = MPI_Comm_size(MPI_COMM_WORLD, &world_size);
        if (ret != 0)
        {
            printf("fail to get comm world isze, ret: %d\n", ret);
            return -1;
        }
        printf("[OK] get world size: %d.\n", world_size);

        int rank;
        ret = MPI_Comm_rank(MPI_COMM_WORLD, &rank);
        if (ret != 0)
        {
            printf("fail to get rank, ret: %d\n", ret);
            return -1;
        }
        printf("[OK] get rank: %d.\n", rank);

        char buf[20] = {0};
        if (rank == 0)
        {
            char *msg = "hello from rank 0";
            size_t msg_len = strlen(msg);
            size_t min_len;
            if (msg_len > 19)
                min_len = 19;
            else
                min_len = msg_len;
            strncpy(buf, msg, min_len);
            ret = MPI_Send(buf, 20, MPI_CHAR, 1, 0, MPI_COMM_WORLD);
            if (ret != 0)
            {
                printf("fail to send data, ret: %d\n", ret);
                return -1;
            }
            printf("[OK] send buf to rank 1:\n" "\t%s\n", buf);
        }
        else if (rank == 1)
        {
            MPI_Status status;
            ret = MPI_Recv(buf, 20, MPI_CHAR, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
            if (ret != 0)
            {
                printf("fail to recv data, ret: %d\n", ret);
                return -1;
            }
            int count;
            MPI_Get_count(&status, MPI_CHAR, &count);
            printf("recv status:\n" "\tsource: %d, tag: %d, count: %d\n",
                status.MPI_SOURCE,
                status.MPI_TAG,
                count
            );
            printf("[OK] recv buf from rank 0:\n" "\t%s\n", buf);
        }
        else
        {
            printf("unknown rank: %d\n", rank);
            return -1;
        }

        ret = MPI_Finalize();
        if (ret != 0)
        {
            printf("fail to finalize mpi, ret: %d\n", ret);
            return -1;
        }
        printf("[OK] finalize mpi.\n");
        
        return 0;
    }
    ```

    `Makefile`:

    ```makefile
    main: main.c
        mpicc -g main.c -o main

    clean:
        rm -f main

    ```

    compile: `make`

    run: `mpirun -n 2 --host 10.0.2.15,10.0.2.4 ./main`

    output:

    ```
    [OK] init mpi.
    [OK] get world size: 2.
    [OK] get rank: 0.
    [OK] init mpi.
    [OK] get world size: 2.
    [OK] get rank: 1.
    [OK] send buf to rank 1:
        hello from rank 0
    recv status:
        source: 0, tag: 0, count: 20
    [OK] recv buf from rank 0:
        hello from rank 0
    [OK] finalize mpi.
    [OK] finalize mpi.
    ```

    说明：

    * 这段代码仅使用了 status 中的 source, tag, count 这三个信息，没有用到 error 信息。error 信息可以用于 recv 未知数量的数据。

* cache tabs

    * 解决SSH no matching host key type found 问题

        <https://blog.alanwei.com/blog/2022/01/24/ssh-no-matching-host-key-type-found/>

    * Interrupt Handling

        <https://static.lwn.net/images/pdf/LDD3/ch10.pdf>

    * Linux Device Drivers, Third Edition

        <https://lwn.net/Kernel/LDD3/>

    * The Linux driver implementer’s API guide

        <https://www.kernel.org/doc/html/v4.12/driver-api/index.html>

    * Device Drivers

        <https://www.kernel.org/doc/html/v6.1/driver-api/driver-model/driver.html>

* iptables relatives

    * chain

        chain 是一系列匹配规则（rule）的集合。

        问题：

        * 是否一条 chain 没有处理的包会被传递给下一条 chain？

    * 猜想：所有的 iptables 命令都需要 sudo 权限

    * 列出当前的规则：`iptables --list`

    * 如何启用一个指定的 table？

    * 如何列出所有的 table ?

        table 的一共就 5 个，且是固定的，不可添加，不可删除，因此没有动态列出所有 table 的需求。

        可用的 table 有：

        `filter`, `nat`, `mangle`, `raw`, `security`

    * 默认进入的 table 是`filter`

    * `filter` table 中可以加入 prerouting, postrouting 这些 chain 吗？

    * 既然有 custom defined chain，那么说明 built-in chain 并不具有特殊功能

    * 所有的 table 都共同在工作吗？是否存在“启用”某个 table，禁用某个 table 的操作？

* 假设 node 1 上有 vm 1，node 2 上有 vm 2。vm 1 无法 ping 通 vm 2 可能是因为只设置了 node 1 上的路由表，没有设置 node 2 上的路由表

    猜想：可能是 vm 1 缎带 vm 2 发送完 icmp 数据包后，vm 2 回复 icmp 包时，找不到 vm 1 所在的网段如何路由过去。

    可以将 node 1 上的路由表新添加一项：vm 2 所在网段的 gateway 为 node 2 的 ip；在 node 2 上的路由表上也新加一条：vm 1 所在网段的 gateway 为 node 1 的 ip。这样就能 ping 通了。
