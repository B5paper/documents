* 想了想，目前处理大型 project 的方法就是将 project 分解成模块 A, B, C, ... 然后锻炼自己快速组合模块 A， B， C, ... 的能力，直到可以快速快速解构、复现整个项目。如果想做对比实验，那就把模块改成 A, B1, C，或 A1, B, C 等等。

* 每日任务模板

    ```md
    * [ ] reorg: documents 30 mins 09.17

        10:13 ~ 10:25

    * [ ] reorg: projects 30 mins 09.17

    * [ ] qa: 2 units 30 mins 09.17

    * [ ] cache tabs 30 mins 09.17

    * [ ] process tabs 30 mins 09.17

    * [ ] process 1 tab 09.17

    * [ ] task 1 xx mins

    * [ ] task 2 xx mins
    ```

    说明：

    * `reorg: documents`之类的任务，由于每次的任务名称一样，所以需要记录日期以区分。

    * `10:13 ~ 10:25`所有任务都需要记录开始和结束时间，以记录有效工作时间

    * 调研任务，reorg, cache tab 任务需要预计总时间。比如`30 mins`。

        这些任务没有明确的任务量，所以用时间来约束。

    * qa 任务需要预计需求量，比如`qa: 2 units`。由于 qa 任务是精心编排的，不存在未知的问题，所以也指定了约束时间，比如`30 mins`。

* `objdump`

    主要用于反汇编和分析目标文件及可执行文件。

    常用功能：

    1. 反汇编

        将二进制可执行文件或目标文件（.o, .exe, .so, .dll 等）中的机器代码转换回汇编语言代码。

        `objdump -d ./my_program`

        * `-d`选项表示反汇编包含指令的节（section）。

    2. 查看目标文件结构

        显示文件的头部信息和各个节（Section）的详细信息。包括文件的格式（如ELF、PE）、入口地址、节的大小和位置等。

        `objdump -h ./my_program`
        
        * `-h`选项显示节的头部摘要。

    3. 查看符号表

        列出文件中定义和引用的所有符号（如函数名、全局变量名）。

        `objdump -t ./my_program`

        * `-t`选项显示符号表。

    4. 查看文件头信息

        显示二进制文件的元数据，例如目标架构（如x86-64、ARM）、操作系统ABI、文件类型（可执行、共享库等）和入口点地址。

        `objdump -f ./my_program`

        * `-f`选项显示文件头信息。

    5. 以十六进制格式查看文件内容

        除了反汇编，objdump 还可以直接显示文件的十六进制和ASCII表示，类似于 hexdump 或 xxd 命令。

        `objdump -s -j .text ./my_program`

        * `-s` 显示所有节的内容。

        * `-j` 指定只显示某个节（如 .text 节）的内容。

    6. 查看动态链接信息

        对于动态链接的可执行文件或共享库，可以显示其依赖的共享库（如Linux下的 .so 文件）以及动态符号表。

        `objdump -p ./my_program`

        * `-p`显示与动态链接相关的信息（在 ELF 文件中，这类似于`readelf -d`命令）。

* `od -t x<N>`

    按`<N>`字节一组，打印十六进制数据。

    其中`<N>`可以取值 1, 2, 4, 8，如果不指定`<N>`，则默认取`2`。

    注意多字节显示时，输出受字节序的影响，比如单字节显示的`01 02`，使用小端序 + `-x2`显示时可能变成`0201`。

* 使用 permute 导致 tensor 变成 continuous 的例子

    ```py
    import torch as t

    a = t.rand(3, 4)
    print('a shape: {}'.format(a.shape))
    a = a.permute(1, 0)
    print('after permute, a shape: {}'.format(a.shape))
    print('is continuous: {}'.format(a.is_contiguous()))
    a = a.view(2, 6)
    ```

    output:

    ```
    a shape: torch.Size([3, 4])
    after permute, a shape: torch.Size([4, 3])
    is continuous: False
    Traceback (most recent call last):
      File "/home/hlc/Documents/Projects/torch_test/main.py", line 8, in <module>
        a = a.view(2, 6)
    RuntimeError: view size is not compatible with input tensor's size and stride (at least one dimension spans across two contiguous subspaces). Use .reshape(...) instead.
    ```

* torch 拟合 xor 函数

    ```py
    import torch
    import torch.nn as nn
    from torch import optim

    class SimpleNN(nn.Module):
        def __init__(self):
            super(SimpleNN, self).__init__()
            self.fc1 = nn.Linear(2, 4)
            self.fc2 = nn.Linear(4, 1)

        def forward(self, x):
            x = torch.relu(self.fc1(x))
            x = self.fc2(x)
            return x
        
    X_train = torch.tensor([[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0]])
    y_train = torch.tensor([[0.0], [1.0], [1.0], [0.0]])

    # Instantiate the Model, Define Loss Function and Optimizer
    model = SimpleNN()
    criterion = nn.MSELoss()
    optimizer = optim.SGD(model.parameters(), lr=0.1)

    for epoch in range(100):
        model.train()

        # Forward pass
        outputs = model(X_train)
        loss = criterion(outputs, y_train)
        
        # Backward pass and optimize
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        if (epoch + 1) % 10 == 0:
            print(f'Epoch [{epoch + 1}/100], Loss: {loss.item():.4f}')

    model.eval()
    with torch.no_grad():
        test_data = torch.tensor([[0.0, 0.0], [0.0, 1.0], [1.0, 0.0], [1.0, 1.0]])
        predictions = model(test_data)
        print(f'Predictions:\n{predictions}')
    ```

    output:

    ```
    Epoch [10/100], Loss: 0.2205
    Epoch [20/100], Loss: 0.1844
    Epoch [30/100], Loss: 0.1600
    Epoch [40/100], Loss: 0.1357
    Epoch [50/100], Loss: 0.1115
    Epoch [60/100], Loss: 0.0890
    Epoch [70/100], Loss: 0.0671
    Epoch [80/100], Loss: 0.0481
    Epoch [90/100], Loss: 0.0320
    Epoch [100/100], Loss: 0.0199
    Predictions:
    tensor([[0.1897],
            [0.9428],
            [0.8315],
            [0.0905]])
    ```

    说明：

    1. `super(SimpleNN, self).__init__()`与`super().__init__()`是等价的

    1. `model.train()`将模型切换为训练模式，不需要写成`model = model.train()`

        特点：

        * Dropout层会随机丢弃神经元

        * BatchNorm层使用当前批次的统计量（均值和方差）

        * 启用梯度计算（autograd）

        * 适合训练阶段使用

    1. `model.eval()`将模型切换为评估模式

        * Dropout层不会丢弃神经元（所有神经元都参与计算）

        * BatchNorm层使用训练阶段学到的运行统计量

        * 通常与torch.no_grad()一起使用来禁用梯度计算

        * 适合测试、验证和推理阶段使用

* criterion prn. [kraɪˈtɪriən] n. 标准，准则

* `remove_const_t`

    除类型的顶层 const 限定符。

    如果输入类型 T 是 const 限定的（如 const int、const std::string），则 remove_const_t<T> 会得到对应的非 const 类型（如 int、std::string）。

    如果输入类型 T 没有 const 限定，则 remove_const_t<T> 直接返回原始类型 T。

    example:

    ```cpp
    #include <type_traits>

    // 示例类型
    using T1 = const int;
    using T2 = int;

    // 移除 const 限定
    using Result1 = std::remove_const_t<T1>; // 等价于 int
    using Result2 = std::remove_const_t<T2>; // 等价于 int

    // 对于指针类型：仅移除顶层 const（指针本身的 const，而非指向对象的 const）
    using T3 = const int*;          // 指针指向 const int，但指针本身非 const
    using Result3 = std::remove_const_t<T3>; // 仍为 const int*（无变化）

    using T4 = int* const;          // 顶层 const：指针本身是 const
    using Result4 = std::remove_const_t<T4>; // 变为 int*
    ```

    注意，`remove_const_t`仅移除顶层 const：对于指针或复合类型，它不会移除底层（被指向对象）的 const 限定。例如：

    * remove_const_t<const int*> 仍为 const int*（因为 const 属于被指向对象，而非指针本身）。

    * remove_const_t<int* const> 会得到 int*（移除了指针本身的 const）。

    相关概念：

    * std::remove_const<T>：是一个类模板，其 ::type 成员类型是结果类型（C++11 起）。

    * std::remove_const_t<T>：是 C++14 引入的辅助别名模板，直接等价于 typename std::remove_const<T>::type。

* `truncate -s <bytes>`

    如果文件不存在, 创建指定大小的空文件，内容全部用空字节（\0）填充。如果文件已存在, 若文件原大小 > 指定大小，则截断文件，丢弃超出部分；若文件原大小 < 指定大小，则扩展文件，用空字节填充新增部分。

    example:

    `truncate -s 4096 /dev/shm/my_tmp_file`

    在`/dev/shm`中创建大小为 4096 字节的文件`my_tmp_file`。

* makefile 模式规则

    模式规则是一种通用模板，它告诉 make 如何基于文件名模式来编译一类文件。它使用通配符 % 来匹配任意非空字符串。

    example:

    ```makefile
    %.o: %.c
    	$(CC) -c $(CFLAGS) $< -o $@
    ```

    解释：

    * `%.o`： 这是目标模式。它匹配任何以 .o 结尾的文件名（例如 main.o, utils.o, foo.o）。

    * `%.c`： 这是依赖模式。它匹配任何以 .c 结尾的文件名。这里的 % 与目标模式中的 % 代表相同的字符串。

    * `$(CC) -c $(CFLAGS) $< -o $@`： 这是规则要执行的命令。

        * `$(CC)`： 通常是编译器，如 gcc 或 clang。

        * `-c`： 告诉编译器只编译不链接，生成目标文件（.o）。

        * `$(CFLAGS)`： 传递给编译器的选项（如 -Wall -g -O2）。

        * `$<`： 一个自动化变量，代表规则中的第一个依赖项的名字。在这个例子中，就是那个匹配到的 .c 文件（例如 main.c）。

        * `-o $@`： 另一个自动化变量，$@ 代表规则中的目标文件名。在这里就是那个 .o 文件（例如 main.o）。

* `$(shell command)`

    `$(shell command)`是一个 Makefile 函数，它在 Makefile 解析阶段，执行一个 Shell 命令，并将其标准输出（stdout）的结果作为字符串返回，然后赋值给一个变量或直接展开使用。

    常见使用场景:

    * 动态获取文件列表

        ```makefile
        # 获取当前目录下所有的 .c 文件
        SOURCES := $(shell find . -name "*.c")

        # 将 .c 文件列表转换为 .o 文件列表
        OBJECTS = $(SOURCES:.c=.o)
        ```

    * 获取系统信息或环境变量

        ```makefile
        # 获取当前用户名
        WHOAMI := $(shell whoami)

        # 获取当前工作目录的绝对路径
        CURRENT_DIR := $(shell pwd)

        # 获取 Git 提交哈希或版本号
        GIT_HASH := $(shell git rev-parse --short HEAD)
        ```

    * 检查环境或工具是否存在

        ```makefile
        # 检查是否安装了某个工具（例如 'pandoc'）
        PANDOC_EXISTS := $(shell command -v pandoc 2> /dev/null)

        ifndef PANDOC_EXISTS
        $(error "Error: pandoc is required but not installed.")
        endif
        ```

    * 生成版本号或构建时间

        ```makefile
        BUILD_DATE := $(shell date +%Y-%m-%d_%H:%M)
        VERSION := 1.0.$(shell git rev-list --count HEAD)
        ```

    * 处理文件名

        ```makefile
        # 获取当前目录名，用于命名目标文件
        DIR_NAME := $(shell basename $(CURDIR))
        TARGET = program_$(DIR_NAME)
        ```

    example:

    ```makefile
    # 使用 shell 命令动态获取所有 .c 文件
    SRCS := $(shell find src -name "*.c")
    # 将 .c 文件名转换为 .o 文件名
    OBJS = $(SRCS:src/%.c=obj/%.o)
    # 获取当前时间作为构建版本
    BUILD_TIME := $(shell date)

    # 最终目标
    myapp: $(OBJS)
    	$(CC) -o $@ $^ $(LDFLAGS)

    # 编译规则
    obj/%.o: src/%.c | obj
    	$(CC) $(CFLAGS) -c $< -o $@

    # 创建 obj 目录的规则
    obj:
    	mkdir -p obj

    # 打印一些信息
    print-info:
    	@echo "Sources: $(SRCS)"
    	@echo "Build time: $(BUILD_TIME)"

    clean:
    	rm -rf obj myapp

    .PHONY: clean print-info
    ```

    注意事项:

    1. 通常与 :=（立即展开赋值）一起使用，确保 shell 命令只执行一次。如果使用 =（递归展开），它可能会在每次变量被展开时都执行一次 Shell 命令，导致性能下降。

    1. 错误处理: 如果执行的 Shell 命令失败（返回非零状态码），make 通常会停止执行并报错。可以使用 Shell 的逻辑操作来避免这个问题（例如 command 2>/dev/null || echo "default"）。

    1. 空格处理: Shell 命令的输出会原样返回，包括换行符。有时可能需要使用 $(strip ...) 函数来去除多余的空白字符。

* `sudo mount -o remount /dev/shm`

    重新挂载 /dev/shm 文件系统，并在此过程中应用或刷新其挂载选项。

    如果没有在命令中指定新的挂载选项（例如 size=2G 或 noexec），那么它将使用系统默认的或之前在 /etc/fstab 文件中配置的选项来重新挂载。

    常见使用场景

    * 应用 /etc/fstab 中的新配置：

        如果你修改了 /etc/fstab 中关于 /dev/shm 的配置（比如改变了大小限制 size=512M），你可以运行此命令来立即应用新的配置，而无需重启系统。

    * 修复权限或属性问题：

        如果 /dev/shm 的权限意外被更改（例如，某个脚本错误地执行了 chmod 700 /dev/shm），导致某些程序无法正常使用共享内存，通过重新挂载可以将其恢复为正确的默认权限。

    * 清除所有内容（不常用）：

        虽然 remount 本身不是为了清除数据，但结合某些选项（如 noexec 然后再 remount 回默认值）可以间接达到目的。更直接的方法是直接重启（数据会丢失）或手动删除其中的文件。

* python class 中定义成员变量

    1. 在`__init__()`或其他成员函数中，使用`self.xxx = yyy`定义成员变量

        ```py
        class DynamicClass:
            def __init__(self):
                self.defined_in_init = "I'm from init" 

            def add_attribute_later(self):
                self.defined_later = "I was created later!"

        # 使用
        obj = DynamicClass()
        print(obj.defined_in_init) # 正常工作

        # print(obj.defined_later) # 这里会报错，因为还没有执行定义它的方法

        obj.add_attribute_later() # 调用方法，动态创建了成员
        print(obj.defined_later)  # 现在可以正常工作了
        ```

    2. 使用类属性

        ```py
        class MyClass:
            # 这是类属性
            class_attr = "I'm a class attribute"

            def __init__(self, instance_attr):
                # 这是实例属性
                self.instance_attr = instance_attr

        # 使用
        obj1 = MyClass("Obj1 value")
        obj2 = MyClass("Obj2 value")

        # 访问实例属性：每个对象独有
        print(obj1.instance_attr) # Obj1 value
        print(obj2.instance_attr) # Obj2 value

        # 访问类属性：所有对象共享，也可以通过类本身访问
        print(obj1.class_attr)    # I'm a class attribute
        print(obj2.class_attr)    # I'm a class attribute
        print(MyClass.class_attr) # I'm a class attribute
        ```

        共享性：所有实例对象共享同一个类属性。如果通过类名修改它（如 MyClass.class_attr = "new"），所有实例看到的都会改变。

        实例访问的陷阱：如果你通过实例对类属性进行赋值（如 obj1.class_attr = "new for obj1"），你实际上是在该实例的命名空间内创建了一个新的同名实例属性，它会遮蔽（shadow）掉类属性。此时，obj1.class_attr 是实例属性，而 obj2.class_attr 和 MyClass.class_attr 仍然是原来的类属性。

    3. 使用`@property`装饰器

        ```py
        class Circle:
            def __init__(self, radius):
                self.radius = radius # 这里只存储了半径

            @property
            def area(self):
                # 面积不需要存储，每次访问时根据半径计算
                return 3.14159 * self.radius ** 2

            @property
            def diameter(self):
                return self.radius * 2

        # 使用
        c = Circle(5)
        print(c.radius)   # 5 (实例属性)
        print(c.diameter) # 10 (看起来是属性，实则是方法计算的结果)
        print(c.area)     # 78.53975 (看起来是属性，实则是方法计算的结果)

        # c.area = 100 # 这会报错，因为@property默认是只读的
        ```

    在使用类成员时，如果不知道初始值，可以使用`Nonde`:

    ```py
    class User:
        # 使用 None 作为占位符，表示这些属性需要后续初始化
        name = None
        email = None
        age = None
    ```

    但是只有`None`无法提供类型信息，可以使用类型注解（Type Hints）配合 None:

    ```py
    class User:
        name: str | None = None
        email: str | None = None
        age: int | None = None
    ```

    不可以只写类型注解，不写初始化值：

    ```py
    class User:
        name: str          # 这只是类型注解
        age: int = 0       # 这是真正的属性定义 + 类型注解

    # 测试
    user = User()
    print(user.age)        # 正常工作，输出: 0
    print(user.name)       # 报错！AttributeError: 'User' object has no attribute 'name'
    ```

* `od -A`

    od -A 选项用于指定输出偏移量（地址）的显示格式。这里的 -A 代表 "Address"。

    * `-A x`: 十六进制（hexadecimal）
    
        `0000000`, `0000010`
    
    * `-A d`: 十进制（decimal）
    
        `0000000`, `0000016`

    * `-A o`: 八进制（octal）, 默认情况
    
        `0000000`, `0000020`

    * `-A n`: 不显示偏移量（none）
    
        （左侧偏移量栏为空）

* 在使用 stream dma 时，如果`dma_map_single()`指定的 flag 为`DMA_BIDIRECTIONAL`，那么每次映射/同步操作都可能同时执行“刷写”和“失效”，性能开销最大。通过这种方法保证缓存一致性。
