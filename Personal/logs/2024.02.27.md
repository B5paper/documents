* makefile 文件名可以是`Makefile`，也可以是`makefile`,但是不能是`makefilE`。

    也就是说，文件名只对第一个字母大小写不敏感。

* vulkan synchronization

    fence 必须先 reset 才能使用。

    一个 fence 只能作用用一个 queue，`vkAcquireNextImageKHR()`也算一个 queue。

    `sem_img_available`必须先由`vkAcquireNextImageKHR()`赋值过后才能交给`vkQueueSubmit()`使用。

    example code:

    ```cpp
    VkSemaphore sem_finish_rendering = create_semaphore(device);
    VkSemaphore sem_img_available = create_semaphore(device);
    VkFence fence_acq_img = create_fence(device);
    VkFence fence_queue_submit = create_fence(device);

    vkResetFences(device, 1, &fence_acq_img);
    uint32_t available_img_idx;
    vkAcquireNextImageKHR(device, swpch, UINT64_MAX, sem_img_available, fence_acq_img, &available_img_idx);

    vkResetFences(device, 1, &fence_queue_submit);
    VkSubmitInfo submit_info{};
    submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submit_info.signalSemaphoreCount = 1;
    submit_info.pSignalSemaphores = &sem_finish_rendering;
    submit_info.waitSemaphoreCount = 1;
    submit_info.waitSemaphoreCount = 0;
    submit_info.pWaitSemaphores = &sem_img_available;
    submit_info.commandBufferCount = 1;
    submit_info.pCommandBuffers = &cmd_buf;
    VkPipelineStageFlags pipeline_stage_flags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    submit_info.pWaitDstStageMask = &pipeline_stage_flags;
    vkQueueSubmit(queue, 1, &submit_info, fence_queue_submit);
    ```

    猜想：fence 只代表 gpu 返回，不代表 queue 执行结束，因此使用 semaphore 来判断 queue 是否执行结束。

    （这段代码中可能还少了一个 wait fence）

* opencl

    * 如果一个 kernel 函数内部有`local`声明的变量，那么这个函数不能被其他 kernel 函数调用

        测试了下，好像没什么问题。

        example:

        ```c
        kernel void func_a(global int *output)
        {
            local int a;
            a = 100;
            *output = a;
        }

        kernel void func_b(global int *output)
        {
            func_a(output);
        }
        ```

        这段代码是正常的，在`main.cpp`中，`output`的输出为 100。

    * 可以给 opencl kernel 加上下面这些修饰符，帮助编译器优化

        ```c
        __attribute__((work_group_size_hint(X, Y, Z)))

        __attribute__((reqd_work_group_size(X, Y, Z)))

        __attribute__((vec_type_hint(<type>)))
        ```

        第一个是 hint，说明只是提示，不是确定的。

        第二个是 reqd，说明是要求，必须和 host 代码保持一致。（如果不一致会怎么样？）

        第三个的`<type>`通常是`int`，不清楚这个有什么用。

    * kernel 函数不能有 private address space 的指针作为参数

    * local variable 必须在 function 的最外层（kernel function scope）申请，且不能初始化。

        local address space 主要是用于 work-group 共享的。当 work-group 结束时，这些变量就会被释放掉。

    * 指针只能在同一个 address space 下被赋值，跨 address space 的赋值是不合法的

        example:

        ```cpp
        void func_a(global float4 *pointer)
        {
            global float4 *g_pointer = pointer;
            // local float4 *l_pointer = pointer;  // compiling error
            // private float4 *p_pointer = pointer;  // compiling error
        }
        ```

    * 如果一个变量是`image2d_t`，那么还可以给参数加上`read_only`或`write_only`修饰，因为当前的 GPU 不允许同时对图片读和写

        这是因为 GPU 对图片数据做了缓存，读图时从缓存中读，但是写图片时不会改变缓存中的内容。