* [v] 调研 a100 4 gpu 环境下，`LINK_NVL`的 bw 为什么低了一半，并修复

    feedback:

    1. 因为添加 nvlink 时，bw 没有乘 count

* [v] 调研 a100 4 gpu 下，为什么 compute path 后，nccl 的每个 gpu 都有连到 nvs 的 path，但是 siccl 没有

    ```
    gpu 565248 --> nvs 0
    gpu 786432 --> nvs 0
    gpu 798720 --> nvs 0
    ```

    feedback:

    1. 因为在 compute path 中，没有计算以 nvswitch 为 base vert 的 path

* [v] 调研 siccl 是否能在 135 机器 4 卡环境上 work

    主要看 compute path 以及 generate coll graph

    feedback:

    1. 目前看起来完全正常。设置 ring 模式 generate coll graph，一共生成 12 个 channel，intra 数据都是 0, 1, 2, 3，inter 数据则都为 0.

* [ ] reorg project: `main_4.cpp`, `DynamicGraph`

    feedback:

    1. `unordered_map<int, int> id_to_idx_table;`

        优点：

        1. 可以根据 id 快速找到 idx，进而可以找到 ptr

        1. 已知 ptr，可以拿到 id，进而找到 idx

        缺点：

        1. 删除节点时，idx 会变动，必须重新构建 table

        2. 已知 ptr 无法

    1. 调研如果使用 move 将一个 vector `vec_src`赋给另一个`vec_dst`，那么会释放`vec_dst`的内存，并将`vec_src`的内存的指针交给`vec_dst`，然后将`vec_src`的内存指针置空吗，还是进行浅拷贝，将`vec_src`的内存内容复制给`vec_dst`？

    1. 调研自定义哈希函数的写法

        ```cpp
        struct VertexPtrHash {
            size_t operator()(const pair<Vertex*, Vertex*> &src_dst) const {
                return std::hash<void*>()(src_dst.first) ^
                    std::hash<void*>()(src_dst.second);
            }
        };
        // <<src, dst>, path>
        unordered_map<pair<Vertex*, Vertex*>, vector<Vertex*>, VertexPtrHash> paths;
        ```

    1. table, path 都可能随着 vert 的增删而失效，如果有部分重建的算法，可以每次增删 vert 时，都部分重建 table 或 path，保证总是有效。如果部分重建的代价很大，或者需要短时间内多次增加、删除 vert，短时间内多次重建的代价大于一次性完全重建的代价，那么可以设置一个 flag，每次 add / del vert 后让 flag 失效，flag 失效时不允许使用 table, path。显式调用 build_table(), search_path() 后，flag 重新有效，此时允许使用 table, path。

        部分重建时，add vert 的函数可以设计为`add_vert(Vert *new_vert, bool keep_table_valid=True)`

    1. reorg project: `main_3.cpp`

    1. reorg project: `main_2.cpp`

    1. reorg project: `main.cpp`

* [ ] 调研`lseek()`

* [ ] 调研`mail` command

* [new] 调研 mpv 播放器

* [ ] 调研`ssh -o PreferredAuthentications=password`
