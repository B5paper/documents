* 写 linux module 时，vscode 的 cpp 配置里，`KBUILD_MODNAME`要写成`KBUILD_MODNAME="hello"`，以前记的笔记是`KBUILD_MODNAME=\"hello\"`，似乎是不对的。

* `pci_iomap()`的 example

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/pci.h>

    static struct pci_device_id pci_id_table[] = {
        { PCI_DEVICE(0x1234, 0x11e8) },
        {0,}
    };

    static void *base_addr_bar0;

    static int edu_probe(struct pci_dev *pci_dev, const struct pci_device_id *id) {
        pr_info("in edu_probe()...\n");

        int ret = pci_enable_device(pci_dev);
        if (ret != 0) {
            dev_err(&pci_dev->dev, "fail to pci enable device, ret: %d\n", ret);
            goto ERR_PCI_ENABLE_DEVICE;
        }

        ret = pci_request_region(pci_dev, 0, "qemu_edu_drv");
        if (ret != 0) {
            dev_err(&pci_dev->dev, "fail to pci request region\n");
            goto ERR_PCI_REQUEST_REGION;
        }

        resource_size_t res_len_bar0 = pci_resource_len(pci_dev, 0);
        base_addr_bar0 = pci_iomap(pci_dev, 0, res_len_bar0);
        if (base_addr_bar0 == NULL) {
            dev_err(&pci_dev->dev, "fail to pci iomap\n");
            goto ERR_PCI_IOMAP;
        }
        return 0;

    ERR_PCI_IOMAP:
        pci_release_region(pci_dev, 0);
    ERR_PCI_REQUEST_REGION:
        pci_disable_device(pci_dev);
    ERR_PCI_ENABLE_DEVICE:
        return -1;
    }

    static void edu_remove(struct pci_dev *pci_dev) {
        pr_info("in edu_remove()...\n");
        pci_iounmap(pci_dev, base_addr_bar0);
        pci_release_region(pci_dev, 0);
        pci_disable_device(pci_dev);
    }

    static struct pci_driver edu_driver = {
        .name = "qemu_edu_drv",
        .id_table = pci_id_table,
        .probe = edu_probe,
        .remove = edu_remove
    };

    int init_mod(void) {
        pr_info("init hlc module...\n");
        int ret = pci_register_driver(&edu_driver);
        if (ret != 0) {
            pr_err("fail to register pci driver\n");
            goto ERR_PCI_REGISTER_DRIVER;
        }
        return 0;

    ERR_PCI_REGISTER_DRIVER:
        return -1;
    }

    void exit_mod(void) {
        pr_info("exit hlc module...\n");
        pci_unregister_driver(&edu_driver);
    }

    module_init(init_mod);
    module_exit(exit_mod);
    MODULE_LICENSE("GPL");
    ```

    dmesg output:

    ```
    [ 9031.003646] init hlc module...
    [ 9031.003763] in edu_probe()...
    [ 9036.304856] exit hlc module...
    [ 9036.304988] in edu_remove()...
    ```

    加载完驱动后执行`sudo cat /proc/iomem | grep edu`, output:

    ```
        fea00000-feafffff : qemu_edu_drv
    ```

    比较关键的四个函数：`pci_enable_device()` -> `pci_request_region()` -> `pci_resource_len()` -> `pci_iomap()`

* `dma_set_mask()`

    告知操作系统和设备驱动程序，某个硬件设备能够访问的系统物理内存地址范围（即DMA地址空间）有多大.

    syntax:

    ```c
    #include <linux/dma-mapping.h>

    int dma_set_mask(struct device *dev, u64 mask);
    int dma_set_coherent_mask(struct device *dev, u64 mask);
    int dma_set_mask_and_coherent(struct device *dev, u64 mask);
    ```

    返回 0 表示成功，返回一个非零的错误代码（通常是负数）表示失败。

    `dma_set_mask_and_coherent()`是其升级版，

    * streaming DMA：用于一次性的数据传输映射。CPU和设备对这块内存的访问可能不是同步的（非一致性）。

    * coherent DMA（或一致性DMA）：用于需要CPU和设备同时、一致地访问的内存（例如控制寄存器所在的内存）。这块内存在映射时会进行特殊处理以保证缓存一致性。

    `dma_set_mask_and_coherent()`的作用是同时为设备的两种DMA映射方式（流式和一致式）设置相同的地址掩码，这是最常见和推荐的做法，因为它确保了行为的一致性。

* `ioremap_cache()`

    将设备的物理 I/O 内存（通常是 PCI/设备的寄存器或显存）映射到内核的虚拟地址空间，并且允许这段区域使用 CPU 的缓存（cache）机制。

    与其他 ioremap 的区别（未验证）：

    * `ioremap()`（或 ioremap_nocache()）：映射为 非缓存（uncached） 内存，CPU 访问时不走缓存，保证读写与硬件保持一致。

    * `ioremap_wc()`：写合并（write-combining），适合显存等带宽敏感区域。

    * `ioremap_cache()`：映射为 缓存（cached） 内存，CPU 访问时可以走缓存，性能高，但可能会导致和设备之间的数据不一致（需要显式刷新/失效 cache）。

    `ioremap_cache() `一般用于：

    * 显存（framebuffer）等只读/读多写少的区域，提高 CPU 访问效率；

    * 确定设备内存与 CPU 缓存一致性可控时。

    注意：不能随便对寄存器区使用 ioremap_cache()，因为缓存会导致寄存器读写失效或顺序错误。

* `od -c <file>`

    以 字符形式（character）显示文件内容，不可打印字符会用转义符（如`\n`, `\t`, `\0`）或八进制表示。

* `platform_get_irq()`

    syntax:

    ```c
    platform_get_irq(struct platform_device *pdev, unsigned int num)
    ```

    从 platform 设备资源 中获取第 num 个中断号（IRQ number），供驱动程序后续调用 request_irq() 等接口使用。

    如果失败，会返回负数错误码（如 -ENXIO, -EINVAL 等）。

    example:

    ```c
    int irq;
    irq = platform_get_irq(pdev, 0);
    if (irq < 0)
        return irq;
    ret = devm_request_irq(&pdev->dev, irq, my_irq_handler, 0,
                           dev_name(&pdev->dev), dev);
    ```

* cache 与 topic

    cache 攒得多了后，可以尝试将 cache entry 合并成 topic，这个 topic 最好是在二级标题`## topic`下开一个三级标题，比如`### irq, interrupt and msix`:
    
    ```markdown
    ## cache

        ...

    ## topic

    ### irq, interrupt and msix

    * cache entry 1

        ...

    * cache entry 2

        ...

    * ...
    ```
    
    而不是在 cache 中再创建一个 entry，比如

    ```markdown
    ## cache
    
    * irq, interrupt and msix [topic]

        * cache entry 1

            ...

        * cache entry 2

            ...

        * ...
    ```

    因为在 cache 中再创建一个 entry 会改变`cache entry 1, 2, ...`的缩进，非常麻烦，而且`irq, interrupt and msix [topic]`只是一个 list entry，没有锚点，不好定位。

* `-rpath`

    `-rpath <dir>`在生成可执行文件时，把指定的目录`<dir>`记录到可执行文件的 运行时库搜索路径（runtime library search path） 中。当程序运行时，动态链接器会优先在这些路径下查找共享库（`.so`），而不用依赖用户再设置`LD_LIBRARY_PATH`。

    example:

    ```bash
    gcc main.c -o main -L/opt/mylib -lmylib -Wl,-rpath,/opt/mylib
    ```

    其中，`-Wl`表示将接下来的参数传递给`ld`，多个传递参数用逗号`,`分隔。

    `ld`中的写法：

    ```bash
    ld -rpath /opt/mylib
    ```

    与其他选项的区别:

    * `-L<dir>`：告诉编译/链接阶段去哪里找库；

    * `-rpath <dir>`：告诉运行时去哪里找库；

    * `LD_LIBRARY_PATH`：环境变量，运行时指定库路径，作用类似 -rpath，但依赖用户环境。

    优先级：

    1. `LD_LIBRARY_PATH`

    2. `-rpath`

    3. 系统默认目录：`/lib`, `/usr/lib`, `/lib64`, `/usr/lib64` …

    4. /etc/ld.so.cache 里缓存的目录

    指定多个`rpath`：

    ```bash
    # method 1
    gcc main.c -Wl,-rpath,/opt/mylib1:/opt/mylib2 -lmylib

    # method 2
    gcc main.c -Wl,-rpath,/opt/mylib1 -Wl,-rpath,/opt/mylib2
    ```

    `rpath`可以用相对路径，但不推荐。动态链接器解析这个相对路径时，不会用你运行程序时的当前目录，而是相对于 可执行文件被加载时的工作目录（current working directory，CWD）。（未验证）

* chatgpt 写的 bash 定时器

    `timer.sh`:

    ```bash
    #!/bin/bash

    if [ $# -ne 2 ]; then
      echo "用法: $0 <N分钟> <audio_file>"
      exit 1
    fi

    TOTAL_MIN=$1
    AUDIO_FILE=$2
    TOTAL_SEC=$((TOTAL_MIN * 60))

    # 设置终端：关闭回显和规范模式
    stty -echo -icanon time 0 min 0

    paused=0
    elapsed=0

    cleanup() {
      stty sane
      tput cnorm
    }
    trap cleanup EXIT

    tput civis  # 隐藏光标

    while [ $elapsed -lt $TOTAL_SEC ]; do
      # 捕获键盘输入
      key=$(dd bs=1 count=1 2>/dev/null)
      if [ "$key" = " " ]; then
        paused=$((1 - paused))  # 切换暂停/恢复
      fi

      if [ $paused -eq 0 ]; then
        elapsed=$((elapsed + 1))
      fi

      remain=$((TOTAL_SEC - elapsed))
      min=$((remain / 60))
      sec=$((remain % 60))

      # 清理并重写
      tput cup 0 0
      tput ed
      printf "总时间: %2d 分钟\n" "$TOTAL_MIN"
      printf "剩余:   %02d:%02d\n" "$min" "$sec"
      if [ $paused -eq 1 ]; then
        printf "[已暂停]\n"
      else
        printf "         \n"
      fi

      sleep 1
    done

    cleanup
    mpv --really-quiet "$AUDIO_FILE"
    ```

    用法：
    
    `bash timer.sh <N> <audio_file>`
    
    定时`N`分钟后播放音频`<audio_file>`，期间 terminal 上会显示倒计时，按空格可以暂时计时，再次按空格恢复。

* 既然有了 bash 定时器，那么可以在看电脑屏幕时开始计时，比如 30 分钟，到时间后，离开座位 5 分钟，或者闭目养神 5 分钟，休息眼睛。

    这部分属于执行系统的内容。

* feedback 中的联想与 task

    在执行 task 的过程中，有些 feedback 是优先级很低很低的联想，有些是大概率相关的 see also，或者并列概念，或者延伸。如果把联想作为正常 feedback task 去处理，那么整体项目池的效率就太低了。

    在 feedback 中，我们将联想标记为`[asso]`：

    ```markdown
    * task xxxx

        feedback:

        * [asso] xxxxx
    ```

    将其加入 project pool 的 task 中时，放在当前 project 所有 task 的最后。

    此时 deps/feedback 相关的任务有 3 个去处：

    1. deps 的任务，放到当前 project 所有 task 的最前面

    2. 正常 feedback 的任务，放到当前 task 后面

    3. `[asso]`标记的 feedback 任务，放到当前 project 所有 tasn 的最后面

* `pci_request_region()`中，name 可以填`NULL`，此时`/proc/iomem`中 name 一栏为`??`（未验证）

* 查看 glibc 版本：`ldd --version`

* dig 命令包含在 bind-utils 软件包中

* `vncviewer`

    使用方法：

    * `vncviewer 192.168.1.100`

    * `vncviewer 192.168.1.100:5901`