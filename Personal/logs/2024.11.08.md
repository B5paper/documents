* openshmem example: bar pair

    `main.c`:

    ```c
    #include <stdio.h>
    #include <unistd.h>
    #include <shmem.h>

    #define NPES 4

    long pSync[SHMEM_BARRIER_SYNC_SIZE];
    int x = 10101;

    int main()
    {
        for (int i = 0; i < SHMEM_BARRIER_SYNC_SIZE; i += 1)
            pSync[i] = SHMEM_SYNC_VALUE;

        shmem_init();
        int me = shmem_my_pe();

        if (me == 0)
            shmem_int_p(&x, 4, 1);
        shmem_barrier_all();  // this line

        if (me == 2)
        {
            printf("Process %d going to sleep\n", me);
            sleep(3);
            printf("Process %d out from sleep\n", me);
        }

        printf("Process %d before barrier\n", me);
        if (me == 2 || me == 3)
            shmem_barrier(2, 0, 2, pSync);
        printf("Process %d after barrier\n", me);

        printf("%d: x = %d\n", me, x);
        
        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 4 ./main`

    output:

    ```
    Process 2 going to sleep
    Process 3 before barrier
    Process 0 before barrier
    Process 0 after barrier
    0: x = 10101
    Process 1 before barrier
    Process 1 after barrier
    1: x = 4

    Process 2 out from sleep
    Process 2 before barrier
    Process 2 after barrier
    Process 3 after barrier
    3: x = 10101
    2: x = 10101
    ```

    这个程序在运行时会 sleep 3 秒，为了区分 sleep 前和 sleep 后的输出，在 output 里添加了一个换行。

    这段代码做了一个综合测试，pe 0 修改 pe 1 里的数据，然后 pe 0 和 pe 1 正常结束。代码中有一行注释了`// this line`，这一行原 example 中是没有的。如果没有这一行，pe 1 中的`x`的值不会被修改成功。

    pe 2 进入 sleep 状态，pe 3 会在`shmem_barrier()`处等待 pe 2。当 pe 2 运行到 barrier 处后，pe 2 和 pe 3 才会恢复运行。

    `SHMEM_BARRIER_SYNC_SIZE`在程序中的实际值是 1，猜测这个值的含义是能同时监视的值的数量。

    `SHMEM_SYNC_VALUE`的值是`-1`，但如果给`pSync[i]`赋其他值，不影响 barrier 的功能。

* openshmem example: barrier

    `main.c`:

    ```c
    #include <stdio.h>
    #include <shmem.h>

    long pSync[SHMEM_BARRIER_SYNC_SIZE];
    int x = 123;

    int main()
    {
        for (int i = 0; i < SHMEM_BARRIER_SYNC_SIZE; i += 1)
            pSync[i] = SHMEM_SYNC_VALUE;

        shmem_init();
        int me = shmem_my_pe();
        int npes = shmem_n_pes();

        if (me == 0)
            shmem_int_p(&x, 456, 1);
        shmem_barrier(0, 0, npes, pSync);

        printf("%d: x = %d\n", me, x);

        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 4 ./main`

    output:

    ```
    0: x = 123
    3: x = 123
    1: x = 456
    2: x = 123
    ```

    如果不添加`shmem_barrier(0, 0, npes, pSync);`这一行，输出会变为：

    ```
    2: x = 123
    3: x = 123
    1: x = 123
    0: x = 123
    ```

    说明：

    1. `long pSync[SHMEM_BARRIER_SYNC_SIZE];`这个数组可以设置为 main 的局部变量，不影响 barrier 功能。

* openshmem example: broadcast

    `main.c`:

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <shmem.h>

    long pSync[SHMEM_BCAST_SYNC_SIZE];

    int main()
    {
        shmem_init();
        int me = shmem_my_pe();
        int npes = shmem_n_pes();

        long *source = (long *) shmem_malloc(npes * sizeof(long));
        for (int i = 0; i < npes; i += 1)
            source[i] = me * 4 + i;

        long *target = (long *) shmem_malloc(npes * sizeof(long));
        for (int i = 0; i < npes; i += 1)
            target[i] = -1;

        for (int i = 0; i < SHMEM_BCAST_SYNC_SIZE; i += 1)
            pSync[i] = SHMEM_SYNC_VALUE;
        shmem_barrier_all();

        printf("before, pe %d: source: %ld %ld %ld %ld, target: %ld %ld %ld %ld\n", me, source[0], source[1], source[2], source[3], target[0], target[1], target[2], target[3]);

        shmem_broadcast64(target, source, npes, 0, 0, 0, npes, pSync);

        printf("after, pe %d: source: %ld %ld %ld %ld, target: %ld %ld %ld %ld\n", me, source[0], source[1], source[2], source[3], target[0], target[1], target[2], target[3]);
        shmem_barrier_all();

        shmem_free(target);
        shmem_free(source);
        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 4 ./main`

    output:

    ```
    before, pe 3: source: 12 13 14 15, target: -1 -1 -1 -1
    after, pe 3: source: 12 13 14 15, target: 0 1 2 3
    before, pe 0: source: 0 1 2 3, target: -1 -1 -1 -1
    after, pe 0: source: 0 1 2 3, target: -1 -1 -1 -1
    before, pe 1: source: 4 5 6 7, target: -1 -1 -1 -1
    after, pe 1: source: 4 5 6 7, target: 0 1 2 3
    before, pe 2: source: 8 9 10 11, target: -1 -1 -1 -1
    after, pe 2: source: 8 9 10 11, target: 0 1 2 3
    ```

    `shmem_broadcast64()`可以将某个 pe 上指定的一块数组广播到其他 pe 上。

    output 中并不是先输出 before，再统一输出 after，说明`shmem_broadcast64()`并不是一个 barrier。

    又自己写了个 example，感觉这个更能突出 broadcast 的作用：

    ```c
    #include <stdio.h>
    #include <shmem.h>

    long pSync[SHMEM_BCAST_SYNC_SIZE];

    int main()
    {
        shmem_init();
        int me = shmem_my_pe();
        int npes = shmem_n_pes();
        
        int arr_len = 3;
        long *arr = (long *) shmem_malloc(arr_len * sizeof(long));
        for (int i = 0; i < arr_len; ++i)
            arr[i] = -1;

        if (me == 0)
        {
            for (int i = 0; i < arr_len; ++i)
                arr[i] = i;
        }

        for (int i = 0; i < SHMEM_BCAST_SYNC_SIZE; i += 1)
            pSync[i] = SHMEM_SYNC_VALUE;
        shmem_barrier_all();

        printf("before, pe %d: arr: %ld %ld %ld\n", me, arr[0], arr[1], arr[2]);

        shmem_broadcast64(arr, arr, arr_len, 0, 0, 0, npes, pSync);

        printf("after, pe %d: arr: %ld %ld %ld\n", me, arr[0], arr[1], arr[2]);
        shmem_barrier_all();

        shmem_free(arr);
        shmem_finalize();
        return 0;
    }
    ```

    output:

    ```
    before, pe 2: arr: -1 -1 -1
    before, pe 3: arr: -1 -1 -1
    after, pe 3: arr: 0 1 2
    before, pe 1: arr: -1 -1 -1
    after, pe 1: arr: 0 1 2
    before, pe 0: arr: 0 1 2
    after, pe 0: arr: 0 1 2
    after, pe 2: arr: 0 1 2
    ```