* c++ 中 unordered_map 无法使用`vector<int>`之类的数据作为 key，但是可以作为 value

    也无法使用`array<>`作为 key。

    如果需要这些数据类型作为 key，需要自己写哈希函数和比较函数。

* `vector<int[26]> v;`实际存放的是`int*`指针，具体的 26 个 int 的存储空间需要自己去申请

    因此没有办法做到`v.push_back()`这种事，同样地，`v.push_back({})`，`v.push_back({1, 2, 3})`，`v.push_back(int[26])`这些也都无法实现。

    但是可以使用`vector<array<int, 26>> v;`实现存放数组的功能。

* `array<int, 26> arr;`没有 clear 的功能，有两种方式可以实现赋值

    1. 使用初始化赋值

        ```cpp
        array<int, 26> arr = {1};  // 将 26 个数据都赋值为 1
        ```

        这个初始化方法在 for 中仍然适用。

    2. 使用`fill()`赋值

        ```cpp
        array<int, 26> arr;
        arr.fill(3);  // 将 26 个数据赋值为 3
        ```

    如果在 for 中声明变量，但是不初始化，那么并不会每次都赋初始值：

    ```cpp
    for (int i = 0; i < 5; ++i)
    {
        array<int, 10> arr;
        for (int num: arr)
        {
            printf("%d, ", num);
        }
        arr[i] = i;
        putchar('\n');
    }
    ```

    output:

    ```
    1, 2, 3, 32512, -394097016, 32512, -394983164, 32512, -394096808, 32512, 
    0, 2, 3, 32512, -394097016, 32512, -394983164, 32512, -394096808, 32512, 
    0, 1, 3, 32512, -394097016, 32512, -394983164, 32512, -394096808, 32512, 
    0, 1, 2, 32512, -394097016, 32512, -394983164, 32512, -394096808, 32512, 
    0, 1, 2, 3, -394097016, 32512, -394983164, 32512, -394096808, 32512,
    ```

    `array<>`没有`fill()`和`assign()`方法。

* 如果一个数据可以使用数组计数来抽取特征，那么可以使用排序使得数据相等

    可以尽量将数据转换成字符串的形式，以便使用哈希表加速。

* `request_irq()`

    header: `#include <linux/interrupt.h>`

* `struct work_struct`

    header: `#include <linux/workqueue.h>`

* `__this_cpu_write()`

    header: `asm/hw_irq.h`

* 一个可用的`INIT_WORK()`的代码，见`ref_17`

    测试：

    ```bash
    make
    sudo insmod wque.ko
    sudo cat /dev/hlc_dev
    ```

    `dmesg` output:

    ```
    [25350.311799] init hlc module done.
    [25366.856255] in m_open()...
    [25366.856262] in m_read()...
    [25366.856265] in irq_handler()...
    [25366.856272] in m_release()...
    [25366.856312] in work_queue_fn()...
    [25414.842921] in exit_mod()...
    [25414.843190] exit hlc module done.
    ```

    explanation:

    1. 在创建`work_struct`对象的时候，需要我们自己申请内存，要么就直接创建全局变量，不能只创建一个指针。

        代码中使用`struct work_struct work_item;`创建了个全局对象。

        这一点和`class_create()`，`device_create()`挺不一样的，这两个函数都是只返回指针，内存由操作系统管理。

    2. `INIT_WORK()`需要将`work_struct`的指针传进去：
    
        `INIT_WORK(&work_item, work_queue_fn);`

    3. `schedule_work()`传的也是指针：

        `schedule_work(&work_item);`

    4. 这份代码不包含函数返回值检测和异常处理，所以比较简洁。

