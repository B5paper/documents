* 使用自己创建的 work queue 的一个 example

    见`ref_18`。

    `dmesg` output:

    ```
    [ 5794.009888] aaaaa: loading out-of-tree module taints kernel.
    [ 5804.635333] in m_open()...
    [ 5804.635340] in m_read()...
    [ 5804.635345] in m_release()...
    [ 8209.385918] in init_mod()...
    [ 8230.417934] in m_open()...
    [ 8230.417941] in m_read()...
    [ 8230.417947] in m_release()...
    [ 8230.417988] in work func
    [ 9099.408811] in exit_()...
    ```

    说明：

    1. 使用`struct workqueue_struct *wque;`创建一个 work queue 指针。

    2. 使用`create_workqueue()`宏创建一个 queue 指针。
    
        `wque = create_workqueue("hlc_wque");`

        显然，work queue 的内存是由操作系统负责管理的，没有显式交给用户管理。

    3. `INIT_WORK(&witem, work_func);`初始化一个 work item，即`struct work_struct`对象。

    4. 使用`queue_work(wque, &witem);`将 work item 放到 work queue 中

        work item 放入后将会被执行。

    5. 使用`destroy_workqueue(wque);`销毁一个 work queue。

    6. `queue_work()`用于将 work item 放入自定义的 work queue 中，`schedule_work()`将 work item 放到 global shared work queue 中。

    7. work item 的回调函数原型：

        ```c
        void work_callback_func(struct work_struct *work_item)
        {
            // do something...
        }
        ```

        要求返回值是`void`，函数参数是`struct work_struct *`。

        不然`INIT_WORK()`宏会报错。

* linked list 的一个 example

    见`ref_19`

    output:

    ```
    [24310.834664] in init_mod()...
    [24310.834666] traverse list:
    [24310.834667] 3
    [24310.834667] 2
    [24310.834668] 1
    [24310.834668] 4
    [24310.834668] list len: 4
    [24319.849530] in exit_mod()...
    ```

    说明：

    1. 头文件：`#include <linux/list.h>`

    2. `struct list_head`只包含两个成员，一个是`prev`，一个是`next`

        所以 linux kernel 中的链表其实是个双向链表。

    3. 我们在构建自定义的链表数据结构的时候，需要把`struct list_head`作为一个成员：

        ```c
        struct ListNode {
            struct list_head head;
            int my_data;
        };
        ```

    4. `INIT_LIST_HEAD(&lst_head);`用于初始化一个链表头，主要功能就是让 next 和 prev 都指向自己。

        注意这个 list head 不是定义在`ListNode`之中的，它只是一个 head，不存储数据。

        linux 想象中的链表是这样的：

        `list_head` -> `ListNode` -> `ListNode` -> `ListNode` -> `...`

        因此`list_head`只是一个链表头，本身不算一个完整的节点。在执行遍历等操作时，`list_head`都不会被访问到。

    5. `list_add(&node_1.head, &lst_head);`

        在`lst_head`后添加一个新节点`node_1`。

        对于后面的`node_2`，`node_3`等，由于每次都是在`lst_head`后面添加，所以其实是倒序添加的：

        ```
        lst_head
        lst_head -> 1
        lst_head -> 2 -> 1
        lst_head -> 3 -> 2 -> 1
        ```

    6. `list_add_tail(&node_4.head, &lst_head);`是在链表的末尾添加 node 4:

        ```
        lst_head -> 3 -> 2 -> 1 -> 4
        ```

    7. 遍历时，通过给定自定义类型的指针和`lsit_head`在自定义类型中的名称来进行遍历

        ```c
        struct ListNode {
            struct list_head head;
            int my_data;
        };

        // ...

        struct ListNode *cur;
        list_for_each_entry(cur, &lst_head, head) {
            pr_info("%d\n", cur->my_data);
        }
        ```

        可以看到，`cur`是用户自己提供的指针，用来访问当前遍历到的节点；`&lst_head`是链表头，`head`是`struct list_head`成员在用户自定义类型`ListNode`里的名字。

        `list_for_each_entry()`是一个宏，将宏展开可以看到它是如何确定每个`cur`的地址的。主要是根据`offset(head)`找到`head`的相对偏移，然后根据`head`的相对偏移再结合`head`的地址，找到`ListNode`的起始地址，这个地址就是`cur`的值。

    8. 遍历的输出为`3, 2, 1, 4`，链表长度为`4`，说明在遍历时并没有访问到`lst_head`。