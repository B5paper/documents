* 境界不可能突然提升。境界的提升需要与自己作战，自己又不可能被轻易打败，所以境界不可能突然提升。

* 面对面交流与网络交流的误会更少，能面对面交流的情况不要隔着网络交流。

* 感觉公司的风水不好，无法静下心来，容易增加攻击性，容易上头，容易情绪极端。

* ai 视频确实恐怖，但是另外一种ai正确却毫无生气，比如微博里的ai水军，回复要么是重复问题，要么是重复感叹，要么是毫无情感的赞美，他们的回复虽然正确，但是没有灵气，也没有情绪波动。

* 正是经历了多次人事变动，才能固化下来自己的方法论，变得稳定。这个过程有点像深度学习的增广变换。但是想到大多数人经历足够长的时间和足够多的事情后，都可以完成这个过程，其实这种能力也不算稀罕。

* lavazza 的森林汤力美式 agosto，是苏打气泡水 + 美式。感觉一般偏下。

* 红楼梦前文线索充足，情节复杂，甚至多次预演暗示结局，但是仅靠前八十回仍无法推测后二十八回的情节，是否意味着对于一个复杂系统，我们无法靠部分规律推测出全貌？

* 如果有突然冒出来的想法，还是停下手头的事先记录想法比较好，后面忘了就再也想不起来了。

* 现代中国教育轻而易举改变了我们对红楼的认知，那么是否还有别的领域被篡改或教得不好呢？

* 即使癸酉癸酉本的各种线索都确凿无疑，仍有许多人坚持自己的想法不肯承认其真实性，说明真的有人只相信自己愿意相信的，即使真相已经在面前。

* 百度百科对金簪雪里埋的解析基本就是瞎解析，这是否说明很多的解析和赏析都是瞎解读，语文很多时候都不可靠？

* 古人对人物的不同性格观察得如此细致，远远超越了现在的 mbti，这是否也说明我对人的性格观察得太少，以为所有人都是想学习知识做出科研贡献

* 幸亏当初没好好学，在背红楼梦意义的时候，只是机械记忆了表现封建统治下家族的兴衰，也没有去深究，现在看来，当初这种认识都是完全错误的，幸好当时没有好好学。

* 伏笔与回环

    如果一个伏笔在一百章之后仍能回收，那么有可能是先写了结局，再去前面剧情埋伏笔，也有可能前面写了段无用剧情，后面注意到了这个剧情，再在结尾添加一段，把伏笔圆上。无论如何，都暗示我们写埋有伏笔的小说，线性地从前写到后一定是不可能的，必须经过反复的负反馈，把逻辑调理通顺，把伏笔都尽数回收。

* 如果多人合作，那么负责区域划分必须明确

* `strchr()`

    找到一个字符串中某个字符第一次出现的位置。

    头文件：`#include <string.h>`

    syntax:

    ```c
    const char *strchr(const char *str, int c);
    char *strchr(char *str, int c);
    ```

    example:

    ```cpp
    #include <string.h>
    #include <stdio.h>

    int main() {
        const char *msg = "hello, world";
        const char *pos = strchr(msg, 'w');
        printf("idx: %ld, ch: %c\n", pos - msg, *pos);
        return 0;
    }
    ```

    output:

    ```
    idx: 7, ch: w
    ```

    如果未找到，返回`NULL`。

    `strchr()`不支持中文。

* 删除当前目录下的所有内容（包括隐藏文件）

    `rm -rf .[!.]* ..?* *`

    解析：

    * `.[!.]*`：匹配所有以`.`开头，且第二个字符不是`.`的文件/文件夹（如`.bashrc`）。

    * `..?*`：匹配所有以`..`开头，且第三个字符存在的文件/文件夹（如`..hidden`）。

    * `*`：匹配所有非隐藏文件/文件夹。

    这里对`.`和`..`进行特殊处理，是为了避开默认存在的两个文件夹，即`.`和`..`。

    如果文件名包含特殊字符（如 -、--、空格等），可以改用：

    `find . -mindepth 1 -delete`

    解析：

    find . -mindepth 1：查找当前目录下的所有文件/文件夹（不包括 . 本身）。

    -delete：直接删除（需谨慎）。

    仅删除隐藏文件和文件夹:

    `rm -rf .[!.]* .??*`

    解析：

    * `.[!.]*` → 匹配`.`开头，第二个字符不是`.`的文件/目录（如 .bashrc、.config）。

    .??* → 匹配 . 开头，且至少 3 个字符的文件/目录（如 .ssh、.gitignore）。

    `find . -maxdepth 1 -name ".*" -exec rm -rf {} +`

    解析：

    -maxdepth 1 → 仅当前目录（不递归子目录）。

    -name ".*" → 匹配所有以 . 开头的文件/目录。

    -exec rm -rf {} + → 批量删除匹配项。

    递归删除子目录中的隐藏文件：

    `find . -name ".*" -exec rm -rf {} +`

    仅删除隐藏文件（保留隐藏目录）:

    `find . -maxdepth 1 -type f -name ".*" -delete`

    -type f → 仅匹配文件（不包括目录）。

* `ls -A`

    查看用户创建的隐藏文件

* 任何以`.`开头的文件或目录都会被系统视为隐藏文件

    `..xxx`并不是例外的隐藏文件。

* c++ `std::format`

    `std::format`是 c++ 20 支持的特性。头文件：`<format>`

    example:

    ```cpp
    #include <format>
    #include <iostream>

    int main() {
        std::string message = std::format("Hello, {}!", "world");
        std::cout << message; 
    }
    ```

    g++ 11.4 目前不支持该特性，无法编译通过。

* nvidia-smi

    nvidia-smi: NVIDIA System Management Interface

    NVML: NVIDIA Management Library

    1.1 可查询的状态

        ECC 错误计数
        GPU 利用率
        活动计算进程
        时钟和 PState
        温度和风扇速度
        电源管理
        硬件识别

    1.2 可修改的状态

        ECC 模式
        ECC 复位
        计算模式
        持久模式

    * `Persistence-M`: 	持久模式是否启用。On 表示启用, Off 表示关闭。启用时 GPU 将保持最大性能状态

    * `Disp.A`: 显示器是否连接到 GPU 的输出端口。On 表示连接,Off 表示没有连接

    * `Volatile Uncorr. ECC`: 未 corrected 错误的易失性 ECC 内存错误计数。用于检测内存错误

        这个数字正常情况下都是全 0.

    * `Perf`: 性能状态。P0 是最大性能状态, P8 是最小性能状态

    * `Compute M.`: 计算模式。Default 是默认模式

    * `MIG M.`: MIG(Multi-Instance GPU) 模式, 将一个物理 GPU 分成多个独立、隔离的实例。Disabled 表示未启用

* 有关 A100

    A100 是 2020 年推出的芯片，前任是 V100，后继是 H100, H200

    A100 的规格：

    SMs 108, TPCs 54

* c++ 中模板类和基类为模板类的模板类，都可以作为聚合类

    ```cpp
    #include <vector>
    #include <stdio.h>
    #include <unordered_map>
    using namespace std;

    template<typename T>
    struct VertexBase {
        int id;
        T type;
    };

    template<typename T, typename P>
    struct Vertex: public VertexBase<T> {
        P msg;
    };

    int main() {
        VertexBase<int> vert_base{1, 2};
        Vertex<int, const char*> vert{1, 2, "haha"};
        printf("id: %d, type: %d, msg: %s\n", vert.id, vert.type, vert.msg);
        
        vector<VertexBase<int>> base_verts;
        // base_verts.emplace_back(3, 4);  // error
        vector<Vertex<int, const char*>> verts;
        // verts.emplace_back(1, 2, "hello");  // error
        return 0;
    }
    ```

    但是`emplace()`和`emplace_back()`，需要类必须自定义构造函数来支持。

    如果调用`base_verts.push_back({3, 4});`，那么本质是先用`{3, 4}`聚合构造（Aggregate Initialization）了一个对象，然后调用`push_back()`的重载版本，此时如果`VertexBase`有移动构造函数，那么调用`push_back(VertexBase&&)`，并调用`VertexBase`的移动构造函数，如果没有，那么调用`push_back(const VertexBase&)`，并调用`VertexBase`的拷贝构造函数。

* `emplace_back()`如果使用默认构造函数，那么必须参数为空：

    `my_vec.emplace_back()`

    如果函数中有参数，那么会被传递给自定义的构造函数：

    `my_vec.emplace_back(1, 2, 3);  // 需要自定义构造函数支持`

* `do { ... } while(0)`

    常用场景：

    1. 构造单条语句，通常用在宏里，可以把多条代码打包成一条。

        ```c
        #define LOG(msg) do { \
            printf("[LOG] %s\n", msg); \
            write_to_file(msg); \
        } while(0)

        // 使用
        if (error)
            LOG("Error occurred");  // 安全展开为单语句
        else
            recover();
        ```

        注：`LOG("Error occurred");`整体才算一个单语句，如果不加`;`则不算单语句，会报错。

        如果不加`do while`，则有：

        ```c
        #define LOG(msg) { printf("[LOG] %s\n", msg); write_to_file(msg); }

        // 展开后：
        if (error)
            { printf(...); write_to_file(...); };  // 结尾分号导致 else 语法错误！
        else
            recover();
        ```

        其中，`{ printf(...); write_to_file(...); }`表示一条语句，其后的`;`表示第二条语句。

    1. 需要用`break`的场景

        * 替换`goto`语句：

            ```c
            int func() {
                do {
                    if (step1_failed) break;
                    if (step2_failed) break;
                    // ...成功逻辑...
                    return 0;
                } while(0);

                // 统一错误处理
                cleanup();
                return -1;
            }
            ```

        * 简化 if 的逻辑

            ```c
            do {
                // 只执行一次的复杂逻辑
                if (condition) break;
                // ...其他代码...
            } while(0);
            ```

* 参考资料与缓存

    对于无法一次处理完的资料，必须使用缓存。

    很多资料（resource）的结构是类似字典的方式（比如博客里写的 linux command 的教程，会列出类似`man`文档里的对参数的详细解释），通常我们可以线性理解，但是每次只能理解一点，因为记忆力有限。

    此时必须把参考资料缓存起来，或者保存 url，或者保存内容，然后每天尝试理解/记忆一点。

    因此，缓存的作用就是一个桥梁，将不适合吸收的参考资料慢慢转换成适配当前的知识图谱的知识。

* gdb 锁定线程

    `set scheduler-locking on`
