* vulkan 相关

    * 有关窗口 buffer 和渲染 buffer 的创建与关联流程

        猜想：swap chain 用于和窗口交换数据，在调用`vkCreateSwapchainKHR(()`时会创建好一些图片缓冲区。

        调用`vkGetSwapchainImagesKHR()`可以拿到缓冲区的这些图片，实际拿到的是`VkImage`类型的一些对象，猜测这些对象其实是图片指针。

        调用`vkCreateImageView()`生成`VkImageView`，可以给`VkImage`加一些额外的图片信息，相当于一个 wrapper 的功能。

        然后再调用`vkCreateFramebuffer()`，将`VkImageViewv`转换成`VkFramebuffer`，供 render pass 使用。

        最终`VkFramebuffer`会被写在`VkRenderPassBeginInfo`对象的`framebuffer`字段中，而`vkCmdBeginRenderPass()`会接收`VkRenderPassBeginInfo`对象作为参数，进行实际的渲染。

    * 有关与窗口交换 buffer 和渲染指令队列

        ```cpp
        void drawFrame(VkDevice &device, VkFence &inFlightFence, VkCommandBuffer &commandBuffer,
            VkSwapchainKHR &swapChain, VkSemaphore &imageAvailableSemaphore,
            VkRenderPass &renderPass, std::vector<VkFramebuffer> &swapChainFramebuffers,
            VkExtent2D &swapChainExtent, VkPipeline &graphicsPipeline,
            VkSemaphore &renderFinishedSemaphore, VkQueue &graphicsQueue,
            VkQueue &presentQueue)
        {
            vkWaitForFences(device, 1, &inFlightFence, VK_TRUE, UINT64_MAX);
            vkResetFences(device, 1, &inFlightFence);

            uint32_t imageIndex;
            vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &imageIndex);

            vkResetCommandBuffer(commandBuffer, 0);
            recordCommandBuffer(commandBuffer, imageIndex, renderPass, swapChainFramebuffers, swapChainExtent, graphicsPipeline);

            VkSubmitInfo submitInfo{};
            submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
            submitInfo.waitSemaphoreCount = 1;
            submitInfo.pWaitSemaphores = &imageAvailableSemaphore;  // 拿到画图所需要的缓冲区
            submitInfo.pWaitDstStageMask = &static_cast<const VkPipelineStageFlags&>(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT);
            submitInfo.commandBufferCount = 1;
            submitInfo.pCommandBuffers = &commandBuffer;
            submitInfo.signalSemaphoreCount = 1;
            submitInfo.pSignalSemaphores = &renderFinishedSemaphore;  // 判断是否绘制完成
            if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFence) != VK_SUCCESS) {
                throw std::runtime_error("failed to submit draw command buffer!");
            }

            VkPresentInfoKHR presentInfo{};
            presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
            presentInfo.waitSemaphoreCount = 1;
            presentInfo.pWaitSemaphores = &renderFinishedSemaphore;
            presentInfo.swapchainCount = 1;
            presentInfo.pSwapchains = &swapChain;
            presentInfo.pImageIndices = &imageIndex;
            vkQueuePresentKHR(presentQueue, &presentInfo);
        }
        ```

        看起来`vkQueuePresentKHR()`会把渲染好的图片的信息加入到 present 队列里。说明 present 队列与窗口的 swap 是 vk 在后台帮忙完成的，它和渲染指令队列是异步交互的。


* c++ 中将一个自动管理的对象（比如局部变量，全局变量等）交给另外一个自动管理的系统（比如 shared_ptr，stl 容器）时，由于会调用移动构造函数，所以有可能不调用构造函数，造成构造函数和析构函数调用的次数不成对，最终导致内存错误。

    一个经典的错误是，在程序结束时，构造函数调用一次，析构函数调用两次。

    example:

    ```cpp
    #include <iostream>
    #include <memory>
    using namespace std;

    struct B;

    struct A
    {
        int val;
        shared_ptr<B> to_b;
        A() {
            cout << "in A constructor" << endl;
        }
        ~A() {
            cout << "in A destructor, val: " << val << endl;
        }
    };

    struct B
    {
        int val;
        weak_ptr<A> to_a;
        B() {
            cout << "in B constructor" << endl;
        }
        ~B() {
            cout << "in B destructor, val: " << val << endl;
        }
    };

    int main()
    {
        A a;
        a.val = 1;
        B b;
        b.val = 2;
        a.to_b = make_shared<B>(b);
        b.to_a = make_shared<A>(a);
        return 0;
    }
    ```

    输出：

    ```
    in A constructor
    in B constructor
    in A destructor, val: 1
    in B destructor, val: 2
    in A destructor, val: 1
    in B destructor, val: 2
    ```

* 假如一个场景中包含了很多物体，我想根据物体对象，拿到它所在的场景，该怎么写 c++ 代码？

    显然要用到指针。但是需不需要用到智能指针？

    一个比较简单的情况：

    ```cpp
    #include <iostream>
    #include <memory>
    #include <vector>
    using namespace std;

    struct Scene;

    struct Object
    {
        string name;
        Scene *pscene;

        string get_scene_name();
    };

    struct Scene
    {
        string name;
        vector<Object> objs;
    };

    string Object::get_scene_name() {
        return pscene->name;
    }

    int main()
    {
        Scene scene;
        scene.name = "m_scene";
        Object obj;
        obj.name = "hello";
        obj.pscene = &scene;
        scene.objs.push_back(obj);

        Object &inner_obj = scene.objs[0];
        cout << "scene name: " << inner_obj.get_scene_name() << endl;
        return09;
    }
    ```

    输出：

    ```
    scene name: m_scene
    ```

    但是如果 scene 在 obj 不知道的时候，偷偷失效了，会发生什么？

    ```cpp
    #include <iostream>
    #include <memory>
    #include <vector>
    using namespace std;

    struct Scene;

    struct Object
    {
        string name;
        Scene *pscene;

        string get_scene_name();
    };

    struct Scene
    {
        string name;
        vector<Object> objs;
    };

    string Object::get_scene_name() {
        return pscene->name;
    }

    int main()
    {
        Scene *scene = new Scene;
        scene->name = "m_scene";
        Object obj;
        obj.name = "hello";
        obj.pscene = scene;
        scene->objs.push_back(obj);

        Object &inner_obj = scene->objs[0];
        delete scene;  // 在 inner_obj 不知道的时候，scene 已经失效了
        cout << "scene name: " << inner_obj.get_scene_name() << endl;
        return 0;
    }
    ```

    这段代码会报运行时错误：

    ```
    terminate called after throwing an instance of 'std::length_error'
        what():  basic_string::_M_create
    ```

    可以看到`scene`会失效，`inner_obj`本身也会失效。

    假如两个对象没有包含的关系，即一个对象中，不使用 stl 容器包含另一个对象，会发生什么？

    ```cpp
    #include <iostream>
    #include <memory>
    #include <vector>
    using namespace std;

    struct B;

    struct A
    {
        string name;
        B *pb;
    };

    struct B
    {
        string name;
        A *pa;
    };

    int main()
    {
        A *a = new A;
        a->name = "a";
        B *b = new B;
        b->name = "b";
        b->pa = a;
        a->pb = b;

        delete a;
        cout << b->name << endl;
        cout << b->pa->name << endl;  // 在这一行会出现运行时错误
        return 0;
    }
    ```

    可见，一个对象的消失，并不会通知另外一个对象。

    如果換成智能指针呢？会发生什么？

    ```cpp
    #include <iostream>
    #include <memory>
    #include <vector>
    using namespace std;

    struct B;

    struct A
    {
        string name;
        shared_ptr<B> pb;
        A() {
            cout << "in A constructor" << endl;
        }
        ~A() {
            cout << "in A destructor" << endl;
        }
    };

    struct B
    {
        string name;
        shared_ptr<A> pa;
        B() {
            cout << "in B constructor" << endl;
        }
        ~B() {
            cout << "in B destructor" << endl;
        }
    };

    int main()
    {
        A *a = new A;
        a->name = "a";
        B *b = new B;
        b->name = "b";
        b->pa = make_shared<A>(*a);
        a->pb = make_shared<B>(*b);

        delete a;
        cout << b->name << endl;
        cout << b->pa->name << endl;
        return 0;
    }
    ```

    输出：

    ```
    in A constructor
    in B constructor
    in A destructor
    in B destructor
    b
    a
    ```

    可以看到，在`delete a;`时，`A`和`B`两个对象就已经被销毁了，后面的输出其实是不可靠的。

    有一个想法是给`A`和`B`互设友元，这样当某个对象失效的时候，可以在析构函数里告诉互相链接的对象。但是这样要求你提前知道哪些类是需要互相通信的，而且当类的数量变多的时候，通信连接数会指数增长。

    其实智能指针和 move 语义也都只能保证有关联的两个指针，如果一个有效，那么另一个也一定有效。无法保证一个失效时，对另外一个指针进行通知；或者让一个指针总是能查询与之相关联的另一个指针是否有效。

    或许可以增加一个全局对象，或者用一个额外的类，来对资源进行管理，提供对象是否失效的查询接口。这样要求每次有新的对象创建，必须在这个资源管理对象中进行注册，当对象被销毁时，在资源管理对象中反注册。这样就又涉及到整个程序的设计思想了，是否真的需要这样做，还得权衡代码复杂度和性能。

    如果让`B`对象包含`A`的指针，如果仅仅是为了传参方便，我觉得没有必要这样做。如果他们确实存在包含关系，那么只需要用到 c++ 的局部变量内存管理就好了。如果两个对象存在依赖关系，那么可以考虑用智能指针。