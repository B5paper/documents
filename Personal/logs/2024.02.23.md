* vulkand command pool 和 command buffer 的创建比较简单

    ```cpp
    VkCommandPool cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
    VkCommandBuffer cmd_buf;
    VkCommandBufferAllocateInfo cmd_buf_alc_info{};
    cmd_buf_alc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    cmd_buf_alc_info.commandBufferCount = 1;
    cmd_buf_alc_info.commandPool = cmd_pool;
    cmd_buf_alc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    result = vkAllocateCommandBuffers(device, &cmd_buf_alc_info, &cmd_buf);
    if (result != VK_SUCCESS)
    {
        printf("fail to allocate command buffer\n");
        exit(-1);
    }
    ```

    按部就班，没有什么难理解的地方。

* leetcode 题目

    * 802. 找到最终的安全状态

        ```
        有一个有 n 个节点的有向图，节点按 0 到 n - 1 编号。图由一个 索引从 0 开始 的 2D 整数数组 graph表示， graph[i]是与节点 i 相邻的节点的整数数组，这意味着从节点 i 到 graph[i]中的每个节点都有一条边。

        如果一个节点没有连出的有向边，则该节点是 终端节点 。如果从该节点开始的所有可能路径都通向 终端节点 ，则该节点为 安全节点 。

        返回一个由图中所有 安全节点 组成的数组作为答案。答案数组中的元素应当按 升序 排列。

        

        示例 1：

        Illustration of graph

        输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
        输出：[2,4,5,6]
        解释：示意图如上。
        节点 5 和节点 6 是终端节点，因为它们都没有出边。
        从节点 2、4、5 和 6 开始的所有路径都指向节点 5 或 6 。

        示例 2：

        输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
        输出：[4]
        解释:
        只有节点 4 是终端节点，从节点 4 开始的所有路径都通向节点 4 。

        

        提示：

            n == graph.length
            1 <= n <= 104
            0 <= graph[i].length <= n
            0 <= graph[i][j] <= n - 1
            graph[i] 按严格递增顺序排列。
            图中可能包含自环。
            图中边的数目在范围 [1, 4 * 104] 内。

        ```

        分析：

        一开始以为这道题没有动态的部分，只需要下一跳是终端节点就可以了：

        ```cpp
        class Solution {
        public:
            bool num_in_vector(int node_id, vector<int> &out_node_ids)
            {
                for (int i = 0; i < out_node_ids.size(); ++i)
                {

                    if (node_id == out_node_ids[i])
                        return true;
                }
                return false;
            }

            vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
                vector<int> final_nodes;
                vector<int> ans;
                for (int i = 0; i < graph.size(); ++i)
                {
                    if (graph[i].empty())
                        final_nodes.push_back(i);
                }

                bool flag = true;
                for (int i = 0; i < graph.size(); ++i)
                {
                    flag = true;
                    for (int j = 0; j < graph[i].size(); ++j)
                    {
                        if (!num_in_vector(graph[i][j], final_nodes))
                        {
                            flag = false;
                            break;
                        }
                    }
                    if (flag)
                    {
                        ans.push_back(i);
                    }
                }
                return ans;
            }
        };
        ```

        上面的代码是解答错误。

        后来又看了看题目，好像是说，不管几跳，只要能找到终端节点就可以。那肯定是要用到动态的算法了，想了想，用递归吧。

        ```cpp
        class Solution {
        public:
            bool num_in_vector(int node_id, vector<int> &out_node_ids)
            {
                for (int i = 0; i < out_node_ids.size(); ++i)
                {
                    if (node_id == out_node_ids[i])
                        return true;
                }
                return false;
            }

            bool next_is_final(int idx, vector<vector<int>> &graph, vector<int> &final_nodes, vector<int> visited)
            {
                if (num_in_vector(idx, visited))
                    return false;
                visited.push_back(idx);

                if (graph[idx].size() == 0)
                    return true;

                if (num_in_vector(idx, final_nodes))
                    return true;

                for (int i = 0; i < graph[idx].size(); ++i)
                {
                    if (!next_is_final(graph[idx][i], graph, final_nodes, visited))
                        return false;
                }
                return true;
            }

            vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
                vector<int> final_nodes;
                vector<int> ans;
                for (int i = 0; i < graph.size(); ++i)
                {
                    if (graph[i].empty())
                        final_nodes.push_back(i);
                }

                for (int i = 0; i < graph.size(); ++i)
                {
                    if (next_is_final(i, graph, final_nodes, {}))
                        ans.push_back(i);
                }
                return ans;
            }
        };
        ```

        上面的代码超时。上面的代码基本想法是用深度优先，`next_is_final()`每次都搜索所有 out 的连线，直到找到终端节点为止。如果找不到，那么说明它不是安全节点。

        这个代码没考虑到图中有环的情况，所以会遇到死循环。万万没想到题目中还有环。

        然后是第三版代码：

        ```cpp
        class Solution {
        public:
            bool next_is_final(int idx, vector<vector<int>> &graph, unordered_set<int> &final_nodes, unordered_set<int> &visited)
            {
                if (visited.find(idx) != visited.end())
                    return false;

                if (graph[idx].size() == 0)
                    return true;

                if (final_nodes.find(idx) != final_nodes.end())
                    return true;

                for (int i = 0; i < graph[idx].size(); ++i)
                {
                    if (visited.find(graph[idx][i]) != visited.end())
                        return false;
                    visited.insert(idx);
                    if (!next_is_final(graph[idx][i], graph, final_nodes, visited))
                    {
                        visited.erase(idx);
                        return false;
                    }
                }
                visited.erase(idx);
                return true;
            }

            vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
                unordered_set<int> final_nodes;
                unordered_set<int> visited;
                vector<int> ans;

                for (int i = 0; i < graph.size(); ++i)
                {
                    if (graph[i].empty())
                        final_nodes.insert(i);
                }

                for (int i = 0; i < graph.size(); ++i)
                {
                    if (next_is_final(i, graph, final_nodes, visited))
                        ans.push_back(i);
                }
                return ans;
            }
        };
        ```

        这次仍然超时。

        这次使用`visited`来避免出现环。`visited`的`inset()`和`erase()`的位置也是凭直觉设置的，代码竟然没出错。

        另外这次删掉了线性查找一个数是否在 vector 里存在的函数，改成了哈希表。

        想了想，哈希表或许没有 bool 数组快，尝试改了下：

        ```cpp
        class Solution {
        public:
            bool next_is_final(int idx, vector<vector<int>> &graph, vector<bool> &visited)
            {
                if (visited[idx])
                    return false;

                if (graph[idx].size() == 0)
                    return true;

                for (int i = 0; i < graph[idx].size(); ++i)
                {
                    if (visited[graph[idx][i]])
                        return false;
                    visited[idx] = true;
                    if (!next_is_final(graph[idx][i], graph, visited))
                    {
                        visited[idx] = false;
                        return false;
                    }
                }
                visited[idx] = false;
                return true;
            }

            vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
                vector<bool> visited(graph.size(), false);
                vector<int> ans;

                for (int i = 0; i < graph.size(); ++i)
                {
                    if (next_is_final(i, graph, visited))
                        ans.push_back(i);
                }
                return ans;
            }
        };
        ```

        （超时）

        这次删掉了判断`final_nodes`，因为`graph[idx].size() == 0`说明已经找到了 final node。

        bool 数组已经是非常快的了，再想更快只能剪枝了。想了想，如果一个节点可以跳到终端节点，那么所有与这个节点相连的节点才能跳到终端节点。

        ```cpp
        class Solution {
        public:
            vector<bool> can_reach_final_nodes;

            bool next_is_final(int idx, vector<vector<int>> &graph, vector<bool> &visited)
            {
                if (graph[idx].size() == 0)
                {
                    can_reach_final_nodes[idx] = true;
                    return true;
                }

                for (int i = 0; i < graph[idx].size(); ++i)
                {
                    if (visited[graph[idx][i]])
                        return false;
                    if (can_reach_final_nodes[graph[idx][i]])
                        continue;
                    visited[idx] = true;
                    if (!next_is_final(graph[idx][i], graph, visited))
                    {
                        visited[idx] = false;
                        return false;
                    }
                }

                visited[idx] = false;
                can_reach_final_nodes[idx] = true;
                return true;
            }

            vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
                vector<bool> visited(graph.size(), false);
                can_reach_final_nodes.assign(graph.size(), false);
                vector<int> ans;

                for (int i = 0; i < graph.size(); ++i)
                {
                    if (next_is_final(i, graph, visited))
                        ans.push_back(i);
                }
                return ans;
            }
        };
        ```

        这份代码是通过的。只击败了 14%。

        使用了一个 bool 数组`can_reach_final_nodes`来剪枝。

        下面是官方题解，有时间了看看：

        * 深度优先搜索 + 三色标记法

            ```cpp
            class Solution {
            public:
                vector<int> eventualSafeNodes(vector<vector<int>> &graph) {
                    int n = graph.size();
                    vector<int> color(n);

                    function<bool(int)> safe = [&](int x) {
                        if (color[x] > 0) {
                            return color[x] == 2;
                        }
                        color[x] = 1;
                        for (int y : graph[x]) {
                            if (!safe(y)) {
                                return false;
                            }
                        }
                        color[x] = 2;
                        return true;
                    };

                    vector<int> ans;
                    for (int i = 0; i < n; ++i) {
                        if (safe(i)) {
                            ans.push_back(i);
                        }
                    }
                    return ans;
                }
            };
            ```

        * 拓扑排序

            ```cpp
            class Solution {
            public:
                vector<int> eventualSafeNodes(vector<vector<int>> &graph) {
                    int n = graph.size();
                    vector<vector<int>> rg(n);
                    vector<int> inDeg(n);
                    for (int x = 0; x < n; ++x) {
                        for (int y : graph[x]) {
                            rg[y].push_back(x);
                        }
                        inDeg[x] = graph[x].size();
                    }

                    queue<int> q;
                    for (int i = 0; i < n; ++i) {
                        if (inDeg[i] == 0) {
                            q.push(i);
                        }
                    }
                    while (!q.empty()) {
                        int y = q.front();
                        q.pop();
                        for (int x : rg[y]) {
                            if (--inDeg[x] == 0) {
                                q.push(x);
                            }
                        }
                    }

                    vector<int> ans;
                    for (int i = 0; i < n; ++i) {
                        if (inDeg[i] == 0) {
                            ans.push_back(i);
                        }
                    }
                    return ans;
                }
            };
            ```

