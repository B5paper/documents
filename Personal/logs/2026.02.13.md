* git merge dev 时，我希望 squash 一下，不要 dev 冗长的提交记录，怎么办

    在 `git merge dev` 时进行 squash，有以下几种方法：

    方法1：使用 `--squash` 参数（推荐）

    ```bash
    git checkout master
    git merge --squash dev
    git commit -m "合并 dev 分支的所有更改"
    ```

    这会将 dev 分支的所有更改合并到工作区并暂存，但不会自动提交，需要你手动提交一次。

    方法2：先 squash 再合并

    如果你不想在 master 分支上操作，可以先在 dev 分支上 squash：

    ```bash
    git checkout dev
    git rebase -i HEAD~n  # 或 git reset --soft 到某个提交
    git checkout master
    git merge dev
    ```

    方法3：使用 `--no-commit` 手动整理

    ```bash
    git checkout master
    git merge --no-commit --no-ff dev
    git reset HEAD^        # 取消合并的自动提交
    git add -A            # 重新添加
    git commit -m "合并 dev 分支"  # 一次提交
    ```

    注意事项

    - **`--squash` 不会保留 dev 分支的提交历史**，所有更改会合并为一次新提交
    - 不会创建合并提交（merge commit），历史是线性的
    - 如果以后需要将 master 合并回 dev，可能需要处理冲突

    示例

    ```bash
    # 当前在 master
    $ git checkout master
    $ git merge --squash dev
    $ git status  # 查看所有已暂存的更改
    $ git commit -m "feat: 合并 dev 分支的新功能"
    ```

    这样就在 master 上得到了一次干净的提交，包含了 dev 的所有更改。

* fnirs sqlite raw data 部分结构解析

    **1. 表结构说明**

    字段名 | 含义
    --- | ---
    `id` | 记录的唯一标识（自增主键）
    `table_name` | 数据表名（可能对应具体的测量数据表）
    `create_date` | 创建日期
    `patient_name` | 患者姓名
    `patient_id` | 患者ID
    `total_time` | 总测量时间
    `admin_email` | 操作员邮箱
    `snr_780` | **780nm 波长信号的信噪比（SNR）数据**
    `snr_850` | **850nm 波长信号的信噪比（SNR）数据**
    `snr_refval` | 参考信噪比值（可能用于质量控制）
    `motion_cal` | 运动校准参数或标记

    **2. 数据含义**

    **`snr_780` 和 `snr_850` 字段**

    - 这两个字段存储的是**以逗号分隔的数值字符串**。

    - 每一串数字代表**一次测量中多个通道（或时间点）的信噪比值**。

    - 例如：

          ```sql
          snr_780 = "17,40,37,35,30,..."
          ```

          表示该次测量中：

          - 通道1（或时间点1）的780nm SNR = 17 dB（或线性值）
          - 通道2（或时间点2）的780nm SNR = 40
          - ...以此类推。

* sqlite3 中，select 语句总是要加一句 select xxx from <table>，我可以不加这个<table>吗？

    **不可以不加 `FROM <table>`**，除非是以下特殊情况：

    1. 必须用 `FROM` 的情况

        SQL标准语法要求 `SELECT` 必须指定数据来源：

        ```sql
        -- 必须 FROM 一个表（或子查询）
        SELECT column1, column2 FROM my_table;
        ```

    2. 不用 `FROM` 的特例

        以下情况可以省略 `FROM`：

        （1）直接选择常量或表达式

        ```sql
        -- SQLite、MySQL、PostgreSQL等都支持
        SELECT 1 + 2;
        SELECT 'Hello' || ' World';
        SELECT CURRENT_TIMESTAMP;
        ```

        **在SQLite中运行示例：**

        ```sql
        sqlite> SELECT 1 + 2;
        1+2
        3

        sqlite> SELECT 'Hello' || ' World!';
        'Hello' || ' World!'
        Hello World!

        sqlite> SELECT date('now');
        date('now')
        2024-01-15
        ```

        （2）使用 `VALUES` 子句创建虚拟表

        ```sql
        -- 标准SQL语法
        SELECT * FROM (VALUES (1, 'A'), (2, 'B')) AS temp_table(id, name);

        -- SQLite特有简写（可以不加FROM）
        SELECT 1 AS id, 'A' AS name
        UNION ALL
        SELECT 2, 'B';
        ```

        （3）查询系统/虚拟表（仍需 `FROM`，但表名特殊）

        ```sql
        -- SQLite系统表（仍需要FROM）
        SELECT name FROM sqlite_master WHERE type='table';
        SELECT * FROM pragma_table_info('table_list');
        ```

    3. 在SQLite中的特殊语法

        SQLite对 `FROM` 的要求相对宽松，但**想要查询表中的数据必须用 `FROM`**：

        ```sql
        -- ✅ 有效：没有FROM，只有表达式
        SELECT 3 * 4;

        -- ❌ 无效：想查表数据但不指定FROM
        SELECT snr_780;  -- 错误！SQLite不知道snr_780来自哪张表

        -- ✅ 正确：指定表名
        SELECT snr_780 FROM table_list;
        ```

    4. 实际应用场景

        场景1：快速计算/测试

        ```sql
        -- 计算器功能
        SELECT (100 * 0.08) AS tax;

        -- 生成序列
        SELECT value FROM generate_series(1, 10);
        -- 注：SQLite没有generate_series，但可用递归CTE替代
        ```

        场景2：从应用变量构造数据

        ```sql
        -- 在应用中构造虚拟数据行
        SELECT 'John' AS name, 25 AS age, '2024-01-15' AS date
        UNION ALL
        SELECT 'Alice', 30, '2024-01-16';
        ```

        场景3：查看数据库信息

        ```sql
        -- 查看SQLite版本（不需要FROM）
        SELECT sqlite_version();

        -- 查看当前设置
        SELECT changes();  -- 上次操作影响的行数
        SELECT last_insert_rowid();  -- 最后插入的rowid
        ```

    5. 针对您的数据表的建议

        对于您之前查询的 `snr_780` 字段，**必须指定表名**：

        ```sql
        -- ❌ 错误：缺少FROM子句
        SELECT snr_780;

        -- ✅ 正确：指定来源表
        SELECT snr_780 FROM table_list;

        -- ✅ 正确：可以加WHERE条件
        SELECT snr_780 FROM table_list WHERE patient_id = 'P001';

        -- ✅ 正确：只查一条数据
        SELECT snr_780 FROM table_list LIMIT 1;
        ```

    **总结**

    - **查询表数据必须用 `FROM <table>`**，这是SQL标准。
    - **只有纯表达式、函数调用、常量选择可以省略 `FROM`**。
    - SQLite遵循这个规则，但提供了一些方便的语法糖（如直接 `SELECT 1+2;`）。

    如果您觉得每次写 `FROM table_list` 麻烦，可以考虑：

    1. **使用视图（View）**：

        ```sql
        CREATE VIEW v_snr AS SELECT snr_780, snr_850 FROM table_list;
        SELECT snr_780 FROM v_snr;  -- 视图名更短
        ```
       
    2. **在应用层封装常用查询**。

    3. **使用SQLite命令行快捷键**（如设置 `.alias`）。

* 简述什么是高低速接口驱动开发工程师

    **高低速接口驱动开发工程师**是嵌入式系统/芯片开发领域的专业职位，主要负责在操作系统内核层（如Linux、RTOS、Android等）开发、移植和优化各种通信接口的驱动程序。其核心工作是确保硬件接口能够被上层软件正确、高效、可靠地访问和控制。

    **核心职责与工作内容**

    1. **低速接口驱动开发**

        *   **典型接口**：I²C、SPI、UART、GPIO、I²S（音频）、PWM等。

        *   **特点**：数据速率相对较低，通常用于控制、配置、状态读取或小批量数据传输。

        *   **工作重点**：保证稳定性、实时性、低功耗和精确的时序控制。常用于连接传感器、触摸屏、EEPROM、音频编解码器等外设。

    2. **高速接口驱动开发**

        *   **典型接口**：USB（2.0/3.x/4）、PCIe、以太网（MAC/PHY）、MIPI（CSI/DSI）、SD/eMMC、SATA、HDMI/DP等。

        *   **特点**：数据速率高（可达Gbps级别），协议复杂，对吞吐量、延迟、带宽利用率要求极高。

        *   **工作重点**：优化大数据流的DMA传输、内存管理、中断处理、电源管理和协议栈的完整实现。常用于连接摄像头、显示屏、存储设备、高速外设和网络。

    3. **公共及跨领域任务**

        *   **驱动框架适配**：遵循Linux内核等现有的驱动模型（如Platform Driver、PCI Driver、USB Gadget等）进行开发。

        *   **芯片移植与BSP开发**：为新芯片或开发板适配和实现所有必要的接口驱动，构成板级支持包。

        *   **调试与调优**：使用逻辑分析仪、示波器等工具进行硬件级调试；进行性能剖析与优化。

        *   **问题排查**：解决驱动与硬件、其他驱动或应用层之间的兼容性、稳定性问题。

        *   **文档编写**：撰写设计文档、API说明和调试指南。

    **必备技能栈**

    *   **核心语言**：精通 **C 语言**，熟悉汇编语言（特定架构）。

    *   **操作系统**：深入理解 **Linux 内核机制**（进程调度、内存管理、中断、DMA、并发与同步等）。

    *   **硬件知识**：能阅读 **硬件原理图** 和 **芯片数据手册**，理解接口的时序图、寄存器定义。

    *   **协议理解**：深入掌握所负责接口的 **通信协议标准**。

    *   **调试能力**：熟练使用内核调试工具（如 `printk`、`ftrace`、`kgdb`）、逻辑分析仪等。

    *   **版本管理**：熟练使用 Git。

    **在产业中的位置与价值**

    *   **位置**：处于**硬件（HW）** 与**上层软件/应用（SW）** 之间的关键桥梁，是系统能正常工作的基石。

    *   **价值**：

        *   **使能硬件**：没有稳定的驱动，再强大的硬件也无法被使用。

        *   **性能决定者**：驱动的质量直接决定了接口的实际性能上限和系统功耗。

        *   **系统稳定性保障**：驱动层的Bug常导致系统崩溃、死机，是系统稳定的关键。

    **简而言之**

    **高低速接口驱动开发工程师，就是让芯片上的各种通信“道路”（从乡间小路到信息高速公路）在操作系统中畅通无阻的“筑路工”和“交通规则制定者”。** 他们需要既懂硬件细节，又精通软件内核，是嵌入式领域技术要求高、不可或缺的核心角色。

* xfreerdp 忽略证书：`/cert:ignore`

* xfreerdp 禁用 rfx: `-rfx`

    在 xfreerdp 中，`+xxx`表示开启某个功能，`-xxx`表示关闭某个功能

* vim 使用 / 搜索时，如何按 raw string 搜索？即我想要搜索的字符串就是字面意思，不是正则表达式的 pattern?

    在 Vim 中，你可以通过以下几种方式按字面意思（raw string）进行搜索，而不是将搜索字符串解释为正则表达式：

    方法1：使用 `\V`（非常神奇模式）

    在搜索模式前加上 `\V`：

    ```vim
    /\V要搜索的字面字符串
    ```

    例如：`/\Vfoo.bar` 会搜索字面值 "foo.bar"，而不会将 `.` 解释为正则表达式中的通配符。

    方法2：转义特殊字符

    在正则表达式中特殊字符前加上 `\`：

    ```vim
    /foo\.bar
    ```

    方法3：使用 `nomagic` 模式（旧方法）

    使用 `\M` 进行不神奇搜索（比 `\V` 少一些限制，但比普通正则更字面）：

    ```vim
    /\M要搜索的字面字符串
    ```

    方法4：使用 `search()` 函数（在脚本中）

    ```vim
    :call search('\V字面字符串')
    ```

    **特殊字符转义参考**

    以下字符在正则表达式中有特殊含义，需要转义（使用 `\`）：

    - `.`、`*`、`[`、`]`、`^`、`$`、`\`、`?`、`+`、`(`、`)`、`{`、`}`、`|`

    **实用技巧**

    如果你想永久使用字面搜索，可以在 `.vimrc` 中设置：

    ```vim
    " 设置搜索时默认使用字面匹配
    nnoremap / /\V
    nnoremap ? ?\V
    ```

    或者使用快捷键快速切换：

    ```vim
    " 按 \v 切换字面搜索
    nnoremap \v /\V
    ```

    **最推荐的方法是使用 `\V`**，因为它最直观且功能完整。

* 如果在 cygwin 中，可以使用 ls 定位到一个文件，但是无法使用 vim 向其中写入内容，那么很有可能是 vim 使用的是 windows 版本的，无法处理`/`路径。使用 cygwin 仓库中的 bash 版本的 vim 可以解决这个问题。

* C++实现数组排序并同步索引

    问：我有两个数组  int arr[] = {3, 5, 2, 1};  int ind[] = {0, 1, 2, 3}。我希望在给 arr 排序时，ind 中的元素也跟随着 arr 中元素的移动而移动，比如 arr 中 3 和 2 交换位置时， ind 中 0 和 2 交换位置。c++ 中如何实现？

    答：

    在 C++ 中，你可以通过多种方式实现这个需求。以下是几种常见的方法：

    方法1：手动实现排序并同步交换

    ```cpp
    #include <iostream>
    #include <algorithm>

    int main() {
        int arr[] = {3, 5, 2, 1};
        int ind[] = {0, 1, 2, 3};
        int n = 4;

        // 使用冒泡排序（或其他排序算法）
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换 arr 中的元素
                    std::swap(arr[j], arr[j + 1]);
                    // 同步交换 ind 中的元素
                    std::swap(ind[j], ind[j + 1]);
                }
            }
        }

        // 输出结果
        std::cout << "排序后的 arr: ";
        for (int i = 0; i < n; i++) std::cout << arr[i] << " ";
        
        std::cout << "\n对应的 ind: ";
        for (int i = 0; i < n; i++) std::cout << ind[i] << " ";
        
        return 0;
    }
    ```

    方法2：使用 pair 和标准库排序（推荐）

    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>

    int main() {
        int arr[] = {3, 5, 2, 1};
        int ind[] = {0, 1, 2, 3};
        int n = 4;

        // 创建 pair 数组，first 存储 arr 的值，second 存储索引
        std::vector<std::pair<int, int>> pairs;
        for (int i = 0; i < n; i++) {
            pairs.emplace_back(arr[i], ind[i]);
        }

        // 根据 arr 的值排序
        std::sort(pairs.begin(), pairs.end(), 
                  [](const std::pair<int, int>& a, const std::pair<int, int>& b) {
                      return a.first < b.first;
                  });

        // 将排序结果放回原数组
        for (int i = 0; i < n; i++) {
            arr[i] = pairs[i].first;
            ind[i] = pairs[i].second;
        }

        // 输出结果
        std::cout << "排序后的 arr: ";
        for (int i = 0; i < n; i++) std::cout << arr[i] << " ";
        
        std::cout << "\n对应的 ind: ";
        for (int i = 0; i < n; i++) std::cout << ind[i] << " ";
        
        return 0;
    }
    ```

    方法3：使用索引数组排序（更高效）

    ```cpp
    #include <iostream>
    #include <algorithm>
    #include <vector>

    int main() {
        int arr[] = {3, 5, 2, 1};
        int ind[] = {0, 1, 2, 3};
        int n = 4;

        // 创建索引数组，初始为 {0, 1, 2, 3}
        std::vector<int> indices(n);
        for (int i = 0; i < n; i++) indices[i] = i;

        // 根据 arr 的值对 indices 进行排序
        std::sort(indices.begin(), indices.end(),
                  [&arr](int i, int j) { return arr[i] < arr[j]; });

        // 根据排序后的 indices 重新排列 arr 和 ind
        std::vector<int> sorted_arr(n);
        std::vector<int> sorted_ind(n);
        
        for (int i = 0; i < n; i++) {
            sorted_arr[i] = arr[indices[i]];
            sorted_ind[i] = ind[indices[i]];
        }

        // 复制回原数组（如果需要）
        std::copy(sorted_arr.begin(), sorted_arr.end(), arr);
        std::copy(sorted_ind.begin(), sorted_ind.end(), ind);

        // 输出结果
        std::cout << "排序后的 arr: ";
        for (int i = 0; i < n; i++) std::cout << arr[i] << " ";
        
        std::cout << "\n对应的 ind: ";
        for (int i = 0; i < n; i++) std::cout << ind[i] << " ";
        
        return 0;
    }
    ```

    方法4：封装成通用函数

    ```cpp
    #include <iostream>
    #include <algorithm>
    #include <vector>

    template<typename T>
    void sort_with_indices(T* arr, int* indices, int n) {
        std::vector<std::pair<T, int>> pairs;
        pairs.reserve(n);
        
        for (int i = 0; i < n; i++) {
            pairs.emplace_back(arr[i], indices[i]);
        }
        
        std::sort(pairs.begin(), pairs.end(),
                  [](const auto& a, const auto& b) {
                      return a.first < b.first;
                  });
        
        for (int i = 0; i < n; i++) {
            arr[i] = pairs[i].first;
            indices[i] = pairs[i].second;
        }
    }

    int main() {
        int arr[] = {3, 5, 2, 1};
        int ind[] = {0, 1, 2, 3};
        int n = 4;

        sort_with_indices(arr, ind, n);

        std::cout << "排序后的 arr: ";
        for (int i = 0; i < n; i++) std::cout << arr[i] << " ";
        
        std::cout << "\n对应的 ind: ";
        for (int i = 0; i < n; i++) std::cout << ind[i] << " ";
        
        return 0;
    }
    ```

    输出结果

    所有方法的输出都是：

    ```
    排序后的 arr: 1 2 3 5 
    对应的 ind: 3 2 0 1
    ```

    **推荐使用方法2或方法3**，因为它们：

    1. 利用标准库的高效排序算法
    2. 代码简洁，易于理解
    3. 时间复杂度为 O(n log n)

    根据你的具体需求，选择最合适的方法即可。

* latex 中，使用 \nu 表示希腊字母 ν（nu）

* makefile 中，不能使用`$(command)`得到 command 的输出，必须使用`$(shell command)`才可以。

* 我开发了一款新硬件，如何对接到 pytorch

    将新硬件对接到PyTorch需要系统性的工作。以下是主要步骤和方案：

    一、核心对接方式

    1. **PyTorch后端扩展**

        ```python
        # 自定义设备注册
        import torch
        from torch.utils.rename_privateuse1 import rename_privateuse1_backend

        # 将自定义设备注册为私有设备
        rename_privateuse1_backend("your_device")

        # 然后在代码中使用
        device = torch.device("your_device:0")
        ```

    2. **使用自定义算子**

        ```python
        import torch
        from torch.library import custom_op

        @custom_op("your_device::custom_linear", mutates_args=())
        def custom_linear(x: torch.Tensor, weight: torch.Tensor) -> torch.Tensor:
            # 调用底层硬件加速库
            return your_hardware_linear(x, weight)
        ```

    二、完整对接架构

    1. **C++扩展接口**

        ```cpp
        // 实现PyTorch的C++扩展接口
        #include <torch/extension.h>
        #include <ATen/native/YourDeviceInterface.h>

        // 注册设备类型
        REGISTER_DEVICE_IMPL(your_device, YourDeviceImpl);

        // 实现核心算子
        at::Tensor your_add(const at::Tensor& self, const at::Tensor& other) {
            // 调用硬件SDK
            return your_hardware::add(self, other);
        }

        TORCH_LIBRARY_IMPL(aten, YourDevice, m) {
            m.impl("add", your_add);
        }
        ```

    2. **Python层封装**

        ```python
        # 创建设备管理类
        class YourDevice:
            @staticmethod
            def is_available():
                return your_hardware.check_availability()
            
            @staticmethod
            def device_count():
                return your_hardware.get_device_count()
            
            @staticmethod
            def set_device(device_id):
                your_hardware.set_current_device(device_id)

        # 注册到PyTorch
        torch.register_device_module("your_device", YourDevice)
        ```

    三、具体实现步骤

    **步骤1：实现基础框架**

    ```python
    # 1. 定义设备属性
    torch._C._set_device_properties(
        "your_device",
        torch._C._DeviceProperties(
            name="Your Hardware",
            major=1,
            minor=0,
            total_memory=your_hardware.get_memory_size(),
            multi_processor_count=your_hardware.get_core_count()
        )
    )

    # 2. 注册分配器
    torch._C._set_allocator("your_device", your_allocator)
    ```

    **步骤2：实现内存管理**

    ```cpp
    // 实现PyTorch的Allocator接口
    class YourAllocator : public at::Allocator {
    public:
        void* allocate(size_t size) override {
            return your_hardware_malloc(size);
        }
        
        void deallocate(void* ptr) override {
            your_hardware_free(ptr);
        }
    };
    ```

    **步骤3：算子实现**

    ```python
    # 使用PyTorch的Dispatch机制
    import torch.library as lib

    # 定义算子
    lib.define("your_device::matmul(Tensor a, Tensor b) -> Tensor")

    # 实现
    @lib.impl("your_device::matmul", "YourDevice")
    def matmul_impl(a, b):
        # 调用硬件加速
        return your_hardware.matmul(a, b)
    ```

    四、优化建议

    1. **逐算子迁移策略**

        ```
        1. 先实现基础算子：add, mul, matmul
        2. 实现自动微分相关算子
        3. 实现常见神经网络层
        4. 优化特定算子性能
        ```

    2. **兼容性考虑**

        ```python
        # 自动回退机制
        def fallback_to_cpu(func):
            def wrapper(*args, **kwargs):
                try:
                    return func(*args, **kwargs)
                except NotImplementedError:
                    # 回退到CPU实现
                    args_cpu = [arg.cpu() for arg in args]
                    return func(*args_cpu, **kwargs).to("your_device")
            return wrapper
        ```

    五、测试与验证

    ```python
    # 创建测试框架
    import pytest

    def test_device_operations():
        # 测试张量创建
        x = torch.randn(10, 10, device="your_device")
        assert x.device.type == "your_device"
        
        # 测试基本运算
        y = x + x
        assert y.device.type == "your_device"
        
        # 测试模型运行
        model = torch.nn.Linear(10, 5).to("your_device")
        output = model(x)
        assert output.device.type == "your_device"
    ```

    六、发布与集成

    1. **创建PyTorch扩展包**

        ```python
        # setup.py
        from setuptools import setup
        from torch.utils.cpp_extension import BuildExtension

        setup(
            name="pytorch-your-device",
            ext_modules=[
                YourDeviceExtension("your_device_extension", sources=["src/your_device.cpp"])
            ],
            cmdclass={
                'build_ext': BuildExtension.with_options(use_ninja=True)
            }
        )
        ```

    2. **文档与示例**

        ```python
        # 提供易用的接口
        def enable_your_device():
            """一键启用自定义设备支持"""
            import torch_your_device
            torch_your_device.init()
        ```

    七、推荐参考项目

    1. **官方示例**: PyTorch `privateuse1` 机制
    2. **ROCm**: AMD GPU对PyTorch的支持
    3. **Intel Extension for PyTorch**: XPU设备支持
    4. **Habana Gaudi**: 专用AI训练芯片对接

    关键注意事项

    1. **保持API兼容性**: 确保与PyTorch现有API完全兼容
    2. **性能优化**: 重点优化数据传输和核心算子
    3. **错误处理**: 提供清晰的错误信息
    4. **内存管理**: 确保内存分配释放正确
    5. **多设备支持**: 考虑多卡并行场景

    建议从最简单的算子开始，逐步扩展功能。PyTorch社区对新硬件支持非常友好，可以考虑在PyTorch论坛或GitHub上寻求帮助。
