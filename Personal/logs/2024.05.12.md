* temp

    * `linux/wait.h`

    * `linux/delay.h`

    * 为什么注释了创建 wait queue head 的两行

    * `DECLARE_WAIT_QUEUE_HEAD()`, `DECLARE_WAITQUEUE()`

    * `add_wait_queue()`

    * `wait_event()`

    * `kthread_should_stop()`, `kthread_stop()`

    * `wake_up()`

    * `remove_wait_queue()`

* `kthread_run()`

    创建并唤醒该线程。
    
    等价于先调用`kthread_create()`，再调用`wake_up_process()`唤醒线程。

    `kthread_run()`不是一个函数，而是一个宏。

    syntax:

    ```c
    kthread_run(threadfn, data, namefmt, ...)
    ```

* `wait_event()`

    `wait_event()`是一个宏。

    syntax: `wait_event(wq, condition)`

    休眠，直到`condition`为真，无法被手动打断。

    队列中的 wait queue 被标记为`TASK_UNINTERRUPTIBLE`。

* `wait_event()`和`wake_up()`传入的都是 wait queue head，即使 entry 加入到了 queue 里，也是处理 head。

    猜想： wait queue 在 wait 时，会将与之相关联的 thread 休眠。

    证据：`DECLARE_WAITQUEUE(wait_task,current);`将 wait entry 和 thread 相关联。