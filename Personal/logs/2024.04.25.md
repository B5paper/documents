* iommu 全称为 input output memory management unit

    mmu 的作用为将 cpu-visible virtual address map 到 physical address

    iommu 的作用为将 device-visible virtual address map 到 physical address

    这里的 physical address 指的都是 cpu memory address

    iommu 可以对 device 展示连续内存，而在实际申请内存时使用碎片内存。

    有些设备只有 32-bit 的寻址能力，iommu 可以扩展设备的寻址能力。

    因为 iommu 对设备提供的都是虚拟地址，所以可以在不同设备间做地址隔离。

    当虚拟设备透传给虚拟机时，虚拟机分配给 device 的是用户态的虚拟内存地址，device 拿用户态的地址和物理内存通信，肯定是有问题的。iommu 可以解决这个问题。

    iommu 实际上使得 dma 成为可能。

    ref: <https://michael2012z.medium.com/iommu-b59e2dc320bd>

* 一个 resource/reference 每次只能提取一点知识，未来可能需要多次提取。是否该使用一个进度标识来标记一个知识来源被处理了多少？

* `git rebase`非交互模式，当遇到文件冲突时，不会让用户去处理 conflict，把不同的 commit 合并成一个，创建一个 merge commit，而是先把 upstream 的 commit 全都照搬过来，然后再把 local 的 commit 叠加到上面

    在非交互模式下，常用的语法为`git rebase <upstream>/<remote_branch> [<local_branch>]`。

    首先要保证有一个有效的 remote:

    `git remote add <new_name> <remote_path/url>`

    然后拉取一下信息，不然找不到 main branch：`git fetch`

    然后设置当前 branch 的 upstream:

    `git branch --set-upstream-to=origin/main`

    最后就可以直接运行`git rebase`了。

    以后每次需要`git rebase`前，都要先`git fetch`一次，拿到 upstream 的信息。

* `ktime_get_seconds()`可以获得系统启动后过去了多少时间

    `ktime_get_real_seconds()`可以获得 utc 时间，但是需要其他库/函数转换成人类可读时间。

    与时间相关的函数都在`linux/timekeeping.h`头文件中。

    如果需要 formatted output time，可以参考这篇：<https://www.kernel.org/doc/html/latest/core-api/printk-formats.html#time-and-date>

    与时间相关的函数与简要说明：<https://www.kernel.org/doc/html/latest/core-api/timekeeping.html>

    ref: <https://stackoverflow.com/questions/55566038/how-can-i-print-current-time-in-kernel>