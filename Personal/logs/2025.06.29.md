* `memmove()`简介

    `memmove()`在头文件`<string.h>`里，功能和`memcpy()`几乎相同，参数和`memcpy()`完全相同。

    `memmove()`和`memcpy()`的区别是`memmove()`可以处理 dst 区间和 src 区间有交叠的情况，而`memcpy()`不做这个保证。

    当 dst 区间和 src 区间有重叠时，`memmove()`可以保证当 src 区间的中后面的数据还没被处理时，不会被覆盖掉。

    example:

    ```cpp
    #include <stdio.h>
    #include <string.h>

    int main() {
        int arr_1[] = {1, 2, 3, 4, 5};
        memcpy(&arr_1[1], &arr_1[0], sizeof(int) * 4);
        for (int i = 0; i < 5; ++i) {
            printf("%d, ", arr_1[i]);
        }
        putchar('\n');

        int arr_2[] = {1, 2, 3, 4, 5};
        memmove(&arr_2[1], &arr_2[0], sizeof(int) * 4);
        for (int i = 0; i < 5; ++i) {
            printf("%d, ", arr_2[i]);
        }
        putchar('\n');

        return 0;
    }
    ```

    output:

    ```
    1, 1, 2, 3, 4, 
    1, 1, 2, 3, 4, 
    ```

    可以看到，使用 linux 上的 gcc 11.4 编译，这两个函数的实际效果是一样的。

* grep 搜索子目录下的指定文件

    `grep -r --include=<glob_exp> <reg_pattern> .`

    这里使用`--include`来指定要搜索的文件名，可以使用等号，也可以把等号替换成空格。

    注意`--include`使用的是通配符表达式，不是正则表达式。为了防止 bash 对输入内容进行转义，通常使用单引号`'<glob_exp>'`将通配符表达式包裹。

    example:

    `grep -r --include='hello*.txt' hello .`

    output:

    ```
    ./dir_2/hello.txt:hello, world
    ./dir_2/hello_w.txt:hello, world
    ```

    如果要指定多个通配符，那么可以指定多个`--include`参数。

* `grep`使用`-l`参数，可以只输出文件路径，不输出具体匹配了哪一行

* c 的变长参数函数无法处理 c++ 的类型

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <stdarg.h>
    using namespace std;

    void func(int a, ...) {
        va_list args;
        va_start(args, a);
        string str = va_arg(args, string);
        va_end(args);
    }

    int main() {
        func(1, string("hello"));
        return 0;
    }
    ```

    在`va_arg(args, string);`这里会提示错误：

    > a class type that cannot be trivially copied cannot be fetched by va_arg

    但是处理指针是可以的：

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <stdarg.h>
    using namespace std;

    void func(int a, ...) {
        va_list args;
        va_start(args, a);
        string *str = va_arg(args, string*);
        printf("%s\n", str->c_str());
        va_end(args);
    }

    int main() {
        string str {"hello, world"};
        func(1, &str);
        return 0;
    }
    ```

    output:

    ```
    hello, world
    ```

    引用也不能处理。

* c++ 中指向数组的引用

    指向数组的引用可以保留数组的长度信息。

    example:

    ```cpp
    #include <stdio.h>
    using namespace std;

    int main() {
        int arr[] = {1, 2, 3, 4, 5};

        int (&arr_r)[] = arr;
        printf("arr_r[2]: %d\n", arr_r[2]);

        // printf("sizeof(arr_r): %lu\n", sizeof(arr_r));  // error

        int (&arr_r_2)[5] = arr;
        printf("sizeof(arr_r_2): %lu\n", sizeof(arr_r_2));

        int (&arr_r_3)[sizeof(arr) / sizeof(int)] = arr;
        printf("sizeof(arr_r_3): %lu\n", sizeof(arr_r_3));

        return 0;
    }
    ```

    output:

    ```
    arr_r[2]: 3
    sizeof(arr_r_2): 20
    sizeof(arr_r_3): 20
    ```

    如果在初始化数组引用时，没有指定元素个数，那么在调用`sizeof(arr_r)`时会编译报错。

    元素个数既可以手动指定，也可以使用`sizeof()`计算出来。如果指定的元素个数与原数组不相同，也会编译时报错。

* 在函数参数中处理指向数组的引用

    需要用类似`int (&arr_r)[5]`的方式传递参数，元素个数必须要填，否则会报错。

    ```cpp
    #include <stdio.h>
    using namespace std;

    void print_arr(int (&arr_r)[5]) {
        int N = sizeof(arr_r) / sizeof(int);
        for (int i = 0; i < N; ++i) {
            printf("%d, ", arr_r[i]);
        }
        putchar('\n');

        for (int val : arr_r) {
            printf("%d, ", val);
        }
        putchar('\n');
    }

    int main() {
        int arr[] = {1, 2, 3, 4, 5};
        print_arr(arr);
        return 0;
    }
    ```

    output:

    ```
    1, 2, 3, 4, 5, 
    1, 2, 3, 4, 5, 
    ```

    如果在模板中使用则更方便，不需要手动指定元素个数，元素个数可以自动推导出来：

    ```cpp
    #include <stdio.h>
    using namespace std;

    template<typename T, size_t N>
    void print_arr(T (&arr_r)[N]) {
        for (int i = 0; i < N; ++i) {
            printf("%d, ", arr_r[i]);
        }
        putchar('\n');

        for (int val : arr_r) {
            printf("%d, ", val);
        }
        putchar('\n');
    }

    int main() {
        int arr[] = {1, 2, 3, 4, 5};
        print_arr(arr);
        return 0;
    }
    ```

    output:

    ```
    1, 2, 3, 4, 5, 
    1, 2, 3, 4, 5,
    ```

* 理论上，说话是一件不可能完成的任务。因为我们需要寻找所有组词造句的可能性，才能说出一句完整的句子，它的时间复杂性是不可接受的。但是每个人都能完成，这是不可思议的一件事。目前不清楚为什么。