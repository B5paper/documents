* 判断`val`是否为 2 的整数幂

    如果 val 是 2 的整数次幂（1, 2, 4, 8, 16, ...），则返回 true

    ```cpp
    bool isPow2(int val) {
        return (val & (val-1)) == 0;
    }
    ```

    example:

    ```cpp
    #include <stdio.h>

    bool isPow2(int val) {
        return (val & (val-1)) == 0;
    }

    int main() {
        for (int i = 0; i <= 32; ++i) {
            if (isPow2(i)) {
                printf("val = %d, true\n", i);
            } else {
                printf("val = %d, false\n", i);
            }
        }
        return 0;
    }
    ```

    output:

    ```
    val = 0, true
    val = 1, true
    val = 2, true
    val = 3, false
    val = 4, true
    val = 5, false
    val = 6, false
    val = 7, false
    val = 8, true
    val = 9, false
    val = 10, false
    val = 11, false
    val = 12, false
    val = 13, false
    val = 14, false
    val = 15, false
    val = 16, true
    val = 17, false
    val = 18, false
    val = 19, false
    val = 20, false
    val = 21, false
    val = 22, false
    val = 23, false
    val = 24, false
    val = 25, false
    val = 26, false
    val = 27, false
    val = 28, false
    val = 29, false
    val = 30, false
    val = 31, false
    val = 32, true
    ```

* `mirrorBits()`

    ```cpp
    int mirrorBits(int val, int pow2) {
        int mirror = 0;
        // mb 表示最高位的 1
        for (int b = 1, mb = (pow2>>1); b < pow2; b <<= 1, mb >>= 1) {
            // 如果 val 最低位为 1，那么 mirror 的最高位置 1
            if (val & b) {
                // |= 保护除了最高位之外的其他位不被改变
                mirror |= mb;
            }
        }
        return mirror;  //0b110;
    }
    ```

    * `pow2`用二进制表示为 1, 10, 100, 1000, 10000, 100000, ... 这样就既指定了位宽，又标记了最高位的 1，后面只需要将 pow2 的 1 一步一步往右移就可以了

    * 假如 pow2 = 8 = 0b1000，那么 val 的最大值就为 pow2 - 1 = 7 = 0b0111, val 的取值范围为 0 ~ 7

    * 此时如果 val = 0b0011，那么就把低位的 1 翻折到高位去，0b0110，注意并不是 0b1100，否则就超过 val 的最大可能取值了

        同理，如果 val = 0b0001，那么 mirror = 0b0100

        如果 val = 0b0111，那么 mirror 不变，仍为 mirror = 0b0111。
    
    * 整体看来，`mirrorBits()`的功能是把`....xxxx`翻转到`.xxxx...`

        example:

        ```cpp
        #include <stdio.h>
        #include <string>
        using namespace std;

        int mirrorBits(int val, int pow2) {
            int mirror = 0;
            for (int b = 1, mb = (pow2>>1); b < pow2; b <<= 1, mb >>= 1) {
                if (val & b) {
                    mirror |= mb;
                }
            }
            return mirror;
        }

        void print_binary(int val) {
            string str;
            while (val) {
                str.push_back(val % 2 ? '1' : '0');
                val >>= 1;
            }
            int left = 0, right = str.size() - 1;
            while (left < right) {
                swap(str[left], str[right]);
                ++left;
                --right;
            }
            printf("%s", str.c_str());
        }

        int main() {
            for (int pow2 = 2; pow2 <= 32; pow2 *= 2) {
                printf("pow2: ");
                print_binary(pow2);
                putchar('\n');
                for (int val = 1; val < pow2; ++val) {
                    int mirror_val = mirrorBits(val, pow2);
                    printf("    ");
                    print_binary(val);
                    printf(" -> ");
                    print_binary(mirror_val);
                    putchar('\n');
                }
            }
            return 0;
        }
        ```

        output:

        ```
        pow2: 10
            1 -> 1
        pow2: 100
            1 -> 10
            10 -> 1
            11 -> 11
        pow2: 1000
            1 -> 100
            10 -> 10
            11 -> 110
            100 -> 1
            101 -> 101
            110 -> 11
            111 -> 111
        pow2: 10000
            1 -> 1000
            10 -> 100
            11 -> 1100
            100 -> 10
            101 -> 1010
            110 -> 110
            111 -> 1110
            1000 -> 1
            1001 -> 1001
            1010 -> 101
            1011 -> 1101
            1100 -> 11
            1101 -> 1011
            1110 -> 111
            1111 -> 1111
        pow2: 100000
            1 -> 10000
            10 -> 1000
            11 -> 11000
            100 -> 100
            101 -> 10100
            110 -> 1100
            111 -> 11100
            1000 -> 10
            1001 -> 10010
            1010 -> 1010
            1011 -> 11010
            1100 -> 110
            1101 -> 10110
            1110 -> 1110
            1111 -> 11110
            10000 -> 1
            10001 -> 10001
            10010 -> 1001
            10011 -> 11001
            10100 -> 101
            10101 -> 10101
            10110 -> 1101
            10111 -> 11101
            11000 -> 11
            11001 -> 10011
            11010 -> 1011
            11011 -> 11011
            11100 -> 111
            11101 -> 10111
            11110 -> 1111
            11111 -> 11111
        ```

        实际结果与前面猜想相同。

* `ethtool`

    install: `sudo apt install ethtool`

    * 查看网卡基本信息: `ethtool <网卡名>`
    
        `ethtool enp0s3`

        output:

        ```
        Settings for enp0s3:
        	Supported ports: [ TP ]
        	Supported link modes:   10baseT/Half 10baseT/Full
        	                        100baseT/Half 100baseT/Full
        	                        1000baseT/Full
        	Supported pause frame use: No
        	Supports auto-negotiation: Yes
        	Supported FEC modes: Not reported
        	Advertised link modes:  10baseT/Half 10baseT/Full
        	                        100baseT/Half 100baseT/Full
        	                        1000baseT/Full
        	Advertised pause frame use: No
        	Advertised auto-negotiation: Yes
        	Advertised FEC modes: Not reported
        	Speed: 1000Mb/s
        	Duplex: Full
        	Auto-negotiation: on
        	Port: Twisted Pair
        	PHYAD: 0
        	Transceiver: internal
        	MDI-X: off (auto)
        netlink error: Operation not permitted
                Current message level: 0x00000007 (7)
                                       drv probe link
        	Link detected: yes
        ```

    * 查看驱动信息: `ethtool -i <网卡名>`

        `ethtool -i enp0s3`

        output:

        ```
        driver: e1000
        version: 6.8.0-65-generic
        firmware-version: 
        expansion-rom-version: 
        bus-info: 0000:00:03.0
        supports-statistics: yes
        supports-test: yes
        supports-eeprom-access: yes
        supports-register-dump: yes
        supports-priv-flags: no
        ```

    * 查看统计信息: `ethtool -S <网卡名>`

        `ethtool -S enp0s3`

        output:

        ```
        NIC statistics:
             rx_packets: 7599541
             tx_packets: 3763596
             rx_bytes: 7471543776
             tx_bytes: 5835620961
             rx_broadcast: 40
             tx_broadcast: 6
             rx_multicast: 0
             tx_multicast: 828
             rx_errors: 0
             tx_errors: 0
             tx_dropped: 0
             multicast: 0
             collisions: 0
             rx_length_errors: 0
             rx_over_errors: 0
             rx_crc_errors: 0
             rx_frame_errors: 0
             rx_no_buffer_count: 0
             rx_missed_errors: 0
             tx_aborted_errors: 0
             tx_carrier_errors: 0
             tx_fifo_errors: 0
             tx_heartbeat_errors: 0
             tx_window_errors: 0
             tx_abort_late_coll: 0
             tx_deferred_ok: 0
             tx_single_coll_ok: 0
             tx_multi_coll_ok: 0
             tx_timeout_count: 0
             tx_restart_queue: 0
             rx_long_length_errors: 0
             rx_short_length_errors: 0
             rx_align_errors: 0
             tx_tcp_seg_good: 1456528
             tx_tcp_seg_failed: 0
             rx_flow_control_xon: 0
             rx_flow_control_xoff: 0
             tx_flow_control_xon: 0
             tx_flow_control_xoff: 0
             rx_long_byte_count: 7471543776
             rx_csum_offload_good: 0
             rx_csum_offload_errors: 0
             alloc_rx_buff_failed: 0
             tx_smbus: 0
             rx_smbus: 0
             dropped_smbus: 0
        ```

    其他还有些功能，目前看上去用处不大。如果专业做网卡这块了再去了解。

* `mmap()`的`MAP_SHARED`模式与`MAP_PRIVATE`模式

    在 shared 模式中，对映射内存的修改会同步到实际文件（如果映射的是文件），其他进程映射同一文件时能看到变更。内存的写操作可能触发文件系统的 I/O（取决于回写策略）。

    在 private 模式中，对映射内存的修改永远不会同步到文件，而是创建进程私有的写时复制（Copy-on-Write, COW）副本。

    （因为不会写多进程程序，所以这里先不写 example）

    MAP_SHARED 的同步可能引入 I/O 延迟，MAP_PRIVATE 的 COW 机制可能导致内存分裂。（什么是内存分裂？）

* `fileno()`可以获得`FILE*`指针对应的 fd

    syntax:

    ```c
    #include <stdio.h>
    int fd = fileno(file_ptr);
    ```

    example:

    ```c
    #include <stdio.h>

    int main() {
        FILE *f = fopen("msg.txt", "rw");
        if (f == NULL) {
            printf("fail to open file\n");
            return -1;
        }

        int fd = fileno(f);
        printf("fd is %d\n", fd);

        fclose(f);
        return 0;
    }
    ```

    output:

    ```
    fd is 3
    ```

    标准流的描述符：

    ```c
    fileno(stdin)  == 0;  // STDIN_FILENO
    fileno(stdout) == 1;  // STDOUT_FILENO
    fileno(stderr) == 2;  // STDERR_FILENO
    ```

* `major = register_chrdev(0, "edu", &file_ops);`

    `register_chrdev`的第一个参数填 0 时，会自动分配一个 region 号。比如 edu 设备就分到了`241`号：

    `cat /proc/devices`:

    ```
    ...
    202 cpu/msr
    204 ttyMAX
    226 drm
    241 edu
    242 ttyDBC
    243 bsg
    ...
    ```