* `finger`是一个早期的网络工具，用于查询系统上的用户信息，现代系统默认禁用

* `pstree`

    `pstree`可以以树状结构显示 ps 的内容。

    example:

    ```
    (base) hlc@hlc-VirtualBox:~$ pstree 
    systemd─┬─ModemManager───2*[{ModemManager}]
            ├─NetworkManager───2*[{NetworkManager}]
            ├─accounts-daemon───2*[{accounts-daemon}]
            ├─acpid
            ├─avahi-daemon───avahi-daemon
            ├─blkmapd
            ├─colord───2*[{colord}]
    ```

    其中数字表示多个相同的进程/线程。

    常用参数：

    * `-c` 选项禁用合并

    * `-p`：显示进程的 PID。

    * `-n`：按 PID 数字排序（默认按进程名排序）。

    * `-a`：显示进程的完整命令行参数。

    * `pstree [username]`: 查看某用户启动的进程树

    * `-A`: 使用 ASCII 字符绘制树（兼容性更好）

* mpv 支持查看视频、音频和图片

    ```bash
    mpv 文件名.mp4          # 播放视频
    mpv 音乐.mp3           # 播放音频
    mpv 图片.jpg           # 查看图片（支持翻页）
    mpv https://视频链接    # 直接播放在线视频（如 YouTube、直播流）
    mpv 文件1 文件2 文件3   # 顺序播放多个文件
    mpv --shuffle *.mp3    # 随机播放当前目录下的音频
    ```

    常用快捷键

    空格	暂停/继续
    → / ←	快进/快退 5 秒
    ↑ / ↓	快进/快退 1 分钟
    f	全屏切换
    q	退出（保留进度）
    Q	强制退出（不保存进度）
    9 / 0	音量减/增
    m	静音切换
    s	截图（保存到当前目录）

    高级功能

    * 字幕与音轨

        ```bash
        mpv --sub-file=字幕.srt 视频.mp4    # 加载外挂字幕
        mpv --audio-file=音频.mka 视频.mkv  # 加载外部音轨
        ```

        播放时按`j`切换字幕，`#`切换音轨。

    * 倍速播放

        ```bash
        mpv --speed=2.0 视频.mp4   # 2倍速播放
        ```

        播放时按`[`和`]`动态调整速度。

    * 无界面模式（后台播放音频）

        ```bash
        mpv --no-video 视频.mp4    # 仅播放音频
        ```

    * 循环播放

        ```bash
        mpv --loop=3 视频.mp4      # 循环播放3次
        mpv --loop=inf 音乐.mp3    # 无限循环
        ```

    * 自定义配置

        编辑`~/.config/mpv/mpv.conf`文件（如不存在则新建）：

        ```conf
        # 示例配置
        vo=gpu                         # 使用GPU加速
        save-position-on-quit=yes      # 退出时保存进度
        sub-auto=fuzzy                 # 自动加载相似名字幕
        ```

    其他实用选项（未验证）

    * 硬件解码：`--hwdec=auto`（启用显卡硬解，降低CPU占用）。

    * 最小化启动：`mpv --no-border --ontop 视频.mp4`（无边框置顶窗口）。

    * 截图不带字幕：`mpv --screenshot-format=png --vf=subtitles=off`。

* `fstat()`用于获取文件的状态信息，比如文件大小、权限、时间戳等

    头文件：`<sys/stat.h>`

    syntax:

    ```cpp
    int fstat(int fd, struct stat *buf);
    ```

    参数：

        fd：已打开文件的文件描述符（通过 open()、fileno() 等获取）。

        buf：指向 struct stat 的指针，用于存储文件状态信息。

    返回值：

        成功返回 0，失败返回 -1 并设置 errno。

    `struct stat`中的常用成员：

    * `st_mode`: 文件类型和权限（如 S_ISREG() 判断是否为普通文件）

    * `st_size`: 文件大小（字节）

    * `st_uid`: 文件所有者的用户ID
    
    * `st_gid`: 文件所属组的组ID

    * `st_atime`: 最后访问时间（Access Time）

    * `st_mtime`: 最后修改时间（Modify Time）

    * `st_ctime`: 最后状态变更时间（Change Time）

    example:

    ```cpp
    #include <fcntl.h>
    #include <unistd.h>
    #include <sys/stat.h>
    #include <stdio.h>

    int main() {
        int fd = open("msg.txt", O_RDONLY);

        struct stat my_stat;
        int ret = fstat(fd, &my_stat);
        if (ret != 0) {
            printf("fail to fstat()...\n");
            return -1;
        }

        printf("file size: %lu\n", my_stat.st_size);

        if (S_ISREG(my_stat.st_mode)) {
            printf("This is a regular file.\n");
        } else if (S_ISDIR(my_stat.st_mode)) {
            printf("This is a directory.\n");
        }

        ret = close(fd);
        if (ret != 0) {
            printf("fail to close fd: %d\n", fd);
            return -1;
        }

        return 0;
    }
    ```

    output:

    ```
    file size: 15
    This is a regular file.
    ```

* `<`, `<<`和`<<<`

    1. <（标准输入重定向）

        用于将文件内容作为命令的标准输入。

        ```bash
        command < file.txt
        ```

        （将 file.txt 的内容传递给 command 作为输入）

    1. <<（Here Document）

        用于在脚本中直接嵌入多行输入，直到遇到指定的结束标记（delimiter）。

        ```bash
        command << EOF
        line 1
        line 2
        EOF
        ```

    1. <<<（Here String）

        用于将单个字符串（而不是文件或多行文本）作为命令的标准输入。

        ```bash
        command <<< "string"
        ```

* `stty -echo`

    关闭回显。

    ```bash
    stty -echo  # 关闭回显
    read -p "Enter password: " password
    stty echo   # 恢复回显
    echo        # 换行（避免密码输入后的提示符紧贴上一行）
    ```

* `stty`

    set teletype, or set terminal

    常用功能：

    * 查看当前终端设置: `stty -a`

    * 关闭回显（输入不显示，如输入密码时）: `stty -echo`

    * 恢复回显：`stty echo`

    * 禁用控制字符（如 Ctrl+C 中断信号）：`stty intr undef  # 取消 Ctrl+C 的中断功能`

    * 将退格键（Backspace）设为删除前一个字符: `stty erase ^H`

    * 如果终端因错误配置导致乱码或无响应，可通过重置恢复：`stty sane`

    * 禁止终端显示输入内容：`stty -echo; read -s; stty echo`

    stty 的配置是临时性的，仅对当前终端会话有效。

* `setsid`

    创建一个新的会话（session）并在此会话中运行指定的命令，使该进程完全脱离当前终端（terminal）的控制

    即使关闭当前终端窗口或退出登录，通过 setsid 启动的进程仍会继续在后台运行（不会被 SIGHUP 信号终止）。

    新进程会成为会话首进程（session leader），且拥有新的进程组 ID（PGID），与原有终端完全无关。

    example:

    * `setsid your_command &`

        后台运行守护进程（daemon）, 适用于需要长期运行的服务（如自定义脚本或服务）。

    * `setsid tail -f /var/log/syslog`

        即使终端关闭，进程也不会退出

    * 替代 nohup 的更彻底方案

        nohup 仅忽略 SIGHUP 信号，而 setsid 直接脱离终端会话。

        ```bash
        # 启动一个完全脱离终端的进程（日志重定向到文件）
        setsid your_command > /var/log/command.log 2>&1 &
        ```

* `strrchr()`

    从右往左搜索指定字符的位置。

    example:

    ```cpp
    #include <string.h>
    #include <stdio.h>

    int main() {
        const char *msg = "hello, world";
        const char *pos_ptr = strrchr(msg, 'r');
        if (pos_ptr == NULL) {
            printf("fail to find pos\n");
            return -1;
        }
        printf("%c is at pos %ld\n", *pos_ptr, pos_ptr - msg);
        return 0;
    }
    ```

    output:

    ```
    r is at pos 9
    ```
