* 有关程序中大量使用随机数的问题

    `rand()`的速度很慢，`mt19937`也只快了 3 倍。如果代码中大量用到`rand()`，那么 cpu 会分配很多时间（90% 甚至更多）在系统调用上。

    如果是对随机性不敏感的场合（比如图片渲染），可以使用打表的方法，提前生成一些随机数，在用的时候直接读取数组就可以了。

    ```cpp
    vector<float> rand_nums;
    const total_rand_nums_count = 1024;
    int rand_num_idx = 0;

    float get_rand_num()
    {
        if (rand_num_idx >= total_rand_nums_count)
            rand_num_idx = 0;
        return rand_nums[rand_num_idx++];
    }

    int main()
    {
        // initialize random numbers table
        rand_nums.resize(total_rand_nums_count);
        for (int i = 0; i < total_rand_nums_count; ++i)
        {
            rand_nums[i] = (float)rand() / RAND_MAX;
        }

        // usage
        float rand_num = get_rand_num();
        return 0;
    }
    ```

    如果现在是多线程，又该怎么办？如果还使用上面的代码，由于`rand_num_idx`并不是线程安全的，所以`rand_nums[rand_num_idx++]`可能会数组越界。

    一个比较自然的想法是加锁：

    ```cpp
    mutex mtx;

    int main()
    {
        // usage
        {
            lock_gurad g(mtx)
            float rand_num = get_rand_num();
        }
    }
    ```

    每个线程在获取随机数时，一个一个访问，保证`rand_num_idx`每次都只递增 1，这样就不会数组越界了。但是加锁同`rand()`一样，会造成性能严重下降，导致 cpu 跑不满，或者 cpu 被浪费在系统调用上。

    如果不加锁，又不想数组越界，还有一种方法是使用`rand_num_idx++ % total_rand_nums_count`作为下标进行访问，然后为了防止`rand_num_idx`递增溢出，在每次访问前或后尝试清零：

    ```cpp
    float get_rand_num()
    {
        if (rand_num_idx >= total_rand_nums_count)
            rand_num_idx = 0;
        return rand_nums[rand_num_idx % total_rand_nums_count++];
    }

    int main()
    {
        // usage
        float rand_num = get_rand_num();
    }
    ```

    这样可能会造成有的随机数没有被访问到，有的随机数被访问了多次。但是由于我们是随机性不敏感的场合，所以这样的代价是可以承受的。使用这样的方法可以把 cpu 跑满。

    如果想让每个随机数都访问到，而且不加锁，不越界，可以让每个线程维护一个自己的`rand_num_idx`，或者干脆每个线程维护一个自己的随机数表。

* 猜想：如果是`vector<vector<int>> arr`，那么`arr`不会占用一大块连续的内存；如果是`vector<array<int, 3>> arr`，那么`arr`会占用一大块连续的内存。

* `array<int, 3> vec;`和`int vec[3];`该如何选择？

    `array<int, 3>`比`int vec[3]`多了一个`=`运算符，比较方便三个数一起赋值。

    `vector`里可以存`array`，但是不能直接存`int []`数组，如果一定要存数组，可以使用一个`struct`将数组包裹起来，再将 struct 对象存到`vector`中。

    因此如果是存一个向量，那么可以选择`array<float, 3>`，这样可以直接使用`pos_1 = pos_2;`这样的功能。

    如果是在`struct`中定义一组数据，那么可以使用`type []`数组。

* c++ 17 的文件系统

    没错，c++ 直到 c++17 才支持文件系统。

    ```cpp
    #include <iostream>
    #include <filesystem>
    namespace fs = std::filesystem;
    using namespace std;

    int main()
    {
        fs::path p("./main");  // 使用字符串创建 path
        string relative_path = p.c_str();  // path 转换成 c-style string
        string absolute_path = fs::absolute(p).c_str();  // 使用 path 构造绝对路径 absolute
        cout << "relative: " << relative_path << endl;  // 不清楚为啥会多个点，不过路径确实没错
        cout << "absolute: " << absolute_path << endl;

        absolute_path = fs::absolute("./main").c_str();  // 也可以直接使用 C 字符串构造 absolute
        cout << "absolute: " << absolute_path << endl;

        string cur_path = fs::current_path();  // 当前目录，当前目录也可以直接用赋值转换成 string
        cout << fs::current_path() << endl;  // path 也可以直接用 cout 输出
        cout << cur_path << endl;
        return 0;
    }
    ```

    输出：

    ```
    relative: ./main
    absolute: /home/hlc/Documents/Projects/cpp_test/./main
    absolute: /home/hlc/Documents/Projects/cpp_test/./main
    "/home/hlc/Documents/Projects/cpp_test"
    /home/hlc/Documents/Projects/cpp_test
    ```

    其余的一些功能，判断是文件还是目录，判断是否存在，遍历目录，拿到文件/目录的元信息（权限，inode之类的），新建，删除，读写追加文件，指定工作目录，以及 socket 之类的系统虚拟文件的读写，等有空了再看吧。

    还有一些常用的功能，比如拼接路径，修改文件名，路径截取，正斜杠和反斜杠的处理，上一级目录，有空了也看看。

    记得编译器要打开 c++ 17 的支持，不然会报错的。 visual studio 默认还在用 c++ 14 的标准。

* 复杂项目的渐进编程法

    不要想着一开始就实现一个接口灵活，非常好用的框架。因为我们编程时面对的是当前的项目，所谓的“灵活”是针对大量的项目而言的，接手的项目比较少时，无法抽象出需要在什么地方灵活。

    比如在渲染物体表面时，一开始可能只用到`Kd`，`Ks`这两个材质参数，后面慢慢又增加了折射，色散之类的效果，又增加了透明度，折射率，吸收率，衰减系统，brdf 之类的材质参数。刚开始的时候不可能考虑到后面的这么多东西，因此过度考虑代码的灵活性也是在浪费时间。

    一个比较好的想法是，对于每个项目，都只使用已有的知识，想办法最快地实现目标，记录下其中学到的东西。然后再开启下一个项目，同样以最快的方式达到目标。一直这样循环下去。

    比如在给函数传参数`vec3`时，既可以使用引用，也可以按值传递。如果要传引用，需要区分左值引用，右值引用，为了统一这两种引用，还要写模板，为了使模板只对`vec3`类型生效，还要写模板元编程`enable_if`，非常麻烦。如果我们的目标仅仅是渲染，那么直接按值传递，可以节省很多时间。只有当按值传递确实成为性能瓶颈时，再考虑将值换成引用。

    如果希望对引用和模板展开调研，可以另开一个项目，专门研究引用，模板，完美转发。但在当前项目中去研究这些东西，是不值得推荐的。

* 按格式解析文件

    目前我觉得比较好的方法是使用有限状态机。有空了刷刷相关的题目。不知道有什么更好的方法。

* 如果想让一个函数既接收左值参数，又接收右值参数，还不想重载，也不想写模板实现完美转发，那么可以试一试`const`左值引用。

    ```cpp
    #include <iostream>
    #include <string>
    using namespace std;

    void print(const string &msg)
    {
        cout << msg << endl;
    }

    int main()
    {
        print("hello");  // OK, "hello" 会先被转换成匿名对象 string("hello")，然后再转换成 const 左值引用

        string hello_world = "hello, world";
        print(hello_world);  // OK，本身就是左值引用
        return 0;
    }
    ```

    想一想，通常右值引用都是匿名对象，我们硬用右值引用改匿名对象也没什么意义。如果懒得定模板，`const`左值引用确实是个比较好的选择。