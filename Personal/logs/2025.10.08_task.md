* [v] qa: review 30 mins 10.08

    11:51 ~ 12:27

    feedback:

    * flex中，`\n {return 0;}`表示结束 parser 程序，进入主程序。如果写成`\n {}`，那么即使按回车换行，parser 程序也不结束。

    * [ ] 调研实现: 增加 reinforce_record.txt
    
        在 review 时，仍然没做出来的题目，在 u0 后或 u1 后输入 r，将当前 unit append 到 reinforce record 中。

        与 review 相似，每周使用`./main.py rein`检测一次 reinforce record。在检测中间如果还有不会的，同样使用 r 将其再次保存到 rein 中，将会的都删除。

        后续可以考虑 monthly reinforce 和 quarterly reinforce 甚至 annually。每周 rein 做不出来的放到每月，每月做不出来的放到每季度，每季度做不出来的放到每年。

* [v] reorg: documents 30 mins 10.08

    12:28 ~ 12:45

    feedback:

    * [ ] 调研实现： reorg doc 时，采用两种策略，一种是默认模式，即 freedom，另外一种是 restricted，只随机选择指定几个文件中的一个

        这些指定的文件，可能积累了大量的 cache，是重点要处理的对象。freedom 模式则增加一点随机游走的可能性，避免过拟合。

    * [ ] `EXIT_FAILURE`是否为一个宏？同类型的宏还有哪些？

        `exit(EXIT_FAILURE);`

    * 记录一下这个写法

        ```cpp
        int threadsPerBlock = 256;
        int blocksPerGrid = (numElements + threadsPerBlock - 1) / threadsPerBlock;
        ```

        如果 numElements 能整除 256，那么取商作为 blocksPerGrid；如果无法整除，那么取`商 + 1`。

        如果自己写这块逻辑，可能写成：

        ```cpp
        blocksPerGrid = numElements / threadsPerBlock;
        if (numElements % threadsPerBlock != 0) {
            blocksPerGrid += 1;
        }
        ```

        这样的话，相当于做了两次除法运算。上面的写法只做了一次除法运算。

* [v] qa: 2 units 30 mins 10.08

    13:04 ~ 13:05

* [O] process 1 tab 10.08

    13:09 ~ 13:44

    feedback:

    * 目前看到

        > 直接构造 std::initializer_list 时指定模板参数

* [v] 调研`np.linspace()`与其他常用的数据创建方法

    14:03 ~ 15:20

    feedback:

    * [ ] 调研 python 中是否有函数重载？

* [v] `kobject_put()`

    15:21 ~ 15:29

* [v] 自己写的程序按 tab 如何自动补全参数？

    15:31 ~ 16:35

* [v] arm linux 环境下是否有类似 nasm 的工具？

    16:36 ~ 16:44

    feedback:

    * [asso] 调研`as`
    
        GNU Assembler (as)

        * 准备树莓派开发板，使用 ssh 进入系统

            或使用 qemu 模拟一个 arm 环境，安装 ubuntu 系统，使用 ssh 进入系统

        * 调研系统中是否有 as，如果没有，安装

        * 跑通第一个 arm 汇编的 hello world 程序

        * 使用汇编实现循环求和 1 + ... + 10

        * 使用汇编实现自定义函数的调用，要求有 2 个输入参数

        * 使用汇编实现斐波那契数列

* [v] `DataLoader`中的 sampler 是什么含义？

    16:47 ~ 17:20

    feedback:

    * [ ] `SubsetRandomSampler()`

* [v] `np.meshgrid()`

    ~ 20:01

* [ ] 聚点，开集，闭区域，无界集

* [ ] 调研 ds 生成的一段代码

    ```c
    // 计算缓冲区的虚拟地址
    void __iomem *device_buffer = dev->mmio_base + 0x1000;

    // 方法一：使用内核提供的IO函数（推荐，因为可移植且安全）
    // 写入一个32位字
    iowrite32(0x12345678, device_buffer);
    // 读取一个32位字
    u32 value = ioread32(device_buffer);

    // 批量写入一段数据（这就是你想要的“强行”操作）
    // src_buf 是你准备好的数据源（在主机内存里）
    // count 是你想写入的32位字的数量
    iowrite32_rep(device_buffer, src_buf, count);

    // 方法二：更“强行”的方式 - 直接解引用指针（需极度小心！）
    // 首先，确保映射时为“不缓存”或“写合并”模式，否则会出问题。
    // 通常用 pci_ioremap_bar() 默认是 ioremap()，这通常是安全的（无缓存）。
    // 但直接解引用 __iomem 指针编译器会报错，所以需要强制转换。

    // 强制转换为 volatile 指针，告诉编译器别优化，每次都要真的访问
    volatile u32 *hardware_buffer = (volatile u32 *)device_buffer;

    // 现在，你可以像普通数组一样操作了！
    hardware_buffer[0] = 0xAAAAAAAA; // 写入第一个字
    value = hardware_buffer[1];      // 读取第二个字

    // 甚至可以用memcpy（但确保目的地址是volatile且没有缓存问题！）
    // memcpy_toio() 是更安全的选择
    memcpy((void *)hardware_buffer, src_buf, count * 4);
    ```