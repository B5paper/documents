* 每天结束的时候要列出来一个明天改进什么地方

* 编译原理图 2-3

    <div style='text-align:center'>
    <img width=800 src='./pics/2024.03.04/Screenshot from 2024-03-04 15-08-49.png'>
    </div>

    REAL 那一个，为什么节点 4 不能直接连到节点 3？

    white space 没看懂，难道注释指的是`--hello,world`这样的形式吗？

    error 也没看懂，它的意思是说，如果有一个字符，只要这个字符不是`\n`，就说明错误的意思吗？

    ID 那个图，是否包含了 IF 的情况？

* 对于图 2-4，如果输入了两个`-`，即`--`，那么并不会在 10 处终止，但是根据最长匹配原则，又不能只匹配一个`-`就停下。该如何解释这个矛盾？

* 用`[o]`表示任务完成了一半，还正在进行

* `vloadn`

    从指定地址 + 指定偏移读取数据。

    syntax:

    ```c
    gentypen vloadn(size_t offset,
        const global gentype *p)
    ```

    Returns sizeof(gentypen) bytes of data read from address (p + (offset * n)).

    The address computed as `(p + (offset * n))` must be 8-bit aligned if gentype is `char` or `uchar`; 16-bit aligned if gentype is `short` or `ushort`; 32-bit aligned if gentype is `int`, `uint`, or `float`; 64-bit aligned if gentype is `long`, `ulong`, or `double`.

    vloadn is used to do an unaligned vector load.

    example:

    `kernels.cl`:

    ```opencl
    kernel void test(global float *in, global float3 *out)
    {
        *out = vload3(1, in);
    }
    ```

    `main.cpp`:

    ```cpp
    #include "../ocl_simple/global_ocl_env.h"

    int main()
    {
        float arr[] = {
            0, 1, 2,
            3, 4, 5
        };
        cl_float3 out;
        init_global_ocl_env("kernels.cl", {"test"});
        add_buf("arr", sizeof(float), sizeof(arr) / sizeof(float), arr);
        add_buf("out", sizeof(cl_float3), 1);
        run_kern("test", {1}, "arr", "out");
        read_buf(&out, "out");
        printf("%f, %f, %f, %f\n", out.s[0], out.s[1], out.s[2], out.s[3]);
        return 0;
    }
    ```

    输出：

    ```
    opencl device name: gfx1034
    3.000000, 4.000000, 5.000000, 0.000000
    [Warning] destroy ocl env
    release ocl buffer: out
    release ocl buffer: arr
    ```

    要求`arr`必须是`float`类型，同样，给 kernel 传递参数时，也需要以`float`指针来传递。如果使用`cl_float3`存储数据以及传递，数据会出错。

    因为`cl_float3`实际上占用的是`sizeof(float) * 4`个字节的内存，所以会有一些问题。

* `vstoren`

    syntax:

    ```c
    gentypen vstoren(gentypen data,
        size_t offset,
        global gentype *p)
    ```

    Write sizeof(gentypen) bytes given by data to address (p + (offset * n)).

    这个函数的返回值类型应该是`void`吧，好像书上写错了。

    这个函数的使用和`vloadn()`正好相反。

    example:

    `kernels.cl`:

    ```c
    kernel void test(global float3 *in, global float *out)
    {
        float3 data = *in;
        vstore3(data, 1, out);
    }
    ```

    `main.cpp`:

    ```cpp
    #include "../ocl_simple/global_ocl_env.h"

    int main()
    {
        cl_float3 in = {1, 2, 3};
        float out[6] = {0};
        init_global_ocl_env("kernels.cl", {"test"});
        add_buf("in", sizeof(cl_float3), sizeof(cl_float3) / sizeof(cl_float3), &in);
        add_buf("out", sizeof(float), 6);
        run_kern("test", {1}, "in", "out");
        read_buf(&out, "out");
        printf("%f, %f, %f\n", out[3], out[4], out[5]);
        return 0;
    }
    ```

    输出：

    ```
    opencl device name: gfx1034
    1.000000, 2.000000, 3.000000
    [Warning] destroy ocl env
    release ocl buffer: out
    release ocl buffer: in
    ```

    可以看到，`in`中的数组被存储到了`out`的 3，4，5 这三个索引处。

* `vload_half()`与`vload_halfn()`，`vstore_harf()`与`vstore_harfn()`

    syntax:

    ```c
    float vload_half(size_t offset,
        const global half *p)

    floatn vload_halfn(size_t offset,
        const global half *p)

    void vstore_half(float data,
        size_t offset,
        global half *p)

    void vstore_halfn(floatn data,
        size_t offset,
        global half *p)
    ```

    Returns sizeof(half) bytes of data read from address (p + offset).

* 有关`hard`类型和`e`, `z`, `p`, `n`

    ```cpp
    void vstore_half_rte(double data, size_t offset, half *p)
    void vstore_half_rtz(double data, size_t offset, half *p)
    void vstore_half_rtp(double data, size_t offset, half *p)
    void vstore_half_rtn(double data, size_t offset, half *p)
    ```

    这几个都涉及到浮点数到整数的转换，猜测`rte`的意思是向偶数取整，`rtz`是向零取整，`rtp`是向正无穷取整，`rtn`是向负方向取整。

    `rt`表示 round to，`e`表示 even，`z`表示 zero，`p`表示 positive，`n`表示 negative。

* `vloada_halfn`

    `load`或`store`后面带一个`a`的，表示 aligned。指针的偏移必须是 1, 2, 4, 8, 16 的整数倍。

    如果碰到`float3`这样的数据，会自动对齐到`float4`。