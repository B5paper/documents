* `std::format`

    std::format 是 C++20 引入的文本格式化库，提供类型安全、高性能的字符串格式化功能，类似于 Python 的 format()。

    基本用法
    
    ```cpp
    #include <format>
    #include <iostream>

    int main() {
        // 1. 基本格式化
        std::string s1 = std::format("Hello, {}!", "World");  // "Hello, World!"
        
        // 2. 位置参数
        std::string s2 = std::format("{1} {0}!", "World", "Hello");  // "Hello World!"
        
        // 3. 带类型的格式化
        int x = 42;
        double pi = 3.14159;
        std::string s3 = std::format("int: {}, double: {}", x, pi);
        
        std::cout << s1 << "\n" << s2 << "\n" << s3 << std::endl;
    }
    ```

    注：

    1. sprintf 要求提前申请好 dst buffer，还需要自己手动计算，非常麻烦
    
        比如`str = "my name: %s, my age: %d, my height: %f\n"`，需要知道`str`中除了`%`变量之外的字符个数，需要知道`%s`代表的字符串的长度，需要知道`%d`对应的变量在字符串化后具体占几个字符，需要知道`%f`小数点后保留 8 位还是 6 位。得到所有信息后，再相加得到 dst buffer 的长度。如果字符串中有 unicode ，那么更加复杂。

        如果我们直接静态申请一块大 buffer，那么又会资源浪费。

        使用 c++ 的`str << "my name: " << name << ", my age: " << ...`也可以完成这个任务，但是字符串之间是断开的，不直观。

        这时候`format()`就呼之欲出了，它很好地解决了这个问题。

    **格式说明符**

    * 数值类型

        ```cpp
        int n = 42;
        double d = 3.14159;

        // 宽度和填充
        std::format("{:10}", n);      // "        42" (默认右对齐)
        std::format("{:<10}", n);     // "42        " (左对齐)
        std::format("{:^10}", n);     // "    42    " (居中对齐)
        std::format("{:*>10}", n);    // "********42" (右对齐，*填充)

        // 进制
        std::format("{:b}", n);       // "101010" (二进制)
        std::format("{:x}", n);       // "2a" (十六进制小写)
        std::format("{:X}", n);       // "2A" (十六进制大写)
        std::format("{:o}", n);       // "52" (八进制)

        // 浮点数
        std::format("{:.2f}", d);     // "3.14" (保留2位小数)
        std::format("{:e}", d);       // "3.141590e+00" (科学计数法)
        std::format("{:.2%}", 0.42);  // "42.00%" (百分比)
        ```

    * 字符串类型

        ```cpp
        std::string str = "hello";

        std::format("{:10}", str);    // "hello     " (右对齐)
        std::format("{:^10}", str);   // "  hello   " (居中对齐)
        std::format("{:.3}", str);    // "hel" (截断前3个字符)
        ```

    * 时间格式化

        ```cpp
        #include <chrono>
        using namespace std::chrono;

        auto now = system_clock::now();

        // 格式化为字符串
        std::string time_str = std::format("Today is {:%Y-%m-%d}", now);
        // 例如: "Today is 2024-01-15"

        // 完整示例
        std::format("{:%Y年%m月%d日 %H:%M:%S}", now);
        ```

    * 自定义类型格式化

        ```cpp
        struct Point {
            int x, y;
        };

        // 特化 formatter
        template <>
        struct std::formatter<Point> {
            constexpr auto parse(std::format_parse_context& ctx) {
                return ctx.begin();
            }
            
            auto format(const Point& p, std::format_context& ctx) const {
                return std::format_to(ctx.out(), "({}, {})", p.x, p.y);
            }
        };

        // 使用
        Point p{10, 20};
        std::string s = std::format("Point: {}", p);  // "Point: (10, 20)"
        ```

    **高级特性**

    1. 输出到迭代器

        ```cpp
        #include <vector>
        std::vector<char> buf;
        std::format_to(std::back_inserter(buf), "Value: {}", 42);
        ```

    2. 输出到字符串

        ```cpp
        std::string s;
        std::format_to(std::back_inserter(s), "{} + {} = {}", 2, 3, 5);
        ```

    3. 获取格式化后的字符数

        ```cpp
        size_t n = std::formatted_size("{} + {} = {}", 2, 3, 5);  // 返回字符数
        ```

    **对比传统方法**

    ```cpp
    // printf (类型不安全)
    printf("%d %f", 42, 3.14);

    // stringstream (冗长)
    std::stringstream ss;
    ss << 42 << " " << 3.14;

    // std::format (推荐)
    std::format("{} {}", 42, 3.14);
    ```

    注意事项

    * 需要 C++20 支持

    * 错误处理：格式字符串错误在编译时（如果可能）或运行时检测

    * 性能：通常比 stringstream 和 sprintf 更快

    * 本地化：通过 std::vformat 支持本地化

    std::format 提供了类型安全、易读且高效的字符串格式化方式，是现代 C++ 中推荐的格式化方法。

* fail2ban 手动往 sshd jail 里添加一个 ip

    ```bash
    # 永久禁止 IP（直到手动移除）
    sudo fail2ban-client set sshd banip 192.168.1.100

    # 禁止带时间限制（例如 1 天）
    sudo fail2ban-client set sshd banip --time 86400 192.168.1.100
    ```

    查看和管理已禁止的 IP:

    ```bash
    # 查看 sshd jail 状态
    sudo fail2ban-client status sshd

    # 查看已禁止的 IP 列表
    sudo fail2ban-client get sshd banned

    # 解禁 IP
    sudo fail2ban-client set sshd unbanip 192.168.1.100
    ```

* Python Type Hint

    Python Type Hint（类型提示）是在 Python 3.5+ 中引入的静态类型检查辅助工具，它允许开发者为变量、函数参数和返回值等标注期望的类型，以提高代码的可读性、可维护性，并借助工具（如 mypy）进行静态类型检查。

    **基本语法**

    ```python
    # 变量注解
    name: str = "Alice"
    count: int = 10

    # 函数参数和返回值注解
    def greet(name: str) -> str:
        return f"Hello, {name}"
    ```

    **常用类型**

    * 基础类型：int, str, float, bool, bytes

    * 复合类型：

        * List[int]：整数列表（需 from typing import List）

        * Dict[str, int]：键为字符串、值为整数的字典

        * Tuple[int, str]：固定长度的元组

        * Optional[int]：可能为 int 或 None（等价于 Union[int, None]）

        * Union[int, str]：可以是 int 或 str

        * Any：任意类型（禁用静态类型检查）

    **Python 3.9+ 简化写法**

    从 Python 3.9 开始，可以直接使用内置类型代替 typing 中的泛型：

    ```python
    # Python 3.9+
    list[int]          # 代替 List[int]
    dict[str, int]     # 代替 Dict[str, int]
    tuple[int, ...]    # 变长元组
    ```

    **示例代码**

    ```python
    from typing import Optional, Union

    def process_data(
        data: list[int],
        prefix: Optional[str] = None
    ) -> dict[str, Union[int, float]]:
        result = {"sum": sum(data)}
        if prefix:
            result["prefix"] = len(prefix)
        return result
    ```

    **静态检查工具**

    * mypy：最常用的类型检查器。

        ```bash
        pip install mypy
        mypy your_script.py
        ```

    注意

    * 运行时可以通过 __annotations__ 属性获取类型信息（用于反射或文档生成）。

    **循环中的类型注解**

    1. 在循环内部注解（Python 3.6+）

        ```python
        for i in range(123):
            i: int  # 在循环体内添加类型注解
            # 或者直接依赖 range() 的类型推断
            pass
        ```

    2. 使用类型注释（Type Comment，较旧的写法，Python 3.x 兼容）
    
        ```python
        for i in range(123):  # type: int
            pass
        ```

    3. 使用 typing.cast（当类型不明显时）

        ```python
        from typing import cast

        items = [1, 2, 3]  # 假设这里 items 类型不明确
        for item in items:
            item_int = cast(int, item)  # 明确告诉类型检查器这是 int
            # 但这不是运行时检查，只是提示类型检查器
        ```

* git submodule sync

    如果`.gitmodules`中的 repo url 路径改变，那么可以使用`git submodule sync`将更改同步到`.git/config`中。

    用法：

    1. 将`.gitmodules`中的所有配置同步到主仓库`.git/config`和子仓库`sub/.git/config`中

        `git submodule sync`

    2. 只同步指定 sub

        `git submodule sync -- <submodule-path>`

        example:

        `git submodule sync -- lib/my-library`

        只修改 my-library 子仓库中的`.git/config`

    注意事项：

    * 如果已经执行过 git submodule update 且本地有 submodule 的 clone，修正 URL 后可能需要删除本地子模块目录重新拉取

    * 如果子模块没有初始化（--init），sync 可能不会生效，因为子模块的 .git 目录还不存在或配置不完整。

    git submodule sync 的作用是同步子模块的远程 URL，具体来说：

    主要功能：

    * 同步 .gitmodules 中的 URL 到 .git/config

        * 当你在 .gitmodules 文件中修改了子模块的 URL 后，git submodule sync 会将这些更改同步到本地的 .git/config 文件中。

    * 更新本地子模块的远程仓库配置

        * 对于已经初始化并拉取过的子模块，它会更新该子模块目录内的 .git/config 中的 remote.origin.url。

    使用场景：

    * 修改了 .gitmodules 中的 URL 后（比如仓库迁移、协议变更等）

    * .git/config 中的 URL 与 .gitmodules 不一致时

    * 重新配置子模块的远程仓库地址

    工作原理：

    ```bash
    # 假设 .gitmodules 中的 URL 已从 old-url 改为 new-url

    # 执行前：
    .gitmodules:          submodule.foo.url = new-url
    .git/config:          submodule.foo.url = old-url   # 旧地址
    foo/.git/config:      [remote "origin"] url = old-url  # 旧地址

    # 执行后：
    git submodule sync

    .git/config:          submodule.foo.url = new-url   # 已更新
    foo/.git/config:      [remote "origin"] url = new-url  # 已更新
    ```

    常用命令组合：

    ```bash
    # 修改 .gitmodules 中的 URL 后
    vim .gitmodules

    # 同步配置
    git submodule sync

    # 更新子模块内容
    git submodule update --init --recursive
    ```

* Beta 分布

    Beta 分布简介

    Beta 分布是定义在区间 $[0, 1]$ 上的连续概率分布，由两个正参数 $\alpha$ (alpha) 和 $\beta$ (beta) 控制。

    1. 概率密度函数（PDF）

        $$f(x; \alpha, \beta) = \frac{x^{\alpha - 1} (1 - x)^{\beta - 1}}{B(\alpha, \beta)} , 0 \leq x \leq 1$$

        其中 $B(\alpha, \beta)$ 是 Beta 函数：

        $$B(\alpha, \beta) = \int_0^1 t^{\alpha - 1} (1 - t)^{\beta - 1} dt = \frac{\Gamma(\alpha) \Gamma(\beta)}{\Gamma(\alpha + \beta)}$$

        $\Gamma$ 是伽马函数。

    2. 统计特征

        均值：

        $$E[X] = \frac{\alpha}{\alpha + \beta}$$

        方差：

        $$Var(X) = \frac{\alpha \beta}{(\alpha + \beta)^2 (\alpha + \beta + 1)}$$

        众数（当 $\alpha \gt 1$,$\beta \gt 1$ 时）：

        $$Mode = \frac{\alpha - 1}{\alpha + \beta - 2}$$

    3. 形状变化

        通过改变 $\alpha$ 和 $\beta$ 可以产生多种形状：

        * $\alpha = \beta = 1$：均匀分布 $U(0,1)$

        * $\alpha \gt 1$, $\beta \gt 1$：单峰，在 (0,1) 内

        * $\alpha < 1$, $\beta < 1$：U 形（两端高中间低）

        * $\alpha > 1$, $\beta = 1$：在 1 处为 0，在 0 处为有限值，右偏

        * $\alpha = 1$, $\beta > 1$：在 0 处为 0，在 1 处为有限值，左偏

        * $\alpha < 1$, $\beta > 1$：反 J 形（集中在 0 附近）

        * $\alpha > 1$, $\beta < 1$：J 形（集中在 1 附近）

    4. 与二项分布的关系

    如果先验分布是 Beta 分布，观测到二项分布数据后，后验分布也是 Beta 分布（共轭先验）：

    先验：$Beta(\alpha, \beta)$, 数据：$k$次成功（总试验 $n$）

    后验：$Beta(\alpha + k,\beta + n - k)$

    5. 应用场景

        * 比例或概率的建模：例如点击率、转化率等（因为范围在 0~1）

        * 贝叶斯统计：作为二项分布的成功概率 p 的先验分布

        * 顺序统计量：均匀分布样本的第 k 个顺序统计量服从 Beta(k, n-k+1)

        * 项目管理：PERT 中用于任务完成时间的建模（经过缩放平移）

        * 机器学习：作为分类器输出的校准分布，或变分推断中的变分分布

    6. 与其他分布的关系

        * Gamma 分布：如果 $X \sim \mathrm{Gamma}(\alpha, 1)$, $Y \sim \mathrm{Gamma}(\beta, 1)$,则

            $$\frac{X}{X + Y} \sim \mathrm{Beta}(\alpha, \beta)$$

        * F 分布：有转换关系

        * 二项分布/伯努利分布：共轭先验

* $\Gamma$ 函数（Gamma function）

    $\Gamma$ 函数（Gamma function） 是阶乘在实数和复数域的推广，计算它主要有以下几种方法：

    1. 定义

        * 1.1 积分定义（$Re(z) > 0$）

            $$\Gamma(z) = \int_0^\infty t^{z-1} e^{-t} dt$$

            对于正整数 $n$：

            $$\Gamma(n) = (n-1)!$$

            特殊值：

            $$\Gamma(1) = 1,\ \Gamma(1/2) = \sqrt{\pi}$$

        * 1.2 递推关系

            $$\Gamma(z+1) = z \Gamma(z)$$

            这个性质让我们可以将任意复平面上的 $\Gamma$ 函数计算转化到主区间（如 1 ≤ Re(z) < 2）。

    2. 计算方法

        * 2.1 直接数值积分

            * 对积分定义式进行数值积分（如 Gauss-Laguerre 积分）

            * 适用于 Re(z) > 0

        * 2.2 Lanczos 近似（最常用）

            这是计算 $\Gamma$ 函数最流行的高精度方法。核心公式：

            $$\Gamma(z+1) = \sqrt{2 \pi} \left( z + g + \frac 1 2 \right)^{z + \frac 1 2} e^{-(z + g + \frac 1 2)} A_g(z)$$

            其中 $g$ 是常数（常用 $g = 607 / 128$，$A_g(z)$ 是一组预先计算的有理函数近似。

            特点：

            * 在整个复平面（除负整数点）都有高精度

            * 计算速度快

            * 被多数数学库采用

    3. 特殊情况的简便计算
    
        * 3.1 正整数

            $$\Gamma(n) = (n-1)! = 1 \times 2 \times \cdots \times (n-1)$$

        * 3.2 半整数

            利用递推和 $\Gamma (1/2) = \sqrt{\pi}$:

            $$\Gamma(n + \frac 1 2) = \frac{(2n)!}{4^n n!} \sqrt{\pi}$$

            例如：

            $$\Gamma(3/2) = \frac 1 2 \sqrt{\pi},\ \Gamma(5/2) = \frac 3 4 \sqrt{\pi}$$

        * 3.3 负数的 $\Gamma$ 函数

            利用反射公式：

            $$\Gamma(1-z) \Gamma(z) = \frac{\pi}{\sin (\pi z)}$$

            例如：

            $$\Gamma(-1/2) = \frac{\Gamma(1/2)}{(-1 / 2)} = -2 \sqrt{\pi}$$

            注意：负整数处是极点（发散）。

    4. 常用近似公式

        * 4.1 Stirling 公式（大 z）

            $$\Gamma(z) \sim \sqrt{\frac{2 \pi}{z}}(\frac{z}{e})^z (1 + \frac{1}{12 z} + \frac{1}{288 z^2} - \cdots)$$
            
            适用于 $\lvert z \rvert$ 较大时。

        * 4.2 小 z 近似

            用递推转到 z>1 再计算。

    5. 实际应用中的计算

        编程实现：

        * Python: math.gamma()（实数）, scipy.special.gamma()（复数）

        * C++: std::tgamma()（C++11）

        * MATLAB: gamma()

        * R: gamma()

        Python 示例：

        ```python
        import math
        print(math.gamma(5))      # 24.0
        print(math.gamma(2.5))    # 1.329340388179137
        ```

        注意事项：

        * 大参数可能溢出（如 $\Gamma(172)$ 超过双精度浮点）

        * 负整数参数返回 NaN 或报错

        * 可用对数 Gamma 函数避免溢出：

            $$\ln \Gamma(z) = \ln(\Gamma(z))$$

            函数：math.lgamma()。

    6. 与 Beta 函数的关系

        Beta 函数通过 Γ 函数计算：

        $$\Beta(x, y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x + y)}$$

        这就是 Beta 分布的归一化常数的来源。

    7. 历史与发展

        * 由欧拉（1729）和勒让德（命名）引入

        * 推广了阶乘到非整数

        * 在概率统计、数论、物理中广泛应用

    总结计算建议：

    * 日常使用：直接调用数学库函数

    * 需要理解：记住递推公式 $\Gamma(z + 1) = z \Gamma(z)$ 和 $\Gamma(1 / 2) = \sqrt{\pi}$

    * 数值稳定性：大参数时使用对数 Gamma 函数

    * 实现原理：Lanczos 近似是工业标准方法

