* 不能只考虑组内的合作，还要考虑组间的合作

* 打字交流，不如语音交流，因为语音会表达额外的情绪。语音交流不如面对面交流，因为有吃饭、打球等社交

* 并不是值表示了含义，而是节点存在的本身表示了含义

* 最可怕的不是站得低，而是站在肥皂水泡泡上，晃晃悠悠，不知道什么时候泡泡会被戳破

* 智能应该从数据和混沌中总结规律，不应该根据（人总结出来的）规律去处理数据

* `pci_iomap()`

    将 pci 设备 bar 空间上的资源映射到内核的内存地址空间里 (内存映射 I/O (MMIO))。

    syntax:

    ```c
    void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen);
    ```

    bar: 要映射的 BAR 的索引（0-5）。

    maxlen: 想要映射的长度。如果为0，则映射整个 BAR 区域。

    这个函数将 pci 设备 bar 指定的物理地址空间映射到内核的虚拟地址空间。如果成功，函数返回一个内核虚拟地址。

    `__iomem`是一个修饰符，提醒程序员这个地址指向的是 I/O 内存，访问它需要使用专门的函数（如 ioread32, iowrite32），而不能直接解引用。

    example:

    ```c
    // to be filled
    ```

    配对函数：`pci_iounmap()`

    `maxlen`有可能超过 bar 允许的长度，所以在映射前，我们最好调用`pci_resource_len(dev, bar)`函数来获取第 bar 个 BAR 的实际长度。如果不动态获取长度，直接映射指定长度的 bar 空间，那么，那么内核会读取 PCI 设备对应的`struct resource`里`->end - ->start + 1`的值，并以此为依据在 mmu 里创建页表。如果驱动访问到了超出合法长度的虚拟地址，那么 mmu 会报 page fault，整个内核有可能崩溃。

* `pci_set_master()`

    启动 pci device 的 bus master 功能。启用这个功能后，该 PCI 设备才能主动发起 DMA（直接内存访问）操作，即能够直接读写系统内存，而无需CPU的参与。

    syntax:

    ```c
    void pci_set_master(struct pci_dev *dev);
    ```

    example:

    ```c
    // 启用设备 (pci_enable_device())。

    // 请求和映射I/O资源（如 pci_request_regions(), pci_iomap()）。

    // 分配DMA缓冲区等资源。

    // pci_set_master();
    ```

    `pci_set_master()`所做的工作非常简单：它设置PCI设备配置空间中命令寄存器的第2位。

    在驱动程序的 remove 或 shutdown 路径中，通常不需要显式地禁用Bus Master，因为PCI核心在禁用设备时会自动处理。

* Bus Master

    在PCI/PCIe总线架构中，大多数设备是“从设备（Slaves）”，只能响应来自CPU的读写请求。

    而有些设备（如网卡、磁盘控制器、高性能显卡）需要能够主动地向系统内存大量、高速地传输数据。这类设备被称为“总线主（Bus Master）”。

    要成为总线主，设备必须能够在总线上驱动地址和数据信号，主动发起传输周期。

    * 如何成为总线主？

        * 每个PCI设备都有一个配置空间，其中包含一个叫做命令寄存器（Command Register） 的16位寄存器。

        * 该寄存器的第2位专门用于控制“总线主”功能：

            * 位2 = 0：禁用设备的Bus Master功能。

            * 位2 = 1：启用设备的Bus Master功能。

        * 默认情况下，在系统启动或设备复位后，这一位通常是清零（禁用） 的。

* `device->irq`

    `dev->irq`存储了分配给该硬件设备的中断请求线（Interrupt ReQuest line）的编号。

    通常使用`request_irq(dev->irq, my_handler, ...)`去注册 ISR。配对函数为`free_irq(dev->irq, dev_id);`

    对于传统PCI设备，这个值通常在系统启动时由BIOS/UEFI或操作系统内核的PCI子系统自动分配。它通过读取设备的配置空间（具体是PCI_INTERRUPT_PIN和PCI_INTERRUPT_LINE寄存器）来分配和设置。对于现代设备（MSI/MSI-X），通常不直接使用`dev->irq`，而是使用`pci_alloc_irq_vectors()`等函数来管理 msi(x) 中断。

    在支持 MSI-X 的 PCI 设备上直接使用 dev->irq，其行为取决于内核版本和系统配置，但通常会导致性能低下、功能受限或完全无法工作。

* qemu edu 不支持 MSI-X （未验证）

* `pci_release_regions()`是`pci_request_regions()`的逆函数。

    syntax:

    ```c
    void pci_release_regions(struct pci_dev *pdev);
    ```

* `list_is_singular()`

    判断当前链表是否只有一个有效节点。

    具体做两件事：

    1. 判断链表非空 (!list_empty(head))。即判断 head->next 是否指向自己。

    2. 判断链表的第一个节点的 next 指针指向头节点 (head->next->next == head)。

    syntax:

    ```c
    #include <linux/list.h>

    bool list_is_singular(const struct list_head *head);
    ```

    `list_is_singular()`要求链表是 init 过的。比如通过`list_del()`从一个链表上取下一个节点后，没有 init，那么无法使用`list_is_singular()`判断这个节点是否为单个节点。

* gcc 编译时，不会记录`-L`的目录，只会指定`-l`指定的 so 文件。

* 如果使用`gcc main.c /path/to/libxxx.so -o main`编译，那么`/path/to/libxxx.so`会被硬编码到`main`中。这个路径可以是软链接。

    这种情况下，如果`libxxx.so`換了位置，那么使用`LD_LIBRARY_PATH`也是无效的。

* `ioremap()`

    将一段物理内存地址（通常是设备的内存或寄存器）映射到内核的虚拟地址空间。

    syntax:

    ```c
    #include <asm/io.h>

    void __iomem *ioremap(resource_size_t phys_addr, unsigned long size);

    void iounmap(volatile void __iomem *addr);
    ```

    example:

    1. 在驱动初始化时映射：

    ```c
    // 假设已知设备的寄存器物理地址是 0xFE000000，长度为 0x2000
    void __iomem *device_regs;
    device_regs = ioremap(0xFE000000, 0x2000);
    if (!device_regs) {
        // 映射失败，错误处理
    }
    ```

    2. 通过返回的虚拟地址访问设备：

        必须使用专门的读写函数（如 readl(), writel()），而不是直接解引用指针。

        ```c
        // 读取一个32位的寄存器
        u32 value = readl(device_regs + REG_OFFSET);

        // 向一个32位的寄存器写入
        writel(new_value, device_regs + ANOTHER_REG_OFFSET);
        ```

        为什么不能用`*`直接访问？ 因为设备寄存器的访问可能有副作用（比如读一次清零）或有严格的访问顺序要求，这些专用函数能保证正确的内存访问语义。

    配对函数：`iounmap()`

    如果你要映射的是非PCI设备的内存（例如，在设备树中定义的平台设备的内存区域），那么你必须使用`ioremap()`。

    如果硬要使用`ioremap()`映射 bar 0 寄存器，那么可能这样做：

    ```c
    // 1. 手动读取PCI配置空间，获取BAR的物理地址和大小
    resource_size_t start = pci_resource_start(pdev, 0); // 获取物理地址
    resource_size_t len   = pci_resource_len(pdev, 0);   // 获取长度
    // 2. 检查资源是否有效（好习惯）
    if (!request_mem_region(start, len, "my_driver")) {
        // 错误处理：内存区域可能已被其他驱动占用
        return -EBUSY;
    }
    // 3. 进行映射
    void __iomem *addr = ioremap(start, len);
    if (!addr) {
        release_mem_region(start, len);
        return -ENOMEM;
    }
    ```

* `ps aux`

    ps: 进程状态（Process Status）

    * `a`： 显示所有用户的进程（而不仅仅是当前用户的）。

    * `u`： 以面向用户的格式显示，这会提供更详细的信息（如 CPU、内存占用率、用户等）。

    * `x`： 列出没有控制终端的进程。这很重要，因为很多系统守护进程（后台服务）是不依赖于终端的。加上 x 才能看到所有这些后台进程。

    输出的关键列的含义：

    | 列名 |全称 | 含义 |
    | - | - | - |
    | `USER` | User | 进程的所有者（是哪个用户启动的） |
    | `PID` | Process ID | 进程的唯一ID号，用于识别和管理进程 |
    | `%CPU` | CPU Percentage | 进程占用CPU的百分比 |
    | `%MEM` | Memory Percentage | 进程占用物理内存的百分比 |
    | `VSZ` | Virtual Set Size | 进程使用的虚拟内存大小（单位：KB） |
    | `RSS` | Resident Set Size | 进程使用的、未被换出的物理内存大小（单位：KB） |
    | `TTY` | Teletypewriter | 进程是在哪个终端上运行的。? 表示不是从终端启动的。 |
    | `STAT` | Process State | 进程状态码（非常重要），例如：<br>- `R`： 正在运行或可运行<br>- `S`： 可中断的睡眠状态（等待事件完成）<br>- `D`： 不可中断的睡眠（通常与IO有关）<br>- `Z`： 僵尸进程（已终止但未被父进程回收）<br>- `T`： 已停止（通常由信号控制） |
    | `START` | Start Time | 进程启动的时间 |
    | `TIME` | CPU Time | 进程实际使用CPU运行的总时间 |
    | `COMMAND` | Command | 启动该进程所用的命令行名称 |

* `od -x`

    od: 是 Octal Dump 的缩写。这个名字源于其最初的主要功能是以八进制（Octal）格式显示文件内容。虽然现在它支持多种格式，但名字保留了下来。

    以十六进制（Hex）格式显示文件的内容.

    `-x`代表输出为“十六进制。
    
    example:

    `od -x msg.txt`

    output:

    ```
    0000000 6568 6c6c 2c6f 7720 726f 646c 202c 696e
    0000020 6168 2c6f 7a20 6961 696a 6e61 202c 6568
    0000040 6568 202c 6168 6168 000a
    0000051
    ```

    * 最左边的一列: 偏移量地址. 表示当前行数据在文件中的起始位置（偏移量），默认以八进制数显示。

    * 中间的多列: 数据内容. -x 选项规定每2个字节（16位）为一组进行显示。
    
        由于计算机的字节序（Endianness）问题，od -x 在显示时使用的是主机本身的字节序（对于大多数x86架构的电脑是小端序）。

        如果文件中连续的2个字节是 0x61 和 0x62（即字符 'a' 和 'b' 的ASCII码），在小端序机器上，od -x 会将其显示为一组：6261（即 0x62 在高位，0x61 在低位）。

    * 如果使用 -x 的同时再加上 -c 选项（即 od -xc），输出还会在最右边增加一列，显示数据对应的ASCII字符。不可打印的字符会显示为转义序列（如 \n）或问号（?）。

        比较神奇的是 ascii 字符会按 2 个字节的间隔自动把顺序倒过来：

        `od -xc msg.txt`:

        ```
        0000000    6568    6c6c    2c6f    7720    726f    646c    202c    696e
                  h   e   l   l   o   ,       w   o   r   l   d   ,       n   i
        0000020    6168    2c6f    7a20    6961    696a    6e61    202c    6568
                  h   a   o   ,       z   a   i   j   i   a   n   ,       h   e
        0000040    6568    202c    6168    6168    000a
                  h   e   ,       h   a   h   a  \n
        0000051
        ```

        可以看到，本来`e = 0x65`，`h = 0x68`，但是在显示的时候 od 自动把顺序纠正了。