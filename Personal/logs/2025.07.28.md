* 关于 A -> B -> C 的猜想

    假如有一个新的概念 A，我们没有关于 A 的定义，只有 A 与其他元素交互的结果，我们希望根据这些线索推导出，或者说，尽量还原出 A 的定义。通常我们会先做出猜想：A 的含义是 B，如果含义为 B，那么现象 C 可以得到解释。但是我们又会寻找反例，现在有了现象 C_1，无法用含义 B 解释，或者说，如果使用 B 推导，应该出现 C_1_reverse，这个现象和 C_1 不相符，此时我们必须将 A 的含义 B 替换为 B_1，使用 B_1 后，现象 C 和现象 C_1 都能得到解释，那么我们认为 B_1 比 B 更接近 A 的真实含义。

    使用这种方法，我们只能无限地让 B_n 接近 A，但是始终无法达到 A，因为我们不清楚未来是否还能找到反例。

    另外，现象 C，C_1 不一定都是由 A 导致的，可能是多重因素共同导致的；能解释 A 的 B 也不止有 B 和 B_1 这两种，可能有很多很多种。这样就为寻找 B 的过程带来了很大的复杂度。

* 如果我们无法根据所有的信息做出假设，那么可以剔除大部分信息后，根据一两个点做出联想和假设

    ```cpp
    if (paths[i].bw > maxBw || (paths[i].bw == maxBw && paths[i].type < minType)) {
      maxBw = paths[i].bw;
      minType = paths[i].type;
      if (pathType)
        *pathType = minType;
      count = 0;
    }
    ```

    比如这段代码，我们仅根据`paths[i].bw > maxBw`，`count = 0;`判断出，这段可能是找最大值，找到比现有值更大的值，那么就清空数组。拿到这个猜想后，再根据这个猜想判断其他代码的含义，是否符合这个猜想。

* topo edge 里 nex node 设置成指针的原因

    ```cpp
    struct TopoEdge {
        EdgeType edge_type;
        // int nex_node_idx;  // deprecated
        TopoNode *nex_node = nullptr;
        NodeType nex_node_type;
        float bw = 0;
    };
    ```

    在删除 node 时，其之后的所有 node idx 会失效，因此这里改成了指针。由于 node 是按`vector<Node*>`的方式存储的，所以删除或添加 node 后，其余 node 的指针不会因为 vector 的扩容/缩容而失效，edge 可以放心使用。

* 使用索引作为 vert 的 id 不合适，因为如果先删除倒数第 2 个 vert，再添加一个 vert，那么倒数的两个 vert 就会拥有相同的 id。