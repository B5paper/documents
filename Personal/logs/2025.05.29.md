* c++ 使用别的文件中的全局变量

    比如在`global_var.h`中声明了个结构体`struct GlobalVar {};`，在`global_var.cpp`中想定义个全局变量，让`user_1.cpp`，`user_2.cpp`都用到这个全局变量，那么可以这样写：

    `global_var.h`:

    ```cpp
    #ifndef GLOBAL_VAR_H
    #define GLOBAL_VAR_H

    struct GlobalVar {
        int val_int;
        const char *val_str;
    };

    #endif
    ```

    `global_var.cpp`:

    ```cpp
    #include "global_var.h"

    GlobalVar global_var {
        123,
        "hello, world"
    };
    ```

    `user_1.h`:

    ```cpp
    #ifndef USER_1_H
    #define USER_1_H

    int user_1_print_global_var_int();

    #endif
    ```

    `user_1.cpp`:

    ```cpp
    #include <stdio.h>
    #include "user_1.h"
    #include "global_var.h"

    extern GlobalVar global_var;

    int user_1_print_global_var_int() {
        printf("in user_1, global var int: %d\n", global_var.val_int);
        return 0;
    }
    ```

    `user_2.h`:

    ```cpp
    #ifndef USER_2_H
    #define USER_2_H

    int user_2_print_global_var_str();

    #endif
    ```

    `user_2.cpp`:

    ```cpp
    #include <stdio.h>
    #include "user_2.h"
    #include "global_var.h"

    extern GlobalVar global_var;

    int user_2_print_global_var_str() {
        printf("in user_2, global val str: %s\n", global_var.val_str);
        return 0;
    }
    ```

    `main.cpp`:

    ```cpp
    #include <stdio.h>
    #include "user_1.h"
    #include "user_2.h"
    #include "global_var.h"

    extern GlobalVar global_var;

    int main() {
        user_1_print_global_var_int();
        user_2_print_global_var_str();

        printf("in main(), global var:\n");
        printf("    val int: %d\n", global_var.val_int);
        printf("    val str: %s\n", global_var.val_str);

        return 0;
    }
    ```

    `Makefile`:

    ```makefile
    main: main.cpp user_1.o user_2.o global_var.o
    	g++ -g main.cpp user_1.o user_2.o global_var.o -o main

    global_var.o: global_var.h global_var.cpp
    	g++ -g -c global_var.cpp -o global_var.o

    user_1.o: user_1.h user_1.cpp
    	g++ -g -c user_1.cpp -o user_1.o

    user_2.o: user_2.h user_2.cpp
    	g++ -g -c user_2.cpp -o user_2.o

    clean:
    	rm -f main *.o
    ```

    output:

    ```
    in user_1, global var int: 123
    in user_2, global val str: hello, world
    in main(), global var:
        val int: 123
        val str: hello, world
    ```

    其中，`extern`表示这个变量的定义不在当前`.cpp`文件中，而在其他`.cpp`或`.o`文件里。
    
    注意在 makefile 中，编译`user_1.o`和`user_2.o`时并没有用到`global_var.o`，在最后生成`main`，也就是 link 环节才会用到`global_var.o`。

* 如果一个全局变量是 const 变量，那么它默认是 static 的。此时如果直接在其他文件里`exteran const GlobalVarType global_val;`引用到这个全局变量，编译器会报错变量未定义。

    解决方案是在给全局变量定义时，加上`extern`关键字。

    example:

    ```cpp
    extern const GlobalVar<string> global_var {
        "hello, world"
    };
    ```

    这样就可以在别的文件里，使用`extern const GlobalVar<string> global_var;`引用到这个变量了。