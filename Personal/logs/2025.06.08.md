* c++ 中 stringstream 处理多次转换

    example:

    ```cpp
    #include <sstream>
    #include <string>
    #include <stdio.h>
    #include <string.h>
    using namespace std;

    int main()
    {
        const char *int_str = "42";
        const char *flt_str = "3.1415926535";
        int int_val;
        float flt_val;

        // test 1
        stringstream ss;
        ss << int_str;
        ss >> int_val;
        printf("int val: %d\n", int_val);

        ss.clear();
        ss << flt_str;
        ss >> flt_val;
        printf("flt val: %f\n", flt_val);

        ss.clear();
        ss << 123;
        printf("str: %s\n", ss.str().c_str());

        // test 2
        printf("ss: %s\n", ss.str().c_str());
        ss.str("empty");
        printf("ss: %s\n", ss.str().c_str());

        // test 3
        stringstream ss_2;
        size_t cur_size = 0;
        char *buf_1m = (char*) malloc(1024 * 1024);  // 1 MB
        memset(buf_1m, ' ', 1024 * 1024);
        buf_1m[1024 * 1024 - 1] = '\0';
        while (cur_size < 512 * 1024 * 1024) {  // 512 MB
            ss_2 << buf_1m;
            if (ss_2.str().size() > cur_size) {
                cur_size = ss_2.str().size();
            } else {
                break;
            }
        }
        printf("cur size: %llu MB\n", cur_size / 1024 / 1024);

        return 0;
    }
    ```

    output:

    ```
    int val: 42
    flt val: 3.141593
    str: 423.1415926535123
    ss: 423.1415926535123
    ss: empty
    cur size: 512 MB
    ```

    其中 test 1 展示了先处理 int 型的字符串，再处理 float 型的字符串，在转换完 int 后，需要调用`ss.clear()`方法重置状态。

    test 2 的输出为`423.1415926535123`，说明调用`.clear()`后 stringstream 内部缓存的字符串并没有被真正清空，必须使用`.str("")`显式赋值，才能清空 stringstream 缓冲区的内容。

    test 3 探索的 stringstream 的缓冲区最大能有多大，是否有到了最大限制后自动清空缓冲的操作。目前测试下来，到了 512 MB 仍然能正常运行，猜测 buffer 大小可能是无限大的。这警示我们在使用同一个 stringstream 对象多次转换时，不仅要调用`c.lear()`，还需要关注 buffer 的大小，不然就可能无限制地增大，占满内存。

* stringstream 可以解析以空格`' '`, tab `'\t'`, 换行`'\n'`作为分隔符的字符串

    example:

    ```cpp
    #include <sstream>
    #include <string>
    #include <stdio.h>
    #include <string.h>
    using namespace std;

    int main()
    {
        // test 1
        int int_val;
        stringstream ss;
        ss << "3.14";
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        putchar('\n');

        // test 2
        ss.clear();
        ss.str("3,14");
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        putchar('\n');

        // test 3
        ss.clear();
        ss.str("3 14");
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        putchar('\n');

        // test 4
        ss.clear();
        ss.str("3\t14\t15");
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        putchar('\n');

        // test 5
        ss.clear();
        ss.str("3\n14");
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        putchar('\n');

        // test 6
        ss.clear();
        ss.str("3  14\t\t15\n\n\n926");
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        ss >> int_val;
        printf("int val: %d\n", int_val);
        putchar('\n');

        return 0;
    }
    ```

    output:

    ```
    int val: 3
    int val: 0
    int val: 0

    int val: 3
    int val: 0

    int val: 3
    int val: 14
    int val: 14

    int val: 3
    int val: 14
    int val: 15

    int val: 3
    int val: 14

    int val: 3
    int val: 14
    int val: 15
    int val: 926

    ```

    test 1 尝试将一个小数解析为整数，stringstream 只解析了整数部分，后续的解析都直接输出 0，看来是有解析错误。

    test 2 尝试使用逗号作分隔符，解析整数，可以看到逗号是无法识别的。

    test 3 使用空格作为分隔符，可以正常连续解析，当整数数量不够解析时，stringstream 总是输出最后一个正确解析的整数。

    test 4 用于测试`'\t'`，可以正常解析。

    test 5 用于测试`'\n'`，可以正常解析。

    test 6 用于测试多个空格，多个制表符，多个换行符分隔的整数，可以正常解析。

* 使用`partial_sum()`计算前缀和

    example:

    ```cpp
    #include <numeric>
    #include <vector>
    #include <stdio.h>
    using namespace std;

    int main()
    {
        int arr[] = {1, 2, 3, 4, 5};
        int res[5] = {0};
        partial_sum(arr, arr+5, res);
        for (int i = 0; i < 5; ++i)
            printf("%d, ", res[i]);
        putchar('\n');

        vector<int> vec{5, 4, 3, 2, 1};
        vector<int> presum(5, 0);
        partial_sum(vec.begin(), vec.end(), presum.begin());
        for (int i = 0; i < 5; ++i)
            printf("%d, ", presum[i]);
        putchar('\n');
        
        return 0;
    }
    ```

    output:

    ```
    1, 3, 6, 10, 15,
    5, 9, 12, 14, 15,
    ```

    `partial_sum()`在`<numeric>`头文件中。如果将迭代器的`begin()`和`end()`作为参数填进去，那么得到的就是标准的前缀和。

* 使用自定义处理函数的`partial_sum()`

    example:

    ```cpp
    #include <numeric>
    #include <functional>
    #include <vector>
    #include <stdio.h>
    using namespace std;

    int custom_sum(int a, int b)
    {
        return a + b + 1;
    }

    int main()
    {
        int arr[] = {1, 2, 3, 4, 5};
        int res[5] = {0};
        partial_sum(arr, arr+5, res, custom_sum);
        for (int i = 0; i < 5; ++i)
            printf("%d, ", res[i]);
        putchar('\n');

        partial_sum(arr, arr+5, res, multiplies<int>());
        for (int i = 0; i < 5; ++i)
            printf("%d, ", res[i]);
        putchar('\n');

        return 0;
    }
    ```

    output:

    ```
    1, 4, 8, 13, 19,
    1, 2, 6, 24, 120,
    ```

    其中，`multiplies`来自头文件`<functional>`。