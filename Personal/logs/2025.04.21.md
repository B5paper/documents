* cpp 中，使用自定义的`operator[]`可以实现使用`[]`取 const 元素的功能

    ```cpp
    #include <unordered_map>
    #include <string>
    #include <iostream>
    #include <initializer_list>
    using namespace std;

    struct MyStruct
    {
        MyStruct(const initializer_list<pair<const char*, const char*>> &init_list)
        {
            for (auto &entry : init_list)
            {
                m.emplace(entry.first, entry.second);
            }
        }

        const string& operator[](const string &key) const
        {
            return m.at(key);
        }

        unordered_map<string, string> m;
    };


    int main()
    {
        const MyStruct obj
        {
            {"hello", "val_1"},
            {"world", "val_2"}
        };

        string key = "hello";
        // const string &val = obj.m[key];  // compiling error
        const string &val = obj[key];
        cout << "key: " << key << ", val: " << val << endl;
        return 0;
    }
    ```

    output:

    ```
    key: hello, val: val_1
    ```

    需要在`const string& operator[](const string &key)`后面加上`const`，才能在`main()`中使用`obj[key]`的方式返回成员的 const 引用。

    说明：

    * 即使在`operator[]()`后加了`const`，标记这是一个 const 函数，依然无法使用`return m[key];`返回`const strung&`。

        翻看`unordered_map`源码可发现，`operator[]`的实现方式如下：

        ```cpp
        mapped_type&
        operator[](const key_type& __k)
        { return _M_h[__k]; }

        mapped_type&
        operator[](key_type&& __k)
        { return _M_h[std::move(__k)]; }
        ```

        可以看到并不是一个`const`函数，因此虽然函数返回的是`const Type&`，保证不会在函数外修改，但是有可能在`operator[]()`中对 const 成员进行修改，这是编译器不允许的。

        而源码中`at()`函数的实现如下：

        ```cpp
        mapped_type&
        at(const key_type& __k)
        { return _M_h.at(__k); }

        const mapped_type&
        at(const key_type& __k) const
        { return _M_h.at(__k); }
        ```

        当返回非 const 引用时，`at()`函数不是 const 的；当返回 const 引用时，`at()`函数是 const 的。这样就保证了无论外面是需要 const 引用，还是非 const 引用，`at()`都可以正常工作。

* cpp 中，对 string 进行`clear()`，会使其`size()`变为 0，但是`capacity()`不会改变。

    ```cpp
    #include <string>
    #include <iostream>
    using namespace std;

    int main()
    {
        string str{"hello, world"};
        cout << str.size() << endl;
        str.clear();
        cout << str << endl;
        cout << str.size() << endl;
        cout << str.capacity() << endl;
        return 0;
    }
    ```

    output:

    ```
    12

    0
    15
    ```

* vscode 中，使用`-exec p`打印字符串数组，会把`\000`也打印出来

    ```cpp
    #include <stdio.h>

    int main()
    {
        char str[16] = "hello";
        printf("%s\n", str);
        return 0;
    }
    ```

    在`return 0;`前下断点，在 vscode debug console 中调用`-exec p str`，输出如下：

    ```
    $1 = "hello\000\000\000\000\000\000\000\000\000\000"
    ```

    而正常的 terminal 中，`printf()`的输出如下：

    ```
    hello
    ```

* `string`会比较 string 中的全部字符，不止是有效字符

    ```cpp
    #include <string>
    #include <stdio.h>
    using namespace std;

    int main()
    {
        string str_1;
        str_1.resize(24, 0);
        sprintf(str_1.data(), "hello");

        string str_2;
        str_2.resize(16, 0);
        sprintf(str_2.data(), "hello");

        if (str_1 == str_2) {
            printf("str_1 == str_2\n");
        } else {
            printf("str_1 != str_2\n");
        }

        string str_3;
        str_3.resize(16, 0);
        sprintf(str_3.data(), "hello");
        str_3[str_3.size() - 1] = '1';

        if (str_2 == str_3) {
            printf("str_2 == str_3\n");
        } else {
            printf("str_2 != str_3\n");
        }

        return 0;
    }
    ```

    output:

    ```
    str_1 != str_2
    str_2 != str_3
    ```

    上面代码中，`str_1`和`str_2`的长度不同因此不相等，`str_2`与`str_3`虽然长度相同，并且有效字符也相同，但是存在非有效字符不同的情况，因此也不相等。

    使用`cout`输出三个字符串：

    ```cpp
    cout << str_1 << endl;
    cout << str_2 << endl;
    cout << str_3 << endl;
    ```

    output:

    ```
    hello
    hello
    hello1
    ```