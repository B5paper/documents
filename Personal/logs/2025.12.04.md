* 贴着 kdj 的交点买入，即使亏也不会亏太多

* 自定义哈希函数

    * 函数对象（仿函数）

        ```cpp
        struct MyHash {
            size_t operator()(const MyClass& obj) const {
                // 计算哈希值
                return ...;
            }
        };
        ```

        example:

        ```cpp
        #include <stdio.h>
        #include <string>
        #include <unordered_map>
        using std::string;
        using std::unordered_map;

        struct MyObj {
            string name;
            int age;

            // operator==() is necessary
            // these two const are both necessary
            bool operator==(const MyObj &obj_2) const {
                if (name == obj_2.name && age == obj_2.age) {
                    return true;
                }
                return false;
            }
        };

        struct MyHash {
            // these two const are both necessary
            size_t operator()(const MyObj &obj) const {
                return std::hash<int>()(obj.age) ^ std::hash<string>()(obj.name);
            }
        };

        int main() {
            unordered_map<MyObj, int, MyHash> my_map;
            MyObj obj{"zhangsan", 15};
            my_map.insert({obj, 1});
            my_map.insert({{"lisi", 18}, 2});
            auto iter = my_map.find({"lisi", 18});
            if (iter != my_map.end()) {
                printf("lisi exists, val: %d\n", iter->second);
            } else {
                printf("lisi doesn't exist, val: %d\n", iter->second);
            }
            return 0;
        }
        ```

        output:

        ```
        lisi exists, val: 2
        ```

    * 模板特化

        ```cpp
        namespace std {
            template<>
            struct hash<MyClass> {
                size_t operator()(const MyClass& obj) const {
                    // 计算哈希值
                    return ...;
                }
            };
        }
        ```

        这个比较神奇，我们竟然能动态拓展标准库。

        example:

        ```cpp
        #include <stdio.h>
        #include <string>
        #include <unordered_map>
        using std::string;
        using std::unordered_map;

        struct MyObj {
            string name;
            int age;

            bool operator==(const MyObj &obj_2) const {
                if (name == obj_2.name && age == obj_2.age) {
                    return true;
                }
                return false;
            }
        };

        namespace std {
        template<>
        struct hash<MyObj> {
            size_t operator()(const MyObj &obj) const {
                return std::hash<int>()(obj.age) ^ std::hash<string>()(obj.name);
            }
        };
        };

        int main() {
            unordered_map<MyObj, int> my_map;
            MyObj obj{"zhangsan", 15};
            my_map.insert({obj, 1});
            my_map.insert({{"lisi", 18}, 2});
            auto iter = my_map.find({"lisi", 18});
            if (iter != my_map.end()) {
                printf("lisi exists, val: %d\n", iter->second);
            } else {
                printf("lisi doesn't exist, val: %d\n", iter->second);
            }
            return 0;
        }

        ```



* 异或操作的特性：

    交换律：hash(a) ^ hash(b) = hash(b) ^ hash(a)

    自反性：a ^ a = 0

    这可能不是最佳组合方式，因为 (a,b) 和 (b,a) 会产生相同哈希值

    更好的方法：

    ```cpp
    struct VertexPtrHash {
        size_t operator()(const pair<Vertex*, Vertex*>& src_dst) const {
            // 使用旋转和组合减少碰撞
            size_t h1 = std::hash<void*>()(src_dst.first);
            size_t h2 = std::hash<void*>()(src_dst.second);
            return h1 ^ (h2 << 1) ^ (h2 >> (sizeof(size_t)*8 - 1));
        }
    };
    ```

    或者直接使用 boost 库：

    ```cpp
    struct VertexPtrHash {
        size_t operator()(const pair<Vertex*, Vertex*>& src_dst) const {
            size_t h1 = std::hash<void*>()(src_dst.first);
            size_t h2 = std::hash<void*>()(src_dst.second);
            // 使用 boost::hash_combine 类似的方法
            return h1 ^ (h2 + 0x9e3779b9 + (h1 << 6) + (h1 >> 2));
        }
    };
    ```

* `std::hash<void*>()(src_dst.first)`**不会**每次都创建一个对象，从而降低性能,编译器会对此进行大量优化.

    std::hash<void*> 通常是一个空类（无成员变量）, 构造空类的开销几乎为0, 编译器可以完全优化掉构造过程.

    如果使用局部变量，编译器也会优化：

    ```cpp
    struct VertexPtrHash {
        size_t operator()(const pair<Vertex*, Vertex*>& src_dst) const {
            std::hash<void*> hasher;  // 构造一次，使用两次
            return hasher(src_dst.first) ^ hasher(src_dst.second);
        }
    };
    ```

    或者使用静态对象？（如果编译器总是优化，那么静态也没什么性能提升吧？）：

    ```cpp
    struct VertexPtrHash {
        size_t operator()(const pair<Vertex*, Vertex*>& src_dst) const {
            static std::hash<void*> hasher;
            return hasher(src_dst.first) ^ hasher(src_dst.second);
        }
    };
    ```

    真正的优化应该关注哈希函数的质量（减少碰撞），而不是这种微小的构造开销。

* android connectbot 中，端口转发中断通常是因为省电策略

    后台程序的小锁是只代表不 kill，不代表不会 freeze。指定后台程序无省电策略限制，才是不会 freeze。

    一旦 freeze，ssh 的 tunnel 即关闭，必须重新连接 ssh 才能打开，但是 ssh session 本身不会退出，仍可正常发送命令。这样会造成迷惑。

* 使用 lambda 表达式作为自定义哈希函数

    example:

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <unordered_map>
    using std::string;
    using std::unordered_map;

    struct MyObj {
        string name;
        int age;

        bool operator==(const MyObj &obj_2) const {
            if (name == obj_2.name && age == obj_2.age) {
                return true;
            }
            return false;
        }
    };

    auto my_hasher = [](const MyObj& obj) {
        return std::hash<string>{}(obj.name) ^ std::hash<int>{}(obj.age);
    };

    int main() {
        // decltype(my_haser) and (0, my_haser) are necessary
        unordered_map<MyObj, int, decltype(my_hasher)> my_map(0, my_hasher);
        MyObj obj{"zhangsan", 15};
        my_map.insert({obj, 1});
        my_map.insert({{"lisi", 18}, 2});
        auto iter = my_map.find({"lisi", 18});
        if (iter != my_map.end()) {
            printf("lisi exists, val: %d\n", iter->second);
        } else {
            printf("lisi doesn't exist, val: %d\n", iter->second);
        }
        return 0;
    }
    ```

    output:

    ```
    lisi exists, val: 2
    ```

    注：

    1. `my_hasher`会被编译器转换成一个没有默认构造函数的仿函数实例

    1. unordered_map 第三个模板参数是类型模板参数，所以不能填`my_hasher`，只能用`decltype(my_hasher)`拿到其类型

    1. `my_map(0, my_hasher)`是必须的，因为`my_hasher`没有构造函数，所以 unordered_map 拿到类型后，无法构造出实例，必须由我们传递一个实例给它。

    1. 之所以写成`my_map(0, my_hasher)`而不是`my_map(my_hasher)`，是因为 int 值可能隐式转换为 hash 值，导致歧义

* git submodule

    将外部仓库作为子模块链接到主项目中，保持独立版本控制。

    usage:

    ```bash
    # 添加子模块
    git submodule add <repository-url> <path>

    # 克隆包含子模块的项目
    git clone <主项目仓库>
    git submodule init
    git submodule update

    # 或克隆时直接拉取子模块
    git clone --recursive <主项目仓库>

    # 更新子模块到指定提交
    cd <子模块目录>
    git pull origin main

    # 提交主项目中子模块的引用更新
    cd <主项目目录>
    git commit -am "更新子模块版本"
    ```

    特点

        独立仓库：子模块是独立的 Git 仓库

        指针引用：主项目只记录子模块的 commit hash

        需要显式初始化更新：克隆后需额外操作获取子模块内容

        分离的版本控制：子模块和主项目分别维护历史

* git subtree

    将外部仓库合并到主项目的子目录中，成为项目的一部分。

    usage:

    ```bash
    # 添加远程仓库
    git remote add <远程名> <repository-url>

    # 添加子树（将外部仓库合并到指定目录）
    git subtree add --prefix=<本地目录> <远程名或URL> <分支> --squash

    # 拉取更新
    git subtree pull --prefix=<目录> <远程名> <分支> --squash

    # 推送修改回子项目
    git subtree push --prefix=<目录> <远程名> <分支>
    ```

    特点

        代码合并：外部代码成为主项目的一部分

        单仓库管理：所有代码在一个仓库中，无需额外初始化

        操作复杂：更新和推送命令较长

        历史合并：可选择是否保留子项目完整历史

