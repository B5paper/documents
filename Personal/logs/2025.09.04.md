* 关于`rsync -r`

    `rsync -r`指递归处理目录，`rsync`默认不开启`-r`，也就是说默认只处理文件。

    `rsync <file_a> <dest_dir>`

    下面是几种情况分析：

    * `rsync /path/to/dir_a /path/to/dir_b`

        `dir_a`是一个目录，所以 rsync 直接跳过不处理。

    * `rsync -r /path/to/dir_a /path/to/dir_b`

        在`dir_b`里创建一个目录`dir_a`，并递归复制`dir_a`中的内容。

    * `rsync -r /path/to/dir_a/ /path/to/dir_b`

        将`dir_a`目录中所有内容复制到`dir_b`中。

    * `rsync /path/to/dir_a/* /path/to/dir_b`

        将`dir_a`中的所有文件复制到`dir_b`下，但是不复制`dir_a`下的目录。

        这个`*`其实是由 bash 展开的，再加上没有`-r`选项，所以展开后，本质上是`rsync <file_1> <file_2> <...> <dst_dir>`

    如果`/path/to/dir_a`是一个目录，那么`/path/to/dir_b`等价于`/path/to/dir_b/`，并且`dir_b`其必须是一个目录。如果是文件，则会报错。

    如果`/path/to/dir_a`是一个文件，那么`dir_b`可以是文件，也可以是目录。如果是文件，那么`dir_a`会覆盖`dir_b`，如果是目录，那么`dir_a`会被复制到目录下，如果`dir_b`中有同名文件，那么会被覆盖。

    `rsync -a`等价于`rsync -rptgo`，包含了`-r`的功能。

* `std::async`

    C++11 中的一个特性，用于异步地启动一个任务（函数或可调用对象），并返回一个 std::future 对象来获取该任务的最终结果。

    头文件：`<future>`

    当你调用 std::async 时，它会尝试（根据你指定的启动策略）在一个新的线程（或内部线程池）中执行你指定的函数.

    std::async 返回一个 std::future 对象。这个 future 对象像一个“提货单”，你可以在未来的某个时候（通常是需要结果的时候）调用它的 .get() 方法。此时：

    * 如果异步任务已经完成，立即得到结果。

    * 如果任务还未完成，当前线程会阻塞等待，直到任务完成并返回结果。

    这省去了手动管理线程、锁、条件变量等复杂同步机制的麻烦。

    可以通过参数控制 std::async 的行为，主要有两种策略（定义在 std::launch 中）：

    * std::launch::async：强制立即开始在一个新线程上异步执行任务。

    * std::launch::deferred：延迟执行。任务不会立即开始，而是等到你调用 future.get() 或 future.wait() 时，在调用者的线程上同步执行。

    * 如果不指定策略（默认行为），则由实现决定采用 async 还是 deferred，这给了编译器优化的空间，但可能导致不确定性。

    如果异步任务中抛出了异常，这个异常不会被丢失。当你调用 future.get() 时，这个异常会在主线程中被重新抛出。这使得异步任务中的错误处理可以和同步代码一样，使用 try/catch 块来完成。

    syntax:

    ```cpp
    // (1) 使用默认启动策略
    template< class Function, class... Args >
    std::future<std::invoke_result_t<std::decay_t<Function>, std::decay_t<Args>...>>
        async( Function&& f, Args&&... args );

    // (2) 指定启动策略
    template< class Function, class... Args >
    std::future<std::invoke_result_t<std::decay_t<Function>, std::decay_t<Args>...>>
        async( std::launch policy, Function&& f, Args&&... args );
    ```

    parameter:

    * `policy` (可选): 指定`std::launch`类型的 enum 值。`std::launch::async`表示强制异步执行，`std::launch::deferred`表示延迟执行。不指定时使用默认策略。

        通常不使用默认策略，因为无法准确估计延迟。

    * `f`: 要异步执行的可调用对象（函数、lambda表达式、函数对象、成员函数指针等）

    * `args...`: 传递给可调用对象的参数

    返回值

    * 返回一个 std::future 对象，其模板类型 R 是函数 f 的返回类型。

        例如：如果 f 返回 int，则返回`std::future<int>`

    example:

    ```cpp
    #include <iostream>
    #include <future>
    #include <chrono>
    #include <thread>

    int expensive_calculation(int x) {
        // 模拟一个耗时的计算
        std::this_thread::sleep_for(std::chrono::seconds(2));
        return x * x;
    }

    int main() {
        std::future<int> result_future = std::async(std::launch::async, expensive_calculation, 10);

        // 主线程可以继续做其他工作，不会被阻塞
        std::cout << "Doing some other work in the main thread...\n";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << "Other work done.\n";

        // 现在需要结果了，调用 get()。如果任务未完成，会在此阻塞等待。
        int result = result_future.get();
        std::cout << "The result is: " << result << std::endl; // 输出 100

        return 0;
    }
    ```

    output:

    ```
    Doing some other work in the main thread...
    Other work done.
    The result is: 100
    ```

    如果要异步调用类的成员函数，需要这样使用：

    ```cpp
    class MyClass {
    public:
        int member_func(int x) {
            return x * 2;
        }
    };

    int main() {
        MyClass obj;
        
        // 调用成员函数，第一个参数是对象指针或引用，后面是成员函数的参数
        auto fut = std::async(&MyClass::member_func, &obj, 42);
        
        std::cout << fut.get() << std::endl; // 输出 84
        
        return 0;
    }
    ```

    * `std::launch::async`：确实会立即创建新线程（或使用线程池）

    * `std::launch::deferred`：不会创建线程，任务延迟到 .get() 时在当前线程同步执行 

* `init_llist_head()`

    init_llist_head() 用于无锁单向链表。初始化一个 struct llist_head 节点，将其 first 指针设置为 NULL，表示一个空的单向链表。

* `/proc/ioports`

    列出当前系统中所有设备已注册（申请）的 I/O 端口地址范围。

    在 x86 体系架构中，CPU 与外部设备（如网卡、磁盘控制器、键盘、串口等）进行通信的一种主要方式是通过I/O 端口。CPU 通过 in 和 out 汇编指令来从端口读取数据或向端口写入数据，从而控制硬件。

    查看：`sudo cat /proc/ioports`

    output:

    ```
    0000-0cf7 : PCI Bus 0000:00
      0000-001f : dma1
      0020-0021 : pic1
      0040-0043 : timer0
      0050-0053 : timer1
      0060-0060 : keyboard
      0064-0064 : keyboard
      0070-0071 : rtc_cmos
        0070-0071 : rtc0
      0080-008f : dma page reg
      00a0-00a1 : pic2
    ...
    ```

    注：

    1. 必须要用`sudo`，否则显示出来的地址全是 0

* `$(MAKE)`与`make`的区别

    只使用`make`的问题：

    * 不可移植：不同的系统可能使用不同的 make 程序名称。例如，BSD 系统通常使用 bmake，而 GNU Make 可能被安装为 gmake。如果你的 Makefile 里写死了 make，在这些系统上就会执行失败。

    * 忽略命令行选项：当你使用一些命令行选项（如 -k, -s, -t）调用顶层的 make 时，在递归调用中直接使用 make 会丢失这些选项。子 make 进程不会继承父进程的 flags，导致行为不一致。

    * 无法传递 -j (并行编译) 选项：这是最致命的问题之一。如果你使用 make -j8 启动并行编译，但在 Makefile 内部递归调用时使用的是 make，那么这个子 make 将会是串行执行的（-j1），无法利用多核优势，严重拖慢编译速度。

    MAKE 是一个 Makefile 内置的宏（变量），它的值就是当前正在执行的 make 程序的完整路径名（例如 /usr/bin/make）。并且可以解决上面列出的问题。

    （如何验证`$(MAKE)`可以继承命令行选项？）

* `strdup()`

    动态复制一个字符串。(C23 标准库)

    syntax:

    ```cpp
    #include <string.h>

    char *strdup(const char *str);
    ```

    返回值：

    * 成功：返回指向新字符串副本的指针。

    * 失败（如内存分配失败）：返回 NULL。

    使用`strdup()`后，必须手动释放内存。