* vector 扩容导致指针失效一例

    ```cpp
    #include <vector>
    #include <stdio.h>
    using namespace std;

    //    1
    //  2   3
    // 4 5 6 7

    struct Node_1 {
        int val;
        vector<Node_1> left_right;
    };

    void test_1() {
        Node_1 root_node;
        vector<Node_1*> node_records;
        root_node.val = 0;
        node_records.push_back(&root_node);

        // left node
        root_node.left_right.emplace_back();
        Node_1 *left_ptr = &root_node.left_right.back();
        left_ptr->val = 1;
        node_records.push_back(left_ptr);

        // right node
        root_node.left_right.emplace_back();
        Node_1 *right_ptr = &root_node.left_right.back();
        right_ptr->val = 2;
        node_records.push_back(right_ptr);

        printf("node: ");
        for (Node_1 * node_ptr : node_records) {
            printf("%d, ", node_ptr->val);
        }
        putchar('\n');
    }

    struct Node_2 {
        int val;
        vector<Node_2*> left_right;

        ~Node_2() {
            for (Node_2 *node_ptr : left_right) {
                delete node_ptr;
            }
        }
    };

    void test_2() {
        Node_2 root_node;
        vector<Node_2*> node_records;

        root_node.val = 0;
        node_records.push_back(&root_node);

        // left node
        root_node.left_right.push_back(new Node_2);
        Node_2 *left_ptr = root_node.left_right.back();
        left_ptr->val = 1;
        node_records.push_back(left_ptr);

        // right node
        root_node.left_right.push_back(new Node_2);
        Node_2 *right_ptr = root_node.left_right.back();
        right_ptr->val = 2;
        node_records.push_back(right_ptr);

        printf("node: ");
        for (Node_2 * node_ptr : node_records) {
            printf("%d, ", node_ptr->val);
        }
        putchar('\n');
    }

    int main() {
        printf("test 1:\n");
        test_1();
        printf("test 2:\n");
        test_2();
        return 0;
    }
    ```

    output:

    ```
    test 1:
    node: 0, -2113935744, 2, 
    test 2:
    node: 0, 1, 2, 
    ```

    `test_1()`使用 Node_1 中的 vector 存储树叶子节点的实体而不是指针，导致在 vector 扩容时元素的地址改变，如果这个时候外部也需要临时地存储一下各个节点的指针，那么就会出错。可以看到 test 1 输出的 val 值，第 2 个明显是错的。

    `test_2()`使用 Node_2 中的 vecotr 存储叶子节点的指针，不存在上述问题。唯一需要注意的地方就是`Node_2`需要写析构函数释放内存。

    在`test_1()`中，`node_records`是否可以不存储指针而去存储 idx？不可以，因为`Node_1`是树状结构，不是扁平一维数组结构。

* const 全局变量不会有冲突

    `src_1.cpp`:

    ```cpp
    int global_val = 123;
    ```

    `src_2.cpp`:

    ```cpp
    #include <stdio.h>

    int global_val = 456;

    int main() {
        printf("global val: %d\n", global_val);
        return 0;
    }
    ```

    compile:

    `g++ src_1.cpp src_2.cpp -o main`

    compiling output:

    ```
    /usr/bin/ld: /tmp/ccAXjHwL.o:(.data+0x0): multiple definition of `global_val'; /tmp/ccozWBXZ.o:(.data+0x0): first defined here
    collect2: error: ld returned 1 exit status
    ```

    可以看到，如果不同的实现文件里有相同名称的全局变量，那么会编译时报错。

    如果全局变量是 const 的，那么不会有这个问题。

    `src_1.cpp`:

    ```cpp
    const int global_val = 123;
    ```

    `src_2.cpp`:

    ```cpp
    #include <stdio.h>

    int global_val = 456;

    int main() {
        printf("global val: %d\n", global_val);
        return 0;
    }
    ```

    compile:

    `g++ src_1.cpp src_2.cpp -o main`

    run:

    `./main`

    output:

    ```
    global val: 456
    ```

    这是因为 const 全局变量都会被自动添加`private`属性。

* 在`struct`中，`add_elm()`成员函数应该返回引用还是返回指针？

    ```cpp
    #include <vector>
    using namespace std;

    struct MyElm {
        int val;
    };

    struct MyStruc {
        vector<MyElm*> elms;

        MyElm& add_elm_1() {
            elms.push_back(new MyElm);
            return *elms.back();
        }

        MyElm* add_elm_2() {
            elms.push_back(new MyElm);
            return elms.back();
        }

        ~MyStruc() {
            for (MyElm *elm : elms) {
                delete elm;
            }
        }
    };

    int main() {
        MyStruc struc;

        for (int i = 0; i < 3; ++i) {
            MyElm &elm = struc.add_elm_1();  // ok
            elm.val = i;
        }

        MyElm &elm_1 = struc.add_elm_1();
        elm_1.val = 3;
        // MyElm &elm_1 = struc.add_elm_1();  // error

        MyElm *elm_ptr = nullptr;
        elm_ptr = struc.add_elm_2();
        elm_ptr->val = 4;
        elm_ptr = struc.add_elm_2();  // ok
        elm_ptr->val = 5;

        return 0;
    }
    ```

    如果在循环中，那么反复对引用赋值是可以的。如果在循环外，无法用新引用的定义覆盖旧引用。但是指针没这个问题。整体看来，指针更灵活一些。

* IFS 与 read

    `IFS`指的是 Internal Field Separator，可以决定`read`是否过滤用户输入的前缀、后缀空格。

    ```bash
    read -p "input something: " msg
    echo "$msg"

    IFS= read -p "input something: " msg
    echo "$msg"
    ```

    交互输入与输出：

    ```
    input something:     hello world
    hello world
    input something:     hello world
        hello world
    ```

    其中，`IFS= read -p "input something: " msg`等价于`IFS="" read -p "input something: " msg`，或`IFS='' read -p "input something: " msg`，即为空。

    `IFS`的默认值为`IFS=" \t\n"`（空格，制表，换行）。

    `echo "$msg"`是为了将`msg`内容解释为一个字符串。假如`msg`值为`    hello`，那么`echo $msg`就变成`echo     hello`，输出为`hello`。而`echo "$msg"`则为`echo "    hello"`，输出为`    hello`。

    `IFS= read`仅作用于当前命令`read`，当`read`执行完后，`IFS`又恢复默认值。

* bash 中输入密码显示为星号（`*`）的模板代码

    ```bash
    stty -echo  # 关闭回显
    unset password
    prompt="Enter password: "
    while IFS= read -p "$prompt" -r -s -n1 char; do
        if [[ $char == $'\0' ]]; then  # 回车键结束
            break
        fi
        prompt='*'
        password+="$char"
    done
    stty echo  # 恢复回显
    echo
    echo "Password: [hidden]"
    ```

    效果：

    ```
    Enter password: **********
    Password: [hidden]
    ```

* `memmem()`

    用于在一段内存中搜索指定内容的位置。

    syntax:

    ```c
    #include <string.h>

    void *memmem(const void *haystack, size_t haystacklen,
                 const void *needle, size_t needlelen);
    ```

    example:

    ```cpp
    #include <string.h>
    #include <stdio.h>

    int main() {
        char buf[128] = {'n', 'i', '\0', 'h', 'a', 'o', '\0', 1, 2, 3};
        char sub[3] = {'o', '\0', 1};
        char *pos = (char*) memmem(buf, 128, sub, 3);
        for (int i = 0; i < 3; ++i) {
            printf("%d, ", *(pos+i));
        }
        putchar('\n');
        return 0;
    }
    ```

    output:

    ```
    111, 0, 1,
    ```

* `std::visit`

    `std::visit`可以根据当前存储的实际类型，动态调用对应的处理逻辑。

    example:

    ```cpp
    #include <variant>
    #include <iostream>
    #include <string>

    int main() {
        std::variant<int, float, std::string> v = "Hello";

        // 定义一个访问器（可以是 lambda、函数对象或普通函数）
        auto visitor = [](auto&& arg) {
            std::cout << arg << std::endl;
        };

        std::visit(visitor, v); // 输出：Hello
    }
    ```

    output:

    ```
    Hello
    ```

    * `visitor`是一个泛型 lambda，可以处理 variant 的所有可能类型。

    * `std::visit`自动检测`v`当前存储的类型，并调用对应的逻辑。

* `open()`的文件覆盖问题

    使用 `open()`函数创建新文件时，在旧文件存在的情况下，如果 flag 中仅有`O_CREAT`，那么不会覆盖旧文件，直接打开现有文件。如果 flag 为`O_CREAT | O_EXCL`，则打开失败，如果文件不存在，则创建新文件。如果 flag 为`O_CREAT | O_TRUNC`，则会覆盖旧文件。

    总结：

    * 默认不覆盖：仅用`O_CREAT`会保留旧文件内容。

    * 禁止覆盖：`O_EXCL`确保文件不存在时才创建。

    * 显式覆盖：`O_TRUNC`强制清空旧文件。

* mmio

    mmio - Memory-Mapped I/O, 内存映射 I/O

    可能有用的资料集合：

    * ioremap 映射地址

        ```c
        #include <linux/io.h>

        void __iomem *mmio_base;

        // 映射物理地址到内核虚拟地址
        mmio_base = ioremap(phys_addr, size);
        if (!mmio_base) {
            pr_err("Failed to ioremap MMIO region\n");
            return -ENOMEM;
        }
        ```

        phys_addr：设备的物理基地址。

        size：要映射的区域大小（字节）。

        __iomem：标记指针指向的是 MMIO 空间（避免直接访问）。

    * 读写 MMIO 寄存器

        ```c
        #include <linux/io.h>

        // 读取 32 位寄存器
        u32 val = readl(mmio_base + offset);

        // 写入 32 位寄存器
        writel(new_val, mmio_base + offset);
        ```

        位宽	读操作	写操作
        8-bit	readb()	writeb()
        16-bit	readw()	writew()
        32-bit	readl()	writel()
        64-bit	readq()	writeq()

    * 解除映射

        ```c
        iounmap(mmio_base);
        ```

    * example

        ```c
        #include <linux/module.h>
        #include <linux/pci.h>
        #include <linux/io.h>

        void __iomem *mmio_base;

        static int my_pci_probe(struct pci_dev *dev, const struct pci_device_id *id) {
            // 获取 BAR0 的物理地址和长度
            phys_addr_t bar0_phys = pci_resource_start(dev, 0);
            size_t bar0_size = pci_resource_len(dev, 0);

            // 映射 MMIO
            mmio_base = ioremap(bar0_phys, bar0_size);
            if (!mmio_base) {
                pr_err("Failed to ioremap BAR0\n");
                return -ENOMEM;
            }

            // 示例：读取第一个寄存器
            u32 reg_val = readl(mmio_base);
            pr_info("MMIO Register 0: 0x%08X\n", reg_val);

            return 0;
        }

        static void my_pci_remove(struct pci_dev *dev) {
            if (mmio_base) {
                iounmap(mmio_base);
            }
        }

        static struct pci_driver my_pci_driver = {
            .name = "my_pci_driver",
            .id_table = my_pci_ids,  // 需定义 PCI 设备 ID 表
            .probe = my_pci_probe,
            .remove = my_pci_remove,
        };

        module_pci_driver(my_pci_driver);
        ```

    * 如果寄存器访问需要严格顺序，使用 rmb() / wmb() / mb() 或 readl_relaxed() / writel_relaxed()（无屏障版本）

* qemu 虚拟机将内部的 22 端口映射到外部的 2222 端口

    `qemu-system-x86_64 -accel kvm -m 8192 -smp 8 -hda ./ccc.qcow2 -netdev user,id=mynet0,hostfwd=tcp::2222-:22 -device virtio-net-pci,netdev=mynet0`

* qemu edu: `-device edu`

* factorial n. 阶乘

* vim 取消行号的方法

    `:set nonu`

    `:set nu!`