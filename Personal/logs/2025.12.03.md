* 实盘经验

    * 煤炭股票和焦煤期货有一定关系，但是并不完全相关，因为煤炭公司不只有焦煤，还有动力煤

* systemd 与 ssh tunnel

    systemd 中启动 ssh tunnel 时，不要使用`ssh -f`，因为这会

    1. 创建一个 ssh 的前台程序，执行登陆认证等操作，假设其 pid 为 PID_1

    2. 成功登录后，fork 一份进程到后台，此时后台进程的 pid 为 PID_2

    3. 退出 PID_1 的 ssh 前台进程

    systemd 检测到 PID_1 退出，会认为 ssh 进程已经结束，从而导致 systemd 错误判断 service 的状态。

    因此我们直接使用`ssh -NL`或`ssh -NR`就可以。

    example:

    ```conf
    [Unit]
    Description=SSH Reverse Tunnel
    After=network.target

    [Service]
    Type=simple
    User=your_username
    # 使用密钥认证，避免交互
    ExecStart=/usr/bin/ssh -o ExitOnForwardFailure=yes -o ServerAliveInterval=30 -o ServerAliveCountMax=3 -N -R 12345:localhost:22 user@remote-server
    Restart=always
    RestartSec=10
    # 密钥权限很重要
    Environment="HOME=/home/your_username"

    [Install]
    WantedBy=multi-user.target
    ```

    ```bash
    # 添加这些选项提高稳定性
    -o ExitOnForwardFailure=yes    # 端口转发失败时退出
    -o ServerAliveInterval=30      # 30秒发送一次保活包
    -o ServerAliveCountMax=3       # 3次无响应后断开
    -o TCPKeepAlive=yes
    -o BatchMode=yes               # 禁用交互提示
    ```

* systemd 的 alternative

    1. 类 Systemd 的现代初始化系统
    OpenRC (Gentoo, Alpine Linux 默认)

        特点：模块化、依赖驱动、兼容传统 init 脚本

        优势：相对轻量，学习曲线平缓

        使用发行版：Gentoo, Alpine Linux, Artix Linux

    runit (Void Linux 默认)

        特点：简单直接，基于监督树（supervision tree）

        设计哲学：保持简单，只做进程监控

        组件：runsvdir, runsv, sv 命令

    s6 和 s6-rc

        特点：Unix 哲学，组件化设计

        优势：非常灵活，可组合性强

        作者：Laurent Bercot

    Dinit

        特点：C++ 编写，配置简单

        目标：提供 systemd-like 功能但更简单

    2. 传统 SysV init

        ```bash
        # 经典的系统V风格
        /etc/rc.d/
        /etc/init.d/
        ```

        特点：简单脚本，顺序启动

        仍在维护：Slackware, Devuan (可选)

    3. 基于监督的初始化系统
    supervisord (Python)

        特点：专注于进程管理而非系统初始化

        场景：常用于容器或特定服务管理

    daemontools / DJB's supervise

        特点：最早的监督式 init 系统之一

        设计者：Daniel J. Bernstein

    4. 针对特定场景的替代
    BusyBox init

        特点：嵌入式系统的极简方案

        场景：资源受限环境，小型 Linux 发行版

    minit (CRUX 使用)

        特点：极简设计

        配置：简单的纯文本文件

    5. 容器/云原生环境
    不用 init 系统

        容器直接运行应用进程

        使用 tini 或 dumb-init 处理信号

    systemd 轻量模式

        systemd 本身也有轻量版本

    各替代方案比较
    名称	学习曲线	复杂性	资源占用	主要优势
    OpenRC	中等	中等	低	平衡性最好，兼容性好
    runit	简单	低	极低	简单可靠，启动快
    s6	较陡	高	低	极其灵活和强大
    Dinit	简单	低	低	现代但简单
    SysV init	简单	低	极低	极其简单
    选择建议
    推荐 OpenRC 如果你：

        想要现代化功能但避免 systemd 复杂性

        需要良好的软件包支持

        来自 systemd 背景，想平滑过渡

    推荐 runit 如果你：

        追求极简主义

        在容器或嵌入式环境

        喜欢 "do one thing well" 哲学

    推荐 s6 如果你：

        是高级用户，需要最大灵活性

        不介意手工配置

        构建定制系统

    发行版支持情况

        完全避免 systemd 的发行版：

            Devuan (Debian 衍生)

            Artix Linux (Arch 衍生)

            Void Linux (runit 默认)

            Alpine Linux (OpenRC 默认)

            Gentoo (OpenRC 默认)

        提供选择的发行版：

            Slackware (传统 SysV)

            CRUX (minit)

* 使用 bash 启动程序时，单行环境变量要写在脚本前面

    `run.sh`:

    ```bash
    ./$1
    ```

    ```bash
    LD_LIBRARY_PATH=xxx bash run.sh main  # OK

    bash LD_LIBRARY_PATH=xxx run.sh main  # error

    bash run.sh LD_LIBRARY_PATH=xxx main  # error
    ```

    环境变量 LD_LIBRARY_PATH 会传递给 bash 进程，然后在 bash 中执行的脚本（run_main.sh）及其子进程（包括 ./main）都会继承这个变量。

    其他传递环境变量的方法：

    * 使用 export

        ```bash
        export LD_LIBRARY_PATH=/path/to/libs
        bash run_main.sh
        ```

* 东芝新小黑 A3

    东芝（现为铠侠KIOXIA）推出的 Canvio Basics A3 系列便携式移动硬盘。

    通常提供 1TB、2TB、4TB 等主流容量版本。

    接口类型：USB 3.2 Gen 1（通常标记为 USB 3.0/3.1 Gen 1），向下兼容 USB 2.0。

    接口形状：标准 USB Type-A 接口。硬盘端为Micro-B接口（即常见的梯形口）。

    读写速度：由于内部是机械硬盘（HDD），速度受限于硬盘转速。典型速度约为：

        读取速度：约 100 - 140 MB/s

        写入速度：约 100 - 130 MB/s

        注意：此为大文件连续读写的理想值，实际传输大量小文件或通过USB 2.0接口连接时会慢很多。

    硬盘类型：2.5英寸 SATA 机械硬盘（HDD）。

    转速：通常是 5400 RPM

    缓存：一般为 8MB - 128MB

    随盘软件：通常不附带备份或加密软件，主打纯硬件、高性价比。

    供电方式：完全通过 USB接口总线供电，无需外接电源适配器。

* 西部数据 WD My Passport (WDBS4B0020)

    在存储基础上增加了数据安全和软件功能。

    WD自产5400转 SATA HDD，可能采用SMR技术（对顺序写入有影响）。

    自带256位AES硬件加密和WD Backup/Discovery软件。

    西部数据的部分My Passport型号（尤其是大容量版本）可能使用 SMR 叠瓦式磁记录技术。在长时间、持续写入大量数据（如备份数百GB文件） 时，速度可能会出现明显下降。而东芝A3通常采用 CMR 传统磁记录（具体需查询型号批次），持续写入更稳定。

    硬件加密：内置 256位AES硬件加密。首次使用时，通过WD Security软件设置密码。此后，不输入密码无法访问硬盘数据，即使硬盘被取出装入其他电脑。这对数据安全非常重要。

    备份软件：自带WD Backup软件，可设置定期自动备份到硬盘。

    工具箱软件：提供硬盘状态监控、诊断等功能。

    在相同容量下，东芝A3的价格通常比WD My Passport低 10%-20%。你为My Passport多付的钱，主要购买了其加密功能和软件套件。

* 如果你觉得 fail2ban 太复杂，可以考虑：

    CrowdSec：更现代、配置更简单的替代品

    firewalld 动态规则：对于简单场景可能够用

    自定义脚本：用简单脚本+iptables/ufw 实现基础防护

* 使用 lastb 命令查看最近的失败登录尝试

* 使用 fail2ban 或 denyhosts 自动封禁多次失败的IP。

* 设置日志监控（如使用 logwatch 或 auditd），对异常登录尝试发出告警。

* vim 模式

    按 v 进入普通可视模式

    按 V 进入行可视模式

    按 Ctrl+V 进入块可视模式

    ```vim
    " 在 .vimrc 中修改可视模式颜色
    highlight Visual cterm=reverse ctermbg=NONE
    ```

    ```vim
    " 临时禁用高亮
    :nohlsearch
    ```

    ```vim
    " 禁用鼠标选择自动进入可视模式
    set mouse-=a
    " 或只禁用部分鼠标功能
    " set mouse=nvi  " n:普通模式, v:可视模式, i:插入模式

    " 鼠标释放后自动退出可视模式
    autocmd CursorMoved * if mode() =~ '^[vV]' | silent! execute "normal! \e" | endif
    ```

    ```vim
    " 按 Ctrl+L 清除高亮
    nnoremap <C-l> :nohlsearch<CR>:call clearmatches()<CR>
    ```

* proxychains

    Proxychains 是一个强制应用程序通过代理服务器进行网络连接的工具，主要用于：

    * 代理链：支持多级代理跳转，增强匿名性

    * 协议支持：支持 HTTP、SOCKS4、SOCKS5 代理

    * 透明代理：无需修改应用程序代码即可使其通过代理工作

    * 绕过限制：帮助受限环境中的工具（如 nmap、wget、ssh）通过代理访问外部网络

    安装：

    `sudo apt install proxychains4`

    配置文件通常位于：

    * `/etc/proxychains.conf`

    * `/etc/proxychains4.conf`

    * `~/.proxychains/proxychains.conf`

    config example:

    ```conf
    # 代理类型 (http/socks4/socks5)
    [ProxyList]
    socks5 127.0.0.1 1080
    http 192.168.1.100 8080
    socks4 10.0.0.1 9050

    # 代理链模式
    # dynamic_chain: 按顺序使用代理，失败的代理会跳过
    # strict_chain: 严格按顺序使用所有代理
    # random_chain: 随机顺序使用代理
    ```

    usage:

    ```bash
    # 基本语法
    proxychains [命令] [参数]

    # 示例
    proxychains curl https://example.com
    proxychains nmap -sT target.com
    proxychains wget http://example.com/file.zip
    proxychains git clone https://github.com/user/repo.git
    # 通过代理进行端口扫描
    proxychains nmap -sS -Pn target.com
    ```

    options:

    ```bash
    proxychains -f /path/to/custom.conf firefox    # 使用自定义配置文件
    proxychains -q nmap target.com                 # 安静模式（不显示代理信息）
    ```

    注意事项

        DNS 解析：

            默认可能泄露 DNS 请求

            可在配置中启用 proxy_dns 选项

        程序兼容性：

            某些静态链接的程序可能无法正常工作

            GUI 程序可能需要额外配置

        性能影响：

            多级代理会降低网络速度

    验证代理生效:

    ```bash
    # 检查公网 IP 是否改变
    proxychains curl ifconfig.me
    proxychains wget -qO- https://api.ipify.org
    ```

* 多级代理

    多级代理跳转是指数据包通过多个代理服务器依次转发，形成一条代理链（Proxy Chain）。每个代理只知道它的前一个节点和后一个节点，不知道完整路径。

    原理：

    以 socks 代理为例，socks 协议支持发送两种包，一种是控制包，用于建立连接，另一种是数据包。多级代理的实现细节如下：

    socks 的 CONNECT 命令中，有一段数据如下：

    ```
    +----+-----+-------+------+----------+----------+
    |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
    +----+-----+-------+------+----------+----------+
    | 1  |  1  | X'00' |  1   | Variable |    2     |
    +----+-----+-------+------+----------+----------+
    ```

    此即控制包，其中 `DST.ADDR` 和 `DST.PORT` 可以是任意目标，包括另一个代理服务器！

    1. 客户端向代理 1 发送 socks 控制包

        ```
        [客户端端口] -> [代理1:1080]
        数据包内容:
            SOCKS5版本: 0x05
            认证方法数: 0x01  
            认证方法: 0x00 (无认证)
            命令: 0x01 (CONNECT)
            保留: 0x00
            地址类型: 0x01 (IPv4)
            目标地址: 代理2的IP
            目标端口: 1080
        ```

    2. 代理 1 向客户端发送 socks ack 包

        ```
        [代理1:1080] -> [客户端端口]
            SOCKS5版本: 0x05
            回复: 0x00 (成功)
            保留: 0x00
            地址类型: 0x01
            绑定地址: 代理1的IP
            绑定端口: 新分配的端口
        ```

        此时客户端和代理 1 建立起一个 socket 连接，客户端以后从这个 socket 发数据，都是直接发 payload （实际发出的信息可能会经过加密），不再有任何代理相关的信息。

    3. 客户端向代理 2 发送 socks connect 包

    4. 此时代理 1 看到数据包是个控制包，读取其中的 DST IP （代理 2）及 DST PORT，建立一个 TCP 连接，然后告诉客户端此包已成功处理

        此时整个代理的结构如下：

        ```
        客户端:12345 → 代理1:1081（进程）
                          ↓ (进程内socket对)
                   → 代理1:12346 → 代理2:1082
        ```

    5. 按照上面的步骤建立代理 2 -> 代理 3 的 socks 连接

        此时客户端已经完成客户端 -> 代理 1 -> 代理 2 -> 代理 3 的建链，从此客户端发送的数据不再包含 socks connect header，而是只有 payload 信息，比如 http 包，或 tcp 包

    6. 客户端直接在与代理 1 连接的 socket 中发送 http payload (假设要访问 baidu.com)

    7. payload 传递到代理 3 处，代理 3 向 baidu.com 的 443 端口建立 TCP 连接

        代理 3 读取代理 2 发过来的请求：`SOCKS5 CONNECT example.com:443`，建立起最后一个 TCP 连接。

        至此，整个代理链路完成，客户端与网站间都是只考虑传输 payload 就可以，中间的所有代理过程都是透明的。

    整个代理过程中，存在两种建立TCP连接的方式，一种是读取SOCKS CONNECT控制报文，另一种是payload的HTTP或者TCP报文。

    在所有的代理连接建立初期，上游必须给下游发送 socks connect 控制报文，告诉下游上游所充当的角色，之后上游的角色不再更改。因此整个角色的确立过程是静态的，不能在传输途中动态改变。这样可以使后续的所有传输都是纯 payload，提高传输效率。

* 代理协议：

    Proxy Protocol：传递原始客户端信息

    HTTP/2 CONNECT：更高效的隧道协议

    QUIC over Proxy：基于UDP的多路复用

    混淆技术：

        TLS包装代理流量

        流量整形避免特征识别

        随机填充数据包

* Proxychains vs Proxychains4 (Proxychains-NG)

    ```
    原始proxychains (2002-2010)
            ↓ (停止维护)
        分支/重写
            ↓
    proxychains-ng (2012-现在)
            ↓
      发行版中的包名：
      - Ubuntu/Debian: proxychains4
      - Arch: proxychains-ng
      - 源代码: 仍叫proxychains-ng
    ```

    对比
    特性	Proxychains (原始/旧版)	Proxychains4 (proxychains-ng)
    维护状态	已停止维护（最后版本2006）	活跃维护（2024年仍在更新）
    项目名称	proxychains	proxychains-ng (Next Generation)
    包名差异	proxychains	proxychains4（二进制名）
    配置文件	/etc/proxychains.conf	/etc/proxychains4.conf
    许可证	GPLv2	GPLv2
    主要开发者	netcreature	rofl0r

    Proxychains-NG的新功能/改进：

    # 1. 更好的DNS处理
    proxychains-ng支持：
    - proxy_dns (通过代理解析DNS)
    - 防止DNS泄露的改进实现
    - 更好的IPv6支持

    # 2. 增强的代理链类型
    proxychains4新增：
    - random_chain (随机代理链)
    - dynamic_chain (动态跳过失效代理)
    - strict_chain (严格链，原始版本也有)

    # 3. 性能优化
    proxychains-ng有：
    - 更快的LD_PRELOAD注入
    - 减少内存占用
    - 更好的多线程支持

    # 4. 兼容性改进
    - 支持更多应用程序
    - 更好的系统调用拦截
    - 修复原始版本的许多bug

    大多数Linux发行版默认安装NG版本：

    ```bash
    # Ubuntu 20.04+
    sudo apt install proxychains4  # 明确安装NG版本

    # 或者
    sudo apt install proxychains   # 可能也是NG，但重命名了

    # Arch Linux
    sudo pacman -S proxychains-ng  # 保持原名
    ```
