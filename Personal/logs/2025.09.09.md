* `ioremap()`与`pci_iomap()`的区别

    ```c
    #include <asm/io.h>

    void __iomem *ioremap(phys_addr_t offset, unsigned long size);
    void iounmap(volatile void __iomem *addr);


    #include <linux/pci.h>

    void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen);
    void pci_iounmap(struct pci_dev *dev, void __iomem *addr);
    ```

    `ioremap()`更底层，更通用。我们给定一个物理地址和大小，它请求内核在页表中建立映射，并返回一个可用的内核虚拟地址。它不关心这个物理地址来自哪里（可以是系统内存、设备内存、甚至是ISA总线上的端口）。

    `pci_iomap()`更高层、PCI 专用。它构建在`ioremap()`或其他类似机制之上，专门用于映射 PCI 设备 BAR（Base Address Register）中声明的内存区域。

    如果使用`ioremap()`，那么需要驱动程序开发者自己获取要映射的物理地址。对于 PCI 设备，需要先调用`pci_resource_start(pdev, bar)`来获取 BAR 对应的物理地址。

    `pci_iomap()`相当于帮你调用了`pci_resource_start()`, `pci_resource_len()`, `ioremap()`。

* `ioread32()`, `iowrite32()`

    用于安全、可移植地访问内存映射 I/O (MMIO) 寄存器.

    syntax:

    ```c
    #include <asm/io.h>

    void iowrite8(u8 value, volatile void __iomem *addr);
    void iowrite16(u16 value, volatile void __iomem *addr);
    void iowrite32(u32 value, volatile void __iomem *addr);
    #ifdef CONFIG_64BIT
    void iowrite64(u64 value, volatile void __iomem *addr);
    #endif
    ```

    参数:

    * `value`: 要写入的数据值。类型分别为`u8`, `u16`, `u32`, `u64`（无符号8/16/32/64位整数）。

    * `addr`: 目标内存映射I/O地址。这是一个指向`__iomem`空间的指针，通常由`ioremap()`, `pci_iomap()`等函数返回。`volatile`关键字告知编译器该地址的内容可能会被硬件意外修改，防止编译器进行激进的优化。

    ```c
    #include <asm/io.h>

    u8 ioread8(const volatile void __iomem *addr);
    u16 ioread16(const volatile void __iomem *addr);
    u32 ioread32(const volatile void __iomem *addr);
    #ifdef CONFIG_64BIT
    u64 ioread64(const volatile void __iomem *addr);
    #endif
    ```

    `addr`: 要读取的源内存映射I/O地址。同样是一个带有 __iomem 和 volatile 修饰符的指针。const 表明函数不会修改指针所指向的内容。

    任何时候你需要与通过 ioremap() 映射的设备寄存器进行交互，都必须使用 ioreadX()/iowriteX() 函数家族，而不是直接使用指针解引用（如 *reg = value）。

* `raw_copy_to_user()`

    将数据从内核空间安全地复制到用户空间。

    syntax:

    ```c
    unsigned long raw_copy_to_user(void __user *to, const void *from, unsigned long n);
    ```

    to： 目标地址（用户空间指针）。

    from： 源地址（内核空间指针）。

    n： 要拷贝的字节数。

    返回值： 如果成功，返回 0；如果失败，返回尚未成功拷贝的字节数。

    “raw”前缀： 这表明它是底层实现。相比 copy_to_user()，它假设调用者已经处理了可能引起睡眠的事情（如缺页中断），通常在知道上下文是安全的情况下使用，性能稍高。

* `LIBRARY_PATH`与 `LD_LIBRARY_PATH`的区别

    `LIBRARY_PATH`用于编译时指示链接器（ld）在链接阶段查找需要链接的库文件（如 libxxx.a 或 libxxx.so）的目录列表。它用于解决 -l 选项指定的库的路径。功能与`-L`比较像。

    搜索顺序通常是：

    1. 首先搜索 -L 指定的目录。

    2. 然后搜索 LIBRARY_PATH 指定的目录。

    3. 最后搜索标准系统库目录（如 /usr/lib, /lib）。

    `LD_LIBRARY_PATH`用于运行时指使`ld.so`或`ld-linux.so`到对应的目录下查找动态共享库（.so 文件）。

* `ld.so`, `ld-linux.so`

    ld.so 和 ld-linux.so 都是 动态链接器/加载器（Dynamic Linker/Loader）。它们的主要作用是在程序运行时（run-time） 完成以下工作：

    * 加载共享库： 将程序所依赖的共享库（.so 文件）从文件系统加载到进程的地址空间。

    * 符号重定位： 解析程序与共享库之间、以及共享库相互之间的函数和变量引用（即符号），将其替换为实际的内存地址。

    * 处理依赖关系： 递归地处理所有传递性依赖（即库所依赖的其他库）。

    ld.so 批的是 /lib/ld.so

    ld-linux.so 指的是 /lib/ld-linux.so.{1,2,3} 或 /lib64/ld-linux-x86-64.so.2

    `ld.so`主要服务于a.out 格式的二进制文件（古老，已淘汰）。在现代系统中，ld.so 通常只是一个指向 ld-linux.so 的符号链接。

    `ld-linux.so`主要服务于 ELF 格式的二进制文件（现代标准）。

     ELF（Executable and Linkable Format）

 * `pkg-config --libs`

    获取链接一个特定软件库（Library）时，需要传递给编译器的所有链接器（Linker） flags（参数）。

    当你编译程序需要用到某个第三方库（比如 OpenCV、GTK、libpng 等）时，这个命令会告诉你应该加哪些 -l 和 -L 参数。

    example:

    ```bash
    pkg-config --libs mpi
    ```

    output:

    ```
    -L/usr/lib/x86_64-linux-gnu/openmpi/lib -lmpi
    ```

    pkg-config 工具通过查询事先安装好的 .pc 配置文件（这些文件通常随库一起安装），自动为你生成正确的、适用于当前系统的编译参数。

    通常与 Makefile 结合起来使用：

    ```makefile
    # 编译 main.c 并链接 libcurl 库
    program: main.c
        gcc main.c -o program `pkg-config --libs --cflags libcurl`
    ```

    其中`--cflags`表示输出`-I<header_path>`

    * `pkg-config --libs <包名>`: 获取链接库所需的参数
    
        `-L/usr/lib -lcurl -lssl -lcrypto`

    * `pkg-config --cflags <包名>`: 获取编译时所需的参数（如头文件路径）
    
        `-I/usr/include/curl`

* `openat()`

    在一个特定的目录文件描述符所指向的目录下，打开或创建一个文件。

    syntax:

    ```c
    #include <fcntl.h>

    int openat(int dirfd, const char *pathname, int flags, ... /* mode_t mode */);
    ```

    参数说明：

    * `dirfd`：一个指向目录的文件描述符。它也可以是一些特殊值：

        一个普通的目录文件描述符（通过 open 某个目录获得）。

        AT_FDCWD：一个特殊值，表示“相对于当前工作目录”。如果指定这个值，openat() 的行为就完全等同于传统的 open()，但它仍然为其他 *at() 系列函数（如 fstatat）提供一致性。

    * `pathname`：要打开的文件路径。它可以是：

        绝对路径（如 /tmp/file）：此时 dirfd 参数会被忽略。

        相对路径（如 file.txt）：此时路径是相对于 dirfd 所指向的目录来解释的。

    * `flags` 和 `mode`：与 open() 函数的参数完全相同，用于指定打开标志（如 O_RDONLY, O_CREAT）和创建文件时的权限。

    返回值：

    成功时：返回一个新打开的文件描述符（一个非负整数）。

    失败时：返回 -1，并设置全局变量 errno 来指示具体的错误原因。

    它是对经典 open() 系统调用的扩展，解决了 open() 在某些场景下的两个关键问题：

    * 竞态条件（Race Conditions）

        竞态条件： 在多线程程序中，如果一个线程在 chdir() 之后、open() 之前，另一个线程也调用了 chdir()，那么第一个线程就会打开错误的文件。这是一个非常经典的TOCTOU（检查时间与使用时间）竞态条件漏洞。

    * 维护进程的“当前工作目录”状态

        使用 openat() 的现代方法：

        * `dirfd = open("/a/b/c", O_DIRECTORY)`: 只打开目录，获取其文件描述符 dirfd

        * `fd = openat(dirfd, "file.txt", ...)`: 在 dirfd 指向的目录下打开文件`
