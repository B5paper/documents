* 互联网和文艺作品中的人物为了典型，常常是标签化的和脸谱化的，失去了很多鲜活的特征。比如要描写一个吝啬的人，总是贯穿作品地描写这个人如何如何吝啬，似乎这个人只要出场，就必定要伴随一个吝啬的情节。但是在生活中多与人接触会发现，人并不是这样的，人有很多的小细节，比如打扑克时偷偷藏一张牌，比如被发现后第二局继续藏牌，比如听见别人讨论某个主题后，总是站在远处嘟囔地插几句评论。这些吝啬可以看作低频主分量，这些细节可以看作高频分量，正是这些高频分量使人变得鲜活和可爱。

    这样就有了两个问题：
    
    1. 文艺作品如果把所有细节都加上，是否会被评论为臃肿不典型？文艺作品表达的可能是用一个人物来代表一类人物，这样的话，必须描写典型的性格，忽略次要的性格。但是这样又会忽略高频分量，使人物不可爱。这似乎是一个矛盾，不清楚该如何解决。

    2. 还是回到以前那个设想，如果我们有一家私塾把所有人都培养为相同的待人接物的模式、几乎相同的知识、以及几乎相同的批判性思维习惯，那么会不会使人们丧失性格的多样性，从而使世界变得无聊？目前看来，确实有这个可能。互联网的很多短剧，网文小说，网红主播，看了开头就能猜到结尾，主角性格千篇一律。既然这样，我们的私塾的目的就会被推翻，那么私塾又该是什么目的？一个规定了人与人最小边界的交流讨论场所？还是仅传授知识，保证健康，但是不改变性格的场所？

* C++20，可以使用概念来约束构造函数

    ```cpp
    #include <concepts>
    #include <iostream>

    template <typename T>
    class Rational {
    public:
        // 只允许算术类型的构造函数
        Rational(T num, T denom) requires std::integral<T> || std::floating_point<T> 
            : numerator(num), denominator(denom) {
            std::cout << "Constructing Rational with arithmetic type\n";
        }
        
    private:
        T numerator;
        T denominator;
    };

    int main() {
        Rational<int> a(1, 2);      // OK
        Rational<double> b(1.0, 2.0); // OK
        // Rational<std::string> c("a", "b"); // 编译错误
    }
    ```

    output:

    ```
    Constructing Rational with arithmetic type
    Constructing Rational with arithmetic type
    ```

    也可以写成：

    ```cpp
    #include <concepts>
    #include <iostream>

    class Rational {
    public:
        // 只允许算术类型的构造函数
        template <std::integral T>
        Rational(T numerator, T denominator) {
            std::cout << "Integral Rational\n";
        }

        template <std::floating_point T>
        Rational(T numerator, T denominator) {
            std::cout << "Floating-point Rational\n";
        }
    };

    int main() {
        Rational a(1, 2);       // 调用整数版本
        Rational b(1.0, 2.0);   // 调用浮点版本
        // Rational c("1", "2"); // 编译错误
    }
    ```

* 在对构造函数使用模板时，`typename`后可以不写`typename = xxx`

    ```cpp
    #include <type_traits>
    #include <iostream>

    class MyClass {
    public:
        // 只允许浮点类型的构造函数
        template <typename T,
                  typename std::enable_if<std::is_floating_point<T>::value, int>::type = 0>
        MyClass(T value) {
            std::cout << "Floating point constructor: " << value << std::endl;
        }
    };

    int main() {
        MyClass a(3.14);    // OK
        // MyClass b(42);   // 编译错误
    }
    ```

    目前不清楚原理。

* 除了使用 sfinae 约束类型外，还可以使用 static assert

    ```cpp
    #include <type_traits>
    #include <iostream>

    class MyClass {
    public:
        template <typename T>
        MyClass(T value) {
            static_assert(std::is_integral<T>::value, 
                         "MyClass constructor only accepts integral types");
            std::cout << "Constructor: " << value << std::endl;
        }
    };

    int main() {
        MyClass a(42);      // OK
        // MyClass b(3.14); // 编译错误，静态断言失败
    }
    ```

* int类型走第一个构造函数，float类型走第二个构造函数，其他所有类型走第三个构造函数 的模板实现

    ```cpp
    #include <type_traits>
    #include <iostream>

    class MyClass {
    public:
        // (1) int 类型的构造函数
        template <typename T, typename = std::enable_if_t<std::is_same_v<T, int>>>
        MyClass(T value) {
            std::cout << "int constructor: " << value << std::endl;
        }

        // (2) float 类型的构造函数
        template <typename T, typename = std::enable_if_t<std::is_same_v<T, float>>>
        MyClass(T value) {
            std::cout << "float constructor: " << value << std::endl;
        }

        // (3) 其他所有类型的构造函数
        template <typename T, 
                  typename = std::enable_if_t<!std::is_same_v<T, int> && !std::is_same_v<T, float>>,
                  typename = void>  // 额外默认参数避免冲突
        MyClass(T value) {
            std::cout << "generic constructor: " << value << std::endl;
        }
    };

    int main() {
        MyClass a(10);          // (1) int 版本
        MyClass b(3.14f);       // (2) float 版本
        MyClass c("hello");     // (3) 通用版本
        MyClass d(3.14);        // (3) 通用版本（double 不是 float）
    }
    ```

* `torch.utils.data`

    There are two types of datasets:

    * map-style datasets: This data set provides two functions  `__getitem__( )`, `__len__( )` that returns the indices of the sample data referred to and the numbers of samples respectively. In the example, we will use this type of dataset.

    * iterable-style datasets: Datasets that can be represented in a set of iterable data samples, for this we use `__iter__( )` function.

    Dataloader syntax:

    ```py
    DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0, collate_fn=None, pin_memory=False, drop_last=False, timeout=0, worker_init_fn=None, *, prefetch_factor=2, persistent_workers=False)
    ```

    example:

    ```py
    # importing libraries
    import torch
    import torchvision
    from torch.utils.data import Dataset, DataLoader
    import numpy as np
    import math

    # class to represent dataset
    class HeartDataSet():

        def __init__(self):
          
            # loading the csv file from the folder path
            data1 = np.loadtxt('heart.csv', delimiter=',',
                               dtype=np.float32, skiprows=1)
            
            # here the 13th column is class label and rest 
            # are features
            self.x = torch.from_numpy(data1[:, :13])
            self.y = torch.from_numpy(data1[:, [13]])
            self.n_samples = data1.shape[0] 
        
        # support indexing such that dataset[i] can 
        # be used to get i-th sample
        def __getitem__(self, index):
            return self.x[index], self.y[index]
          
        # we can call len(dataset) to return the size
        def __len__(self):
            return self.n_samples


    dataset = HeartDataSet()

    # get the first sample and unpack
    first_data = dataset[0]
    features, labels = first_data
    print(features, labels)
    ```

    output:

    ```
    tensor([ 63.0000,   1.0000,   3.0000, 145.0000, 233.0000,   1.0000,   0.0000,
            150.0000,   0.0000,   2.3000,   0.0000,   0.0000,   1.0000]) tensor([1.])
    ```

    dataloader example:

    ```py
    # Loading whole dataset with DataLoader
    # shuffle the data, which is good for training
    dataloader = DataLoader(dataset=dataset, batch_size=4, shuffle=True)

    # total samples of data and number of iterations performed
    total_samples = len(dataset)
    n_iterations = total_samples//4
    print(total_samples, n_iterations)
    for i, (targets, labels) in enumerate(dataloader):
        print(targets, labels)
    ```

    traning example:

    ```py
    num_epochs = 2

    for epoch in range(num_epochs):
        for i, (inputs, labels) in enumerate(dataloader):

            # here: 303 samples, batch_size = 4, n_iters=303/4=75 iterations
            # Run our training process
            if (i+1) % 5 == 0:
                print(f'Epoch: {epoch+1}/{num_epochs}, Step {i+1}/{n_iterations}|\
                    Inputs {inputs.shape} | Labels {labels.shape}')
    ```

* 常见金融机构

    以下是一些与高盛齐名或在其特定领域内具有巨大影响力的主要机构，可以分为几大类：
    一、 顶级投行与全能银行

    这些机构与高盛业务模式类似，在全球范围内提供投资银行、销售与交易、财富管理等全方位服务，合称 “Bulge Bracket”。

        摩根大通 - 按资产计算是美国最大的银行，其投资银行业务常年位居全球榜首，实力极其均衡和强大。

        摩根士丹利 - 俗称“大摩”，在高净值财富管理、股票承销等领域享有盛誉，是高盛最直接的竞争对手之一。

        美银美林 - 美国银行的证券业务部门，拥有强大的零售经纪网络和投资银行业务。

        花旗集团 - 全球化的金融服务巨头，特别是在固定收益和外汇市场拥有强大实力。

        巴克莱资本 - 英国银行业巨头巴克莱的投资银行部门，在欧洲和市场业务方面实力雄厚。

        瑞银集团 - 瑞士的金融巨头，是全球最大的财富管理机构，其投资银行业务也颇具规模。

        德意志银行 - 德国的领军银行，尽管近年经历重组，但在全球尤其是欧洲市场仍是一个重要参与者。

    二、 精品投行

    这些机构规模较小，但专注于提供高价值的顾问服务，如并购、重组等，不与全能银行进行全线竞争。

        拉扎德 - 极其专注于并购和重组顾问，尤其擅长复杂的跨境交易。

        瑞德 - 在医疗保健等特定行业的并购顾问方面享有顶级声誉。

        Evercore - 近年来发展迅速的精品投行，由摩根士丹利前CEO创立，吸引了大量顶尖人才。

        Moelis & Company - 由资深银行家Ken Moelis创立，在并购和重组领域表现活跃。

        古根海姆合伙公司 - 在媒体、电信和科技行业的交易中非常活跃。

    三、 资产管理公司与对冲基金

    这些机构是资本市场上的“大买家”，它们管理着巨额资金，进行投资以获取回报，是投行的重要客户。

        贝莱德 - 全球最大的资产管理公司，其管理的资产规模超过9万亿美元。它不仅是市场的参与者，其动向本身就能影响市场。

        先锋领航 - 指数投资和ETF的先驱，是全球最大的公募基金发行方之一。

        道富环球投资管理 - 另一家资产管理巨头，以其SPDR ETF系列闻名。

        桥水基金 - 全球最大的对冲基金，以其基于宏观经济原理的“纯阿尔法”策略闻名。

        文艺复兴科技 - 传奇对冲基金，以其高度依赖数学模型和量化交易的“大奖章基金”著称。

        城堡基金 - 顶尖的做市商和多策略对冲基金，在量化交易领域极具影响力。

        潘兴广场资本管理 - 由活跃投资者比尔·阿克曼创立，以其激进的投资策略和寻求董事会席位以推动公司改革而闻名。

    四、 专业服务机构

    这些机构虽不是直接的资本参与者，但为整个金融体系提供不可或缺的支持。

        三大信用评级机构：

            穆迪

            标准普尔

            惠誉

            它们对国家和公司信用等级的评定，直接影响着融资成本和市场信心。

        四大会计师事务所：

            普华永道

            德勤

            安永

            毕马威

            它们负责审计上市公司财报，是金融市场信任的基石。

    总结

    简单来说，华尔街的版图是这样的：

        卖方：以高盛、摩根大通等投行为代表，他们创造和销售金融产品。

        买方：以贝莱德、桥水等资管和对冲基金为代表，他们购买和持有这些产品。

        服务方：以麦肯锡（咨询）、四大（审计）、三大（评级） 等为代表，他们为整个链条提供专业服务。

    这些机构共同构成了一个复杂、强大且相互关联的全球金融网络。