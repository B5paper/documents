* `tail -f`

    用于动态追踪文件末尾的新内容, 默认显示文件最后 10 行

    其他选项：

    -n <行数>：指定初始显示的行数（如 tail -f -n 20 file.log 显示最后 20 行）。

    -F：比 -f 更健壮，会跟踪文件重命名或重建（如日志轮转场景）。

    使用 -F 时，tail 会定期检查文件的 inode 编号 是否变化（例如日志轮转后新文件的 inode 不同）。如果变化，则关闭旧文件描述符，重新打开新文件继续跟踪。

* `grep -c`

    `grep -c "pattern" filename`

    只显示行数，不显示内容。

    如果统计多个文件，则分别显示行数：

    `grep -c "GET" access.log access.log.1`

    output:

    ```
    access.log: 1200
    access.log.1: 800
    ```

    说明：

    1. 单行多次匹配：`-c`只统计行数，即使一行中多次匹配模式，仍计为`1`。

        如需统计所有匹配次数（非行数），可用`grep -o "pattern" | wc -l`。

* 总以为我们是在赌浪头，原来他们是从一座浪尖到另一座浪尖

* process url 的方法

    网页资源的几个特性：

    1. 参考价值通常有 tutorial, see also, reference, news 这四个方面

    1. 不一定能全部理解，原因可能是线性内容 + 每天能理解的时间有限，也可能是有非线性内容

    1. 可能会滚动更新

    1. 可能会消失，网页被删除

    因此需要把每个网页资源都作为一个长期项目，每次处理一点，记录下当前的位置和进度。等网页内容全部处理完成时，开始定期 tracking 网页，检查是否有滚动更新。

* 邻接矩阵 Adjacency Matrix

    使用二维数组`A[N][N]`表示图中顶点之间连接关系，`N`为图中顶点的数量。
    
    可以看出`A`是一个方阵。

    $A$矩阵元素存储边的权重。若仅表示边是否存在，可以置`1`或置`0`。若需要表示边的权重，则可以用有效数值表示$\mathrm{weight}$，用$0$或$\infty$表示边不存在。编程时，无穷$\infty$可以使用`INT32_MAX`表示。

    构建方法：

    * 无向图

        若顶点`i`和`j`之间有边，则$A[i][j] = A[j][i] = \mathrm{weight}$.

        方阵`A`关于主对角线对称。主对角线上的元素$A[i][i]$若有数值，表示图中存在自环，如果为`0`或无穷，则说明不存在自环。

    * 有向图

        $A[i][j] = \mathrm{weight}$表示存在从顶点$i$指向$j$的边。方阵$A$不一定对称。

    example:

    ```
    顶点: 1 — 2 — 3
    矩阵: 
      [[0, 1, 0],
       [1, 0, 1],
       [0, 1, 0]]
    ```

    优点：

    * 快速判断两顶点是否相邻（时间复杂度$O(1)$）。

    缺点：

    * 如果图是稀疏图，那么$A$中大量的元素会被置$0$或$\infty$，浪费存储空间

    * 遍历邻接点需扫描整行，效率较低（相比邻接表）。

* $\infty$在 python 中的表示

    可以使用`float('inf')`表示无穷大。

    ```python
    # Python 示例（用 float('inf') 表示 ∞）
    adj_matrix = [
        [0, 2, float('inf')],
        [2, 0, 3],
        [float('inf'), 3, 0]
    ]
    ```

* graph 图相关数据结构的一次探索

    ```cpp
    struct Vertex;

    struct Edge {
        Vertex *nex_vert;
        int dist;
    };

    struct Vertex {
        vector<Edge*> edges;

        Edge* add_edge(Vertex *nex_vert) {
            Edge *new_edge = new Edge;
            new_edge->nex_vert = nex_vert;
            edges.push_back(new_edge);
            return new_edge;
        }

        int del_edge(Edge *edge) {
            for (size_t edge_idx = 0; edge_idx < edges.size(); ++edge_idx) {
                if (edges[edge_idx] == edge) {
                    edges.erase(edges.begin() + edge_idx);
                    delete edge;
                    return 0;
                }
            }
            return -1;
        }

        int del_edge(size_t edge_idx) {
            if (edge_idx >= edges.size()) {
                return -1;
            }
            Edge *edge = edges[edge_idx];
            edges.erase(edges.begin() + edge_idx);
            delete edge;
            return 0;
        }

        ~Vertex() {
            for (Edge *edge : edges) {
                delete edge;
            }
        }
    };

    struct Graph {
        vector<Vertex*> verts;

        Vertex* add_vert() {
            Vertex *new_vert = new Vertex;
            verts.push_back(new_vert);
            return new_vert;
        }

        int deL_vert(Vertex *vert) {
            for (size_t vert_idx = 0; vert_idx < verts.size(); ++vert_idx) {
                if (verts[vert_idx] == vert) {
                    verts.erase(verts.begin() + vert_idx);
                    delete vert;
                    return 0;
                }
            }
            return -1;
        }

        int del_vert(size_t vert_idx) {
            if (vert_idx >= verts.size()) {
                return -1;
            }
            Vertex *vert = verts[vert_idx];
            verts.erase(verts.begin() + vert_idx);
            delete vert;
            return 0;
        }

        ~Graph() {
            for (Vertex *vert : verts) {
                delete vert;
            }
        }
    };

    struct PathSearcher {
        static vector<Vertex*> tmp_path;
        static vector<Vertex*> min_dist_path;
        static int min_dist;

        static Vertex *vert_dst;
        static Graph *graph;

        static int recur_search_path_first_match(Vertex *vert) {
            if (vert == vert_dst) {
                tmp_path.push_back(vert);
                return 0;
            }

            for (int i = 0; i < vert->edges.size(); ++i) {
                Edge *edge = vert->edges[i];
                int ret = recur_search_path_first_match(edge->nex_vert);
                if (ret == 0) {
                    tmp_path.push_back(vert);
                    return 0;
                }
            }

            return -1;
        }

        static vector<Vertex*> get_path_first_match() {
            std::reverse(tmp_path.begin(), tmp_path.end());
            return tmp_path;
        }

        static int recur_search_path_min_dist(Vertex *vert) {
            if (vert == vert_dst) {
                int dist = 0;
                Vertex *cur_vert = tmp_path[0];
                for (int i = 1; i < tmp_path.size(); ++i) {
                    Vertex *nex_vert = tmp_path[i];
                    for (int j = 0; j < cur_vert->edges.size(); ++j) {
                        Edge *edge = cur_vert->edges[j];
                        if (edge->nex_vert == nex_vert) {
                            dist += edge->dist;
                            break;
                        }
                    }
                    cur_vert = nex_vert;
                }
                if (dist < min_dist) {
                    min_dist_path = tmp_path;
                    min_dist = dist;
                }
                return 0;
            }

            for (int i = 0; i < vert->edges.size(); ++i) {
                Edge *edge = vert->edges[i];
                Vertex *nex_vert = edge->nex_vert;
                tmp_path.push_back(nex_vert);
                int ret = recur_search_path_min_dist(nex_vert);
                tmp_path.pop_back();
            }
            return 0;
        }
    };

    vector<Vertex*> PathSearcher::tmp_path;
    vector<Vertex*> PathSearcher::min_dist_path;
    Vertex* PathSearcher::vert_dst;
    Graph* PathSearcher::graph;
    int PathSearcher::min_dist;

    int search_path_first_match(vector<Vertex*> &path, Graph &graph,
        int src_vert, int dst_vert) {
        Vertex *vert_src = graph.verts[src_vert];
        Vertex *vert_dst = graph.verts[dst_vert];

        PathSearcher::tmp_path.clear();
        PathSearcher::graph = &graph;
        PathSearcher::vert_dst = vert_dst;
        int ret = PathSearcher::recur_search_path_first_match(vert_src);
        if (ret != 0) {
            printf("fail to recur search path first match\n");
            return -1;
        }
        path = PathSearcher::get_path_first_match();
        return 0;
    }

    int search_path_min_dist(vector<Vertex*> &path, int &min_dist,
        Graph &graph, int src_vert, int dst_vert) {
        Vertex *vert_src = graph.verts[src_vert];
        Vertex *vert_dst = graph.verts[dst_vert];

        PathSearcher::min_dist = INT32_MAX;
        PathSearcher::tmp_path.clear();
        PathSearcher::tmp_path.push_back(vert_src);
        PathSearcher::graph = &graph;
        PathSearcher::vert_dst = vert_dst;

        int ret = PathSearcher::recur_search_path_min_dist(vert_src);
        if (ret != 0) {
            printf("fail to recur search path min dist\n");
            return -1;
        }
        path = PathSearcher::min_dist_path;
        min_dist = PathSearcher::min_dist;

        return 0;
    }

    void print_path(Graph &graph, vector<Vertex*> &path) {
        for (int i = 0; i < path.size(); ++i) {
            Vertex *vert = path[i];
            int vert_idx;
            for (int j = 0; j < graph.verts.size(); ++j) {
                if (graph.verts[j] == vert) {
                    vert_idx = j;
                    break;
                }
            }
            if (i == path.size() - 1)
                printf("%d", vert_idx);
            else
                printf("%d -> ", vert_idx);
        }
        putchar('\n');
    }

    int main() {
        Graph graph;
        int num_verts = 7;
        for (int i = 0; i < num_verts; ++i) {
            graph.add_vert();
        }
        vector<pair<int, int>> input_edges {
            {0, 1}, {0, 2}, {0, 3},
            {1, 4}, {1, 2},
            {2, 5}, {2, 3},
            {3, 5},
            {4, 5},
            {5, 6}
        };

        srand(time(NULL));
        for (int i = 0; i < input_edges.size(); ++i) {
            auto [cur_vert, nex_vert] = input_edges[i];
            Vertex *vert_cur = graph.verts[cur_vert];
            Vertex *vert_nex = graph.verts[nex_vert];
            Edge *new_edge = new Edge;
            new_edge->nex_vert = vert_nex;
            new_edge->dist = rand() % 19 + 1;
            vert_cur->edges.push_back(new_edge);
        }

        vector<Vertex*> path;

        printf("-------- search_path_first_match --------\n");
        int ret = search_path_first_match(path, graph, 0, 6);
        if (ret != 0) {
            printf("fail to serach path first match\n");
            return -1;
        }

        for (int i = 0; i < path.size(); ++i) {
            printf("%p -> ", path[i]);
        }
        putchar('\n');

        print_path(graph, path);
        putchar('\n');

        printf("-------- search_path_min_dist --------\n");
        int min_dist;
        ret = search_path_min_dist(path, min_dist, graph, 0, 6);
        if (ret != 0) {
            printf("fail to search path min dist\n");
            return -1;
        }

        printf("min dist: %d\n", min_dist);
        for (int i = 0; i < path.size(); ++i) {
            printf("%p -> ", path[i]);
        }
        putchar('\n');

        print_path(graph, path);

        return 0;
    }
    ```

    output:

    ```
    -------- search_path_first_match --------
    0x5a3471048eb0 -> 0x5a3471048ef0 -> 0x5a3471048f60 -> 0x5a3471048fd0 -> 0x5a3471048ff0 -> 
    0 -> 1 -> 4 -> 5 -> 6

    -------- search_path_min_dist --------
    min dist: 23
    0x5a3471048eb0 -> 0x5a3471048ed0 -> 0x5a3471048fd0 -> 0x5a3471048ff0 -> 
    0 -> 2 -> 5 -> 6
    ```

    目前我们希望图可以动态删除节点，可以搜索 path，可以快速对接常见的图问题，兼容性广泛，性能不要求像邻接矩阵那么高，但是也不能太低。

    说明：

    * `struct Edge {`

        ```cpp
        struct Edge {
            Vertex *nex_vert;
            int dist;
        };
        ```

        `Edge`被设计为单向边，指向下一个节点的指针。即使是指针，那就要求在创建 edge 时，net vert 必须已经存在。

        如果存储 next vert 的方式是索引，则没有这个问题，但是如果 graph 删除了 vert，那么 vert 的索引会失效。这样的代价或许太大。

        或许可以存储 next vert 的 id，这点后面可以考虑。

        `Edge`没有存储 src vert，说明 edge 并不是独立于 vert 存在的，而是一定是 vert 的一个成员。或许 edge 可以独立于 vert 存在，后面可以探索下。

    * `struct Vertex {`

        ```cpp
        struct Vertex {
            vector<Edge*> edges;
        ```

        `Vertex`中存储`edges`使用了指针，如果使用实体，后面 path 在存储 edge list 的时候，无法使用 edge 指针，因为随着 vector 的扩容，edge 的地址会改变；也无法使用 edge idx，因为删除 edge 后，idx 会失效。但是如果后面的 path 存储的是 vert list 而非 edge list，那么就可以使用 edge 实体了。再想一想，path 使用 vert list 时，找 vert 之间在的 edge 仍需搜索，而存储 edge list，可以很方便地找到下一个 vert，因此 path 不会去存 vert list。

        由此我们可以推断出：如果对象 A 会被对象 B 依赖，那么对象 A 就应该用 malloc, new, unique_ptr 等方式创建，如果 A 是独立的，别的对象 B, C 等不依赖 A，那么 A 可以是实体，也可以是指针。

    * `Edge* add_edge(Vertex *nex_vert)`

        ```cpp
            Edge* add_edge(Vertex *nex_vert) {
                Edge *new_edge = new Edge;
                new_edge->nex_vert = nex_vert;
                edges.push_back(new_edge);
                return new_edge;
            }
        ```

        这里使用了 new，其实使用 unique_ptr 也行，后面就不需要手动 delete 了。

    * `int del_edge(Edge *edge) {`

        ```cpp
        int del_edge(Edge *edge) {
            for (size_t edge_idx = 0; edge_idx < edges.size(); ++edge_idx) {
                if (edges[edge_idx] == edge) {
                    edges.erase(edges.begin() + edge_idx);
                    delete edge;
                    return 0;
                }
            }
            return -1;
        }

        int del_edge(size_t edge_idx) {
            if (edge_idx >= edges.size()) {
                return -1;
            }
            Edge *edge = edges[edge_idx];
            edges.erase(edges.begin() + edge_idx);
            delete edge;
            return 0;
        }
        ```

        `del_edge()`设计了两个，分别是线性查找并删除，以及直接删除，对应不同的用户需求。

    * `~Vertex() {`

        ```cpp
        ~Vertex() {
            for (Edge *edge : edges) {
                delete edge;
            }
        }
        ```

        vertex 被销毁时，会自动销毁其包含的 edge。如果使用 unique ptr，这件事其实是托管给 vector 去做。

    * `struct Graph {`

        ```cpp
        struct Graph {
            vector<Vertex*> verts;
        ```

        vertex 毫无疑问需要使用指针来保存。面临的问题和 edge 是一样的。后面的代码与 edge 相似，不再赘述。

    * `Vertex* add_vert() {`

        graph, vertex, edge 是否应该被设计为纯的数据结构而不包含成员方法？`add_vert()`是否应该被设计为`graph_add_vert(Graph *graph)`？

        其他函数是否应该被设计为

        `graph_add_edge(Graph *graph, Vertex *vert, Edge *edge)`？

        关于这点的讨论目前不太明朗。

    * `struct PathSearcher {`

        ```cpp
        struct PathSearcher {
            static vector<Vertex*> tmp_path;
            static vector<Vertex*> min_dist_path;
            static int min_dist;

            static Vertex *vert_dst;
            static Graph *graph;
        ```

        如果将 path search 的功能写在 graph 里，比如`graph.search_path_first_match()`，那么 Graph 就需要存储一些递归搜索时用到的临时变量，比如`tmp_path`, `min_dist_path`，`min_dist`等。这些数据并不是 graph 的一员，放在 graph 里会很奇怪。因此这里专门创建了个`PathSearcher`类，存储这些数据。

        可以看到，在`PathSearcher`中，graph 只是它的一个成员，或者说，是为了搜索路径临时保存的一个状态。

    * `static int recur_search_path_first_match(Vertex *vert) {`

        `PathSearcher`只需要保存一些信息，本质是把一些数据和搜索函数绑定起来，而不需要创建实例对象，所以我们把数据和函数都声明为静态的。

        `recur_search_path_first_match()`这个函数似乎写的有问题，按道理应该有`pop_back()`的过程才对，不可能只靠`push_back()`就找到目标节点。

    * `static int recur_search_path_min_dist(Vertex *vert) {`

        回溯法找最小路径，复杂度很高，可以用来测试 graph 整数数据结构的性能。

    * `int search_path_first_match(vector<Vertex*> &path, Graph &graph, int src_vert, int dst_vert) {`

        手动配置`PathSearcher`中的各个字段太麻烦了，我们专门写一个全局函数`search_path_first_match()`来配置`PathSearcher`中成员的初始值，并执行搜索，返回结果。
        
        `search_path_min_dist()`同理。

        前面讨论过，`path`使用`vector<Vertex*>`来存储，其实不太好。但是想一想，存储 edge，无法直观看到 vertex；存储 vertex，无法快速找到 edge。那么答案呼之欲出了，我们需要单独创建一个`struct Path`来存储 path，既存储 edge list，又存储伴生的 vert list。

    * `void print_path(Graph &graph, vector<Vertex*> &path) {`

        按道理`print_path()`不应该依赖 graph 才对，因为 path 中已经包含有路径的全部信息了。

    * `vector<pair<int, int>> input_edges {`

        如果希望以文档的形式大批量地导入 edge，那么免不了要使用 vert idx 或 vert id。

    上面的大部分代码都是线程不安全的，如果需要多线程操作同一个对象，那么需要设置锁，或者更改底层的数据结构，重新设计。

* 根据之前的笔记记录的对未知概念的推断过程，可以得出，凡是有推翻之前错误的假设的情况，总是因为发现了新的证据，新的证据更强，更清晰，歧义更少

* Yoshua Bengio（约书亚·本吉奥）

    核心方向：

    1. 贝叶斯神经网络（Bayesian Neural Networks, BNN）

    2. 生成模型与贝叶斯框架

        * 贝叶斯生成对抗网络（Bayesian GAN），通过贝叶斯方法优化生成器和判别器的参数分布，提升生成样本的多样性和稳定性。

        * 变分自编码器（VAE）

            通过变分推断学习隐变量的后验分布

    3. 注意力机制中的贝叶斯视角

        在Transformer和注意力机制中，Bengio团队尝试用贝叶斯方法建模注意力权重的不确定性，例如通过随机注意力（Stochastic Attention）提升鲁棒性。

    4. 因果推断与贝叶斯网络

        为贝叶斯网络（Bayesian Networks）和神经网络结合可解决AI的因果表征学习问题

* decoder-only arch

    由解码器堆叠而成。
    
    单向注意力，仅允许每个位置关注左侧历史信息（掩码自注意力）。每次只预测下一个 token。

    gpt 系列就是 decoder-only 架构。

    自回归（逐token生成），确保输出连贯性，但Encoder-Decoder通过编码器的双向建模能更好理解输入，适合复杂映射任务。Decoder-Only因结构简单，在大规模预训练中更高效。

    左侧历史信息 (left-context) : 在生成第$t$个 token 时，模型只能看到当前位置之前的所有 token（即位置 $1$, $2$, $...$, $t−1$），而无法访问未来的 token（位置 $t+1$, $t+2$, $...$）。这样保证生成过程的自回归性（逐词生成），符合语言的自然顺序

    
