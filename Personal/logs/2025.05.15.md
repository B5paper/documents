* vertex + graph 的功能拓展探索

    ```cpp
    #include <iostream>
    #include <unordered_map>
    #include <vector>
    #include <unordered_set>
    #include <string>
    #include <cstdio>
    using namespace std;

    template<typename T>
    struct BaseVertex {
        int id;
        vector<T*> edges;
    };

    template<typename T>
    struct BaseGraph {
        vector<T*> verts;
        void print_verts() {
            for (int i = 0; i < verts.size(); ++i) {
                printf("%d, ", verts[i]->id);
            }
            putchar('\n');
        }
    };

    struct Vertex: public BaseVertex<Vertex> {

    };

    struct Graph: public BaseGraph<Vertex> {

    };

    struct MyVertex: public BaseVertex<MyVertex> {
        int vert_type;
        string vert_name;
    };

    struct MyGraph: public BaseGraph<MyVertex> {
        void print_verts() {
            for (int i = 0; i < verts.size(); ++i) {
                printf("%d type: %d, ", verts[i]->id, verts[i]->vert_type);
            }
            putchar('\n');
        }

        void filter_my_vertex_type(int type) {
            for (int i = 0; i < verts.size(); ++i) {
                if (verts[i]->vert_type == type) {
                    printf("%d, ", verts[i]->id);
                }
            }
            putchar('\n');
        }
    };

    int main() {
        Graph graph;
        for (int i = 0; i < 5; ++i) {
            graph.verts.emplace_back(new Vertex);
            graph.verts[i]->id = i;
        }
        graph.print_verts();

        MyGraph my_graph;
        for (int i = 0; i < 5; ++i) {
            my_graph.verts.emplace_back(new MyVertex);
            my_graph.verts[i]->id = i;
            my_graph.verts[i]->vert_type = 1;
        }
        my_graph.print_verts();
        my_graph.verts[2]->vert_type = 2;
        my_graph.verts[4]->vert_type = 2;
        my_graph.filter_my_vertex_type(2);
        return 0;
    }
    ```

    output:

    ```
    0, 1, 2, 3, 4, 
    0 type: 1, 1 type: 1, 2 type: 1, 3 type: 1, 4 type: 1, 
    2, 4,
    ```

    说明

    * `BaseVertex`中`T`类型的指针，我们只知道`T`类型会继承自`BaseVertex`，也可能就是`BaseVertex`。此时我们发现`BaseVertex`无法实例化：

        假如`T`就是`BaseVertex`，那么

        ```cpp
        BaseVertex<BaseVertex> vert;
        ```

        无法通过编译。因为尖括号内的`BaseVertex`，仍然是一个模板类型，编译器会提示模板参数缺失。我们再填一级也不行，`BaseVertex<BaseVertex<BaseVertex<T>>>`，这样递归填下去，`T`还是无法被确定。

        此时我们必须借助另一个类来完成实例化：

        ```cpp
        struct Vertex: public BaseVertex<Vertex> {

        };

        int main() {
            Vertex vert;  // OK
            return 0;
        }
        ```

        此时`Vertex`继承自`BaseVertex`，而`BaseVertex`的模板类型又是`Vertex`。这样通过一个额外的类型，将递归变成了两种类型的循环调用，从而可以通过编译。

    * `BaseGraph`被设计成只依赖`BaseVertex`内成员的类，即`T`一定继承自`BaseVertex`

        ```cpp
        template<typename T>
        struct BaseGraph {
            vector<T*> verts;
            void print_verts() {
                for (int i = 0; i < verts.size(); ++i) {
                    printf("%d, ", verts[i]->id);
                }
                putchar('\n');
            }
        };
        ```

        如果能显式地约束`T`一定继承自`BaseVertex`，那么在输入`verts[i]->`时就能自动显示成员了。可惜到 c++20 才支持类型约束。

        `BaseGraph`可以使用`Vertex`实例化，但是不能用`BaseVertex`实例化：

        ```cpp
        BaseGraph<Vertex> graph;
        ```

        但是我们想了想，如果使`Graph`类型默认对应`Vertex`类型，`BaseGraph`默认对应`BaseVertex`类型，视觉效果更好一点：

        ```cpp
        // BaseGraph<BaseVertex> base_graph;  // not allowed
        Graph graph;  // graph.verts is Vertex*
        ```

    * 是否可以将`BaseGraph`里的函数实现放到`Graph`里？不可以，因为`Graph`和`Vertex`绑定在一起，后面的 derived graph 如果继承了 Graph，那么就连带着 Vertex 一起绑定了。我们还是希望 derived graph 和 derived Vertex 绑定。

    * `MyVertex`增加了几个字段，

        ```cpp
        struct MyVertex: public BaseVertex<MyVertex> {
            int vert_type;
            string vert_name;
        };
        ```

        后面与`struct MyGraph: public BaseGraph<MyVertex>`绑定在一起，`MyGraph`通过处理`Graph`增加的字段来增加高级功能（比如使得节点有 type 的属性）。

    整体看来。代码的对称性足够，实际使用时简洁，可扩展性强，唯一的不足地方是`BaseGraph`中，IDE 无法给出成员的编程提示，这个问题只能等到 c++ 20 再修复了。

* 如果一个模板类的基类仍是模板类，那么必须使用`this`指针才能访问到基类中的成员

    ```cpp
    #include <cstdio>
    using namespace std;

    template<typename T>
    struct BaseClass {
        T val;
        void print_msg() {
            printf("hello from base class, val: %d\n", val);
        }
    };

    template<typename T>
    struct MyClass: public BaseClass<T> {
        void invoke_func_from_base_class(T input_val) {
            // val = input_val;  // error
            // print_msg();  // error
            this->val = input_val;
            this->print_msg();
        }
    };

    int main() {
        MyClass<int> obj;
        obj.invoke_func_from_base_class(123);
        return 0;
    }
    ```

    如果基类的类型在编译时期就已经确定，那么可以不使用 this 指针：

    ```cpp
    #include <cstdio>
    using namespace std;

    template<typename T>
    struct BaseClass {
        T val;
        void print_msg() {
            printf("hello from base class, val: %d\n", val);
        }
    };

    template<typename T>
    struct MyClass: public BaseClass<int> {
        void invoke_func_from_base_class(T input_val) {
            val = input_val;  // ok
            print_msg();  // ok
        }
    };

    int main() {
        MyClass<int> obj;
        obj.invoke_func_from_base_class(123);
        return 0;
    }
    ```

* initializer list 本质是右值

    ```cpp
    #include <unordered_map>
    #include <string>
    #include <utility>
    #include <cstdio>
    using namespace std;

    enum Color {
        RED,
        BLUE,
        GREEN,
        YELLOW
    };

    struct LookupTable {
        unordered_map<Color, string> lut;
        // 这里必须加 const，因为 main() 中给出的列表是右值，
        // 我们必须使用 const 左值，或者直接使用右值引用来接收它
        explicit LookupTable(const initializer_list<
            pair<Color, string>> &init_list) {
            for (auto iter = init_list.begin(); iter != init_list.end(); ++iter) {
                lut.emplace(iter->first, iter->second);
            }
        }
        const string& operator[](const Color &color) const {
            return lut.at(color);
        }
    };

    LookupTable Color_Id_To_String {
        {RED, "red"},
        {BLUE, "blue"},
        {GREEN, "green"},
        {YELLOW, "yellow"}
    };

    int main() {
        Color color = GREEN;
        printf("color is %s\n", Color_Id_To_String[color].c_str());
        return 0;
    }

    ```

    output:

    ```
    color is green
    ```

* 不能使用 edge 去初始化 vertex

    一个使用 edge 去 init 的 example 如下：

    ```cpp
    explicit StaticGraph(const initializer_list<pair<int, int>> &init_list) {
        int max_vert_idx = -1;
        for (auto &&iter = init_list.begin(); iter != init_list.end(); ++iter) {
            max_vert_idx = std::max(max_vert_idx,
                std::max(iter->first, iter->second));
        }
        verts.resize(max_vert_idx + 1);
        for (int i = 0; i <= max_vert_idx; ++i) {
            verts[i] = new Vertex;
            Vertex &vert = *verts[i];
            vert.id = i;
        }
        for (auto &&iter = init_list.begin(); iter != init_list.end(); ++iter) {
            verts[iter->first]->edges.push_back(verts[iter->second]);
        }
    };

    int main() {
        // 不能使用 edge 去初始化 vertex，因为 edge 只有索引信息，没有 vertex 的属性信息
        StaticGraph graph {
            {0, 1}, {0, 2}, {0, 3},
            {1, 2}, {1, 4},
            {2, 5},
            {3, 5},
            {4, 5},
            {5, 6}
        };
        return 0;
    }
    ```

    我们必须先 init vertex，再添加 edges:

    ```cpp
    struct Graph: public BaseGraph<Vertex> {
        void init_verts(const initializer_list<DevType> &init_list) {
            for (auto iter = init_list.begin(); iter != init_list.end(); ++iter) {
                Vertex *vert_ptr = new Vertex;
                Vertex &vert = *vert_ptr;
                vert.id = this->verts.size();
                vert.dev_type = *iter;
                this->verts.push_back(vert_ptr);
            }
        }

        void init_edges(const initializer_list<pair<int, int>> &init_list) {
            for (auto iter = init_list.begin(); iter != init_list.end(); ++iter) {
                this->verts[iter->first]->edges.push_back(
                    this->verts[iter->second]);
            }
        }
    }

    int test() {
        Graph graph;

        graph.init_verts({GPU, GPU, CPU, NIC, CPU, GPU, NIC});

        // 目前这里的做法是先 init vert，然后再将 edge 连接上，这样应避免了无法录入 vertex info 的问题
        graph.init_edges({
            {0, 1}, {0, 2}, {0, 3},
            {1, 2}, {1, 4},
            {2, 5},
            {3, 5},
            {4, 5},
            {5, 6}
        });

        return 0;
    }
    ```

* extended static graph

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <iostream>
    #include <vector>
    #include <unordered_map>
    #include <algorithm>
    #include <utility>
    #include <initializer_list>
    using namespace std;

    template<typename T>
    struct BaseVertex {
        int id;
        vector<T*> edges;
    };

    // 约束：T 必须继承自 BaseVertex
    template<typename T>
    struct BaseGraph {
        vector<T*> verts;

        ~BaseGraph() {
            for (T* vert_ptr : verts) {
                delete vert_ptr;
            }
        }

        void init_verts(const initializer_list<int> &init_list) {
            for (int i = 0; i < init_list.size(); ++i) {
                verts.push_back(new T);
                T *vert = verts[i];
                vert->id = *(init_list.begin() + i);
            }
        }

        void init_edges(const initializer_list<pair<int, int>> &init_list) {
            for (auto iter = init_list.begin(); iter != init_list.end(); ++iter) {
                verts[iter->first]->edges.push_back(verts[iter->second]);
            }
        }

        void print_graph() {
            for (int i = 0; i < verts.size(); ++i) {
                T* vert = verts[i];
                printf("idx %d: vert id %d, num edges: %lu\n",
                    i, vert->id, vert->edges.size());
                printf("\t-> ");
                for (int j = 0; j < vert->edges.size(); ++j) {
                    printf("%d, ", vert->edges[j]->id);
                }
                putchar('\n');
            }
        }
    };

    struct PrimeVertex: public BaseVertex<PrimeVertex> {};

    struct PrimeGraph: public BaseGraph<PrimeVertex> {};

    enum DevType {
        GPU,
        CPU,
        NIC,
        NET
    };

    template<typename KeyType, typename ValType>
    struct LookupTable {
        unordered_map<KeyType, ValType> lut;
        explicit LookupTable(const initializer_list<
            pair<KeyType, ValType>> &init_list) {
            for (auto iter = init_list.begin(); iter != init_list.end(); ++iter) {
                lut.emplace(iter->first, iter->second);
            }
        }
        const ValType& operator[](const KeyType &key) const {
            return lut.at(key);
        }
    };

    const LookupTable<DevType, string> Dev_Type_Id_To_Str {
        {GPU, "gpu"},
        {CPU, "cpu"},
        {NIC, "nic"},
        {NET, "net"}
    };

    struct Vertex: public BaseVertex<Vertex> {
        DevType dev_type;
    };

    struct Graph: public BaseGraph<Vertex> {
        void init_verts(const initializer_list<DevType> &init_list) {
            for (auto iter = init_list.begin(); iter != init_list.end(); ++iter) {
                Vertex *vert_ptr = new Vertex;
                Vertex &vert = *vert_ptr;
                vert.id = this->verts.size();
                vert.dev_type = *iter;
                this->verts.push_back(vert_ptr);
            }
        }

        void init_edges(const initializer_list<pair<int, int>> &init_list) {
            for (auto iter = init_list.begin(); iter != init_list.end(); ++iter) {
                this->verts[iter->first]->edges.push_back(
                    this->verts[iter->second]);
            }
        }

        void print_graph() {
            for (int i = 0; i < verts.size(); ++i) {
                Vertex &vert = *verts[i];
                printf("idx: %d, vert id: %d, dev type: %s, num edges: %lu\n",
                    i, vert.id, Dev_Type_Id_To_Str[vert.dev_type].c_str(),
                    vert.edges.size());
                printf("\t-> ");
                for (int j = 0; j < vert.edges.size(); ++j) {
                    printf("%d, ", vert.edges[j]->id);
                }
                putchar('\n');
            }
        }

        void collect_verts(vector<Vertex*> &out_verts, DevType dev_type) {
            out_verts.clear();
            for (int i = 0; i < verts.size(); ++i) {
                if (verts[i]->dev_type == dev_type) {
                    out_verts.push_back(verts[i]);
                }
            }
        }
    };

    // 要求输入按顺序，vert 的编号必须从 0 开始，并且与位置保持一致
    struct StaticGraph: public Graph {
        struct VertexPtrHash {
            size_t operator()(const pair<Vertex*, Vertex*> &src_dst) const {
                return std::hash<Vertex*>()(src_dst.first) ^
                    std::hash<Vertex*>()(src_dst.second);
            }
        };

        unordered_map<pair<Vertex*, Vertex*>, vector<int>, VertexPtrHash> paths;
        // DynamicGraph 下才会考虑 paths 是否为 valid
        // staitc 模式下，paths 经初始化后一直有效
        // bool is_paths_valid = false;
        // path 应该是一个 edge list，不应该是 vert list
        // 因为给定 edge 可以很快查到 next vert，但是给定两个 vert 不容易查到 edge
        // path is an edge idx list
        int search_path_bfs(vector<int> **path_ptr, int src_id, int dst_id) {
            Vertex *src_vert = verts[src_id];
            Vertex *dst_vert = verts[dst_id];
            auto iter = paths.find({src_vert, dst_vert});
            if (iter != paths.end()) {
                *path_ptr = &iter->second;
                return 0;
            }

            vector<Vertex*> que_cur, que_nex;
            que_cur.push_back(src_vert);
            while (!que_cur.empty()) {
                for (int i = 0; i < que_cur.size(); ++i) {
                    Vertex *cur_vert = que_cur[i];
                    for (int j = 0; j < cur_vert->edges.size(); ++j) {
                        Vertex *nex_vert = cur_vert->edges[j];
                        if (paths.find({src_vert, nex_vert}) != paths.end()) {
                            continue;
                        }
                        vector<int> &path_src_to_cur = paths[{src_vert, cur_vert}];
                        vector<int> &path_src_to_nex = paths[{src_vert, nex_vert}];
                        path_src_to_nex = path_src_to_cur;
                        path_src_to_nex.push_back(j);
                        if (nex_vert == dst_vert) {
                            *path_ptr = &path_src_to_nex;
                            return 0;
                        }
                        que_nex.push_back(nex_vert);
                    }
                }
                que_cur = que_nex;
                que_nex.clear();
            }
            *path_ptr = nullptr;
            return -1;
        }

        void print_path(int src_id, vector<int> &path) {
            Vertex &src_vert = *verts[src_id];
            printf("%d", src_vert.id);
            Vertex *vert = &src_vert, *vert_nex;
            for (int i = 0; i < path.size(); ++i) {
                vert_nex = vert->edges[path[i]];
                printf(" -> %d", vert_nex->id);
                vert = vert_nex;
            }
            putchar('\n');
        }
    };

    int main() {
        printf("-------- prime graph --------\n");
        PrimeGraph p_graph;
        p_graph.init_verts({0, 1, 2, 3, 4});
        p_graph.init_edges({
            {0, 1}, {0, 2}, {0, 4},
            {1, 3}, {1, 4},
            {2, 1}, {2, 3}, {2, 0},
            {4, 0}, {4, 2}
        });
        p_graph.print_graph();
        putchar('\n');

        printf("-------- static graph --------\n");
        StaticGraph graph;
        graph.init_verts({GPU, GPU, CPU, NIC, CPU, GPU, NIC});
        graph.init_edges({
            {0, 1}, {0, 2}, {0, 3},
            {1, 2}, {1, 4},
            {2, 5},
            {3, 5},
            {4, 5},
            {5, 6}
        });

        graph.print_graph();

        vector<int> *path_ptr;
        int ret = graph.search_path_bfs(&path_ptr, 0, 6);
        if (ret != 0) {
            printf("fail to get path\n");
            return -1;
        }
        graph.print_path(0, *path_ptr);

        vector<Vertex*> gpu_verts;
        graph.collect_verts(gpu_verts, GPU);
        printf("gpu vert ids: ");
        for (Vertex *vert : gpu_verts) {
            printf("%d, ", vert->id);
        }
        putchar('\n');

        return 0;
    }
    ```

    output:

    ```
    -------- prime graph --------
    idx 0: vert id 0, num edges: 3
    	-> 1, 2, 4, 
    idx 1: vert id 1, num edges: 2
    	-> 3, 4, 
    idx 2: vert id 2, num edges: 3
    	-> 1, 3, 0, 
    idx 3: vert id 3, num edges: 0
    	-> 
    idx 4: vert id 4, num edges: 2
    	-> 0, 2, 

    -------- static graph --------
    idx: 0, vert id: 0, dev type: gpu, num edges: 3
    	-> 1, 2, 3, 
    idx: 1, vert id: 1, dev type: gpu, num edges: 2
    	-> 2, 4, 
    idx: 2, vert id: 2, dev type: cpu, num edges: 1
    	-> 5, 
    idx: 3, vert id: 3, dev type: nic, num edges: 1
    	-> 5, 
    idx: 4, vert id: 4, dev type: cpu, num edges: 1
    	-> 5, 
    idx: 5, vert id: 5, dev type: gpu, num edges: 1
    	-> 6, 
    idx: 6, vert id: 6, dev type: nic, num edges: 0
    	-> 
    0 -> 2 -> 5 -> 6
    gpu vert ids: 0, 1, 5, 
    ```