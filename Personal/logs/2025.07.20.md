* 如果有临时的想法，那么只靠记录关键字无法回忆起当时的所有想法和情节，必须要把临时的想法记录成完成的一句话或一段话才可以。

    前几天参加 riscv 活动，记录下了“一生一芯：任务拆分”这几个字，现在已经想不起来为什么要记录这几个词了，也想不起来当时冒出来什么 idea，什么想法。

* 机器人如果能像 riscv 活动一样有展台，那么一定会有很多的人前来询问带来流量。

* 关于 c++ 中数组名的赋值问题

    如果数组名是函数参数，那么在函数内部，数组名可以被赋值为新的指针，如果数组名在函数外部，那么在函数内部无法修改数组名所指的内容：

    ```cpp
    #include <stdio.h>
    #include <stdlib.h>

    void func(int arr[]) {
        int *new_arr = (int*) malloc(sizeof(int) * 3);
        new_arr[0] = 3;
        new_arr[1] = 2;
        new_arr[2] = 1;
        arr = new_arr;
        printf("%d, %d, %d\n", arr[0], arr[1], arr[2]);
        free(new_arr);
    }

    void func_2(int *arr[]) {
        int *new_arr = (int*) malloc(sizeof(int) * 3);
        new_arr[0] = 3;
        new_arr[1] = 2;
        new_arr[2] = 1;
        *arr = new_arr;
        printf("%d, %d, %d\n", (*arr)[0], (*arr)[1], (*arr)[2]);
        // free(new_arr);
    }

    int main() {
        int arr[3] = {1, 2, 3};
        func(arr);
        printf("arr: %p, %d, %d, %d\n", arr, arr[0], arr[1], arr[2]);
        func_2((int**) &arr);
        printf("arr: %p, %d, %d, %d\n", arr, arr[0], arr[1], arr[2]);
        return 0;
    }
    ```

    output:

    ```
    3, 2, 1
    arr: 0x7fffc728817c, 1, 2, 3
    3, 2, 1
    arr: 0x7fffc728817c, -1680833888, 22371, 3
    ```

    在`func()`内部，`arr`的含义被成功改变，而在`func_2()`调用过后，`arr`的值仍保持和原来一样。

* 跳板机 英语 Bastion Host

* ssh 

    使用跳板机连接到主机，等价于`-J`。其 ssh config 文件写法为

    ```
    Host <目标主机别名>
        HostName <目标主机IP或域名>
        User <用户名>
        ProxyJump <跳板机用户名>@<跳板机IP或域名>
    ```

    也可以分开写：

    ```
    Host jump
        HostName jump.example.com
        User user_jump

    Host target
        HostName target.example.com
        User user_target
        ProxyJump jump  # 使用跳板机 "jump"
    ```

    多级跳板：

    ```bash
    ssh -J jump1,jump2,jump3 target
    ```

    ssh config:

    ```
    Host target
        ProxyJump jump1,jump2,jump3
    ```

    如果跳板机的端口不是默认的 22 端口，那么可以这样配置：

    ```bash
    ssh -J user@jump-host:2222 user@target-host
    ```

    ```
    # 配置跳板机
    Host jump-host
        HostName jump-host.example.com
        User user_jump
        Port 2222  # 指定非默认端口

    # 配置目标主机（通过跳板机连接）
    Host target-host
        HostName target-host.example.com
        User user_target
        ProxyJump jump-host  # 自动使用 jump-host 的端口 2222
    ```

* `ps -e --forest`

    * `-e`

        显示所有进程（包括其他用户的进程），等同于`-A`。

        `man ps`中的解释：

        > -e     Select all processes.  Identical to -A.

    * `--forest`

        以树状缩进形式显示进程层级，清晰体现父子关系。

        其输出中使用`\_`而不是`|_`，目前仍不清楚原因。

* `ps -f`

    既显示完整信息，也显示完整 cmd（比如绝对路径）。否则只显示简略信息和 cmd 名称。

    example:

    ```bash
    ps -a
    ```

    output:

    ```
        PID TTY          TIME CMD
       2178 tty2     00:00:00 gnome-session-b
     295495 pts/9    00:01:03 ssh
     296484 pts/10   00:00:02 socat
     489812 pts/3    00:00:00 ps
    ```

    ```bash
    ps -af
    ```

    output:

    ```
    UID          PID    PPID  C STIME TTY          TIME CMD
    hlc         2178    2174  0 7月19 tty2    00:00:00 /usr/libexec/gnome-session-b
    hlc       295495  294700  0 7月19 pts/9   00:01:03 ssh -R 8825:127.0.0.1:8825 h
    hlc       296484  296052  0 7月19 pts/10  00:00:02 socat TCP-LISTEN:8825,reusea
    hlc       490526  487976  0 12:26 pts/3    00:00:00 ps -af
    ```

    可以看到，使用`-f`后，信息有截断，但是确实是完整路径。如果要显示未截断的完整信息，那么需要再加上`-l`参数。

* `fgrep`与`grep -F`都表示 Fixed-string grep，`fgrep`是旧版 linux 的独立命令，不推荐使用。目前更推荐使用`grep -F`.

* 我为什么是错的

    在学习的过程中，有时候不想知道“你为什么是对的”，而是想知道“我为什么是错的”。

* 有关 nccl 任务更深的问题：

    是否可以使用局部推理的方式，使一个复杂系统理解另一个复杂系统？

* `rsync`默认开启了`-r`递归拷贝，虽然提供了`-r`参数，但大部分情况下无实际用处。

* c++ `vector`调用`resize()`时，会保留尽可能多的已有元素，仅增加/删除需要改动的部分。

    example:

    ```cpp
    #include <vector>
    #include <stdio.h>
    using namespace std;

    void print_vec(vector<int> &vec) {
        for (int i = 0; i < vec.size(); ++i) {
            printf("%d, ", vec[i]);
        }
        putchar('\n');
    }

    int main() {
        vector<int> vec{1, 2, 3};
        vec.resize(10);
        print_vec(vec);
        vec[3] = 4;
        vec[4] = 5;
        vec.resize(2);
        print_vec(vec);
        return 0;
    }
    ```

    可以看到，扩容时，仅在`vec`末尾补充 0，前面的`1, 2, 3`并未被修改。而在缩容时，`1, 2`也得到了保留。

    如果在调用`resize()`时提供了`val`，那么使用`val`对新增元素进行初始化。

    调用`resize()`时，如果申请了新的内存，将旧的元素的内容移动到新的内存上去，那么会调用移动构造函数或拷贝构造函数，旧的元素会调用析构函数进行销毁。具体的调用规则如下：

    * 如果元素类型具有 noexcept 的移动构造函数，vector 会优先调用 移动构造函数（高效，避免不必要的拷贝）。

    * 如果移动构造函数可能抛出异常（非 noexcept），vector 会保守地调用 拷贝构造函数（保证强异常安全性）。

    * 如果元素类型不可移动（仅支持拷贝），强制使用 拷贝构造函数。

* `sudo -l`

    列出当前用户可以使用`sudo`执行哪些 root 操作。

    `sudo -ll`可以列出更详细的输出。

    `sudo -U user -l`可以查看其他用户的 root 权限。

* `/proc/<PID>/cmdline` 是 Linux 系统 伪文件系统（procfs） 中的一个特殊文件，用于 获取指定进程（PID）的完整命令行启动参数，以`\0`（空字符）分隔各个参数。

    如果进程本身就是以相对路径启动的，比如`bash`，那么`cmdline`不会显示其绝对路径。

    `cmdline`的结尾没有`\n`。

    因为 cmdline 使用`\0`进行参数分隔，所以避免了很多字符转义的问题。

* `grep -n`可以显示行号。行数从 1 开始计数。