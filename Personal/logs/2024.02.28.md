* 对于黑洞任务，应该用时间去限制

    比如只执行 30 分钟，然后整理一下已经得到的信息，解决的问题，尝试对未来的进度进行估计。

    这样的过程应该被称为采样。

* 低频（主能量）信息对应的是直觉，高频（低能量）信息对应的是强推理

* vulkan draw frame

    * 在调用`vkQueuePresentKHR()`时，可以指定多个 swapchain，猜测作用是同时更新多个窗口。

    * 一个 renderpass 由多个模块组成：pipeline, scissor, viewport, vertex buffer, index buffer, draw command

    * 一个 command buffer 中包含多个 render pass

    example code:

    ```cpp
    vkResetFences(device, 1, &fence_acq_img);
    uint32_t available_img_idx;
    result = vkAcquireNextImageKHR(device, swpch, UINT64_MAX, sem_img_available, fence_acq_img, &available_img_idx);

    VkCommandBufferBeginInfo cmd_buf_beg_info{};
    cmd_buf_beg_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    cmd_buf_beg_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    vkBeginCommandBuffer(cmd_buf, &cmd_buf_beg_info);

        VkRenderPassBeginInfo rdps_beg_info{};
        rdps_beg_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        rdps_beg_info.renderPass = render_pass;
        rdps_beg_info.framebuffer = frame_bufs[available_img_idx];
        rdps_beg_info.renderArea.offset = {0, 0};
        rdps_beg_info.renderArea.extent = {700, 500};
        rdps_beg_info.clearValueCount = 1;
        VkClearValue clr_val{0, 0, 0, 1};
        rdps_beg_info.pClearValues = &clr_val;
        vkCmdBeginRenderPass(cmd_buf, &rdps_beg_info, VK_SUBPASS_CONTENTS_INLINE);

            vkCmdBindPipeline(cmd_buf, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);
            VkViewport viewport{};
            viewport.x = 0.0f;
            viewport.y = 0.0f;
            viewport.width = 700;
            viewport.height = 500;
            viewport.minDepth = 0.0f;
            viewport.maxDepth = 1.0f;
            vkCmdSetViewport(cmd_buf, 0, 1, &viewport);
            VkRect2D scissor{};
            scissor.offset = {0, 0};
            scissor.extent.width = 700;
            scissor.extent.height = 500;
            vkCmdSetScissor(cmd_buf, 0, 1, &scissor);
            VkDeviceSize offset = 0;
            vkCmdBindVertexBuffers(cmd_buf, 0, 1, &vtx_buf, &offset);
            vkCmdBindIndexBuffer(cmd_buf, idx_buf, 0, VK_INDEX_TYPE_UINT32);
            // vkCmdDrawIndexed(cmd_buf, 9, 1, 0, 0, 0);
            vkCmdDraw(cmd_buf, 9, 1, 0, 0);

        vkCmdEndRenderPass(cmd_buf);

    result = vkEndCommandBuffer(cmd_buf);

    vkResetFences(device, 1, &fence_queue_submit);
    VkSubmitInfo submit_info{};
    submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submit_info.signalSemaphoreCount = 1;
    submit_info.pSignalSemaphores = &sem_finish_rendering;
    submit_info.waitSemaphoreCount = 1;
    submit_info.waitSemaphoreCount = 0;
    submit_info.pWaitSemaphores = &sem_img_available;
    submit_info.commandBufferCount = 1;
    submit_info.pCommandBuffers = &cmd_buf;
    VkPipelineStageFlags pipeline_stage_flags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    submit_info.pWaitDstStageMask = &pipeline_stage_flags;
    vkQueueSubmit(queue, 1, &submit_info, fence_queue_submit);

    VkPresentInfoKHR prst_info{};
    prst_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
    prst_info.swapchainCount = 1;
    prst_info.pSwapchains = &swpch;
    prst_info.pImageIndices = &available_img_idx;
    prst_info.waitSemaphoreCount = 1;
    prst_info.pWaitSemaphores = &sem_finish_rendering;
    vkQueuePresentKHR(queue, &prst_info);
    ```

    不清楚这里的`rdps_beg_info.renderArea.offset`和`rdps_beg_info.renderArea.extent`是干嘛用的，理论上和后面的 viewport 和 scissor 功能重合了。

    vulkan 画一个三角形，根本用不到 descriptor set 和 uniform buffer。

* 暴露的接口越多，代码越底层，可组合的方式就越多，功能越强大，编程越繁琐难用

    可见代码量也是评价一个库是否好用的参考标准

    反过来想，如果要实现一个功能，拆分了代码后，并不能增加可组合的方式，那么它就一定是需要优化的。

    比如 vulkan，虽然比 opengl 繁琐，但是完全支持异步，多线程，这就是拆分功能的代价。

* 冒泡排序

    ```cpp
    #include <iostream>
    #include <random>
    #include <algorithm>
    using namespace std;

    int main()
    {
        int arr[10];
        for (int i = 0; i < 10; ++i)
            arr[i] = i;
        shuffle(arr, arr+10, mt19937(random_device{}()));
        
        for (int num: arr)
            printf("%d, ", num);
        putchar('\n');

        for (int i = 0; i < 9; ++i)
        {
            for (int j = 0; j < 9; ++j)
            {
                if (arr[j] > arr[j+1])
                    swap(arr[j], arr[j+1]);
            }
        }

        for (int num: arr)
            printf("%d, ", num);
        putchar('\n');
        return 0;
    }
    ```

    第`0`轮排完，最后一个数一定是最大的，即最后`1`**个**数是排好的。

    第`1`轮排完，最后两个数是最大的，即最后`2`**个**数是排好的，并且排好的区间的左界一定大于左界之外的所有数。（假设所有数都不重复）

    由此可以归纳出猜想：第`i`轮排完，最后`i+1`个数是排好的。

    当剩 2 个数没排时，这 2 个数比排好的数都小，但是这 2 个数的大小关系未知，还得再排一次。

    当只剩 1 个数没排时，它一定是最小的，不需要再排了。

    因此我们要排好`n-1`个数。应用前面归纳出的猜想，当`i+1 = n-1`时，`i = n-2`，那么只需要排完第`n - 2`轮就可以了。

    也就是说，`i`的取值范围为`[0, n-2]`，一共排`n-1`轮。

    这是一个序数与基数之间的归纳猜想，可以看出即使是冒泡排序，也有一定的复杂性。

    我们可以把序数`i`直接換成基数“轮数”。即第 1 轮排完，最后 1 个数是最大的；第 2 轮排完，最后 2 个数是最大的。

    第`n`轮排完，最后`n`个数是最大的。我们只需要排`n-1`个数，因此需要排`n-1`轮。

    当`i`的取值范围为`[0, n-1]`时，共执行`n`轮。要想执行`n-1`轮，只需要让`i`取到`n-2`就可以了。

    这样稍微简单一点。

    大部分的算法题都是这样归纳出猜想以节约时间，是否有更好的分析方法？

* 归并排序

    ```cpp
    #include <iostream>
    #include <random>
    #include <algorithm>
    using namespace std;

    void merge_sort(int arr[10], int left, int right)
    {
        if (right - left + 1 <= 1)
            return;

        int mid_idx = left + (right - left) / 2;
        merge_sort(arr, left, mid_idx);
        merge_sort(arr, mid_idx+1, right);
        int i = left, j = mid_idx + 1, p = 0;
        int *temp = (int*) malloc(right - left + 1);
        while (i <= mid_idx && j <= right)
        {
            if (arr[i] < arr[j])
                temp[p++] = arr[i++];
            else
                temp[p++] = arr[j++];
        }
        while (i <= mid_idx)
            temp[p++] = arr[i++];
        while (j <= right)
            temp[p++] = arr[j++];
        for (p = 0; p < right - left + 1; ++p)
            arr[left + p] = temp[p];
        free(temp);
    }

    int main()
    {
        int arr[10];
        for (int i = 0; i < 10; ++i)
            arr[i] = i;
        shuffle(arr, arr+10, mt19937(random_device{}()));

        for (int num: arr)
            printf("%d, ", num);
        putchar('\n');
        
        merge_sort(arr, 0, 9);

        for (int num: arr)
            printf("%d, ", num);
        putchar('\n');
        return 0;
    }
    ```

    一些边界条件没想清楚：

    * `int mid_idx = left + (right - left) / 2;`

        这一行为什么能保证最后一定是左右两个区间长度分别为`[0, 1], [1, 0], [1, 1]`这三种情况？

    * `while (i <= mid_idx && j <= right)`

        这一行是否可以保证，left 和 right 的长度最多只差 1？

        如果左右两个区间的长度最大只差 1，那么后面的两行

        ```cpp
        while (i <= mid_idx)
        while (j <= right)
        ```

        就可以不这么写了。

    归并排序其实是一个后序遍历的树，因为只有处理完了当前节点的两个子节点，才能去归并当前节点。

* opencl build in functions

    * `get_work_dim`

        syntax:

        ```c
        uint get_work_dim()
        ```

    * `get_global_size`

        syntax:

        ```c
        size_t get_global_size(uint dimindx)
        ```

    * `get_global_id`

        ```c
        size_t get_global_id(uint dimindx)
        ```

    * `get_num_groups`

        ```c
        size_t get_num_groups(uint dimindx)
        ```

    * `get_group_id`

        ```c
        size_t get_group_id(uint dimindx)
        ```

    * `get_local_id`

        ```c
        size_t get_local_id(uint dimindx)
        ```
    
    * `get_local_size`

        ```c
        size_t get_local_size(uint dimindx)
        ```
    
    opencl 中的三角函数都是以弧度为单位。

    `gentype acospi(gentype x)`计算的是`acos(x) / PI`。

    比如`acospi(0.5)`，先计算出来弧度为`PI/3`，再把这个数除以`PI`，得到`1/3`。

    * `gentype atan(gentype y_over_x)`

        试了一下，这里的`y`指的是直角三角形的对边，`x`指的是另一条直角边。

        输入的参数是`y / x`。

    * `gentype cbrt(gentype x)`

        求立方根。

        C 的数学库里也有这个函数。之前竟然都不知道。

    * `gentype copysign(gentype x, gentype y)`

        将`x`的符号变成和`y`一样。

    * `gentype fmax(gentype x,gentype y)`

        Returns y if x < y; otherwise it returns x. If one argument is a NaN, fmax() returns the other argument.
        
        If both arguments are NaNs, fmax() returns a NaN.

    * `gentype logb(gentype x)`

        Compute the exponent of x, which is the integral part of logr|x|.

        不知道这里的`r`是什么意思。

    * `gentype rint(gentype x)`

        按四舍五入法将小数转换成整数。

        如果是`x.5`，似乎只会舍入到偶数。比如`0.5`变成`0`，`1.5`变成 2.

    * `gentype rootn(gentype x, intn y)`

        Compute x to the power 1/y.

    * `gentype round(gentype x)`

        严格执行四舍，五入

    * `gentypef half_cos(gentypef x)`

        Compute the cosine of x. x must be in the range `[-2^16… +2^16]`.

        这里的`x`仍是浮点数，不清楚`2^16`这个数字是怎么来的。

        `half`可能指的是半精度。

    常用的常量：

    * `M_E_F`, `M_E`

        Value of e

    * `M_PI_F`, `M_PI`

        Value of pi

    * `M_1_PI_F`, `M_1_PI`

        Value of 1/pi

* 如果遇到的知识是条目式的，没有理解难度，但是数量比较大，是否该将其列入到记忆任务中？还是说调研时先跳过？

* opencl 中内置函数的运算有一定的误差，官方文档给出了误差上界

    比如

    `1.0f/x`的误差为`<= 2.5 ulp`

    `cos`的误差为`<= 4 ulp`

    `fabs`的误差为`0 ulp`

    其中`ulp`指的是两个相邻最近的离散值的距离。

* opencl 中的浮点数和整数用的是两套函数

    比如整数的绝对值用的是

    `ugentype abs(gentype x)`

    如果使用`abs(1.0);`，则会在编译时报错。

* opencl 中一些常见的宏

    ```c
    #define CHAR_BIT 8
    #define INT_MAX 2147483647
    #define LONG_MIN (-0x7fffffffffffffffL – 1)
    #define SCHAR_MAX 127
    #define SHRT_MIN (-32767 – 1)
    #define UCHAR_MAX 255
    #define UINT_MAX 0xffffffff
    ```

* 正则表达式的一些 example

    | 正则表达式 | 对应的字符串类型 |
    | - | - |
    | `if` | `{return IF;}` |
    | `[a-z][a-z0-9]*` | `{return ID;}` |
    | `[0-9]+` | `{return NUM;}` |
    | `([0-9]+"."[0-9]*)|([0-9]*"."[0-9]+)` | `{return REAL;}` |
    | `("--"[a-z]*"\n")|(" "|"\n"|"\t")+` | `{ /* do nothing */ }`|
    | `.` | `{ error(); }` |

    这里比较有意思的是`REAL`这一行。正则表达式有点像填空，每个位置上，一个 pattern 可能出现零次，一次，或多次。但是一个位置上 pattern 的出现与否，并不影响另外位置上的 pattern 是否出现。因此如果要约束两个位置上只能是`(0, 1), (1, 0), (1, 1)`，而不能是`(0, 0)`，那么就只能写两遍，就像 real 那一行那样。

    注意最后一行的`.`并不是字符串句号，而是句点符号，表示除換行符之外的任意单个字符。

* 正则表达式的一些缩写

    `[abcd]`表示`(a|b|c|d)`

    `[b-g]`表示`[bcdefg]`

    `[b-gM-Qkr]`表示`[bcdefgMNOPQkr]`

    $M?$表示$(M | \epsilon)$

    $M^+$表示$(M \cdot M^*)$

    这些缩写只是为了方便，并没有增加正则表达式的描述能力。

    