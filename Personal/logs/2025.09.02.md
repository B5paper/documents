* `dma_set_mask_and_coherent()`

    设置 DMA 掩码。检查并告知内核：当前设备（通常是 PCIe、USB 等外设）能够访问的系统物理地址范围。确保 DMA 操作的安全性和正确性：防止设备尝试访问超出其寻址能力的物理地址，从而导致数据损坏或系统崩溃。

    并非所有硬件设备都支持 64 位物理地址寻址。一些较老或成本较低的设备可能只支持 32 位（即 4GB）甚至更小的地址空间。

    syntax:

    ```c
    int dma_set_mask_and_coherent(struct device *dev, u64 mask);
    ```

    * mask: 一个位掩码，表示设备支持的地址位。例如，0xFFFFFFFF 表示 32 位掩码（支持 4GB 以下地址），`DMA_BIT_MASK(64)` 表示 64 位掩码（支持全部 64 位地址）。

    返回值：

    * 成功时返回 0。

    * 失败时返回非零值（通常是`-EIO`），表示平台无法在该掩码下支持 DMA。例如，在一个不支持 64 位 DMA 的系统上尝试设置 64 位掩码可能会失败。

    example:

    ```c
    struct device *dev = &my_pci_dev->dev;
    u64 dma_mask = DMA_BIT_MASK(64); // 假设我们的设备支持 64 位 DMA

    if (dma_set_mask_and_coherent(dev, dma_mask)) {
        // 64 位 DMA 设置失败，尝试回退到 32 位
        dev_warn(dev, "64-bit DMA not supported, trying 32-bit\n");
        if (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32))) {
            dev_err(dev, "No usable DMA configuration found\n");
            return -EIO;
        }
    }
    ```

    dma_set_mask_and_coherent() 实际上一次性设置了两个掩码：（未看懂）

    * 流式 DMA 掩码 (DMA Mask)：

        用于“流式” DMA 映射（dma_map_single 等）。

        这种映射通常是短期、一次性的，缓存一致性通常由软件显式维护（如手动刷缓存）。

        内核会确保为流式 DMA 分配的内存地址落在设备声明的这个地址范围内。

    * 一致性 DMA 掩码 (Coherent DMA Mask)：

        用于“一致性” DMA 映射（dma_alloc_coherent 等）。

        这种映射是长期存在的，硬件和 CPU 都可以无障碍地访问，缓存一致性由硬件自动维护。

        内核会确保为一致性 DMA 分配的内存地址同样落在设备声明的这个地址范围内。

    `dma_set_mask_and_coherent()`确保了：

    * 内核不会为 DMA 操作分配设备无法访问的内存地址。

        （内核只能分指定范围内的地址）

    * 设备驱动能够安全、可靠地执行 DMA 数据传输，充分发挥设备性能。

        （设备只能访问只能范围内的地址）

    辅助宏：

    ```c
    #define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : (1ULL<<(n))-1)
    ```

    * `DMA_BIT_MASK(32)` 生成 0x00000000FFFFFFFF

    * `DMA_BIT_MASK(64)` 生成 0xFFFFFFFFFFFFFFFF

* ai 的另一个作用是，熟人里专业与专业相差太远，自己的专业别人不一定懂，遇到问题只能自己瞎想，无法与别人交流。豆瓣的小组、学术圈的 workshop 从一定程度上改善了这个问题，但问题仍然存在。有了 ai 可以简单聊几句，虽然不一定能解答，但是起码有思路有方向了，基本不存在交流困难这个问题了。

* `dev_set_drvdata()`, `dev_get_drvdata()`

    从 struct device 对象中获取其关联的驱动私有数据（private driver data）的指针.

    syntax:

    ```c
    void dev_set_drvdata(struct device *dev, void *data);

    void *dev_get_drvdata(const struct device *dev);
    ```

    返回值:

    * `void *`: 成功则返回之前通过`dev_set_drvdata()`设置的指针。

    * 如果之前没有设置过，或者 dev 为 NULL，则返回 NULL。

    其实`dev_set_drvdata()`本质是把一个指针和一个 dev 关联起来，这样用户可以在`struct my_device_data`里定义自己需要管理的设备状态、数据（比如 dma 的地址和大小）、控制同步的锁等等。这些资源如果定义成全局的，不是不可以，但是最后还是得用户去关联到 dev，非常麻烦。

    example:

    ```c
    /* 1. 驱动自定义的私有数据结构 */
    struct my_device_data {
        int irq;
        void __iomem *regs;
        spinlock_t lock;
        // ... 其他设备特定字段
    };

    /* 2. 在 probe 函数中设置驱动数据 */
    static int my_driver_probe(struct device *dev)
    {
        struct my_device_data *priv;

        priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
        if (!priv)
            return -ENOMEM;

        // 初始化 priv 结构...
        priv->irq = platform_get_irq(...);
        priv->regs = devm_ioremap_resource(...);

        // !!! 关键步骤：将 priv 指针存储到 dev 中 !!!
        dev_set_drvdata(dev, priv);

        return 0;
    }

    /* 3. 在其它函数中获取驱动数据 */
    static void my_driver_do_something(struct device *dev)
    {
        // !!! 关键步骤：从 dev 中取回 priv 指针 !!!
        struct my_device_data *priv = dev_get_drvdata(dev);

        if (!priv) {
            dev_err(dev, "No driver data found!\n");
            return;
        }

        // 现在可以使用 priv 来访问设备特定数据了
        writel(0xAA55, priv->regs + SOME_REG_OFFSET);
    }

    /* 4. 在 remove 函数中获取并清理 */
    static int my_driver_remove(struct device *dev)
    {
        struct my_device_data *priv = dev_get_drvdata(dev);

        // 使用 priv 进行资源清理...
        // devm_* 函数会自动清理，所以这里可能不需要做太多

        // 通常不需要手动将 drvdata 设置为 NULL，因为 dev 本身即将被销毁
        // 但显式设置是个好习惯
        dev_set_drvdata(dev, NULL);

        return 0;
    }
    ```

    如果`struct my_device_data`指针由`dma_set_mask_and_coherent()`赋予，并且只存储 binary 数据，那么也完全可以把这里当作一个 buffer。binary 数据中，可能会有字节序（Endianness）的问题，需要注意。