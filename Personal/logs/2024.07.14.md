* ib core 是通过下面的代码访问到 port 相关的属性/数据的

    `device->port_data[port_num].pkey_list`

* `ibv_get_device_list()`, `ibv_open_device()`这些函数都属于 umd 的内容

    通过于 sysfs 交互返回信息。

* umd 通过 ioctl 调用 kmd 中定义好的接口函数

    包括 create qp，create cq 这些

* linux driver 中的 read 返回的是已经处理的字节数

    如果返回的未处理的字节数大于 0，那么`cat`会无限循环调用 read 读取数据。

    如果 write 函数返回的字节数小于需要处理的字节数，那么`echo xxx > /dev/hlc_dev`也会无限循环调用 write 写入数据。

* ioctl 是阻塞执行的

* 将 ipv4 地址从字符串转化为 uint32_t

    ```c
    struct in_addr inaddr;
    inet_pton(AF_INET, serv_addr, &inaddr);
    ```

    这个转换好直接就是大端序的，不需要再`htonl()`了。

    头文件：

    ```c
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    ```

* [ ] 调研 ib verbs umd 如何通过 ioctl 调用到 aux driver 中的 ops

* [ ] 调研 sysfs 读写，sync