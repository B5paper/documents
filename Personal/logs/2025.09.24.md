* const 指针不允许 free()

    example:

    ```c
    #include <stdlib.h>
    #include <stdio.h>

    int main() {
        char *real_path = realpath("./", NULL);
        printf("real path: %s\n", real_path);
        free(real_path);
        return 0;
    }
    ```

    这里`real_path`不能是`const char*`。

* 基址寄存器（BARs）

    当电脑开机时，BIOS或操作系统会遍历所有PCIe设备，读取每个BAR的需求。然后，系统会统一规划，为每个设备的BAR分配一个实际的、唯一的起始内存地址（即“基址”），并把这个地址写回BAR中。此后，当CPU需要访问该设备时，只需从BAR指定的基址开始，进行读写操作即可。

    BAR中存储的值，是 CPU 视角下的总线地址（在x86体系结构中也常称为物理地址）。

    分配 bar 的过程：

    1. 初始值（设备声明）：在系统分配之前，BAR中存放的并不是一个有效的地址，而是一个特殊的值，用于声明该设备所需地址空间的类型（是内存空间还是I/O空间）和大小。例如，设备会将某些位写为只读的1，系统软件通过读取并操作这些值，可以计算出设备需要多大的窗口。

    2. 最终值（系统分配）：在系统启动（或设备热插拔）时，BIOS或操作系统会执行以下操作：

        * 读取所有PCIe设备的BAR初始值，了解每个设备的需求。

        * 在全局物理地址空间中，找出一段段未被占用的、大小合适的空闲区域。

        * 将每个空闲区域的起始地址（即基址）写入到对应设备的BAR中。

* 需要实现 asso 任务的重排序，以及接下来的任务的重排序

    不然可能难而无法完成的任务总是放在轻松且易完成任务的上面。

* vscode sync scroll

    vscode 中同时滚动左右两个分栏

    extension name: `Sync Scroll`

    安装完后，`Ctrl` + `Shift` + `P`打开命令栏，搜索 sync scroll，会看到一个 change sync scroll mode，选择之后，会有三个选项:

    * normal

        保持左右两栏行数相同。

    * offset

        保持左右两栏滚动相同的距离

    * off

    在 vscode 右下角也会有当前 sync scroll 模式的状态。

* makefile 中的 +=

    在 Makefile 中，+= 是追加赋值运算符，用于向变量追加新内容，而不是替换原有内容。

    `+=`会忽略左右的空格，甚至会忽略右侧的所有空白分隔符（空格，制表以及换行）

    example:

    ```makefile
    msg = nihao
    msg += hello world

    msg_2 = nihao
    msg_2 +=hello world

    msg_3 = nihao
    msg_3 +=    hello world

    msg_4 = nihao
    msg_4 = hello	world\
    zaijian


    test:
    	@echo $(msg)
    	@echo $(msg_2)
    	@echo $(msg_3)
    	@echo $(msg_4)
    ```

    output:

    ```
    nihao hello world
    nihao hello world
    nihao hello world
    hello world zaijian
    ```

* cuda 矩阵乘的 example

    假设我们要计算：

    C = A * B

    其中 A 是 M x K 的矩阵，B 是 K x N 的矩阵，那么结果 C 就是 M x N 的矩阵。

    example:

    ```cpp
    #include <stdio.h>
    #include <stdlib.h>
    #include <cuda_runtime.h>
    #include <assert.h>

    // CUDA 矩阵乘法内核函数
    __global__ void matrixMultiplyKernel(float* A, float* B, float* C, 
                                       int M, int N, int K) {
        // 计算当前线程负责的结果矩阵位置
        int row = blockIdx.y * blockDim.y + threadIdx.y;
        int col = blockIdx.x * blockDim.x + threadIdx.x;
        
        // 检查是否在有效范围内
        if (row < M && col < N) {
            float sum = 0.0f;
            // 计算A的第row行和B的第col列的点积
            for (int i = 0; i < K; i++) {
                sum += A[row * K + i] * B[i * N + col];
            }
            C[row * N + col] = sum;
        }
    }

    // CPU版本的矩阵乘法，用于验证结果
    void matrixMultiplyCPU(float* A, float* B, float* C, int M, int N, int K) {
        for (int row = 0; row < M; row++) {
            for (int col = 0; col < N; col++) {
                float sum = 0.0f;
                for (int i = 0; i < K; i++) {
                    sum += A[row * K + i] * B[i * N + col];
                }
                C[row * N + col] = sum;
            }
        }
    }

    // 比较两个矩阵是否相等（允许一定的误差）
    bool compareMatrices(float* A, float* B, int size, float tolerance = 1e-5f) {
        for (int i = 0; i < size; i++) {
            if (fabs(A[i] - B[i]) > tolerance) {
                printf("Mismatch at index %d: CPU=%f, GPU=%f\n", i, A[i], B[i]);
                return false;
            }
        }
        return true;
    }

    // 初始化矩阵
    void initializeMatrix(float* matrix, int rows, int cols) {
        for (int i = 0; i < rows * cols; i++) {
            matrix[i] = static_cast<float>(rand() % 10); // 0-9的随机数
        }
    }

    // 打印矩阵（小矩阵用于调试）
    void printMatrix(float* matrix, int rows, int cols, const char* name) {
        printf("%s:\n", name);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                printf("%6.2f ", matrix[i * cols + j]);
            }
            printf("\n");
        }
        printf("\n");
    }

    int main() {
        // 矩阵维度
        const int M = 512;  // A的行数，C的行数
        const int K = 256;  // A的列数，B的行数  
        const int N = 384;  // B的列数，C的列数
        
        printf("Matrix Multiplication: A(%d x %d) * B(%d x %d) = C(%d x %d)\n", 
               M, K, K, N, M, N);
        
        // 分配主机内存
        size_t size_A = M * K * sizeof(float);
        size_t size_B = K * N * sizeof(float);
        size_t size_C = M * N * sizeof(float);
        
        float* h_A = (float*)malloc(size_A);
        float* h_B = (float*)malloc(size_B);
        float* h_C = (float*)malloc(size_C);      // GPU结果
        float* h_C_CPU = (float*)malloc(size_C);  // CPU结果（用于验证）
        
        // 初始化矩阵
        srand(2024); // 固定随机种子以便重现结果
        initializeMatrix(h_A, M, K);
        initializeMatrix(h_B, K, N);
        
        // 分配设备内存
        float *d_A, *d_B, *d_C;
        cudaMalloc(&d_A, size_A);
        cudaMalloc(&d_B, size_B);
        cudaMalloc(&d_C, size_C);
        
        // 拷贝数据到设备
        cudaMemcpy(d_A, h_A, size_A, cudaMemcpyHostToDevice);
        cudaMemcpy(d_B, h_B, size_B, cudaMemcpyHostToDevice);
        
        // 配置线程块和网格维度
        dim3 blockSize(16, 16); // 256个线程 per block
        dim3 gridSize((N + blockSize.x - 1) / blockSize.x, 
                      (M + blockSize.y - 1) / blockSize.y);
        
        printf("Grid: (%d, %d), Block: (%d, %d)\n", 
               gridSize.x, gridSize.y, blockSize.x, blockSize.y);
        
        // 创建CUDA事件用于计时
        cudaEvent_t start, stop;
        cudaEventCreate(&start);
        cudaEventCreate(&stop);
        
        // 执行GPU计算
        cudaEventRecord(start);
        matrixMultiplyKernel<<<gridSize, blockSize>>>(d_A, d_B, d_C, M, N, K);
        cudaEventRecord(stop);
        
        // 等待内核执行完成
        cudaEventSynchronize(stop);
        
        // 计算GPU运行时间
        float gpuTime = 0.0f;
        cudaEventElapsedTime(&gpuTime, start, stop);
        
        // 拷贝结果回主机
        cudaMemcpy(h_C, d_C, size_C, cudaMemcpyDeviceToHost);
        
        // 执行CPU计算并计时
        clock_t cpuStart = clock();
        matrixMultiplyCPU(h_A, h_B, h_C_CPU, M, N, K);
        clock_t cpuEnd = clock();
        double cpuTime = ((double)(cpuEnd - cpuStart)) / CLOCKS_PER_SEC * 1000.0;
        
        // 验证结果
        bool resultsMatch = compareMatrices(h_C, h_C_CPU, M * N);
        
        // 输出结果
        printf("\n=== 性能结果 ===\n");
        printf("GPU Time: %.2f ms\n", gpuTime);
        printf("CPU Time: %.2f ms\n", cpuTime);
        printf("Speedup: %.2fx\n", cpuTime / gpuTime);
        printf("Results Match: %s\n", resultsMatch ? "Yes" : "No");
        
        // 打印前3x3部分结果（对于大矩阵）
        if (M >= 3 && N >= 3) {
            printf("\n=== 前3x3结果验证 ===\n");
            printf("GPU Result (top-left 3x3):\n");
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    printf("%8.2f ", h_C[i * N + j]);
                }
                printf("\n");
            }
            
            printf("\nCPU Result (top-left 3x3):\n");
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    printf("%8.2f ", h_C_CPU[i * N + j]);
                }
                printf("\n");
            }
        }
        
        // 清理资源
        free(h_A);
        free(h_B);
        free(h_C);
        free(h_C_CPU);
        cudaFree(d_A);
        cudaFree(d_B);
        cudaFree(d_C);
        cudaEventDestroy(start);
        cudaEventDestroy(stop);
        
        printf("\nDemo completed successfully!\n");
        return 0;
    }
    ```

    output:

    ```
    Matrix Multiplication: A(512 x 256) * B(256 x 384) = C(512 x 384)
    Grid: (24, 32), Block: (16, 16)

    === 性能结果 ===
    GPU Time: 0.07 ms
    CPU Time: 167.03 ms
    Speedup: 2298.38x
    Results Match: Yes

    === 前3x3结果验证 ===
    GPU Result (top-left 3x3):
     5172.00  5910.00  5610.00 
     4534.00  4625.00  4653.00 
     4819.00  5186.00  5153.00 

    CPU Result (top-left 3x3):
     5172.00  5910.00  5610.00 
     4534.00  4625.00  4653.00 
     4819.00  5186.00  5153.00 

    Demo completed successfully!
    ```

* `sudo lsof /dev/shm/nccl-AoFK4o`

    用于查看正在使用特定 NCCL 共享内存文件的进程信息。

    lsof: "list open files" - 列出打开文件的工具

    输出列的含义：

        COMMAND: 使用该文件的进程名称（如 python3, train.py 等）

        PID: 进程 ID

        USER: 进程所有者

        FD: 文件描述符（mem 表示内存映射文件）

        TYPE: 文件类型（REG 表示常规文件）

        SIZE/OFF: 文件大小

        NODE: 文件节点号

        NAME: 文件名