* const 指针不允许 free()

    example:

    ```c
    #include <stdlib.h>
    #include <stdio.h>

    int main() {
        char *real_path = realpath("./", NULL);
        printf("real path: %s\n", real_path);
        free(real_path);
        return 0;
    }
    ```

    这里`real_path`不能是`const char*`。

* 基址寄存器（BARs）

    当电脑开机时，BIOS或操作系统会遍历所有PCIe设备，读取每个BAR的需求。然后，系统会统一规划，为每个设备的BAR分配一个实际的、唯一的起始内存地址（即“基址”），并把这个地址写回BAR中。此后，当CPU需要访问该设备时，只需从BAR指定的基址开始，进行读写操作即可。

    BAR中存储的值，是 CPU 视角下的总线地址（在x86体系结构中也常称为物理地址）。

    分配 bar 的过程：

    1. 初始值（设备声明）：在系统分配之前，BAR中存放的并不是一个有效的地址，而是一个特殊的值，用于声明该设备所需地址空间的类型（是内存空间还是I/O空间）和大小。例如，设备会将某些位写为只读的1，系统软件通过读取并操作这些值，可以计算出设备需要多大的窗口。

    2. 最终值（系统分配）：在系统启动（或设备热插拔）时，BIOS或操作系统会执行以下操作：

        * 读取所有PCIe设备的BAR初始值，了解每个设备的需求。

        * 在全局物理地址空间中，找出一段段未被占用的、大小合适的空闲区域。

        * 将每个空闲区域的起始地址（即基址）写入到对应设备的BAR中。

* 需要实现 asso 任务的重排序，以及接下来的任务的重排序

    不然可能难而无法完成的任务总是放在轻松且易完成任务的上面。

* vscode sync scroll

    vscode 中同时滚动左右两个分栏

    extension name: `Sync Scroll`

    安装完后，`Ctrl` + `Shift` + `P`打开命令栏，搜索 sync scroll，会看到一个 change sync scroll mode，选择之后，会有三个选项:

    * normal

        保持左右两栏行数相同。

    * offset

        保持左右两栏滚动相同的距离

    * off

    在 vscode 右下角也会有当前 sync scroll 模式的状态。