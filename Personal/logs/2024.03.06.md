* vulkan 在创建 renderpass 和 pipeline 时，并不涉及到 frame buffer

    在 cmd draw 的时候，才会用到 frame buffer

* 在`VkBufferCreateInfo`中，如果`sharingMode`是`VK_SHARING_MODE_EXCLUSIVE`，那么`queueFamilyIndexCount`可以直接写 0，当然`pQueueFamilyIndices`也不用填了。

* vulkan 的 fence 在创建时要加一个`VK_FENCE_CREATE_SIGNALED_BIT`的 flag，表示一开始就能对它使用 wait。

    其实 fence 也是一个 semaphore。

* c++ 中，对于模板函数，即使通用类型在参数列表中消失，也算函数的重载

    但是实际无法正常调用，因为无法推导出`T`的类型：

    ```cpp
    #include <iostream>
    using namespace std;

    template<typename T>
    void print(int a, int b)
    {
        cout << a << ", " << b << endl;
    }

    template<typename T>
    void print(int a, int b, T c)
    {
        cout << a << ", " << b << ", " << c << endl;
    }

    int main()
    {
        print(1, 2, 3);  // OK
        print(4, 5);  // Error
        print<int>(4, 5);  // OK, T = int
        return 0;
    }
    ```

    比如上面的代码，`void print(int a, int b)`的参数列表并没有给出`T`，所以尽管它算作`print()`的一个重载，但是后面的代码`print(4, 5);`并不能通过编译，因为无法推导出`T`的类型。

    如果我们像这样`print<int>(4, 5);`指定了`T`的类型，那么是可以正常运行的。

* 图论里，如果已知一个 node，需要知道和这个 node 相连的边的情况，那么用链表是最优选择。

    如果已知两个 node，需要知道这两个 node 之间的边的情况，那么用矩阵是最优选择。

    如果既需要知道某个 node 有哪些边，又需要快速查询两个 node 之间是否相连，可以同时使用这两种结构。