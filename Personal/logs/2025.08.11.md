 * note

    ```cpp
    // XmlTag 会自动扩容，这里存的指针会发生改变
    // 树形结构无法存索引
    // 因此如果一个树形结构，既在增长过程，又需要 vector 临时存指针，
    // 那么树形结构的每个节点就必须使用 malloc 来申请，否则
    // vector 中的指针会发生改变
    vector<XmlTag*> silink_tag_records;
    ```

* note 2

    ```cpp
    // 设置为 const 后，自动变为 private，这样如果有多个 .o 文件都编译了
    // 这个对象，不会重名报错。因为这里面的数据不会改变，所以不需要设置为
    // 跨文件的全局变量，也用不到 extern
    const LookupTable<int, const char*> Vert_Type_Id_to_Str {
    ```

* note 3

    ```cpp
    // vert id 由用户选择填写，无论是使用索引还是使用哈希等算法
    // 这里返回指针，使得外部的指针可以反复赋值，如果用引用就无法反复赋值了
    // 想了下，返回指针，如果真的反复赋值，前面的指针又会被丢掉，和引用一个下场
    // 那么返回引用也行
    Vertex& add_vert() {
    ```

* note 4

    ```cpp
    // ncclNvmlDevicePairs 在 nvml 中，是个 (32, 32) 的数组，其中填充了
    // 任意两个 gpu dev 之间的 p2p status
    // 这样看来，dev 其实就是设备的物理编号，nccl 中和 nvml 中保持相同的含义
    // nvml 只处理设备的物理编号
    // status = ncclNvmlDevicePairs[indexes[i-1]][indexes[i-0]].p2pStatusRead;
    ```

* note 5

    ```cpp
    // hops 表示的是，从当前节点出发，需要经过 hops 节点，才能到达指定节点
    // 比如 vert 0 -> vert 1 -> vert 2 -> vert 3
    // 那么 vert 0 到 vert 3 的 hops 就是 3
    int hops = gpu_to_cpu_paths[cpu_vert_idx].edge_list.size();
    ```

* note 6

    ```cpp
                // 为什么两个 gpu 之间一定要经过 cpu？
                // nic / net 是一定经过 cpu 的，host 中转也一定经过 cpu
                // 如果中间节点是 pci，那 p2p_active == 0 就不成立了
                // nvlink 更不可能，所以一定要经过 cpu
                ret = add_inter_step(topo_system, CPU,
                    cpu_idx, GPU, vert_idx_2, GPU, vert_idx_1);
    ```

* note 7

    ```cpp
        // 从这里可以看出，rank 是对 peerInfo 的编号
        // 对比前面的，我们知道 dev 是物理编号
        PeerInfo* dstInfo = &comm.peerInfo[topo_system.nodes[GPU][vert_idx_1]->gpu.rank];
    ```

* note 8

    ```cpp
    // 如果 val 是 2 的整数次幂（1, 2, 4, 8, 16, ...），则返回 true
    bool isPow2(int val) {
        return (val & (val-1)) == 0;
    }
    ```

* note 9

    ```cpp
    // pow2 用二进制表示为
    // 1, 10, 100, 1000, 10000, 100000, ...
    // 这样就既指定了位宽，又标记了最高位的 1，后面只需要将 pow2 的 1 一步一步往右移就可以了
    // 假如 pow2 = 8 = 0b1000，那么 val 的最大值就为 pow2 - 1 = 7 = 0b0111
    // val 的取值范围为 0 ~ 7
    // 此时如果 val = 0b0011，那么就把低位的 1 翻折到高位去，0b0110，
    // 注意并不是 0b1100，否则就超过 val 的最大可能取值了
    // 同理，如果 val = 0b0001，那么 mirror = 0b0100
    // 如果 val = 0b0111，那么 mirror 不变，仍为 mirror = 0b0111。
    int mirrorBits(int val, int pow2) {
        int mirror = 0;
        // mb 表示最高位的 1
        for (int b = 1, mb = (pow2>>1); b < pow2; b <<= 1, mb >>= 1) {
            // 如果 val 最低位为 1，那么 mirror 的最高位置 1
            if (val & b) {
                // |= 保护除了最高位之外的其他位不被改变
                mirror |= mb;
            }
        }
        return mirror;  //0b110;
    }

    ```

* note 10

    ```cpp
    // 这个实现了 x / y 向上取整，如果 x 正好是 y 的整数倍，那么不向上取整
    // 这个算法还挺巧妙的，如果写成
    // if (x % y == 0)
    //     res = x / y;
    // else
    //     res = x / y + 1;
    // 那么就太复杂了，没有 (x + y - 1) / y 简单
    // 目前不清楚这个算法是怎么想出来的
    #define DIVUP(x, y) \
        (((x)+(y)-1)/(y))

    int div_up(int x, int y) {
        return (x + y - 1) / y;
    }
    ```

* note 11

    ```cpp
    // bw = 0, 为什么？ graph->bwInter 为 0.119999997, bw 又为 int 类型，所以被四舍五入为 0
    const int bw = graph->bwInter;
    ```