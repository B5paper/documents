* note 8

    ```cpp
    // 如果 val 是 2 的整数次幂（1, 2, 4, 8, 16, ...），则返回 true
    bool isPow2(int val) {
        return (val & (val-1)) == 0;
    }
    ```

* note 9

    ```cpp
    // pow2 用二进制表示为
    // 1, 10, 100, 1000, 10000, 100000, ...
    // 这样就既指定了位宽，又标记了最高位的 1，后面只需要将 pow2 的 1 一步一步往右移就可以了
    // 假如 pow2 = 8 = 0b1000，那么 val 的最大值就为 pow2 - 1 = 7 = 0b0111
    // val 的取值范围为 0 ~ 7
    // 此时如果 val = 0b0011，那么就把低位的 1 翻折到高位去，0b0110，
    // 注意并不是 0b1100，否则就超过 val 的最大可能取值了
    // 同理，如果 val = 0b0001，那么 mirror = 0b0100
    // 如果 val = 0b0111，那么 mirror 不变，仍为 mirror = 0b0111。
    int mirrorBits(int val, int pow2) {
        int mirror = 0;
        // mb 表示最高位的 1
        for (int b = 1, mb = (pow2>>1); b < pow2; b <<= 1, mb >>= 1) {
            // 如果 val 最低位为 1，那么 mirror 的最高位置 1
            if (val & b) {
                // |= 保护除了最高位之外的其他位不被改变
                mirror |= mb;
            }
        }
        return mirror;  //0b110;
    }

    ```

* note 10

    ```cpp
    // 这个实现了 x / y 向上取整，如果 x 正好是 y 的整数倍，那么不向上取整
    // 这个算法还挺巧妙的，如果写成
    // if (x % y == 0)
    //     res = x / y;
    // else
    //     res = x / y + 1;
    // 那么就太复杂了，没有 (x + y - 1) / y 简单
    // 目前不清楚这个算法是怎么想出来的
    #define DIVUP(x, y) \
        (((x)+(y)-1)/(y))

    int div_up(int x, int y) {
        return (x + y - 1) / y;
    }
    ```

* note 11

    ```cpp
    // bw = 0, 为什么？ graph->bwInter 为 0.119999997, bw 又为 int 类型，所以被四舍五入为 0
    const int bw = graph->bwInter;
    ```
