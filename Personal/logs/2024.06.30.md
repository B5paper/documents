* `getopt()`

    linux 中处理 argc, argv 的函数。

    example:

    ```c
    #include <stdio.h>
    #include <unistd.h>

    int main(int argc, char **argv)
    {
        int opt;
        do {
            opt = getopt(argc, argv, "csp:");
            if (opt == -1)
                break;
            printf("opt: %c, optarg: %s\n", opt, optarg);
        } while (opt != -1);
        return 0;
    }
    ```

    运行：

    ```
    hlc@hlc-VirtualBox:~/Documents/Projects/cpp_test$ ./main -c
    opt: c, optarg: (null)
    hlc@hlc-VirtualBox:~/Documents/Projects/cpp_test$ ./main -s
    opt: s, optarg: (null)
    hlc@hlc-VirtualBox:~/Documents/Projects/cpp_test$ ./main -p
    ./main: option requires an argument -- 'p'
    opt: ?, optarg: (null)
    hlc@hlc-VirtualBox:~/Documents/Projects/cpp_test$ ./main -p 1234
    opt: p, optarg: 1234
    ```

    可以看到，对于格式`csp:`，当程序后跟的参数是`c`或`s`时，不需要再加额外的值。`p`的后面加了个冒号，表示`p`后面必须要跟一个参数值，否则就报错。

    具体的参数值可以使用`optarg`全局变量得到。

    如果解析结束，`getopt()`会返回`-1`.


    ref:

    1. Using getopt in C with non-option arguments
    
        <https://stackoverflow.com/questions/18079340/using-getopt-in-c-with-non-option-arguments>

    2. getopt(3) — Linux manual page

        <https://man7.org/linux/man-pages/man3/getopt.3.html>

    3. 12.17 getopt.h

        <https://www.gnu.org/software/gnulib/manual/html_node/getopt_002eh.html>
* 不`rdma_connect()`就无法 post send，但是可以 post recv

* 不处理 cm event 也无法 post send

* 如果一个 mr 有 remote 操作，那么它的内存必须在堆上申请

* metadata 只需要 local write access 就可以了

    真正的 buffer 才需要 remote read/write access

* `ibv_req_notify_cq()`是必须的，不然真不通知了

* 即使 get cq event 也不代表数据发送完了

    在 get cq event 后突然结束程序，对方仍然有可能没有收到数据

* rdma server 有 server cm id，还有 client cm id

    rdma client 只有一个 cm id

* 如果一方没有 post recv wr，另一方就直接 post send wr，那么发送的数据会丢失，而且 send 方还会返回 cq event

* 一开始一直 rdma read/write 不成功，主要是因为 send wr 的 opcode 没写对

* 在调用`getopt()`后，rdma qp 就无法创建成功了

* NIC 指网卡，Network interface controller

* max 地址表示为 12 个十六进制数

* MTU (maxmimum transmission unit，最大传输单元)指的是数据链路层上能通过的最大负载的大小，单位为字节

    标准心碎网的 MTU 为 1500。

    如果 IP 层有数据包要发送，而数据包的长度超过了 MTU，IP 层就要对数据包进行分片（fragmentation）操作。

* 缓存（cache）使用的是静态随机存储（static random access memory, SRAM）

