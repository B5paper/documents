* ptx tmp

    * The NVIDIA GPU architecture is built around a scalable array of multithreaded Streaming Multiprocessors (SMs).

    * A multiprocessor consists of multiple Scalar Processor (SP) cores, a multithreaded instruction unit, and on-chip shared memory. It implements a single-instruction barrier synchronization.

        The multiprocessor maps each thread to one scalar processor core, and each scalar thread executes independently with its own instruction address and register state. 

        每个 sp 对应一个线程吗？

    * The multiprocessor SIMT unit creates, manages, schedules, and executes threads in groups of parallel threads called warps. (This term originates from weaving, the first parallel thread technology.)

        simt unit 指的是管理多个 sp 的组件吗？

    * When a multiprocessor is given one or more thread blocks to execute, it splits them into warps that get scheduled by the SIMT unit.

        SM 拿到 blocks，SM 将 blocks 分成多个 warps。每个 warp 对应一个 simt unit.

    * At every instruction issue time, the SIMT unit selects a warp that is ready to execute and issues the next instruction to the active threads of the warp.

        warp 和 simt unit 并不是绑定的关系，simt unit 会动态选择准备就绪的 warp 进行处理。

        一个 warp 中的 threads 也不是都为 active 状态，可能只有部分是 active 状态。（猜测这里的 active 和 if 条件语句有关）

    * A warp executes one common instruction at a time, so full efficiency is realized when all threads of a warp agree on their execution path. If threads of a warp diverge via a data-dependent conditional branch, the warp serially executes each branch path taken, disabling threads that are not on that path, and when all paths complete, the threads converge back to the same execution path. Branch divergence occurs only within a warp; 

        如果一个 warp 中的多个 thread 根据 if 语句发生了 diverge，一部分 threads 走 branch 1，另一部分 threads 走 branch 2，那么 warp 会先执行 branch 1 的代码，再执行 branch 2 的代码，最后再把所有 threads 合并到一起，执行 common 代码。

        显然，最坏的情况是 branch 1 上有 N - 1 个 threads，而 branch 2 上只有 1 个 thread，并且 branch 2 的代码很长。为了这一个 thread，其他 thread 要等很长时间，彻底破坏了 simt 的优势。

    * How many blocks a multiprocessor can process at once depends on how many registers per thread and how much shared memory per block are required for a given kernel since the multiprocessor’s registers and shared memory are split among all the threads of the batch of blocks. 

        看来 sm 中的寄存器和 shared memory 的数量是有限的，根据这些资源的占用情况，动态决定一个 sm 能同时处理多少个 block。

        推论：或者是编译，或者是固件，一定有个地方会计算 sm 中寄存器资源的占用情况，并在 dispatch 任务时会根据这些占用情况进行派发。

    * 从 vulta 架构开始，引入了 Independent Thread Scheduling，此时不再以 warp + mask 的形式进行线程调度，提高了灵活性。

        目前并不清楚这点是怎么 work 的，有时间了再看。

    * on-chip memory

        片上内存，速度快。一共有 4 种。

        * register，每个 thread 独占。

        * shared memory, 位置在 sm 上，逻辑上 block 共享

        * read-only constant cache，位置在 sm 上，逻辑情况未知

        * read-only texture cache，位置在 sm 上，逻辑情况未知

* seldom adv. 很少 eg. however, substantial performance improvements can be realized by taking care that the code seldom requires threads in a warp to diverge.

* coalesce prn. [ˌkoʊəˈles] v. 联合，合并 eg. Vector architectures, on the other hand, require the software to coalesce loads into vectors and manage divergence manually.

* ptx tmp

    * PTX is case sensitive and uses lowercase for keywords.

    * ptx 语句有两种，一种是 directive，另一种是 instruction

        常见的 directive 如下：

        ```
                .reg     .b32 r1, r2;
                .global  .f32  array[N];

        start:  mov.b32   r1, %tid.x;
                shl.b32   r1, r1, 2;          // shift thread id by 2 bits
                ld.global.b32 r2, array[r1];  // thread[tid] gets array[tid]
                add.f32   r2, r2, 0.5;        // add 1/2
        ```

        常见的 insrruction 如下：

        `abs`, `cvta`, `membar`

    * identifier

        ptx 中的 identifier 与 c/c++ 中的相似。

        regular expression:

        ```
        followsym:   [a-zA-Z0-9_$]
        identifier:  [a-zA-Z]{followsym}* | {[_$%]{followsym}+
        ```

    * Predefined Identifiers

        ptx 预定义了一些常量。常用的常量：

        `%clock`, `%laneid`, `%lanemask_gt`

    * integer 有 signed 和 unsigned 之分，以 64 位为例，分别表示为`.s64`, `.u64`

    * 整型的字面量  Integer literals

        常见的格式如下：

        ```
        hexadecimal literal:  0[xX]{hexdigit}+U?
        octal literal:        0{octal digit}+U?
        binary literal:       0[bB]{bit}+U?
        decimal literal       {nonzero-digit}{digit}*U?
        ```

    * floating point

        ptx 支持使用十六进制数按照 IEEE 754 格式精确表示浮点数。

        ```
        0[fF]{hexdigit}{8}      // single-precision floating point
        0[dD]{hexdigit}{16}     // double-precision floating point
        ```

        example:

        ```asm
        mov.f32  $f3, 0F3f800000;       //  1.0
        ```

    * A state space is a storage area with particular characteristics.

        常用的 state space:

        * `.reg`: Registers, fast.

        * `.sreg`: Special registers. Read-only; pre-defined; platform-specific.

            The special register (.sreg) state space holds predefined, platform-specific registers, such as grid, cluster, CTA, and thread parameters, clock counters, and performance monitoring registers. All special registers are predefined.

        * `.const`: Shared, read-only memory.

        * `.global`: Global memory, shared by all threads.

        * `.local`: Local memory, private to each thread.

        * `.param`: Kernel parameters, defined per-grid; or Function or local parameters, defined per-thread.

        * `.shared`: Addressable memory, defined per CTA, accessible to all threads in the cluster throughout the lifetime of the CTA that defines it.

        * `.tex`: Global texture memory (deprecated).

    * The constant (.const) state space is a read-only memory initialized by the host. Constant memory is accessed with a `ld.const` instruction.

    * Constant memory is restricted in size, currently limited to 64 KB which can be used to hold statically-sized constant variables.

        常量的空间竟然有 64 KB，感觉还是比较大的。

    * There is an additional 640 KB of constant memory, organized as ten independent 64 KB regions. The driver may allocate and initialize constant buffers in these regions and pass pointers to the buffers as kernel function parameters.

        没有明白这个是啥意思，猜测：默认的字面量和 const 变量都是存在 64 KB 的 constant memory 中，如果有额外的大量常量数据的需要，比如传入一个世界地图的数据之类的，可以在驱动层面额外申请，并且显式地把数据写入进去。推论：640 KB 的 constant memory 是所有 sm 共享的。

* 交互式地阅读材料并不能解决效率逐渐降低的问题，只能缓解。如果想要解决，还是得靠真正的输出。