* c++ elements gui

    repo: <https://github.com/cycfi/elements>

    声明式语法：Domain Specific Embedded Languages (DSEL)

    install:

    `git clone --recurse-submodules  https://github.com/cycfi/elements.git`

    linux 上 elements 依赖 GTK3

    ```bash
    sudo apt-get install libcairo2-dev
    sudo apt-get install libgtk-3-dev
    sudo apt-get install libwebp-dev
    ```

    compile:

    ```bash
    cd elements
    mkdir build
    cd build
    cmake -G "Unix Makefiles" ../
    ```

    编译完成后，可进入`build/examples`文件夹中运行各个 example 程序。

    `hello_universe`简析：

    ```cpp
    #include <elements.hpp>

    using namespace cycfi::elements;

    int main(int argc, char* argv[])
    {
       app _app("Hello Universe");
       window _win(_app.name());
       _win.on_close = [&_app]() { _app.stop(); };

       view view_(_win);

       view_.content(
          scroller(image{"space.jpg"})
       );

       _app.run();
       return 0;
    }
    ```

    `app`看起来是做事件循环的。

    `window`看起来是只有在关闭时，才触发调用`_app.stop()`，那么 windows 是如何和 app 绑定到一起的？看起来应该是靠 app name 的字符串。（这是否意味着，不给 window 传入`_app.name()`，即使传入 c-style 字符串，window 也能正常 work？）

    `view`与 window 做了绑定，看起来应该是 view 只负责填充内容，app 的消息交给 window，window 将 app 的消息和 window 本身的消息都交给 view 处理。

    `_app.run()`进入主事件循环，没有什么好说的。

    `_win.on_close = [&_app]() { _app.stop(); };`说明 window 关闭的时候，app 不一定关闭，还可能在后台处理消息。

    compile example:

    ```bash
    cd hello_universe/build
    cmake -DELEMENTS_ROOT=/home/hlc/Documents/Projects/elements ..
    ```

    需要配置一下`ELEMENTS_ROOT`，否则会报错。

* be in flux 变化无常

* inch v. 缓慢地移动 eg. Please take note that Elements is still very much in flux as we are inching closer towards a version 1.0 release.

* `getuid()`等函数在头文件`<unistd.h>`中，返回当前用户的 uid。

    example:

    ```cpp
    #include <unistd.h>
    #include <stdio.h>

    int main() {
        uid_t uid = getuid();
        printf("uid: %u\n", uid);
        uid_t euid = geteuid();
        printf("euid: %u\n", euid);
        gid_t gid = getgid();
        printf("gid: %u\n", gid);
        gid_t egid = getegid();
        printf("egid: %u\n", egid);
        return 0;
    }
    ```

    output:

    普通运行：

    ```
    uid: 1000
    euid: 1000
    gid: 1000
    egid: 1000
    ```

    使用`sudo ./main`运行：

    ```
    uid: 0
    euid: 0
    gid: 0
    egid: 0
    ```

    可以看到，`uid`与`euid`目前没有什么区别。

    可以运行命令`id`，看到类似的输出：

    ```
    uid=1000(hlc) gid=1000(hlc) groups=1000(hlc),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),109(kvm),122(lpadmin),135(lxd),136(sambashare),137(docker),140(libvirt)
    ```

    `sudo id`输出如下：

    ```
    uid=0(root) gid=0(root) groups=0(root)
    ```

* `getpwuid()`用法

    根据 uid 去`/etc/passwd`中查询信息。

    example:

    ```
    #include <unistd.h>
    #include <pwd.h>
    #include <stdio.h>

    int main() {
        uid_t uid = getuid();
        printf("uid: %u\n", uid);
        passwd* pwd = getpwuid(uid);
        if (pwd == NULL) {
            printf("fail to get pwuid\n");
            return -1;
        }
        printf("pw_name: %s\n", pwd->pw_name);
        printf("pw uid: %u\n", pwd->pw_uid);
        printf("pw gid: %u\n", pwd->pw_gid);
        printf("pw dir: %s\n", pwd->pw_dir);
        printf("pw shell: %s\n", pwd->pw_shell);
        printf("pw passwd: %s\n", pwd->pw_passwd);
        printf("pw gecos: %s\n", pwd->pw_gecos);
        return 0;
    }
    ```

    output:

    ```
    uid: 1000
    pw_name: hlc
    pw uid: 1000
    pw gid: 1000
    pw dir: /home/hlc
    pw shell: /bin/bash
    pw passwd: x
    pw gecos: hlc,,,
    ```

    相似地，`getpwnam()`通过用户名查询用户信息。

* `sudo`与`/etc/sudoers`

    用户使用 sudo 执行的命令会被记录到`/var/log/auth.log`文件中。

    比如用户执行`sudo echo hello`，日志的记录为

    ```
    Jul 27 14:38:16 hlc-VirtualBox sudo:      hlc : TTY=pts/5 ; PWD=/home/hlc/Documents/documents/Personal/logs ; USER=root ; COMMAND=/usr/bin/echo hello
    Jul 27 14:38:16 hlc-VirtualBox sudo: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1000)
    Jul 27 14:38:16 hlc-VirtualBox sudo: pam_unix(sudo:session): session closed for user root
    ```

    `/etc/sudoers`规定了用户使用 sudo 可以执行哪些命令。

    通常使用`visudo`编辑这个文件，`visudo`可以在保存前进行语法检查，防止语法出错。

    `sudoers`文件的语法为：

    ```
    user    HOST=(RUNAS_USER)    COMMANDS
    %group  HOST=(RUNAS_USER)    COMMANDS
    ```

    其中，

    * `user/%group`：用户名或%组名。

    * `HOST`：允许使用 sudo 的主机名（通常设为`ALL`）。

    * `(RUNAS_USER)`：可以切换的目标用户（如 `(root)`、`(ALL)`）。

        通常设置为`(ALL:ALL)`或`(ALL)`。

        * `(ALL)`: 允许用户以 任意用户身份（包括 root）执行命令。

            ```bash
            sudo -u root apt update    # 以 root 身份运行
            sudo -u bob apt install xx # 以用户 bob 身份运行
            ```

        * `(root)`: 仅允许用户以 root 身份 执行命令（不能切换为其他用户）。

            ```bash
            sudo systemctl restart nginx      # 隐含 -u root
            sudo -u alice systemctl start xx  # 报错（不允许）
            ```

        * `(ALL:ALL)`: 允许用户以 任意用户和任意用户组 身份执行命令（用户和组均可切换）。

            `(RUNAS_USER:RUNAS_GROUP)`, 若省略`:GROUP`，默认使用目标用户的默认组。注意这个 group 的指定在后面，不在前面。

            ```bash
            sudo -u alice -g developers chmod 755 file
            sudo -u root -g root chmod 600 /etc/shadow
            ```

    `COMMANDS`：允许执行的命令（绝对路径，`ALL`表示全部）。

    example:

    ```conf
    alice   ALL=(root)    /usr/bin/apt      # alice 可以 root 身份运行 apt
    %admin  ALL=(ALL)     ALL                # admin 组成员可执行任何命令
    ```

    使用别名（变量）：

    ```conf
    User_Alias     ADMINS = alice, bob
    Host_Alias     SERVERS = 192.168.1.1
    Runas_Alias    DEVS = tom
    Cmnd_Alias     PKG_CMDS = /usr/bin/apt, /usr/bin/dpkg

    ADMINS SERVERS=(DEVS) PKG_CMDS
    ```

    其他配置：

    * `NOPASSWD`：执行命令无需密码

        ```conf
        bob    ALL=(root)    NOPASSWD: /usr/bin/systemctl
        ```

    * `!`排除命令：

        ```conf
        charlie ALL=(ALL) ALL, !/usr/bin/passwd root
        ```

    * 全局配置

        通过`Defaults`设置全局行为，如：

        ```conf
        Defaults    env_keep += "HTTP_PROXY"   # 保留环境变量
        Defaults    insults                    # 输错密码时显示“嘲讽”
        ```

    因为编辑这个文件可能会影响到当前虚拟机环境，所以上面的命令都没有验证过。

* `/etc/sudoers`中，`@includedir /etc/sudoers.d`用于 加载`/etc/sudoers.d`目录下的所有配置文件

    例如：

    `/etc/sudoers.d/web_admins` -> 存放 Web 管理员的 sudo 权限

    `/etc/sudoers.d/db_admins` -> 存放数据库管理员的 sudo 权限

    在软件包安装时（如 Docker、Nginx），它们可能会自动在`/etc/sudoers.d/`下添加自己的规则。

    修改`/etc/sudoers.d/`下的文件后，无需重启，sudo 会自动识别（但建议用`visudo -c`检查语法）。

    文件名：不能包含`.`或`~`（避免读取临时文件或备份文件）。

    权限：必须为 0440（root:root 可读，其他用户不可读），否则 sudo 会忽略它并报错.

    ```bash
    # 检查所有 sudoers 文件（包括 sudoers.d 下的）
    sudo visudo -c
    ```

* yum 简介

    Yum（Yellowdog Updater Modified）

    * 安装软件包

        `yum install <package_name>`

    * 安装本地 RPM 包（自动解决依赖）

        `yum localinstall <path_to_rpm>`

    * 升级单个软件包

        `yum update <package_name>`

    * 升级所有可升级软件包

        `yum update`

    * 检查可升级的软件包

        `yum check-update`

    * 搜索软件包（按名称/描述）

        `yum search <keyword>`

    * 列出已安装的软件包

        `yum list installed`

        `yum list`会显示仓库中所有可用的软件包（包括已安装和未安装的）。

        `yum list available`仅列出可安装但尚未安装的软件包

        `yum list updates`列出所有可升级的软件包

        `yum list extras`列出已安装但不在仓库中的包（如手动安装的 RPM）

        `yum list <package_name>`搜索特定软件包（支持通配符，如`yum list "nginx*"`）

    查看软件包信息
    yum info <package_name>

    列出软件包的依赖
    yum deplist <package_name>

    查找提供特定文件的软件包
    yum provides <file_path>

    删除软件包（保留依赖）
    yum remove <package_name>

    删除无用依赖
    yum autoremove

    清理旧内核
    yum remove $(rpm -q kernel | grep -v $(uname -r))

    删除软件包（保留依赖）
    yum remove <package_name>

    删除无用依赖
    yum autoremove

    清理旧内核
    yum remove $(rpm -q kernel | grep -v $(uname -r))

    列出所有仓库
    yum repolist all

    启用/禁用仓库
    yum-config-manager --enable/disablerepo <repo_name>

    添加新仓库
    yum-config-manager --add-repo <repo_url>

    清理缓存（保留元数据）
    yum clean packages

    清理所有缓存（包括元数据）
    yum clean all

    重建缓存
    yum makecache

    查看历史操作
    yum history

* `yum list`和`yum search`的区别

    * `yum list <package>`

        精确列出匹配名称的软件包（包括已安装、可安装或可升级的版本）。

        特点:

        * 严格匹配包名：默认按完整名称匹配（支持通配符 *）。

        * 显示详细信息：输出包含 包名、版本号、所属仓库（如是否已安装）。

        * 不搜索描述：仅检查包名，不涉及软件包的描述或关键字。

        example:

        `yum list "nginx*"  # 列出所有名称以 `nginx` 开头的软件包`

        output:

        ```
        nginx.x86_64    1.20.1-1.el7    @epel      # 已安装
        nginx-module.x86_64 1.20.1-1.el7 updates    # 可升级
        ```

    * `yum search <package>`

        通过关键字搜索软件包（匹配包名和描述信息）。

        特点:

        * 模糊搜索：同时匹配包名、描述、摘要中的关键字。

        * 返回摘要：显示包名和简要描述，但不显示版本或仓库信息。

        * 结果更广泛：可能包含名称不直接相关但描述匹配的包。

        example:

        `yum search "web server"  # 搜索描述或名称中包含 "web server" 的包`

        output:

        ```
        nginx.x86_64 : High performance web server
        httpd.x86_64 : Apache HTTP Server
        ```

* `calloc()`简介

    头文件：`<stdlib.h>`

    `calloc()`与`malloc()`相似，都是分配内存，只不过`calloc()`是按`elm_size * num_elm`的方式计算内存大小，并对内存数据进行置`0`，而`malloc()`使用`buf_size`计算内存大小，并保持内存数据的随机，不进行置`0`。

    example:

    ```cpp
    #include <stdlib.h>
    #include <stdio.h>

    int main() {
        size_t num_elm = 5;
        int *arr = (int*) calloc(sizeof(int), num_elm);
        for (int i = 0; i < num_elm; ++i) {
            printf("%d, ", arr[i]);
        }
        putchar('\n');
        free(arr);
        arr = (int*) malloc(sizeof(int) * num_elm);
        for (int i = 0; i < num_elm; ++i) {
            printf("%d, ", arr[i]);
        }
        putchar('\n');
        free(arr);
        return 0;
    }
    ```

    output:

    ```
    0, 0, 0, 0, 0, 
    -1140679150, 5, 0, 0, 0,
    ```

* `sizeof(void)`

    `sizeof(void)`本身无意义，gcc/g++ 可以通过编译，输出为`1`，但是会报 warning。

    example:

    ```cpp
    #include <stdio.h>

    int main() {
        size_t len_void = sizeof(void);
        printf("len_void: %lu\n", len_void);
        return 0;
    }
    ```

    compile output:

    ```
    main_5.cpp: In function ‘int main()’:
    main_5.cpp:4:23: warning: invalid application of ‘sizeof’ to a void type [-Wpointer-arith]
        4 |     size_t len_void = sizeof(void);
          |                       ^~~~~~~~~~~~
    ```

    output:

    ```
    len_void: 1
    ```

* `sudo -S`

    用于从标准输入（stdin）读取密码，而非交互式终端提示.

    `-S`等价于`--stdin`

    example:

    ```bash
    echo "你的密码" | sudo -S command

    cat password.txt | sudo -S apt update  # 从文件读取密码
    ```

    需要注意的是 echo 不会换行：

    ```bash
    echo xxx | sudo -S echo hello
    ```

    output:

    ```
    [sudo] password for hlc: hello
    ```

    似乎没有什么好的解决方案。

* `rsync --exclude`

    `rsync --exclude=PATTERN`让 rsync 忽略匹配 PATTERN 的文件或目录，不进行同步。`PATTERN`可以是文件名、目录名（`PATTERN`需加`/`表示目录），或通配符模式（如`*.log`）。支持多次使用，排除多个不同规则。`PATTERN`作用于 src 目录。

    `rsync -av --exclude-from='exclude-list.txt' /source/ /destination/`

    `--exclude-from`表示从文件读取排除规则。

    example:

    `exclude-list.txt`:

    ```
    *.bak
    /logs/
    *.tmp
    ```

    排除隐藏文件：

    `rsync -av --exclude='.*' /source/ /destination/`

    优先级：

    `--include`的优先级高于`--exclude`，可组合使用（如先排除再包含部分文件）。

    * pattern 路径匹配细节

        * 相对路径：

            `PATTERN` 默认相对于 src 的路径。例如：

            `--exclude='temp/'` -> 排除`src/temp/`。

            `--exclude='/file.txt'` -> 排除`src/file.txt`（开头的 / 表示相对于 src 根）。

        * 绝对路径无效：

            若`PATTERN`是绝对路径（如`/home/user/file.txt`），rsync 会直接忽略（因为它始终相对于 src）。

* c++ `optional`

    头文件`#include <optional>`

    example:

    ```cpp
    #include <optional>
    #include <string>
    #include <stdio.h>
    using namespace std;

    int main() {
        optional<int> opt_1;  // 无值
        optional<string> opt_2 = "hello, world";
        optional<float> opt_3 = nullopt;  // 显式表示无值

        printf("opt_1 has value: %d\n", opt_1.has_value());
        printf("opt_2 has value: %d\n", opt_2.has_value());
        printf("opt_3 has value: %d\n", opt_3.has_value());

        int val = opt_1.value_or(1234);  // 如果无值则使用默认值 1234
        string &str = opt_2.value();
        printf("opt_1 value: %d\n", val);
        printf("opt_2 value: %s\n", str.c_str());

        return 0;
    }
    ```

    其他常用函数：

    * `.reset()`：重新设置为无值

    * `opt.emplace("New String");  // 直接构造新值`：原地构造

* `pgrep`

    `pgrep`可根据程序的名称快速找到 pid.

    ```bash
    pgrep firefox
    ```

    output:

    ```
    2301052
    ```

    `pgrep`通常可以和`kill`等命令连用：

    `kill $(pgrep nginx)`

    如果有多个进程实例，则会列出多个 pid:

    ```bash
    pgrep bash
    ```

    output:

    ```
    2740
    3059
    2293259
    2294904
    2328484
    2529093
    2618992
    2754955
    2792818
    2823794
    ```
