* c/c++ 中都不允许两个指针直接相加

    但是 c 将指针显式转换为整数，可以使用指针 + 整数，或整数 + 整数。

* `printf()`的格式化

    使用`%x`打印十六进制数时，不会在前面加上`0x`。如果需要加上前缀，可以使用`%#010x`。不清楚这个 spec 是在哪写的。ref: <https://stackoverflow.com/questions/14733761/printf-formatting-for-hexadecimal>

    `%d`打印的是 integer，`%ld`打印的是 long integer，注意这些都是 signed 值。

    `%u`打印的是 unsigned integer，`%lu`打印的是 unsigned long integer。

    单独一个`%l`没有什么意义。

    long 类型是 64 位，int 类型是 32 位。如果用打印 int 类型的命令打印 long 类型，那么会截取低 32 位打印。

    如果使用打印 signed 的命令打印 unsigned 类型，那么由于对最高位的处理不同，可能会出现负数。

    `printf()`打印不同颜色的字体：<https://blog.csdn.net/qq_41673920/article/details/80334557/>

* `printk()`中指针地址的打印

    `%p`打印的并不是真实地址，而是经过处理的地址

    `%px`打印的是原始地址值，不经过处理。

    `%pK`是按配置文件打印值，更具体的用法可以参考这里：<https://blog.csdn.net/zqwone/article/details/127057245>

    <https://www.kernel.org/doc/Documentation/printk-formats.txt>

* cached tasks

    调研函数：

    `pci_enable_device`, `dev_set_drvdata`

    `pci_resource_start`, `pci_resource_len`, `pci_ioremap_bar`

    `pci_set_master`, `dma_set_mask`, `pci_ioremap_wc_bar`

    调研：`iommu_domain_alloc`, `iommu_group_get`, `iommu_attach_group`

    `dev_to_node`, `kzalloc_node`, `spin_lock_init`

    `mutex_lock`, `mutex_unlock`, `mutex_destroy`

    `idr_init_base`

    `kfree`, `dev_info`

    调研：

    `writel`, `BUG()`, `readq`, `writeq`, `pci_read_config_dword`, `pci_find_ext_capability`

    `readl`, 

    * `pci_register_driver()`这个也是内核调用，有时间了看下含义

    调研一下`KBUILD_MODNAME`的含义。

    * 需要调研的函数

        * `spin_unlock_irqrestore()`

        * `dev_get_drvdata()`

        * `mdev_register_device()`

    * 调研 linux kernel 函数

        `mdev_get_drvdata()`

        `copy_from_user()`

        `BIT()`

