* matplotlib 画 3d surface 的 example

    ```py
    import numpy as np
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D
    import matplotlib.font_manager as fm

    # 设置中文字体
    plt.rcParams['font.sans-serif'] = ['Noto Sans CJK JP']  # 使用黑体
    plt.rcParams['axes.unicode_minus'] = False    # 解决负号显示问题

    # 创建数据
    x = np.linspace(-5, 5, 100)
    y = np.linspace(-5, 5, 100)
    X, Y = np.meshgrid(x, y)
    Z = np.sin(np.sqrt(X**2 + Y**2))

    # 创建图形
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # 绘制曲面
    surf = ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.8)

    # 添加颜色条
    fig.colorbar(surf)

    # 设置标签 - 现在中文可以正常显示
    ax.set_xlabel('X轴')
    ax.set_ylabel('Y轴')
    ax.set_zlabel('Z轴')
    ax.set_title('3D曲面图示例')

    plt.show()
    ```

* 将 note, qa, routine (example) 放到同一个目录下

    由于 routine 可能以单个文件的形式存在，也可能以工程的形式（文件夹）存在，所以使用 routines 文件夹放置所有的 routine，需要文件的时候创建文件，需要文件夹的时候创建文件夹。

    这样遵循了两个原则：

    1. 意义相近的事物尽量放到一起

    2. 类型相似的事物如果大于等于 3 个，那么就创建一个 group （文件夹）

    经过这样改动后，linux driver 文件夹目录结构如下：

    ```
    (base) hlc@hlc-VirtualBox:~/Documents/documents/Linux/linux_driver$ tree
    .
    ├── linux_driver_note.md
    ├── linux_driver_note_qa_exam_db
    ├── linux_driver_note_qa.md
    ├── linux_driver_note_qa.md_backup
    ├── linux_driver_note_qa.md.bk
    └── routines
        └── ref_25
            ├── app_code.cpp
            ├── kern_mod_code.c
            └── Makefile

    2 directories, 8 files
    ```

    reference resouces 继续作为全局 ref 使用，如果某个 ref 有明确的分类需求/条件，那么将这个 ref 放到 note local 的 routines 目录下。

* 仅靠 cache entry 的堆砌，似乎很难自动地生成一个 routine

    如果有构造 routine 的动机、想法、冲动，那么就快速实施想法，或者生成 task。总是想着“等所有前置知识都学完了，便可以自动生成只需要临门一脚就可实现的 routine”，是不可能实现的。

*  CUDA 向量加（Vector Addition） example

    ```cpp
    #include <stdio.h>
    #include <stdlib.h>
    #include <cuda_runtime.h>

    // CUDA 内核函数：向量加法
    __global__ void vectorAdd(const float* A, const float* B, float* C, int numElements)
    {
        int i = blockDim.x * blockIdx.x + threadIdx.x;
        if (i < numElements) {
            C[i] = A[i] + B[i];
        }
    }

    // 初始化主机数据的辅助函数
    void initData(float* ptr, int size, float value)
    {
        for (int i = 0; i < size; ++i) {
            ptr[i] = value + i;
        }
    }

    // 验证结果的辅助函数
    bool verifyResult(const float* A, const float* B, const float* C, int numElements)
    {
        const float epsilon = 1.0e-6f;
        for (int i = 0; i < numElements; ++i) {
            if (fabs(C[i] - (A[i] + B[i])) > epsilon) {
                printf("验证失败! 在索引 %d: 期望 %.2f, 得到 %.2f\n", 
                       i, A[i] + B[i], C[i]);
                return false;
            }
        }
        printf("验证成功! 所有元素计算正确。\n");
        return true;
    }

    int main(void)
    {
        // 设置向量长度
        const int numElements = 50000;
        const size_t size = numElements * sizeof(float);
        printf("[信息] 向量加法，每个向量长度为 %d 元素\n", numElements);

        // 分配主机内存
        float *h_A, *h_B, *h_C;
        h_A = (float*)malloc(size);
        h_B = (float*)malloc(size);
        h_C = (float*)malloc(size);

        if (!h_A || !h_B || !h_C) {
            printf("主机内存分配失败!\n");
            exit(EXIT_FAILURE);
        }

        // 初始化主机数组
        initData(h_A, numElements, 1.0f);  // A = [1, 2, 3, ...]
        initData(h_B, numElements, 2.0f);  // B = [2, 3, 4, ...]
        // 期望结果: C = [3, 5, 7, ...]

        // 分配设备内存
        float *d_A, *d_B, *d_C;
        cudaMalloc((void**)&d_A, size);
        cudaMalloc((void**)&d_B, size);
        cudaMalloc((void**)&d_C, size);

        // 拷贝输入数据从主机到设备
        cudaMemcpy(d_A, h_A, size, cudaMemcpyHostToDevice);
        cudaMemcpy(d_B, h_B, size, cudaMemcpyHostToDevice);

        // 启动内核配置
        int threadsPerBlock = 256;
        int blocksPerGrid = (numElements + threadsPerBlock - 1) / threadsPerBlock;
        printf("[信息] 启动内核配置: %d 个线程块, 每个块 %d 个线程\n", 
               blocksPerGrid, threadsPerBlock);

        // 执行CUDA内核
        vectorAdd<<<blocksPerGrid, threadsPerBlock>>>(d_A, d_B, d_C, numElements);

        // 等待所有GPU操作完成
        cudaDeviceSynchronize();

        // 检查内核执行是否有错误
        cudaError_t err = cudaGetLastError();
        if (err != cudaSuccess) {
            printf("CUDA 内核执行错误: %s\n", cudaGetErrorString(err));
            exit(EXIT_FAILURE);
        }

        // 拷贝结果从设备到主机
        cudaMemcpy(h_C, d_C, size, cudaMemcpyDeviceToHost);

        // 验证结果
        verifyResult(h_A, h_B, h_C, numElements);

        // 打印前10个结果作为示例
        printf("\n前10个结果示例:\n");
        for (int i = 0; i < 10 && i < numElements; ++i) {
            printf("C[%d] = %.2f (A[%d] + B[%d] = %.2f + %.2f)\n", 
                   i, h_C[i], i, i, h_A[i], h_B[i]);
        }

        // 释放设备内存
        cudaFree(d_A);
        cudaFree(d_B);
        cudaFree(d_C);

        // 释放主机内存
        free(h_A);
        free(h_B);
        free(h_C);

        printf("\n[信息] 程序执行完成，内存已释放。\n");

        // 重置设备以便性能分析工具获取更准确的数据
        cudaDeviceReset();

        return 0;
    }
    ```

    threadIdx.x：线程在其线程块（Block）内的索引。

    blockIdx.x：线程块在网格（Grid）中的索引。

    blockDim.x：每个线程块中的线程数量。

    compile:

    `nvcc -o vector_add vector_add.cu`

    run:

    `./vector_add`

    output:

    ```
    [信息] 向量加法，每个向量长度为 50000 元素
    [信息] 启动内核配置: 196 个线程块, 每个块 256 个线程
    验证成功! 所有元素计算正确。

    前10个结果示例:
    C[0] = 3.00 (A[0] + B[0] = 1.00 + 2.00)
    C[1] = 5.00 (A[1] + B[1] = 2.00 + 3.00)
    C[2] = 7.00 (A[2] + B[2] = 3.00 + 4.00)
    C[3] = 9.00 (A[3] + B[3] = 4.00 + 5.00)
    C[4] = 11.00 (A[4] + B[4] = 5.00 + 6.00)
    C[5] = 13.00 (A[5] + B[5] = 6.00 + 7.00)
    C[6] = 15.00 (A[6] + B[6] = 7.00 + 8.00)
    C[7] = 17.00 (A[7] + B[7] = 8.00 + 9.00)
    C[8] = 19.00 (A[8] + B[8] = 9.00 + 10.00)
    C[9] = 21.00 (A[9] + B[9] = 10.00 + 11.00)

    [信息] 程序执行完成，内存已释放。
    ```

* 傅里叶变换

    任何复杂的周期函数（或非周期信号）都可以分解为一系列不同频率、不同振幅的简单正弦波和余弦波的叠加。

    时域：我们平时看到的信号波形，其横轴是时间，纵轴是振幅。它告诉我们信号在时间上是如何变化的。

    频域：经过傅里叶变换后得到的视图，其横轴是频率，纵轴是该频率对应的振幅（或能量）。它告诉我们信号是由哪些频率成分组成的，以及每种成分的强度有多大。

    数学定义：

    对于一个连续时间信号 $f(t)$，其连续傅里叶变换 $F(\omega)$ 定义为：

    $F(ω)=∫_{−\infty}^{\infty}f(t)e^{−iωt} dt$

    其中：

    * $F(\omega)$ 是频域函数，它是一个复数，包含了频率 $\omega$ 分量的振幅和相位信息。

    * $\omega = 2\pi f$ 是角频率。

    * $e^{-i\omega t}$ 是欧拉公式的核心，它等价于 $\cos(\omega t) - i\sin(\omega t)$。

    简单来说，这个公式是在计算原始信号 $f(t)$ 与一个频率为 $\omega$ 的复指数信号（可以理解为旋转的圆）的相关性。如果相关性很强，$|F(\omega)|$ 的值就很大，说明信号中包含大量该频率的成分。

* 正弦函数的傅里叶变换

    正弦函数：$f(t) = \sin(2\pi f_0 t)$，其中 $f_0$ 是它的频率。

* 正弦函数

    $y = \sin ⁡x$, 其中 xx 是自变量（通常表示角度，单位为弧度或度），yy 是因变量。

    定义:

    * 单位圆定义：在直角坐标系中，以原点为圆心、半径为1的单位圆上，角度$\theta$（以 x 轴正方向为始边，逆时针旋转为正）的终边与单位圆的交点的纵坐标即为$\sin⁡θ$

    * 直角三角形定义：在直角三角形中，$\sin⁡ \theta = \frac{对边}{斜边}$（适用于锐角）。

    * 级数定义（解析定义）：

        $\sin x = x - \frac{x^3}{3!} ​+ \frac{x^5}{5!}​− \frac{x^7}{7!} ​+ \cdots$（其中$x$为弧度）。

    性质:

    * 定义域与值域

        定义域：全体实数
       $\mathbb R$（即 $(−\infty, +\infty)$）。

    * 周期性

        是周期函数，最小正周期为 $2\pi$（即 $\sin⁡(x + 2 k \pi) = \sin ⁡x$，$k \in \mathbb Z$）。

    * 奇偶性

        是奇函数，即 $\sin ⁡(−x) = − \sin ⁡x$，图像关于原点对称。

    * 对称性

        关于点 $(k \pi, 0)$（$k \in \mathbb Z$）中心对称，关于直线 $x = \frac{π}{2} + k \pi$ （$k \in \mathbb Z$）轴对称。

    * 单调性

        在区间 $[−\frac{\pi}{2} + 2 k \pi, \frac{\pi}{2} + 2 k \pi]$ 上单调递增，在区间 $[\frac{\pi}{2} + 2 k \pi, \frac{3\pi}{2} + 2 k \pi]$ 上单调递减（$k \in \mathbb Z$）

    * 最值

    * 零点

    * 导数与积分

    * 与其他函数的关系

    图像:

    * 波形曲线（正弦曲线），在 $[−1,1]$ 之间振荡，周期为 $2 \pi$，过原点且关于原点对称。

* 弧度与角度的关系

    角度制： 将一个圆周分为360等份，每一份对应的圆心角称为1度（1°）。这是基于对圆周的人为分割。

    弧度制： 用角所对应的弧长与半径的比值来定义角的大小。具体定义为：在一个圆中，长度等于半径的弧所对的圆心角的大小为1弧度（1 rad）。

    换算关系：

    一个完整的圆周，其角度是360°，其对应的弧长是整个圆的周长，即 2πr。根据弧度定义，这个圆心角的弧度值 = 弧长 / 半径 = 2πr / r = 2π。因此，我们得到了最关键的关系：360° = 2π 弧度。

    由此可以推导出：

    * 180° = π 弧度

    * 1° = π/180 弧度

    * 1 弧度 = 180/π ≈ 57.3°

    弧度 x 既代表角度，也代表单位圆上对应的弧长。

* makefile 中的`?=`

    ?= 被称为 条件赋值符 或 默认赋值符。只有当这个变量之前没有被赋值过（是空的），才会给它赋值。如果已经有值了，那么就忽略这次赋值。

    如果我们在 makefile 中写`CFLAGS ?= -Wall -O2`，那么在外部执行`make CFLAGS="-g"`时，makefile 发现`CFLAGS`已经被赋值了，那么`CFLAGS ?= -Wall -O2`将不再生效。

    makefile 中的四种赋值方法：

    | 操作符 | 名称 | 作用 |
    | - | - | - |
    | `=` | 递归赋值 | 在变量被使用时才会展开并确定值。 |
    | := |	直接赋值 |	在变量被定义时就立即展开并确定值。 |
    | ?= |	条件赋值 |	如果变量为空，则赋予等号右边的值。 |
    | += |	追加赋值 | 将等号右边的值追加到现有变量之后。 |

* `OBJS = $(SRCS:.c=.o)`

    将 SRCS 变量中的所有 .c 后缀文件名替换为 .o 后缀，并将结果赋值给 OBJS 变量。

    SRCS：通常是一个包含所有 C 源文件名的变量，例如`SRCS = main.c utils.c helper.c`

    example:

    ```makefile
    SRCS = main.c utils.c helper.c
    OBJS = $(SRCS:.c=.o)

    myprogram: $(OBJS)
        gcc -o myprogram $(OBJS)

    main.o: main.c
        gcc -c main.c

    utils.o: utils.c
        gcc -c utils.c

    helper.o: helper.c
        gcc -c helper.c
    ```

    等价写法：

    `OBJS = $(patsubst %.c,%.o,$(SRCS))`

* `df -T /dev/shm`

    显示 /dev/shm 目录所在文件系统的磁盘空间使用情况和文件系统类型信息。

    * df：disk free 的缩写，用于显示文件系统的磁盘空间使用情况

    * -T：选项，显示文件系统类型

    example output:

    ```
    Filesystem     Type  1K-blocks  Used Available Use% Mounted on
    tmpfs          tmpfs   8180620 55444   8125176   1% /dev/shm
    ```

    * 文件系统：tmpfs - 临时文件系统

    * 类型：tmpfs - 基于内存的临时文件系统

    * 1K-块：总容量（以 1KB 为单位）

* `sudo mount -t tmpfs -o size=2G tmpfs /dev/shm`

    将 /dev/shm 目录重新挂载为大小为 2GB 的 tmpfs（临时文件系统）。

    这个操作会：

    * 覆盖现有的 /dev/shm 挂载

    * 之前存储在 /dev/shm 中的所有数据都会丢失

    * 新的大小限制会影响所有使用共享内存的应用程序

    默认的 /dev/shm 大小通常是系统物理内存的 50%。
