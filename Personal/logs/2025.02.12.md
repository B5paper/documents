* nccl tmp

    * 多卡之间如何 reduce copy?

    * 如何动态确定多 srcs / dst?

* cuda 中，使用 struct 辅助实现偏特化

    因为 c++ 不允许模板函数的偏特化，所以我们使用 struct 辅助一下。

    `main.cu`:

    ```cpp
    #include <cuda_runtime.h>
    #include "../utils/cumem_hlc.h"
    #include "../utils/timeit.h"

    enum Op
    {
        op_sum,
        op_minus
    };

    template<typename T, Op op>
    struct Calc;

    template<typename T>
    struct Calc<T, op_sum>
    {
        __device__ static void do_calc(T *a, T *b, T *out)
        {
            *out = *a + *b; 
        }
    };

    template<typename T>
    struct Calc<T, op_minus>
    {
        __device__ static void do_calc(T *a, T *b, T *out)
        {
            *out = *a - *b;
        }
    };

    template<typename T, Op op>
    __global__ void do_calc(T *a, T *b, T *out)
    {
        Calc<T, op>::do_calc(a, b, out);
    }

    int main()
    {
        float *cubuf_1, *cubuf_2;
        cudaMalloc(&cubuf_1, sizeof(float));
        cudaMalloc(&cubuf_2, sizeof(float));
        assign_cubuf_rand_int(cubuf_1, 1);
        assign_cubuf_rand_int(cubuf_2, 1);
        print_cubuf(cubuf_1, 1);
        print_cubuf(cubuf_2, 1);
        do_calc<float, op_sum><<<1, 1>>>(cubuf_1, cubuf_2, cubuf_1);
        cudaDeviceSynchronize();
        printf("after:\n");
        print_cubuf(cubuf_1, 1);
        print_cubuf(cubuf_2, 1);
        return 0;
    }
    ```

    compile: `vcc -g -G main.cu -o main`

    run: `./main`

    output:

    ```
    3.0, specialized as float
    1.0, specialized as float
    after:
    4.0, specialized as float
    1.0, specialized as float
    ```

* cuda 中代码对函数进行偏特化时，`nvcc`的报错

    `main.cu`:

    ```cpp
    #include <cuda_runtime.h>
    #include "../utils/cumem_hlc.h"
    #include "../utils/timeit.h"

    enum Op
    {
        op_sum,
        op_minus
    };

    template<typename T, Op op>
    __global__ void do_calc(T *a, T *b, T *out);

    template<typename T>
    __global__ void do_calc<T, op_sum>(T *a, T *b, T *out)
    {
        *out = *a + *b; 
    }

    template<typename T>
    __global__ void do_calc<T, op_minus>(T *a, T *b, T *out)
    {
        *out = *a - *b;
    }

    int main()
    {
        float *cubuf_1, *cubuf_2;
        cudaMalloc(&cubuf_1, sizeof(float));
        cudaMalloc(&cubuf_2, sizeof(float));
        assign_cubuf_rand_int(cubuf_1, 1);
        assign_cubuf_rand_int(cubuf_2, 1);
        print_cubuf(cubuf_1, 1);
        print_cubuf(cubuf_2, 1);
        do_calc<float, op_sum><<<1, 1>>>(cubuf_1, cubuf_2, cubuf_1);
        cudaDeviceSynchronize();
        printf("after:\n");
        print_cubuf(cubuf_1, 1);
        print_cubuf(cubuf_2, 1);
        return 0;
    }
    ```

    compile: `nvcc -g -G main.cu -o main`

    compiling output:

    ```
    main_9.cu(21): error: function template "do_calc(T *, T *, T *)" has already been defined
      __attribute__((global)) void do_calc<T, op_minus>(T *a, T *b, T *out)
                                   ^

    1 error detected in the compilation of "main_9.cu".
    ```

    nvcc 编译器认为函数不能有偏特化，因此去找函数`do_calc()`的第一个实现，结果在代码中找到的是`do_calc<T, op_sum>()`。后来又找到了`do_calc<T, op_minus>()`的实现，因此就认为是重复定义了`do_calc()`，所以报错。