* pip 可以直接使用环境变量`http_proxy`, `https_proxy`等进行代理

* ubuntu 中 apt update 的图形界面的程序是`software-properties-gtk`

    启动时记得加上`sudo`或`sudo -E`，否则设置不会被保存。

* `ls -l`命令将最近修改时间的文件放到最上面

    `ls -lt`

    * -t：按修改时间排序，最新的文件在最前面。

    ls 的其他选项：

    * `-r`：倒序

    * `-a`：显示隐藏文件

* `ls`默认不支持直接按文件创建时间（birth time）排序

    ls 主要显示的是文件的修改时间（mtime）、访问时间（atime）和状态变更时间（ctime）

    较新的内核支持按创建时间排序：

    ```bash
    ls -lt --time=birth
    ```

    -l：长格式显示

    -t：按时间排序（默认是 mtime，但配合 --time=birth 就是按创建时间排序）

    --time=birth：显示并按创建时间排序

* ls 按访问时间排序

    ```bash
    ls -ltu
    ```

    -l：长格式显示

    -t：按时间排序（默认是 mtime，但配合 -u 就是按 atime 排序）

    -u：使用访问时间（atime）而不是修改时间（mtime）

* 二元函数的极限

    设二元函数$f(P) = f(x, y)$的定义域为$D$，$P_0(x_0, y_0)$是$D$的聚点。如果存在常数$A$，对于任意给定的正数$\varepsilon$，总存在正数$\delta$，使得当点$P(x, y) \in D \cap \mathring U (P_0, \delta)$时，都有

    $$\lvert f(P) - A \rvert = \lvert f(x, y) - A \rvert < \varepsilon$$

    成立，那么就称常数$A$为函数$f(x, y)$当$(x, y) \to (x_0, y_0)$时的极限，记作

    $$\lim_{(x, y) \to (x_0, y_0)} f(x, y) = A$$

    为了区别一元函数的极限，二元函数的极限又叫二重极限。

* 聚点

    如果对于任意给定的$\delta \gt 0$，点$P$的去心邻域$\mathring U (P, \delta)$内总有$E$中的点，则称$P$是$E$的聚点。

    注：

    1. 邻域是定义在全集（比如$\mathbb R^n$）中的，它可能包含很多不在$E$中的点。

        我们关心的是：无论取多么小的邻域，里面必须至少有一个来自$E$且不同于$P$的点（因为去心邻域排除了$P$本身）。

        用数学语言表达即为：

        $\forall \delta > 0$，$\mathring U(P, \delta) \cap E \neq \varnothing$。

        我们只关注这个邻域与$E$的交集非空，不要求整个邻域都在$E$内。

    1. 定义强调$E$中的点，主要是为了处理$P$在$E$的边界，或者$E$是稀疏点集等情况。

        下面是几个例子：

        * 在$R$中，取$E = (0,1] \cup \{ 2 \}$，考虑$P = 0$，$\mathring U (0, \delta)$。

            当$\delta \leq 1$时，$\mathring U$中的所有点都在$E$中；

            当$\delta \gt 1$时，$\mathring U$中的点有些在$E$中，有些不在，仍满足聚点的定义。

            在这个例子中，$P = 2$不是$E$的聚点，而是$E$的孤立点。

        * 取$E = \left\{ \frac{1}{n}, n \in \mathbb N \right\}$，$P = 0$，$\mathring U (0, \delta)$。

            由于$E$是离散的，所以无论$\delta$取多少，$\mathring U$中的大部分点都不在$E$中。

        * 取$E$为$\mathbb R^2$中的一个圆盘，$P$是边界上一点

            由于$P$在边界上，所以$\mathring U(P, \delta)$总是包含有$E$内的点和$E$外的点。

* 二元函数极限的证明 example

    题目：设$f(x, y) = (x^2 + y^2) \sin \frac{1}{x^2 + y^2}$，求证$\lim_{(x, y) \to (0, 0)} f(x, y) = 0$

    证明：

    $$\lvert f(x, y) - 0 \rvert = \lvert (x^2 + y^2) \sin \frac{1}{x^2 + y^2} - 0 \rvert \leq x^2 + y^2$$

    对于邻域$\mathring U(0, \delta)$内的任意一点$(x, y)$，总有

    $$x^2 + y^2 < \delta^2$$

    $\forall \varepsilon \gt 0$，我们取$\delta = \sqrt{\varepsilon}$，则有

    $$\lvert f(x, y) - 0 \rvert \leq x^2 + y^2 < \delta^2 = \varepsilon$$

    因此$A = 0$是其极限。

    注：

    1. $\delta = \sqrt{\varepsilon}$是我们手动构造的，方便代入或者缩放，构造不等式。

* `dma_sync_single_for_cpu()`

    在 DMA 传输完成后，让 CPU 能够安全地访问已被 DMA 设备写入数据的内存缓冲区，或者确保 CPU 对缓冲区的修改能被下一次 DMA 传输正确读取。

    在 CPU 和 DMA 设备之间同步一块共享内存的数据， 为了 CPU 即将进行的访问做准备。

    syntax:

    ```c
    #include <linux/dma-mapping.h>

    void dma_sync_single_for_cpu(
        struct device *dev,
        dma_addr_t addr,
        size_t size,
        enum dma_data_direction dir
    );
    ```

    * `dev`: 指向设备结构体的指针。这个指针通常在你初始化设备时获得（例如通过 &pdev->dev 获取平台设备指针）。它包含了 DMA 掩码等设备相关的 DMA 属性。

    * `addr`: DMA 总线的地址。这个地址不是内核的虚拟地址，而是之前通过 dma_map_single() 或类似映射函数返回的地址。它代表了设备能够直接访问的内存位置。

    * `size`: 需要同步的内存区域的大小（以字节为单位）。这个大小应该与你之前映射时使用的大小一致。

    * `dir`: DMA 数据传输的方向。这个方向必须与之前调用 dma_map_single() 时使用的方向一致。它有以下几种可能的值：

        * `DMA_BIDIRECTIONAL`

        * `DMA_TO_DEVICE`

        * `DMA_FROM_DEVICE`

    CPU 和 DMA 设备之间的 缓存一致性 问题:

    1. CPU 有缓存：CPU 访问内存时，会把数据缓存在自己的高速缓存（Cache）里，以加速后续访问。这意味着，CPU 看到的数据可能不是内存中的最新数据。

    2. DMA 直接访问内存：DMA 设备不经过 CPU，直接与内存交互。它不知道 CPU 的缓存里有什么。

    3. 数据不一致的风险：

        场景一（DMA 设备 -> CPU）：DMA 设备将新数据直接写入内存。但此时 CPU 缓存里的可能还是旧数据。如果 CPU 不去读取内存而直接读缓存，就会得到错误（过时）的数据。

        场景二（CPU -> DMA 设备）：CPU 准备了一些数据，打算让 DMA 设备来读取。CPU 可能只把数据写到了自己的缓存里，还没来得及写回内存。如果此时 DMA 设备直接从内存读取，得到的就是不完整/错误的数据。

    `dma_sync_single_for_cpu()` 就是为了解决上述 场景一 的问题，确保在 DMA 输入操作（设备到内存）后，CPU 能读到最新数据。同时，它也会为 场景二 的下一次传输做准备。

    这个函数会根据 DMA 的方向（由之前建立映射时指定）来执行不同的操作：

    * 如果方向是 DMA_FROM_DEVICE（数据从设备到内存）：

        作用：使 CPU 的缓存失效。

        解释：这相当于告诉 CPU：“你缓存里的这块内存数据已经过期了，下次读的时候必须去内存里拿最新的。” 这样 CPU 就能读到 DMA 设备刚刚传输过来的新数据。

    * 如果方向是 DMA_TO_DEVICE（数据从内存到设备）或 DMA_BIDIRECTIONAL（双向）：

        作用：通常在这个时机不做太多事，但它隐含着为下一次 DMA_TO_DEVICE 做准备。其主要同步工作是在它的“兄弟函数” dma_sync_single_for_device 中完成的（该函数在启动 DMA 前调用，用于刷写 CPU 缓存到内存）。

    一个典型的执行流程

    1. 分配缓冲区：驱动程序分配一块内存缓冲区。

    2. 映射 DMA：调用 dma_map_single()，获取一个设备可以理解的总线地址。（此时可能会刷写 CPU 缓存，确保设备能读到正确数据）

    3. 启动 DMA（设备读）：将总线地址告诉设备，并启动 DMA 传输（例如，从设备读取数据到内存）。

    4. DMA 传输中：设备独立工作，将数据写入内存。CPU 可以处理其他任务。

    5. DMA 传输完成：设备发出中断，通知 CPU 传输完成。

    6. 同步给 CPU：驱动程序中调用 dma_sync_single_for_cpu(...， DMA_FROM_DEVICE)。这会使得 CPU 缓存中对应这块缓冲区的部分失效。

    7. CPU 访问数据：现在，驱动程序可以安全地读取缓冲区，CPU 会从主内存中获取 DMA 设备写入的最新数据，而不是过时的缓存数据。

    8. 解除映射：当不再需要 DMA 访问时，调用 dma_unmap_single() 解除映射。

* py 中实现 enum

    ```py
    from enum import Enum

    class Color(Enum):
        RED = 1
        GREEN = 2
        BLUE = 3

    # 使用
    print(Color.RED)        # Color.RED
    print(Color.RED.name)   # RED
    print(Color.RED.value)  # 1
    ```

    自动赋值:

    ```py
    from enum import Enum, auto

    class Color(Enum):
        RED = auto()
        GREEN = auto()
        BLUE = auto()

    print(Color.RED.value)   # 1
    print(Color.GREEN.value) # 2
    ```

    字符串枚举:

    ```py
    from enum import Enum

    class HttpStatus(Enum):
        OK = "200 OK"
        NOT_FOUND = "404 Not Found"
        SERVER_ERROR = "500 Internal Server Error"

    print(HttpStatus.OK.value)  # "200 OK"
    ```

    使用 IntEnum（整数枚举）:

    ```py
    from enum import IntEnum

    class Priority(IntEnum):
        LOW = 1
        MEDIUM = 2
        HIGH = 3

    # IntEnum 可以与其他整数比较
    print(Priority.LOW == 1)  # True
    ```

    使用 Flag（标志枚举）:

    ```py
    from enum import Flag, auto

    class Permission(Flag):
        READ = auto()
        WRITE = auto()
        EXECUTE = auto()
        READ_WRITE = READ | WRITE

    # 使用
    user_permissions = Permission.READ | Permission.WRITE
    print(Permission.READ in user_permissions)  # True
    ```

    唯一值枚举:

    ```py
    from enum import Enum, unique

    @unique
    class Status(Enum):
        PENDING = 1
        PROCESSING = 2
        COMPLETED = 3
        # ERROR = 1  # 这会抛出 ValueError，因为值重复
    ```

    对枚举进行迭代：

    ```py
    from enum import Enum

    class Color(Enum):
        RED = 1
        GREEN = 2
        BLUE = 3

    for color in Color:
        print(color.name, color.value)
    ```

* 每天执行 2 个线性调研任务就差不多了（输入），剩下的时间应该去自由探索和验证想法（输出）

    线性学习任务是永无止境的，又是自底向上的方法，学完了只能“暂时存着”，等到后面有一天突然发现（模式匹配到）手头的任务要用到这些存储的底层知识时，这些线性学习的成果才能有用武之地，效率很低。

    对于非线性的探索任务，用到什么查什么资料，跟随心里的节奏，完成任务的效率会高一些。

    但是线性调研和 qa exam 又不能完全不做，这是基石，基础，是食材，颜料，是线性组合的基底。这些线性调研的知识点通过灵活的组合、变形、延伸，会有强大的力量。