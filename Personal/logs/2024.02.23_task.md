1. [v] cache tabs 30 mins

    10:32 ~10:44

    feedback:

    1. 以后可以把 cache tabs 的时间缩减到 15 分钟

2. [v] qa 随机 4 个 40 mins

    10:52 ~ 11:02

3. [v] 实现`python3 main.py --randexam <qa_file_path_collection_path> <num>` 30 mins

    随机抽取`<num>`个项目，每个项目中再随机抽取一个 item。保证`<num>`个项目都是不一样的。

    如果`<num>`大于项目的总数，那么发出 warning，并只抽取`<max_num>`个项目。

    如果没有`<num>`参数，只随机抽取一个。

4. [v] 力扣做一道略论的题

    13:29 ~ 15:51

5. [v] vulkan 学习 command pool，command buffer 的创建 30 mins

    15:52 ~ 17:01

    feedback:

    1. 目前的进展到这里

        ```cpp
        #include "../simple_vulkan/simple_vk.hpp"

        int main()
        {
            glfwInit();
            VkInstance inst;
            create_vk_instance(inst);
            glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
            GLFWwindow *window = glfwCreateWindow(700, 500, "hello", nullptr, nullptr);
            VkSurfaceKHR surf;
            glfwCreateWindowSurface(inst, window, nullptr, &surf);
            VkPhysicalDevice phy_dev;
            uint32_t queue_family_idx;
            select_vk_physical_device(phy_dev, queue_family_idx, queue_family_idx, inst, surf);
            VkDevice device;
            VkQueue queue;
            create_vk_device(device, queue, queue, phy_dev, queue_family_idx, queue_family_idx);
            VkSwapchainKHR swpch;
            create_vk_swapchain(swpch, device, surf, queue_family_idx);
            VkRenderPass render_pass = create_render_pass(VK_FORMAT_B8G8R8A8_SRGB, device);
            VkPipeline pipeline = create_pipeline("./vert_2.spv", "frag_2.spv", 0, {0, 0}, device, {700, 500}, render_pass);
            
            uint32_t swpch_img_count;
            vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, nullptr);
            std::vector<VkImage> swpch_imgs(swpch_img_count);
            vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, swpch_imgs.data());

            std::vector<VkImageView> swpch_img_views(swpch_img_count);
            VkImageViewCreateInfo img_view_crt_info{};
            img_view_crt_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
            img_view_crt_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
            img_view_crt_info.format = VK_FORMAT_B8G8R8A8_SRGB;
            img_view_crt_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};
            VkResult result;
            for (int i = 0; i < swpch_img_count; ++i)
            {
                img_view_crt_info.image = swpch_imgs[i];
                result = vkCreateImageView(device, &img_view_crt_info, nullptr, &swpch_img_views[i]);
                if (result != VK_SUCCESS)
                {
                    printf("fail to create image view, error code %d\n", result);
                    exit(-1);
                }
            }

            VkFramebufferCreateInfo frame_buf_crt_info{};
            frame_buf_crt_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
            frame_buf_crt_info.renderPass = render_pass;
            frame_buf_crt_info.attachmentCount = 1;
            frame_buf_crt_info.width = 700;
            frame_buf_crt_info.height = 500;
            frame_buf_crt_info.layers = 1;
            std::vector<VkFramebuffer> frame_bufs(swpch_img_count);
            for (int i = 0; i < swpch_img_count; ++i)
            {
                frame_buf_crt_info.pAttachments = &swpch_img_views[i];
                result = vkCreateFramebuffer(device, &frame_buf_crt_info, nullptr, &frame_bufs[i]);
                if (result != VK_SUCCESS)
                {
                    printf("fail to create frame buffer, error code: %d\n", result);
                    exit(-1);
                }
            }

            VkCommandPool cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
            cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
            VkCommandBuffer cmd_buf;
            VkCommandBufferAllocateInfo cmd_buf_alc_info{};
            cmd_buf_alc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
            cmd_buf_alc_info.commandBufferCount = 1;
            cmd_buf_alc_info.commandPool = cmd_pool;
            cmd_buf_alc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
            result = vkAllocateCommandBuffers(device, &cmd_buf_alc_info, &cmd_buf);
            if (result != VK_SUCCESS)
            {
                printf("fail to allocate command buffer\n");
                exit(-1);
            }

            return 0;
        }
        ```

        下次直接从这里开始，不用再浪费时间了。

6. [v] 复习 opencl，尝试给出一个 qa

    17:38 ~ 18:30

    feedback:

    1. opencl 的笔记缺少很多基础东西，需要慢慢补全

7. [ ] 调研编译器