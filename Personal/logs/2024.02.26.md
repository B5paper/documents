* 应该三天整理一次 log

    五天整理一次 log 会花将近一个小时

* compiler: 正则表达式，regular expression

    正则表达式其实是定义了一个由字符串组成的集合。正则表达式可以使用有限的符号来定义无限元素的集合。

    * 符号（symbol）

        symbol $\bold a$ 可以匹配任意包含$\bold a$的字符串。

    * 可选（alternation）

        对于两个正则表达式$M$，$N$，$M | N$可以形成一个新的正则表达式。只要一个字符串包含$M$或$N$其中的一个，就可以匹配得上。

    * 联结（concatenation）

        $M \cdot N$表示$M$后紧跟$N$。

    * $\epsilon$（epsilon）

        表示空字符串。

    * 重复（repetition）

        对于给定的正则表达式$M$，它的克林（Kleene）闭包是$M^*$。

        如果一个字符串是由$M$中的字符串经零至多次联结运算的结果，则该字符串属于$M^*$。

    Examples:

    * $a$

        表示`{"a"}`。

    * $a\, |\, b$

        表示`{"a", "b"}`。

    * $(a\, |\, b) \cdot a$

        表示`{"aa", "ba"}`。

    * $(a \cdot b) \, |\, \epsilon$

        表示`{"", "ab"}`。

    * $((a\, |\, b) \cdot a)^*$

        表示`{"", "aa", "ba", "aaaa", "baaa", "aaba", "baba", "aaaaaa", ...}`

    * $(0 \, | \, 1)^* \cdot 0$

        由$2$的倍数组成的二进制数。

    * $b^*(abb^*)^*(a \, | \, \epsilon)$

        由`a`和`b`组成，但`a`不连续出现的字符串。

    * $(a\, | \, b)^*aa(a \, | \, b)^*$

        由`a`和`b`组成，且有连续出现的`a`的字符串。

    在写正则表达式时，联结符号（$\cdot$）和$\epsilon$符号可以被省略。并假定克林闭包的优先级高于联结运算，联结运算的优先级高于可选运算。

    examples:

    * $ab \, | \, c$表示$(a \cdot b) \, | \, c$

    * $(a\, |\, )$表示$(a \, | \, \epsilon)$

    感觉这样定义的正则表达式其实就是离散数学和集合论的结合，每个位置上可能有，可能没有，再加𣥖与，或，空集。

* vulkan vertex buffer, index buffer

    example code:

    ```cpp
    float vtxs[9] = {
        -0.5, 0, 0,
        0, 0.5, 0,
        0.5, 0, 0
    };
    VkBuffer vtx_buf;
    VkDeviceMemory vtx_buf_mem;
    create_vk_buffer(vtx_buf, vtx_buf_mem, phy_dev, device, 3 * 3 * sizeof(float), VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
    float *p_mem_data = nullptr;
    result = vkMapMemory(device, vtx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
    memcpy(p_mem_data, vtxs, sizeof(vtxs));
    vkUnmapMemory(device, vtx_buf_mem);

    uint32_t idxs[3] = {0, 1, 2};
    VkBuffer idx_buf;
    VkDeviceMemory idx_buf_mem;
    create_vk_buffer(idx_buf, idx_buf_mem, phy_dev, device, sizeof(idxs), VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
    vkMapMemory(device, idx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
    memcpy(p_mem_data, idxs, sizeof(idxs));
    vkUnmapMemory(device, idx_buf_mem);

    VkCommandBufferBeginInfo cmd_buf_beg_info{};
    cmd_buf_beg_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    cmd_buf_beg_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    vkBeginCommandBuffer(cmd_buf, &cmd_buf_beg_info);
    VkDeviceSize offset = 0;
    vkCmdBindVertexBuffers(cmd_buf, 0, 1, &vtx_buf, &offset);
    vkCmdBindIndexBuffer(cmd_buf, idx_buf, 0, VK_INDEX_TYPE_UINT32);
    vkEndCommandBuffer(cmd_buf);
    ```

    vulkan 专门给出了`VK_BUFFER_USAGE_VERTEX_BUFFER_BIT`和`VK_BUFFER_USAGE_INDEX_BUFFER_BIT`这两个 buffer 类型，用于创建 vertex buffer 和 index buffer。如果用了其他类型，后面`vkCmdBindXXXXBuffer()`会运行时报错。

    数据的传递通过 map memory 完成。