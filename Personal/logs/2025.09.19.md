* cache entry 必须够小，够多，才能形成 topic。如果都是长篇、深入、垂直的 cache entry，那么很难形成 topic。

* ssh 远程执行 command，kill 本地 ssh 后，远程 command 被同步关闭

    可以使用`ssh -f -tt user@host "<command> > /dev/null 2>&1"`

    解释：

    * `-f`: fork 一份 ssh 在后台运行

    * `-tt`: 强制分配一个 psudo terminal，使得 local ssh 被 kill 时，远程的 psudo terminal 也被 kill，顺便清空 psudo terminal 里的所有 jobs

        `-t`只是建议分配 psudo terminal，和`-f`合用时会被抑制。`-tt`则是强制分配，不会被抑制。

    * `> /dev/null 2>&1`: 如果不加这个，远程的 stdout 会输出到当前 local terminal

* `objdump -p <文件名> | grep NEEDED`

    * -p 选项： 代表 --private-headers，用于显示文件格式中特定于该文件的“私有”头信息。对于 ELF 格式的文件（Linux 和大多数Unix-like系统上的标准格式），这个选项会显示出程序头表（Program Headers） 和动态段（Dynamic Section） 等关键信息。

    ldd 会实际尝试加载库并模拟运行，在某些不安全的情况下可能执行恶意代码。而 objdump -p | grep NEEDED 是静态分析，只读取文件头信息，因此更安全，尤其是在分析来源不可信的二进制文件时。

    其他常见的标签：

    * 核心依赖与加载相关

        * `NEEDED`

            该文件运行时所依赖的共享库的名称（如 libc.so.6）。一个文件可以有多个 NEEDED 条目。

        * `SONAME`(Shared Object Name)

            仅存在于共享库（.so 文件）中。它包含了该库的共享对象名称。链接器在链接时会把这个名字（而不是文件名）记录到最终的可执行文件中。这就是实现库版本兼容性的关键机制。

            例如，你有一个文件名为 libxyz.so.1.2.3 的库，但其 SONAME 可能是 libxyz.so.1。可执行文件在运行时寻找的将是 libxyz.so.1，而不是具体的 libxyz.so.1.2.3。

        * `RPATH` / `RUNPATH`

            包含一个用冒号分隔的目录列表。动态链接器在查找 NEEDED 库时，会优先在这些目录中搜索，然后再去默认的系统库路径（如 /lib, /usr/lib）中查找。

            RPATH 是较老的属性，其优先级很高。

            RUNPATH 是新标准，其优先级规则不同（在 LD_LIBRARY_PATH 之后查找）。

    * 符号解析相关

        * HASH / GNU_HASH: 指向一个符号哈希表。动态链接器使用这个表来快速查找函数和变量（符号）在库中的地址，极大地加快了动态链接的过程。GNU_HASH 是现代 Linux 系统上更优的格式。

        * STRTAB: 指向字符串表的地址。该表存储了所有动态链接所需的字符串，如符号名、库名等。

        * SYMTAB: 指向符号表的地址。该表包含了所有需要被动态链接的符号（函数名、变量名）的详细信息（名称、值、大小等）。链接器通常结合 HASH 和 STRTAB 来使用它。

        * PLT (Procedure Linkage Table) / PLTGOT (通常显示为 JMPREL): 指向重定位表的地址。这个表包含了所有需要延迟绑定（Lazy Binding）的函数引用信息。这是实现“第一次调用函数时才进行链接”机制的关键。

    * 初始化与终止相关

        * INIT: 指向初始化函数的地址。这个函数（通常命名为 _init）会在该共享库被加载到内存后、任何其他代码执行之前，由动态链接器自动调用。用于完成该库的全局构造和初始化工作。

        * FINI: 指向终止函数的地址。这个函数（通常命名为 _fini）会在该共享库从内存中卸载之前，由动态链接器自动调用。用于完成清理工作（如释放资源）。

            注意：现代代码更推荐使用 `__attribute__((constructor))` 和 `__attribute__((destructor))` 函数属性来代替直接使用 _init 和 _fini 节。

    * 其他重要标签

        * TEXTREL: 这是一个标志。如果存在，表明链接器需要修改代码段（.text段）的权限（例如将其设为可写）以便进行重定位。这通常意味着共享库不是用 -fPIC 选项编译的（位置无关代码），会带来安全性和性能上的损失。看到这个标志通常不是好事情。

        * FLAGS / FLAGS_1: 一些特殊的标志位。例如 FLAGS_1 中的 PIE 标志表示该可执行文件是位置无关的可执行文件（Position-Independent Executable），这是现代Linux系统上ASLR（地址空间布局随机化）的基础。

        * DEBUG: 这是一个占位符，用于调试信息，通常没有运行时语义。

    ref: 
    
    1. <https://docs.oracle.com/cd/E53394_01/html/E54813/chapter6-42444.html>

    1. `man 5 elf`

    1. <https://www.gnu.org/software/binutils/>

* elf dynamic section lookup table

    | 标签名 (Tag) | 十六进制值 (Hex) | 含义简述 |
    | - | - | - |
    | DT_NULL | 0x0 | 标记动态段的结束 |
    | DT_NEEDED | 0x1 | 所需共享库的名称（字符串表偏移） |
    | DT_PLTGOT | 0x3 | 全局偏移表（GOT）和/或过程链接表（PLT）的地址 |
    | DT_HASH | 0x4 | 符号哈希表的地址 |
    | DT_STRTAB | 0x5 | 字符串表的地址 |
    | DT_SYMTAB | 0x6 | 符号表的地址 |
    | DT_INIT | 0xC | 初始化函数的地址 |
    | DT_FINI | 0xD | 终止函数的地址 |
    | DT_SONAME | 0xE | 共享库自身的SONAME（字符串表偏移） |
    | DT_RPATH | 0xF | 库搜索路径（已过时，被DT_RUNPATH取代） |
    | DT_SYMBOLIC | 0x10 | 提示链接器从该库本身开始符号解析 |
    | DT_DEBUG | 0x15 | 用于调试（运行时地址由调试器填充） |
    | DT_TEXTREL | 0x16 | 存在代码段重定位，表明非PIC代码 |
    | DT_JMPREL | 0x17 | PLT重定位条目的地址 |
    | DT_RUNPATH | 0x1D | 库搜索路径 |
    | DT_GNU_HASH | 0x6FFFFEF5 | GNU扩展的哈希表样式 |
    | DT_INIT_ARRAY | 0x19 | 初始化函数指针数组的地址 |
    | DT_FINI_ARRAY | 0x1A | 终止函数指针数组的地址 |

* `set tags=./tags,./TAGS,tags,TAGS,/path/to/other/tags`

    设置 Vim 查找 tags 文件的搜索路径列表，用逗号分隔多个路径。

    解释：

    * `./tags` - 当前文件所在目录的 tags 文件

    * `./TAGS` - 当前文件所在目录的 TAGS 文件（大写版本）

    * `tags` - 当前工作目录的 tags 文件

    * `TAGS` - 当前工作目录的 TAGS 文件（大写版本）

    * `/path/to/other/tags` - 指定的绝对路径下的 tags 文件

* 内存屏障

    内存屏障（Memory Barrier），也称为内存栅栏（Memory Fence），是一类低级别的指令，用于强制限制CPU和编译器对内存访问操作的重排序。

    它的主要作用是：确保屏障之前的特定内存操作一定在屏障之后的特定内存操作之前完成。

    如果没有内存屏障，为了提高性能，CPU和编译器可能会对指令进行重排序，这在单核时代没问题，但在多核多线程并发环境下，会导致其他线程看到错误的执行顺序，从而引发不可预知的错误。

* `wmb()`

    写内存屏障 (Write Memory Barrier), 全称: smp_wmb(), 是 linux kernel 中定义的宏。

    确保所有在 wmb() 之前的写操作，一定在所有在 wmb() 之后的写操作之前执行完成。

    syntax:

    ```c
    #include <asm-generic/barrier.h>
    #include <arch/x86/include/asm/barrier.h>  // for x86 arch

    wmb()
    ```

    * 典型场景: 生产者-消费者模式

        1. 生产者准备数据（写操作到内存缓冲区）。

        2. 生产者设置一个标志位（例如 data_ready = 1）来通知消费者数据准备好了。

        如果没有 wmb()，CPU或编译器可能会重排序，先执行步骤2（写标志位），后执行步骤1（写数据）。这样消费者看到标志位后去读数据，读到的可能就是还没准备好的错误数据。
        在步骤1和步骤2之间插入 wmb()，就能保证数据一定先于标志位被写入。

* `rmb()`

    读内存屏障 (Read Memory Barrier), 全称: smp_rmb()

    确保所有在 rmb() 之前的读操作，一定在所有在 rmb() 之后的读操作之前执行完成。

    * 典型场景: 生产者-消费者模式（消费者侧）

        1. 消费者看到标志位 data_ready == 1（读操作）。

        2. 消费者去读取生产者准备好的数据（读操作）。

        如果没有 rmb()，CPU可能会为了效率先预读数据缓冲区，然后再检查标志位。如果标志位检查失败，它就读到了无效的旧数据。
        在步骤1和步骤2之间插入 rmb()，就能保证一定是先读完标志位，确认数据有效后，再去读数据。

* `wmb()`与`rmb()`的 ecample

    ```c
    // 共享数据结构
    struct shared_data {
        int data[100];
        int flag;
    };

    // 生产者线程
    void producer(void) {
        // ... 准备数据到 data_buffer ...
        for (int i = 0; i < 100; i++) {
            shared->data[i] = i;
        }

        // 写内存屏障！确保上面的数据写入一定先于下面的标志位写入
        wmb();

        // 发布数据：通知消费者数据准备好了
        shared->flag = 1;
    }

    // 消费者线程
    void consumer(void) {
        while (!shared->flag) { // 等待数据准备好
            // 等待...
        }

        // 读内存屏障！确保先读完标志位，再读数据
        rmb();

        // 现在可以安全地消费数据了
        for (int i = 0; i < 100; i++) {
            print("%d\n", shared->data[i]);
        }
    }
    ```

* `dma_set_mask_and_coherent()`主要影响的是`dma_alloc_coherent()`, `dma_map_single()`之类的函数，与`pci_iomap()`无关。

* 一个 pci iomap 的 example

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/pci.h>

    static struct pci_device_id pci_id_table[] = {
        { PCI_DEVICE(0x1234, 0x11e8) },
        {0,}
    };

    static void *base_addr_bar0;

    static int edu_probe(struct pci_dev *pci_dev, const struct pci_device_id *id) {
        pr_info("in edu_probe()...\n");

        int ret = pci_enable_device(pci_dev);
        if (ret != 0) {
            dev_err(&pci_dev->dev, "fail to pci enable device, ret: %d\n", ret);
            goto ERR_PCI_ENABLE_DEVICE;
        }

        ret = pci_request_region(pci_dev, 0, "qemu_edu_drv");
        if (ret != 0) {
            dev_err(&pci_dev->dev, "fail to pci request region\n");
            goto ERR_PCI_REQUEST_REGION;
        }

        resource_size_t res_len_bar0 = pci_resource_len(pci_dev, 0);
        base_addr_bar0 = pci_iomap(pci_dev, 0, res_len_bar0);
        if (base_addr_bar0 == NULL) {
            dev_err(&pci_dev->dev, "fail to pci iomap\n");
            goto ERR_PCI_IOMAP;
        }
        
        return 0;

    ERR_PCI_IOMAP:
        pci_release_region(pci_dev, 0);
    ERR_PCI_REQUEST_REGION:
        pci_disable_device(pci_dev);
    ERR_PCI_ENABLE_DEVICE:
        return -1;
    }

    static void edu_remove(struct pci_dev *pci_dev) {
        pr_info("in edu_remove()...\n");
        pci_iounmap(pci_dev, base_addr_bar0);
        pci_release_region(pci_dev, 0);
        pci_disable_device(pci_dev);
    }

    static struct pci_driver edu_driver = {
        .name = "qemu_edu_drv",
        .id_table = pci_id_table,
        .probe = edu_probe,
        .remove = edu_remove
    };

    int init_mod(void) {
        pr_info("init hlc module...\n");
        int ret = pci_register_driver(&edu_driver);
        if (ret != 0) {
            pr_err("fail to register pci driver\n");
            goto ERR_PCI_REGISTER_DRIVER;
        }
        return 0;

    ERR_PCI_REGISTER_DRIVER:
        return -1;
    }

    void exit_mod(void) {
        pr_info("exit hlc module...\n");
        pci_unregister_driver(&edu_driver);
    }

    module_init(init_mod);
    module_exit(exit_mod);
    MODULE_LICENSE("GPL");
    ```

    dmesg output:

    ```
    [ 1514.274978] hello: loading out-of-tree module taints kernel.
    [ 1514.275048] hello: module verification failed: signature and/or required key missing - tainting kernel
    [ 1514.277452] init hlc module...
    [ 1514.277735] in edu_probe()...
    [ 1514.313214] ACPI: \_SB_.LNKD: Enabled at IRQ 10
    [ 1523.042644] exit hlc module...
    [ 1523.042691] in edu_remove()...
    ```