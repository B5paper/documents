* zig

    website: <https://ziglang.org/>

    验证安装: `zig version`
    
    **基本用法**

    1. 编写第一个程序

        创建 hello.zig：
        
        ```zig
        const std = @import("std");

        pub fn main() !void {
            std.debug.print("Hello, {s}!\n", .{"World"});
        }
        ```

    2. 运行与编译

        直接运行（临时编译执行）：

        ```bash
        zig run hello.zig
        ```

        编译为可执行文件：

        ```bash
        zig build-exe hello.zig
        ./hello
        ```

        调试版本（带调试信息）：

        ```bash
        zig build-exe hello.zig -O Debug
        ```

        发布版本（优化）：

        ```bash
        zig build-exe hello.zig -O ReleaseSafe
        ```

        注：

        1. zig 没有添加 bash completion，所以`zig bui<tab>`不会自动补全子命令

        1. `-O Debug`中 Debug 的 D 必须大写，否则会报错。

    3. 使用构建系统（zig build）

        创建 build.zig：

        ```zig
        const std = @import("std");

        pub fn build(b: *std.Build) void {
            const exe = b.addExecutable(.{
                .name = "myapp",
                .root_source_file = .{ .path = "src/main.zig" },
            });
            b.installArtifact(exe);
        }
        ```

        运行构建：

        ```bash
        zig build
        ```

        注：

        1. 执行后报错

            ```
            (base) hlc@hlc-VirtualBox:~/Documents/Projects/zig_test$ zig build
            build.zig:6:10: error: no field named 'root_source_file' in struct 'Build.ExecutableOptions'
                    .root_source_file = .{ .path = "src/main.zig" },
                     ^~~~~~~~~~~~~~~~
            /home/hlc/Softwares/zig-x86_64-linux-0.16.0-dev.1859+212968c57/lib/std/Build.zig:767:31: note: struct declared here
            pub const ExecutableOptions = struct {
                                          ^~~~~~
            referenced by:
                runBuild__anon_30442: /home/hlc/Softwares/zig-x86_64-linux-0.16.0-dev.1859+212968c57/lib/std/Build.zig:2235:33
                main: /home/hlc/Softwares/zig-x86_64-linux-0.16.0-dev.1859+212968c57/lib/compiler/build_runner.zig:456:29
                5 reference(s) hidden; use '-freference-trace=7' to see all references
            ```

    **关键特性体验**

    1. 编译时计算

        ```zig
        const std = @import("std");

        fn factorial(n: u32) u32 {
            return if (n == 0) 1 else n * factorial(n - 1);
        }

        pub fn main() void {
            const result = comptime factorial(5); // 编译时计算
            std.debug.print("5! = {d}\n", .{result});
        }
        ```

    2. 交叉编译

        ```bash
        # 编译为 Windows 64 位程序
        zig build-exe hello.zig -target x86_64-windows

        # 编译为 ARM Linux 程序
        zig build-exe hello.zig -target aarch64-linux-gnu
        ```

    **开发工具**

    1. 语言服务器

        Zig 自带 LSP，支持编辑器自动补全：

        ```bash
        zig build-exe --help  # 查看所有选项
        ```

    2. 文档生成

        ```bash
        zig test hello.zig --docs  # 生成文档
        ```

        注：

        1. 这个功能好像不能用。可能是 ai 的幻觉。

    3. 测试

        在源码中添加测试：

        ```zig
        test "basic test" {
            try std.testing.expect(1 + 1 == 2);
        }
        ```

        运行测试：

        ```bash
        zig test hello.zig
        ```

    **注意事项**

    * 版本选择：Zig 更新较快，建议使用最新稳定版。

    * 标准库文档：使用 `zig std` 命令查看本地文档。

    * 包管理：目前依赖通过 Git 子模块或构建系统管理，官方包管理器在开发中。

    注：

    1. `zig std`会生成文档网页，监听 127.0.0.1 的端口，并且在浏览器中打开。

    **学习资源**

    * 官方文档：
    
        Zig Language Reference: <https://ziglang.org/documentation>

    * 《Zig 语言圣经》：
    
        zig.guide: <https://ziglearn.org>

    Zig 的设计强调直观和可控，适合系统编程、编译器开发或对性能有严苛要求的场景。

* tar

    tar 是 Linux/Unix 系统中用于打包和压缩文件的核心命令，名称源于 Tape Archive（磁带归档）。

    **基本语法**

    ```bash
    tar [选项] [输出文件] [输入文件/目录]
    ```

    **常用操作选项**

    1. 主要操作（必须选一个）

        * `-c`：创建新归档（create）。

        * `-x`：解压归档（extract）。

        * `-t`：查看归档内容（list）。

        * `-r`：向归档追加文件（不常用）。

    2. 辅助选项

        * `-f [文件名]`：指定归档文件名（file）。必须放在选项最后。

        * `-v`：显示处理过程（verbose）。

        * `-z`：通过 gzip 压缩/解压（后缀通常为 .tar.gz 或 .tgz）。

        * `-j`：通过 bzip2 压缩/解压（后缀 .tar.bz2）。

        * `-J`：通过 xz 压缩/解压（后缀 .tar.xz）。

        * `-C [目录]`：解压到指定目录（Change directory）。

        * `--exclude=`：排除特定文件/目录。

    **常用示例**

    1. 打包与压缩

        ```bash
        # 打包目录（不压缩）
        tar -cvf archive.tar /path/to/dir

        # 打包并用 gzip 压缩
        tar -czvf archive.tar.gz /path/to/dir

        # 打包并用 bzip2 压缩
        tar -cjvf archive.tar.bz2 /path/to/dir

        # 打包时排除某些文件
        tar -czvf backup.tar.gz --exclude="*.log" /path/to/dir
        ```

    2. 查看归档内容

        ```bash
        tar -tf archive.tar.gz      # 仅列表
        tar -tzvf archive.tar.gz    # 列表并显示详细信息
        ```

        注：

        1. tar 无法快速只查看顶层文件，必须配合正则表达式之类的命令来过滤才能看到。

    3. 解压

        ```bash
        # 解压到当前目录
        tar -xvf archive.tar
        tar -xzvf archive.tar.gz    # 解压 gzip
        tar -xjvf archive.tar.bz2   # 解压 bzip2

        # 解压到指定目录
        tar -xzvf archive.tar.gz -C /target/dir
        ```

    4. 直接操作压缩包内容

        ```bash
        # 不解压直接查看文件内容
        tar -O -xzf archive.tar.gz file.txt | less

        # 追加文件到压缩包（仅适用于未压缩的 tar 包）
        tar -rf archive.tar newfile.txt
        ```

    **常用组合速记**

    * 创建压缩包：`tar -czvf [输出文件.tar.gz] [目录]`

    * 解压压缩包：`tar -xzvf [文件.tar.gz]`

    * 查看内容：`tar -tzvf [文件.tar.gz]`

    **注意事项**

    * 选项顺序：-f 必须后接文件名，且通常放在最后。

    * 保留权限：默认保留文件权限（如需保留所有权用 -p，但需 root 权限）。

    * 现代简化写法：较新版本的 tar 支持省略 -，如 tar xvf archive.tar。

    * 压缩效率：xz > bzip2 > gzip（压缩率越高，耗时越长）。

    **实用技巧**

    ```bash
    # 1. 打包时保留软链接（默认行为）
    tar -czhf backup.tar.gz /path

    # 2. 仅打包比指定日期新的文件
    tar -czvf newfiles.tar.gz --newer="2023-01-01" /path

    # 3. 增量备份（结合 find）
    find /data -type f -mtime -7 | tar -czvf backup_week.tar.gz -T -
    ```
    
    掌握这些核心用法即可应对大多数场景，更多细节可通过 `man tar` 查看。

* 高阻态

    在没有 AI 时，心生的无数的问题因为信息不够或者没有导师指导无法推动进度，这些问题既无法被遗忘，也无法被解决，只能因为悬挂的高阻态，等待未来被解决的机缘。

* `tar -t`只查看顶层目录

    方法一：使用 --strip-components（推荐）

    ```bash
    tar -tf archive.tar.gz --strip-components=0

    --strip-components=0 会显示完整的路径，但配合其他命令可以筛选出顶层目录。
    ```

    方法二：使用管道组合命令

    ```bash
    # 只显示第一级目录/文件（不包含子目录内容）
    tar -tf archive.tar.gz | cut -d/ -f1 | sort -u

    # 或者使用 awk
    tar -tf archive.tar.gz | awk -F/ '{print $1}' | sort -u

    # 或者使用 sed
    tar -tf archive.tar.gz | sed 's|/.*||' | sort -u
    ```

    方法三：查看目录类型的顶层项目

    ```bash
    # 只显示顶层目录（排除文件）
    tar -tf archive.tar.gz | grep -E '^[^/]+/$' | head -20

    # 显示所有顶层项目（目录和文件）
    tar -tf archive.tar.gz | grep -v '/' | head -20
    ```

    方法四：使用 tar 的过滤选项（tar 1.28+）

    ```bash
    # 只显示目录（部分版本支持）
    tar -tf archive.tar.gz --no-wildcards-match-slash --wildcards "*/"
    ```

    实际示例

    假设有一个归档文件内容如下：

    ```text
    project/
    project/src/
    project/src/main.py
    project/docs/
    project/docs/readme.txt
    project/requirements.txt
    ```

    查看顶层目录：

    ```bash
    tar -tf project.tar.gz | cut -d/ -f1 | sort -u
    ```

    输出：

    ```text
    project
    ```

    查看顶层所有项目（包含文件和目录）：

    ```bash
    tar -tf project.tar.gz | awk -F/ 'NF==1 {print $0}' | sort -u
    ```

    常用快捷命令

    创建一个别名方便使用：

    ```bash
    # 添加到 ~/.bashrc
    alias tartop='tar -tf $1 | cut -d/ -f1 | sort -u'

    # 使用
    tartop archive.tar.gz
    ```

    这样就能快速查看归档文件的顶层结构了。

* matlab 命令行

    * 通过 `matlab -nodisplay -nosplash -r "command"` 在终端中运行命令（适用于 Linux/macOS）

    * `octave --eval "command"` 在终端中执行单行命令。

* matlab table

    table 类型是MATLAB中用于存储异构数据的表格型数据结构，类似于电子表格或数据库表。

    1. 创建table

        ```matlab
        % 从变量创建
        names = {'Alice'; 'Bob'; 'Charlie'};
        ages = [25; 30; 35];
        scores = [85.5; 92.0; 78.5];
        T = table(names, ages, scores, ...
                  'VariableNames', {'Name', 'Age', 'Score'});

        % 从文件导入
        T = readtable('data.csv');
        ```

        注：

        1. 为什么 names 使用的是`{}`，而其他的使用的是`[]`？

            可以写成`names = ['Alice'; 'Bob'; 'Charlie']`吗？

    2. 访问数据

        ```matlab
        % 按列名访问
        T.Age        % 返回数值向量
        T.('Name')   % 返回元胞数组

        % 索引访问
        T(1:2, :)              % 前两行
        T(:, {'Name', 'Age'})  % 特定列
        T{1:2, 'Age'}          % 提取数值数据
        T{1, 'Name'}           % 单个元素
        ```

    3. 修改和添加

        ```matlab
        % 添加新列
        T.Gender = {'F'; 'M'; 'M'}';

        % 修改数据
        T.Age(2) = 31;

        % 重命名变量
        T.Properties.VariableNames = {'FullName', 'Years', 'Grade'};
        ```

    4. 常用操作

        ```matlab
        % 筛选数据
        young = T(T.Age < 30, :);  % 年龄小于30的行

        % 排序
        sortedT = sortrows(T, 'Age');

        % 分组统计
        groupsummary(T, 'Gender', 'mean', 'Score')  % 按性别分组求平均分

        % 连接表格
        T2 = [T; newRows];       % 垂直连接
        T3 = [T, additionalCol]; % 水平连接
        ```

    5. 实用属性

        ```matlab
        T.Properties.VariableNames    % 查看列名
        T.Properties.Description = '学生数据表'  % 添加描述
        T.Properties.RowNames = {'S1','S2','S3'}  % 设置行名
        ```

    6. 类型转换

        ```matlab
        % table转矩阵（数值列）
        M = T{:, {'Age', 'Score'}};

        % table转元胞数组
        C = table2cell(T);

        % 转置
        T_transpose = rows2vars(T);
        ```

    特点总结：

    * 异构数据：每列可包含不同类型数据（数值、字符、逻辑等）

    * 列名访问：支持通过变量名直接访问列数据

    * 数据完整性：保持数据与元数据的关联

    * 集成分析：与统计、机器学习工具箱良好兼容

    table 类型特别适合处理结构化数据，是替代dataset类型的现代推荐方式。