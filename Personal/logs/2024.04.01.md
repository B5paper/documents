* git 启动 interactive rebase mode

    首先使用`git rebase --interactive HEAD~N`，或者`git rebase -i HEAD~N`进入交互式 rebase 模式。

    这表示从 HEAD commit 开始算起，将最近的 N 个 commit 合并成一个。

    进入交互模式后，将需要 squash 的 commit 改成这个样式：

    ```
    pick d94e78 Prepare the workbench for feature Z     --- older commit
    s 4e9baa Cool implementation 
    s afb581 Fix this and that  
    s 643d0e Code cleanup
    s 87871a I'm ready! 
    s 0c3317 Whoops, not yet... 
    s 871adf OK, feature Z is fully implemented      --- newer commit
    ```

    保存后退出，commit 会自动合并，然后提示是否修改 comment，可以改可以不改。再保存退出，就完成了。

* <https://www.internalpointers.com/>

    一个博客，没什么很新的东西，但是讲得很细，偶尔可以看看。

* 应该创建一个项目叫 reorg，同 qa 一起，组成自举系统

    reorg 用于每次在所有笔记，所有项目，以及所有理论系统中挑选出一个片段，尝试对其进行整理，重组，发散或者删除。

* cargo config aliyun mirror

    <https://developer.aliyun.com/mirror/crates.io-index/>

* sling note

    * `slint::include_modules!();`

        这个应该是把所有需要用到的 module 都包含进来。

        试了试找具体引入进来了什么，没找到。

    * slint 的代码模板

        <https://github.com/slint-ui/slint-rust-template>

        按照这个说明可以创建一个代码模板，一个简单的小程序。功能是点击一个按钮，使得窗口上显示的数字加一。

    * main 函数

        ```rs
        fn main() -> Result<(), slint::PlatformError> {
            let ui = AppWindow::new()?;

            ui.on_request_increase_value({
                let ui_handle = ui.as_weak();
                move || {
                    let ui = ui_handle.unwrap();
                    ui.set_counter(ui.get_counter() + 1);
                }
            });

            ui.run()
        }
        ```

        可以看出，`ui`是 new 出来的，`AppWindow`应该也是一个重要的 mod，背会。

        `ui`会自动找到 ui 代码里定义的一些回调函数，然后在这里对其进行定义。

        `ui.as_wea()`拿到一个 weak 指针。为什么不使用`&`或`&mut`？

        `move`表示将 ui 的 weak 指针移动到新线程里，然后让`ui`对象调用 ui 中成员的 set get 方法。

        `ui.run()`应该表示的是进入事件循环。

    * ui code

        ```slint
        import { Button, VerticalBox } from "std-widgets.slint";

        export component AppWindow inherits Window {
            in-out property<int> counter: 42;
            callback request-increase-value();
            VerticalBox {
                Text {
                    text: "Counter: \{root.counter}";
                }
                Button {
                    text: "Increase value";
                    clicked => {
                        root.request-increase-value();
                    }
                }
            }
        }
        ```

        看来`std-widgets.slint`中有许多的 ui 组件。

        `Button`是按钮不必多言，`VerticalBox`看起来像一个 layout。

        `export component AppWindow inherits Window`，`Window`是基类，`AppWindow`是派生类。不清楚除了`Window`还有其他什么基类？

        `in-out property<int> counter: 42;`这个看来是定义了一个成员变量`counter`。如果是复杂的 struct 呢，该怎么写？

        `callback request-increase-value();`这个看来是声明了一个回调函数。

        `VerticalBox {`，这段用来定义 components，这些 ui 组件的写法就像一个个 struct。

        `text: "Counter: \{root.counter}";`看来 ui component 不能存储动态的变量数据。

* sling 的一个最小测试例子

    `Cargo.toml`:

    ```toml
    # ...

    [dependencies]
    slint = "1.5.0"

    # ...
    ```

    `main.rs`:

    ```rs
    slint::slint!{
        export component HelloWorld {
            Text {
                text: "hello world";
                color: green;
            }
        }
    }
    fn main() {
        HelloWorld::new().unwrap().run().unwrap();
    }
    ```

    compile:

    `cargo build`

    run:

    `cargo run`

    效果：出现一个小窗口，上面有绿色的字 hello world

* slint plotter slint 初探

    `plotter.slint`:

    ```slint
    // Copyright © SixtyFPS GmbH <info@slint.dev>
    // SPDX-License-Identifier: MIT

    import { Slider, GroupBox, HorizontalBox, VerticalBox } from "std-widgets.slint";

    export component MainWindow inherits Window {
        in-out property <float> pitch: 0.15;
        in-out property <float> yaw: 0.5;

        pure callback render_plot(/* pitch */ float, /* yaw */ float, /* amplitude */ float) -> image;

        title: "Slint Plotter Integration Example";
        preferred-width: 800px;
        preferred-height: 600px;

        VerticalBox {
            Text {
                font-size: 20px;
                text: "2D Gaussian PDF";
                horizontal-alignment: center;
            }

            Image {
                source: root.render_plot(root.pitch, root.yaw, amplitude-slider.value / 10);
                touch := TouchArea {
                    property <float> pressed-pitch;
                    property <float> pressed-yaw;

                    pointer-event(event) => {
                        if (event.button == PointerEventButton.left && event.kind == PointerEventKind.down) {
                            self.pressed-pitch = root.pitch;
                            self.pressed-yaw = root.yaw;
                        }
                    }
                    moved => {
                        if (self.enabled && self.pressed) {
                            root.pitch = self.pressed-pitch + (touch.mouse-y - touch.pressed-y) / self.height * 3.14;
                            root.yaw = self.pressed-yaw - (touch.mouse-x - touch.pressed-x) / self.width * 3.14;
                        }
                    }
                    mouse-cursor: self.pressed ? MouseCursor.grabbing : MouseCursor.grab;
                }
            }

            HorizontalBox {
                Text {
                    text: "Amplitude:";
                    font-weight: 600;
                    vertical-alignment: center;
                }

                amplitude-slider := Slider {
                    minimum: 0;
                    maximum: 100;
                    value: 50;
                }
            }
        }
    }
    ```

    `use plotters::prelude::*;`

    看来这个是绘图的重点。

    ```rs
    slint::slint! {
        import { MainWindow } from "plotter.slint";
    }
    ```

    `MainWindow`，又一个新组件。`plotter.slint`，不清楚这个是怎么来的。slint 里自带了 plotter 这个模块吗？

    `pure callback render_plot(/* pitch */ float, /* yaw */ float, /* amplitude */ float) -> image;`

    不清楚这个 pure 是什么意思。

    `title: "Slint Plotter Integration Example";`

    `title`，以及下面的`preferred-width`和`preferred-height`，看起来都是固有属性，可以直接在 slint 中赋值的。

    `source: root.render_plot(root.pitch, root.yaw, amplitude-slider.value / 10);`

    看来`source`用的是`render_plot()`的返回值，而`render_plot()`返回的是一个 image。

    `touch := TouchArea {`

    不清楚这个`:=`是什么意思，以及`TouchArea`是在哪里引入的。猜测：`Image`也是一个 container，`touch`只是给匿名对象`TouchArea`增加了一个名字。

    `pointer-event(event) => {`看来是`TouchArea`的事件处理函数，`event`中包含了事件信息。

    `if (event.button == PointerEventButton.left && event.kind == PointerEventKind.down) {`

    看来`event`是个 struct，当有事件时，会把对应的 value 赋值。

    `self.pressed-pitch = root.pitch;`

    `self`毫无疑问访问的是本组件的数据，但是`root`访问的是上一级组件，还是根组件呢？

    `moved => {`看来是在这里处理鼠标拖动事件。

    `if (self.enabled && self.pressed) {`

    `enabled`和`pressed`显然不是自定义的属性，那么它们是内置属性吗？

    `mouse-cursor: self.pressed ? MouseCursor.grabbing : MouseCursor.grab;`

    猜测：所有某个数据随别的数据的变动而变动的情况，都使用`:`来定义这个数据。

* plotter slint rs code analyze

    ```rs
    // Copyright © SixtyFPS GmbH <info@slint.dev>
    // SPDX-License-Identifier: MIT

    use plotters::prelude::*;
    use slint::SharedPixelBuffer;

    #[cfg(target_arch = "wasm32")]
    use wasm_bindgen::prelude::*;

    #[cfg(target_arch = "wasm32")]
    mod wasm_backend;

    slint::slint! {
        import { MainWindow } from "plotter.slint";
    }

    fn pdf(x: f64, y: f64, a: f64) -> f64 {
        const SDX: f64 = 0.1;
        const SDY: f64 = 0.1;
        let x = x as f64 / 10.0;
        let y = y as f64 / 10.0;
        a * (-x * x / 2.0 / SDX / SDX - y * y / 2.0 / SDY / SDY).exp()
    }

    fn render_plot(pitch: f32, yaw: f32, amplitude: f32) -> slint::Image {
        let mut pixel_buffer = SharedPixelBuffer::new(640, 480);
        let size = (pixel_buffer.width(), pixel_buffer.height());

        let backend = BitMapBackend::with_buffer(pixel_buffer.make_mut_bytes(), size);

        // Plotters requires TrueType fonts from the file system to draw axis text - we skip that for
        // WASM for now.
        #[cfg(target_arch = "wasm32")]
        let backend = wasm_backend::BackendWithoutText { backend };

        let root = backend.into_drawing_area();

        root.fill(&WHITE).expect("error filling drawing area");

        let mut chart = ChartBuilder::on(&root)
            .build_cartesian_3d(-3.0..3.0, 0.0..6.0, -3.0..3.0)
            .expect("error building coordinate system");
        chart.with_projection(|mut p| {
            p.pitch = pitch as f64;
            p.yaw = yaw as f64;
            p.scale = 0.7;
            p.into_matrix() // build the projection matrix
        });

        chart.configure_axes().draw().expect("error drawing");

        chart
            .draw_series(
                SurfaceSeries::xoz(
                    (-15..=15).map(|x| x as f64 / 5.0),
                    (-15..=15).map(|x| x as f64 / 5.0),
                    |x, y| pdf(x, y, amplitude as f64),
                )
                .style_func(&|&v| {
                    (&HSLColor(240.0 / 360.0 - 240.0 / 360.0 * v / 5.0, 1.0, 0.7)).into()
                }),
            )
            .expect("error drawing series");

        root.present().expect("error presenting");
        drop(chart);
        drop(root);

        slint::Image::from_rgb8(pixel_buffer)
    }

    #[cfg_attr(target_arch = "wasm32", wasm_bindgen(start))]
    pub fn main() {
        // This provides better error messages in debug mode.
        // It's disabled in release mode so it doesn't bloat up the file size.
        #[cfg(all(debug_assertions, target_arch = "wasm32"))]
        console_error_panic_hook::set_once();

        let main_window = MainWindow::new().unwrap();

        main_window.on_render_plot(render_plot);

        main_window.run().unwrap();
    }
    ```

    `use slint::SharedPixelBuffer;`看起来像是导入图片缓冲区相关的功能。

    `import { MainWindow } from "plotter.slint";`

    这里的`plotter.slint`，就是那个 slint ui 界面文件的名字。

    `fn pdf(x: f64, y: f64, a: f64) -> f64 {`看来是采样计算那个高斯分布图的，不重要。

* rust plotters

    usage:

    ```toml
    [dependencies]
    plotters = "0.3.3"
    ```

* rust 中`into_xxx`通常是将自身所有权转换成另一个对象的类型，`xxx()`则通常只是 borrow。

* slint function

    slint 中的函数使用`function`关键字定义。

    ```slint
    export component Example {
        in-out property <int> min;
        in-out property <int> max;
        protected function set-bounds(min: int, max: int) {
            root.min = min;
            root.max = max
        }
        public pure function inbound(x: int) -> int {
            return Math.min(root.max, Math.max(root.min, x));
        }
    }
    ```

* slint callback

    callback 可以使用`=>`定义：

    ```slint
    export component Example inherits Rectangle {
        // declare a callback
        callback hello;

        area := TouchArea {
            // sets a handler with `=>`
            clicked => {
                // emit the callback
                root.hello()
            }
        }
    }
    ```

    可以带参数：

    ```slint
    export component Example inherits Rectangle {
        // declares a callback
        callback hello(int, string);
        hello(aa, bb) => { /* ... */ }
    }
    ```

    也可以有返回值：

    ```slint
    export component Example inherits Rectangle {
        // declares a callback with a return value
        callback hello(int, int) -> int;
        hello(aa, bb) => { aa + bb }
    }
    ```
