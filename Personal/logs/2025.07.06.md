* 理性不可能完成约束

    根据我们之前所讨论的，刚性兑付不可取，我们的任务必须是可回退的任务，那么既然这样，我们是否有理由拒绝完成一切任务？比如，早上起床，可以起，也可以不起，我们完全可以为不起床找理由，“昨天睡得晚，今天很困，如果现在就起，那么今天的精力一定不充足，还不如多睡一小会，換来当天全天的精神”。如果采用刚性任务，我们发现很多任务都可能因为外力打断、时间不够、能力不足等原因无法完成，最后会流于欺骗和形式主义。但是可回退任务（柔性任务）又会给自己找各种理由，最终导致各种任务都有借口完不成。由此我们可以推断，纯理性无法对任务的完成做约束。

    那么该怎么解决任务完成的问题呢？除了理性，我们还有惯性（生活习惯）、情感、居住环境、工作环境、气候气温、四季变化、文化，目前看来，除了饿了必须吃饭，困了必须睡觉这些生理因素的制约，其他的大多数可有可无的任务的完成，似乎只有这些因素才能制约。

    假如上面的猜想为真，那么我们可以推断，理性只能更合理地安排任务，而非理性才能决定任务的完成。

    根据上面的推断，如果我们想提高任务的完成度，那么可以从整理环境入手，从养成习惯入手，从身体与自然变幻融为一体入手等。前面的比较好理解，“与自然融为一体”则表示天亮就起，如果不起床，到了中午时明显感觉温度升高，再睡下去心里会很烦躁，这样就表示身体的行为与自然不符了，同理，夏天温度高，运动时不容易扭伤，那就多运动；冬天就多居家，少做剧烈运动；春秋不冷不热，是学习和旅游的好时机。这些只是一些猜想，如与事实不符后面纠正。

* 精神与物质，内存与外现，东方与西方

    在动漫、电影、小说等作品中，日本更重视精神与内在，心境做出改变，外在也会跟着改变，而美国似乎更在意外在的炫酷，只有发现外在的表现行不通时，才会考虑改变内心。这两种截然相反的观点非常有趣。

* 使用`typename`告诉编译器当前的名字是个类型名

    example:

    如果直接编译下面的代码，是编译不通的：

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <unordered_map>
    using namespace std;

    struct A {
        typedef unordered_map<string, string> Dict;
        Dict dict;
    };

    template<typename T>
    struct B {
        T::Dict dict_b;
    };

    int main() {
        B<A> b;
        return 0;
    }
    ```

    编译输出：

    ```
    main_5.cpp:14:5: error: need ‘typename’ before ‘T::Dict’ because ‘T’ is a dependent scope
       14 |     T::Dict dict_b;
          |     ^
          |     typename 
    make: *** [Makefile:2: main] Error 1
    ```

    此时我们必须在`T::Dict dict_b;`前加一个`typename`，才能编译通过：

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <unordered_map>
    using namespace std;

    struct A {
        typedef unordered_map<string, string> Dict;
        Dict dict;
    };

    template<typename T>
    struct B {
        typename T::Dict dict_b;
    };

    int main() {
        B<A> b;
        return 0;
    }
    ```

    默认情况下，编译器认为依赖未知类型`T`的符号都是普通成员，而不是类型名。如果想告诉编译器这个符号是个类型，而不是成员变量或函数，那么必须使用`typename`。

* `tee -a`表示在文件末尾追加

    如果文件不存在，则会创建文件。

    echo 本身会在行尾加`\n`，因此不需要额外考虑`\n`。

    ```bash
    echo 'heloo' | tee -a log.txt
    echo 'heloo' | tee -a log.txt
    cat log.txt
    ```

    output:

    ```
    heloo
    heloo
    heloo
    heloo
    ```

* grep 查看前后 n 行文本

    * 向前 n 行：`grep -B n`

    * 向后 n 行：`grep -A n`

    * 前后各 n 行：`grep -C n`

    其中 A 表示 after，B 表示 before，C 表示 context。

    example:

    `msg.txt`:

    ```
    hello, world, nihao, zaijian
    123, 234, 345, 456, nihao
    hello, 345
    haha
    hehesdf
    aaaaa
    bbb
    ```

    run: `grep -B 1 -A 2 345 msg.txt`

    output:

    ```
    hello, world, nihao, zaijian
    123, 234, 345, 456, nihao
    hello, 345
    haha
    hehesdf
    ```

    run : `grep -C 1 345 msg.txt`

    output:

    ```
    hello, world, nihao, zaijian
    123, 234, 345, 456, nihao
    hello, 345
    haha
    ```

* `rsync -z`表示在传输过程中对要传输的文件进行压缩。如果传输过程文本文件比较多，可以使用`-z`大幅提高传输效率。

* `ssh -A`选项的全称为 Agent Forwarding，对应的 ssh command 为`ForwardAgent`，可以将本地的 ssh 私钥（比如`id_rsa`）临时放到远端机器上。

    假设我们当前的机器为`A`，需要登陆的机器为`C`，现在有个中间机器`B`。如果我们按通常方式`ssh <user>@<B_addr>`登陆到 B 机器，再使用`ssh <user>@<C_addr>`登陆到 C 机器，那么 C 会认为是 B 申请的登陆。假如 C 机器只存储了 A 的公钥，而不允许 B 登陆，那就只能使用`-A`选项了。

    先使用`ssh -A <user>@<B_addr>`登陆到 B，再使用`ssh <user>@<C_addr>`登陆到 C，此时 C 会认为是 A 申请的登陆。

    同理，使用跳板机参数`-J`时，也可以使用这个功能：`ssh -A -J <jump_user>@<jump_addr> <target_user>@<target_addr>`。

* `const char*` / `char*`不能转换为`string&`，只能转换为`const string&`或`string&&`。

* c++ bind

    `bind()`在头文件`<functional>`中。

    基本用法是绑定函数的参数，或者交换参数的顺序：

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <functional>
    using namespace std;

    void print(const string &msg, int val) {
        printf("%s, val: %d\n", msg.c_str(), val);
    }

    void add(int a, int b) {
        printf("%d + %d = %d\n", a, b, a + b);
    }

    int main() {
        print("hello", 42);
        auto print_hello = bind(print, "hello", 42);
        // std::_Bind<void (*(const char *, int))(const std::string &msg, int val)>
        print_hello();

        add(1, 2);
        auto swap_add = bind(add, placeholders::_2, placeholders::_1);
        swap_add(1, 2);

        return 0;
    }
    ```

    output:

    ```
    hello, val: 42
    hello, val: 42
    1 + 2 = 3
    2 + 1 = 3
    ```

    由于 bind 返回的类型非常长（上面代码中的`std::_Bind<void (*(const char *, int))(const std::string &msg, int val)>`），所以通常使用`auto`来替代。

    如果需要交换参数位置，可以使用`std::placeholders`中的`_1`, `_2`, ... 表示 bind 返回的函数的第 1 个参数，第 2 个参数。

    `bind()`也支持类的成员函数，以及 lambda 表达式：

    ```cpp
    #include <stdio.h>
    #include <string>
    #include <functional>
    using namespace std;

    struct MyClass {
        string msg;

        void print(const string &out_msg) {
            printf("%s, %s\n", msg.c_str(), out_msg.c_str());
        }
    };

    int main() {
        MyClass obj{"hello"};
        auto print_msg = bind(&MyClass::print, &obj, placeholders::_1);
        print_msg("world");

        int val = 42;
        auto print_msg_2 = bind([val](const string &msg, int val_out) {
            printf("%s, %d, %d\n", msg.c_str(), val, val_out);
        }, "hello, world", placeholders::_1);
        print_msg_2(123);

        return 0;
    }
    ```

    output:

    ```
    hello, world
    hello, world, 42, 123
    ```

    如果捕捉了外部变量，那么用普通方法是拿不到 lambda 表达式的指针的，但是我们可以使用 bind 或`std::function`拿到 lambda 表达式的可调用对象。

    注：

    1. `bind(&MyClass::print, &obj, placeholders::_1);`中，必须使用`&MyClass::print`和`&obj`，不能使用`MyClass::print`（普通函数的名字即为地址，成员函数的名字必须加`&`才能表示地址），不推荐使用`obj`（会按值传递`obj`对象）。

    1. 由于使用了`bind()`，所以函数并不是当场调用的，而是有可能在对象销毁的时候才被调用，但是我们传进去的是对象的指针，所以指针有可能失效，`bind()`返回的可调用对象的调用也可能失败。
