* 看电脑/手机 25 分钟，闭眼休息 5 分钟。这个数值目前还是比较有用的，起码眼疼程度不会进一步发展。

* 如果让单个大佬负责科技树，以及 idea 估值，那么是否会陷入偏执和固化？

* ctags 基本用法

    install: `sudo apt install universal-ctags`

    进入工程目录，执行`ctags -R .` (递归地为当前目录及所有子目录中的文件生成 tags)，执行完后会生成`tags`文件。

    常用快捷键：

    * `Ctrl-]`: 跳转到光标下符号的定义处

    * `g Ctrl-]`: 如果有多个匹配的定义，此命令会列出所有候选，让你选择跳转到哪一个

    * `Ctrl-t`: 跳回到跳转之前的位置（类似于“后退”按钮）。可以多次按它来回溯跳转历史。

    * `:ts <tag>`或`:tselect <tag>`: 列出所有匹配`<tag>`的标签定义，供你选择。

    * `:tjump <tag>`: 跳转到`<tag>`。如果只有一个匹配则直接跳转，有多个则列出列表。

* ctags 扩展用法

    ```bash
    # 进入你的项目目录
    cd /path/to/your/project

    # 递归地为当前目录及所有子目录中的文件生成 tags
    ctags -R .

    # 如果你只想为特定类型的文件生成 tags（例如只想要 C++ 和头文件），可以使用 --languages 选项
    ctags -R --languages=C,C++ .

    # 一个更常用的强大命令：排除不需要的目录（如 node_modules, build, .git）
    ctags -R --exclude=node_modules --exclude=build --exclude=.git .
    ```

    * 自动在上级目录查找 tags 文件

        大型项目可能有多级目录，你不一定总是在项目根目录打开文件。这个配置让 Vim 自动向上递归查找父目录中的 tags 文件，非常有用。

        ```vim
        " 在 ~/.vimrc 中添加
        set tags=./tags;,tags;
        ```

        * `./tags;`：从当前文件所在目录开始查找名为 tags 的文件，; 代表“如果没找到，继续向上递归到父目录查找”，直到找到为止。

        * `tags;`：同时也在当前工作目录（:pwd 显示的目录）下查找 tags 文件。

    * tips

        * 将`tags`文件添加到你的`.gitignore`中，因为它可以根据本地环境重新生成，不需要纳入版本控制。

        * 将`ctags -R .`命令写入项目的 Makefile 或构建脚本。

* ``int major = register_chrdev(0, "hlc_dev", &fops);``失败时会返回负数，成功时返回 0 或正数

    常见的错误码：

    * `-ENOMEM`: 内存分配失败

    * `-EBUSY`: 设备号已被占用（当第一个参数不为0时）

    * `-EINVAL`: 无效参数

    * `-ENODEV`: 设备不存在或其他错误

    成功时的返回值：

    * 如果第一个参数为 0（如你的例子）：返回动态分配的正的主设备号

    * 如果第一个参数指定了具体设备号：返回0表示成功

* `ioremap_wc()`

    将一段物理内存地址映射到内核虚拟地址空间，并指明该映射支持“写合并”（Write-Combining）内存访问特性

    特点：

    * 合并（Combining）：如果CPU在很短的时间内连续发起多个针对相邻地址的写入操作，内存控制器可以将这些操作合并为一个更大的总线传输事务。这显著减少了访问次数，提高了效率。

    * 缓冲（Buffering）：写入操作可能不会立即到达最终设备，而是先被放入一个缓冲区，稍后再一起发送。这同样是为了优化性能。

    * 弱排序（Weak Ordering）：写合并操作不严格保证其相对于其他内存操作的顺序，这为硬件优化提供了更大灵活性。

    常用于: 显卡的帧缓冲区（Framebuffer）或显存.

    在现代内核（大约 v2.6 以后）中, `ioremap()`默认就等同于`ioremap_nocache()`.

* 应该创建一个闭眼问题集，方便在闭眼休息的时候思考问题

* `dma_alloc_coherent()`

    为设备与 CPU 之间进行直接内存访问（DMA）而分配一段“一致性”内存。解决了由于 CPU 缓存（Cache）的存在而引发的“缓存一致性问题”。它分配的内存区域被设置为 “无缓存”（Uncacheable） 的，或者内核会通过硬件机制（如 Cache Coherent Interconnect）自动维护这块内存的缓存一致性。

    syntax:

    ```c
    #include <linux/dma-mapping.h>

    void *dma_alloc_coherent(struct device *dev, size_t size,
                             dma_addr_t *dma_handle, gfp_t gfp);
    ```

    参数说明：

    * `dma_handle`: 一个指向 `dma_addr_t` 类型的指针。这是一个输出参数。函数成功返回后，`*dma_handle` 中存储的就是分配的内存区域的DMA总线地址。驱动程序需要将这个地址提供给设备，设备将使用这个地址来执行DMA操作。

    * `gfp`: gfp_t	分配内存时使用的标志位

        * `GFP_KERNEL`: 标准的内核内存分配，可能在分配时睡眠（阻塞）。

        * `GFP_ATOMIC`: 原子分配，不会睡眠，用于中断上下文等不能调度的地方。

    返回值：

    * `void *`: 如果分配成功，返回一个指向已分配内存区域的内核虚拟地址的指针。CPU使用这个指针来读写这块内存。

    * `NULL`: 如果分配失败，则返回 NULL。

    问题场景描述：

    * CPU 在处理数据时，数据可能缓存在 CPU 的高速缓存中，并未立即写回主内存。

    * 如果此时设备通过 DMA 直接从主内存读取数据，它读到的就是过时的、旧的数据。

    * 反之，如果设备通过 DMA 将数据写入主内存，而 CPU 的缓存中还有该地址的旧数据，那么 CPU 后续读取时可能会从缓存中得到过时的、旧的数据。

    常用的应用场景：

    * 网络设备驱动：分配用于接收和发送数据包的网络数据缓冲区。

    * 块设备驱动（如 SCSI）：分配传输命令和数据的“scatter-gather”列表。

    * USB 驱动：分配用于传输 USB 请求的数据缓冲区。

    配对函数：`dma_free_coherent()`

    syntax:

    ```c
    void dma_free_coherent(struct device *dev, size_t size,
                           void *cpu_addr, dma_addr_t dma_handle);
    ```

* `ldconfig`

    创建、更新和维护共享库的缓存和必要的链接，通过生成缓存文件 /etc/ld.so.cache 来加速程序启动时寻找共享库的过程，并管理共享库的符号链接，以便系统能够快速地找到并加载运行程序时所需的共享库（.so 文件）

    当你在Linux系统上运行一个程序时，动态链接器（ld.so 或 ld-linux.so）负责在程序启动前将它所依赖的所有共享库加载到内存中。

    动态链接器不会每次都去慢吞吞地扫描整个硬盘上的所有目录来寻找库文件，那样太慢了。相反，它直接去查询由 ldconfig 预先准备好的缓存文件 /etc/ld.so.cache。这个缓存就像一本书的索引，让动态链接器能瞬间找到所需的库。

    在执行了以下操作后，需要手动执行`sudo ldconfig`:

    * 安装了新的共享库（例如通过 make install 或手动拷贝 .so 文件到系统目录）。

    * 删除了已有的共享库。

    * 修改了共享库的搜索路径（例如编辑了 /etc/ld.so.conf 或在该目录下增加了新的 .conf 文件）。

    apt 等软件安装了新的包后，会自动调用`ldconfig`。

    更新缓存: `sudo ldconfig`

    显示缓存内容: `ldconfig -p`

* 在 Makefile 中，`$(VAR)`和`${VAR}`在功能上是完全相同的，可以互换使用。

    使用 makefile 的内置函数时，必须使用圆括号，比如`$(subst from,to,text)`

    综合看来，makefile 中使用圆括号较多，使用花括号`${VAR}`比较少见。

    makefile 中，不允许使用`$VAR`。只会解析`$V`。

    example:

    ```makefile
    NAME = MyApp
    VAR = wrong_value
    V = correct_value

    test:
    	@echo "你想输出 MyApp, 但实际会输出: $NAME"
    	@echo "解析后相当于: $(V)NAME"
    	@echo "而变量 V 的值是: $(V)"
    ```

    output:

    ```
    你想输出 MyApp, 但实际会输出: AME
    解析后相当于: correct_valueNAME
    而变量 V 的值是: correct_value
    ```