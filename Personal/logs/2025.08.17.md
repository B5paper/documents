* `ncclNvmlDevicePairs`在 nvml 中，是个 (32, 32) 的数组，其中填充了任意两个 gpu dev 之间的 p2p status，这样看来，dev 其实就是设备的物理编号，nccl 中和 nvml 中保持相同的含义，nvml 只处理设备的物理编号。

    相关代码：
    
    ```cpp
    // ...
    status = ncclNvmlDevicePairs[indexes[i-1]][indexes[i-0]].p2pStatusRead;
    // ...
    ```

* nccl 中`hops`表示的是，从当前节点出发，需要经过`hops`个节点，才能到达指定节点。

    比如 vert 0 -> vert 1 -> vert 2 -> vert 3，那么 vert 0 到 vert 3 的`hops`就是 3。

    ```cpp
    int hops = gpu_to_cpu_paths[cpu_vert_idx].edge_list.size();
    ```

* nccl `add_inter_step`

    为什么在`add_inter_step()`时，两个 gpu 之间一定要经过 cpu？ nic / net 是一定经过 cpu 的，host 中转也一定经过 cpu，如果中间节点是 pci，那`p2p_active == 0`就不成立了。nvlink 更不可能，所以一定要经过 cpu

    ```cpp
    ret = add_inter_step(topo_system, CPU,
        cpu_idx, GPU, vert_idx_2, GPU, vert_idx_1);
    ```

* `rank`是对`peerInfo`的编号

    ```cpp
    PeerInfo* dstInfo = &comm.peerInfo[topo_system.nodes[GPU][vert_idx_1]->gpu.rank];
    ```

    从这里可以看出，rank 是对 peerInfo 的编号。对比前面的，我们知道 dev 是物理编号。

* `lstat()`

    如果路径指向符号链接，`lstat()`返回的是符号链接本身的信息（如链接文件的大小、权限等），而`stat()`会处理链接指向的文件。

    syntax:

    ```c
    #include <sys/stat.h>
    int lstat(const char *pathname, struct stat *statbuf);
    ```

    example:

    ```c
    #include <sys/stat.h>
    #include <stdio.h>
    #include <unistd.h>

    int check_link_file(const char *file_path) {
        struct stat my_stat;
        int ret = lstat(file_path, &my_stat);
        if (ret != 0) {
            printf("fail to run fstat()\n");
            return -1;
        }

        if (S_ISLNK(my_stat.st_mode)) {
            printf("%s is a link file\n", file_path);
        } else {
            printf("%s is not a link file\n", file_path);
        }

        return 0;
    }

    int main() {
        const char *file_paths[2] = {
            "msg.txt",
            "msg_link.txt"
        };

        int ret = check_link_file(file_paths[0]);
        if (ret != 0) {
            printf("fail to check link file: %s\n", file_paths[0]);
            return -1;
        }

        ret = check_link_file(file_paths[1]);
        if (ret != 0) {
            printf("fail to check link file: %s\n", file_paths[1]);
            return -1;
        }

        return 0;
    }
    ```

    output:

    ```
    msg.txt is not a link file
    msg_link.txt is a link file
    ```

* 符号链接本身的大小是其指向的路径字符串的长度

    example:

    ```
    lrwxrwxrwx 1 hlc hlc    7  8月 17 13:34 msg_link.txt -> msg.txt
    ```

* `disown`

    `disown`将指定作业从 Shell 的作业列表中删除，但进程仍继续运行。

    常见用法：

    ```bash
    disown <jobspec>      # 移除指定作业（如 %1）
    disown -a             # 移除所有作业
    disown -r             # 仅移除运行中的作业
    disown -h             # 将任务保留在 job list 但对其屏蔽 SIGHUP 信号（推荐用法）
    ```

    启动后台任务后使用 disown -h，即使退出 Shell 也不终止进程（类似 nohup 效果）。

    disown 不会自动重定向输出

    被 disown 的进程仍属于当前用户，但会变成孤儿进程（由 init/systemd 接管）

    example:

    ```
    $ long_task &       # 启动后台任务
    $ disown -h %1      # 屏蔽 SIGHUP 并移除作业
    $ exit              # 退出 Shell，任务继续运行
    ```

    被 disown 解除绑定的任务，无法使用`kill <PID>`的方式结束（为什么？），但可以通过`kill -kill <PID>`结束任务。

* `netstat`

    `netstat -a`: 显示所有连接

    `netstat -s`: 显示统计摘要

    `netstat -r`: 查看系统的路由表信息

    `netstat -i`: 显示网络接口的配置和流量统计

    `netstat -tuln`: 列出所有处于监听（LISTEN）状态的端口

    `netstat -tulnp`: 查看占用端口的进程ID（PID）和程序名（需管理员权限）

    常用参数：

    * `-a`: 显示所有连接和监听端口。

    * `-n`: 以数字形式显示地址和端口（禁用DNS解析）。

    * `-t/-u`: 仅显示TCP/UDP连接。

    * `-p`: 显示进程信息（Linux）。

    * `-o`: 显示进程ID（Windows）。

    * `-r`: 显示路由表。

    * `-s`: 显示协议统计信息。

* `stat()`

    头文件：`#include <sys/stat.h>`

    syntax:

    ```c
    int stat(const char *restrict pathname,
            struct stat *restrict statbuf);
    ```

    返回文件信息。

    这个函数和`fstat()`唯一区别是，`fstat()`使用的是`fd`，而`stat()`使用的是文件路径。

* `stat <file_path>`

    输出文件的基本信息。

    example:

    ```
    (base) hlc@hlc-VirtualBox:~$ stat xml_log_4_gpu.txt
      File: xml_log_4_gpu.txt
      Size: 7311      	Blocks: 16         IO Block: 4096   regular file
    Device: 802h/2050d	Inode: 938640      Links: 1
    Access: (0664/-rw-rw-r--)  Uid: ( 1000/     hlc)   Gid: ( 1000/     hlc)
    Access: 2025-08-03 09:42:13.930462794 +0800
    Modify: 2025-06-06 09:55:17.893493034 +0800
    Change: 2025-06-06 09:55:17.893493034 +0800
     Birth: 2025-06-05 16:56:25.016703429 +0800
    ```

* `[ -f file ]`

    检查文件是否存在且为普通文件，等价于`test -f file`

    如果 file 是符号链接，-f 会检查链接指向的目标文件是否为普通文件（跟随链接）

    其他常见文件测试选项
    选项	作用
    -e file	文件/目录是否存在（不检查类型）。
    -d file	是否为目录。
    -L file	是否为符号链接。
    -s file	文件是否存在且大小大于0字节。
    -r file	文件是否可读。
    -w file	文件是否可写。
    -x file	文件是否可执行。

* `grep -o`

    `-o`等价于`--only-matching`，仅输出匹配到的文本部分（而非整行）

    如果一行中有多个匹配项，`-o`会将每个匹配项单独输出为一行

    example:

    ```bash
    echo "abc123def456" | grep -o "[0-9]\+"
    ```

    output:

    ```
    123
    456
    ```

* `find`的匹配模式

    -name 和 -iname： 使用 glob 模式，按文件名匹配。`-iname`表示大小写不敏感。

    -regex 和 -iregex：使用正则表达式。正则匹配的是完整路径（如 ./dir/file.txt），而非仅文件名。

    其他匹配方式:

    * -path：类似 -name，但匹配完整路径（使用 glob 语法）。

    * -perm、-size 等：按权限、大小等属性匹配，与正则/glob 无关。

* glob 匹配

    * 匹配任意字符（包括空字符）。

    ? 匹配单个字符。

    [abc] 匹配 a、b 或 c。