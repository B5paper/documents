* 总是对自己熟悉的领域过于骄傲，总以为自己的进度领先，不愿投入时间。其实对自己熟悉的领域，更应该舍得投入时间才对。

* 如果一个`* { } my_task`类型的 task 长期无法完成，那么它应该被升级为一个 project

* `outl`

    端口映射 I/O (PMIO)：使用一个与物理内存地址空间分离的、独立的地址空间（0x0000 到 0xFFFF）来访问设备。CPU 需要使用专门的 in 和 out 指令来与这个空间进行数据交换。

    `outl`: 从 CPU 向 外部设备的指定端口输出（写） 一个 32位（4字节） 的长字（Long Word） 数据。

    syntax (AT&T):

    ```asm
    outl %eax, port_number
    ```

    CPU 执行 outl 指令时，会将一个 32 位的值（通常存放在寄存器 eax 中）通过数据总线，发送到由指令指定的一个 16 位的 I/O 端口地址.

    当端口号大于 255 时，需要先放入 dx 寄存器：

    ```asm
    movw $0x1F7, %dx   # 将端口号 0x1F7 存入 dx 寄存器
    outl %eax, %dx     # 将 eax 中的 32 位数据输出到 dx 指定的端口
    ```

    example:

    告诉硬盘控制器要读取的扇区数:

    ```asm
    movl $0x100, %eax  # 设置要读取 256 个扇区
    movw $0x1F2, %dx   # 0x1F2 是硬盘扇区计数器的端口号
    outl %eax, %dx     # 将这个命令发送给硬盘
    ```

* `inb`

    从外部设备的指定端口向 CPU 输入（读） 一个 8位（1字节） 的数据。

    `b`：代表操作的数据长度是“字节”（8位）。

    syntax:

    ```asm
    inb port_number, %al
    ```

    CPU 执行 inb 指令时，会通过地址总线指定一个 16 位的 I/O 端口，然后该端口上的设备会通过数据总线返回一个 8 位的值，CPU 会将其接收（通常存入 al 寄存器）。

    或者当端口号大于 255 时：

    ```asm
    movw $0x3F8, %dx   # 将串口线路状态寄存器的端口号 0x3F8 存入 dx
    inb %dx, %al       # 从该端口读取一个字节的状态信息到 al 寄存器
    ```

    example:

    检查串口是否有数据到达:

    ```asm
    movw $0x3FD, %dx   # 0x3FD 是串口线路状态寄存器的端口
    inb %dx, %al       # 读取状态字节
    testb $0x01, %al   # 检查“数据就绪”位是否为 1
    jnz data_available # 如果为 1，跳转到数据处理代码
    ```

    `b`是字节（8位），`w`是字（16位），`l`是长字（32位）。

* `sparse`

    Linux 内核代码的静态代码分析器, 主要用于定位与类型安全和内存模型相关的问题。

    它通过扩展 GCC 并解析源代码来实现以下功能：

    * 类型检查： 强化内核中特定的数据类型属性。例如，检查地址空间（__user, __kernel）、内存一致性（__rcu）等注解是否正确使用，确保用户空间的指针不会被直接解引用。

    * 上下文检查： 确保某些函数在正确的上下文中调用（例如，可能睡眠的函数不能在原子上下文中调用）。

    * 锁机制检查： 帮助检查锁的初始化和使用是否正确，减少死锁风险。

    * 字节序检查： 帮助识别可能存在的字节序（Endianness）问题。

    通常在编译内核时使用，make C=1（检查重新编译的文件）或 make C=2（检查所有文件）。

* `dma_addr_t`

    dma_addr_t 保存的是设备能理解的物理地址, 而不是内核使用的虚拟地址。

    本质上是一个无符号整数类型（通常是 u64 或 u32）.

    驱动开发者应将其视为一个“黑盒”或令牌（token）或 handle。不需要关心它的具体数值是什么，只需要在DMA API函数中正确地传递和使用它。不能直接对它进行数学运算或解引用。

    地址转换的产生：

    * 简单系统（无IOMMU）： 设备直接访问物理内存。这时，dma_addr_t 通常就是CPU的物理地址（phys_addr_t）。驱动需要确保设备可以访问该物理地址范围。

    * 复杂系统（有IOMMU/SMMU）： IOMMU是一个位于设备和内存之间的硬件单元，类似于CPU的MMU。它可以将设备看到的“IO虚拟地址”（IOVA）翻译成真正的物理地址。

        在这种情况下，驱动通过DMA API申请的内存，其返回的 dma_addr_t 是一个IO虚拟地址（IOVA），而不是真正的物理地址。设备使用这个IOVA进行数据传输，IOMMU会透明地完成IOVA到物理地址的转换。