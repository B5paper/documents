* [v] process 1 tab  09.16

    feedback:

    * [asso] 既然 epoll 可以监控 fd，那么除了 socket fd 外，epoll 是否也可以监控普通文件的改动？

    * [ ] 调研 make_unique(), 其他常见的构造 unique_ptr 的方法

* [v] reorg: documents 30 mins 09.16

    feedback:

    * [asso] 调研自己搭建 ftp 服务器，是否能用 aria2 实现多线程下载？

    * [asso] 调研 http 服务器是否支持 aria2 多线程下载文件？

* [v] 调研内联汇编

    ```c
    // 一个非常简化的概念性示例，并非真实代码
    static inline unsigned char inb(unsigned short port) {
        unsigned char data;
        asm volatile ("inb %1, %0" : "=a" (data) : "Nd" (port));
        return data;
    }
    ```

* [v] 调研 vim-gutentags

    feedback:

    1. [ ] 如何安装 Vim-Plug，并检验安装成功？

* [P] 调研`iowrite32_rep()`系列

    ```c
    #include <asm/io.h>

    void iowrite8_rep(volatile void __iomem *addr, const void *buf, unsigned long count);
    void iowrite16_rep(volatile void __iomem *addr, const void *buf, unsigned long count);
    void iowrite32_rep(volatile void __iomem *addr, const void *buf, unsigned long count);

    void ioread8_rep(volatile void __iomem *addr, void *buf, unsigned long count);
    void ioread16_rep(volatile void __iomem *addr, void *buf, unsigned long count);
    void ioread32_rep(volatile void __iomem *addr, void *buf, unsigned long count);
    ```

    feedback:

    * [ ] 调研 ds 生成的一段代码

        ```c
        // 计算缓冲区的虚拟地址
        void __iomem *device_buffer = dev->mmio_base + 0x1000;

        // 方法一：使用内核提供的IO函数（推荐，因为可移植且安全）
        // 写入一个32位字
        iowrite32(0x12345678, device_buffer);
        // 读取一个32位字
        u32 value = ioread32(device_buffer);

        // 批量写入一段数据（这就是你想要的“强行”操作）
        // src_buf 是你准备好的数据源（在主机内存里）
        // count 是你想写入的32位字的数量
        iowrite32_rep(device_buffer, src_buf, count);

        // 方法二：更“强行”的方式 - 直接解引用指针（需极度小心！）
        // 首先，确保映射时为“不缓存”或“写合并”模式，否则会出问题。
        // 通常用 pci_ioremap_bar() 默认是 ioremap()，这通常是安全的（无缓存）。
        // 但直接解引用 __iomem 指针编译器会报错，所以需要强制转换。

        // 强制转换为 volatile 指针，告诉编译器别优化，每次都要真的访问
        volatile u32 *hardware_buffer = (volatile u32 *)device_buffer;

        // 现在，你可以像普通数组一样操作了！
        hardware_buffer[0] = 0xAAAAAAAA; // 写入第一个字
        value = hardware_buffer[1];      // 读取第二个字

        // 甚至可以用memcpy（但确保目的地址是volatile且没有缓存问题！）
        // memcpy_toio() 是更安全的选择
        memcpy((void *)hardware_buffer, src_buf, count * 4);
        ```

* [O] 实现 dump 功能

* [ ] `objdump`

* [ ] `od -t x<N>`

* [ ] 为什么经过 transpose、permute 等操作后，张量会变成不连续的？

* [ ] 调研 <https://www.geeksforgeeks.org/deep-learning/pytorch-learn-with-examples/>

    目前看到

    > Building and Training Neural Networks with PyTorch

* [ ] reorg linux driver

    关注中断部分，增加 qa unit

* [ ] `remove_const_t`

* [ ] 调研`truncate`

    `sudo truncate -s 9637892 /dev/shm/nccl-AoFK4o`

* [ ] 调研 makefile 模式规则（例如 %.o: %.c）

* [new] reorg: cuda