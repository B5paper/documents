* 本来夏天应该比较热，体力消耗快，不想学，学习效率低，但是真到了夏天，反而往公司跑得更
勤了，可能是因为慢慢习惯了恶劣环境，抗压能力更强了。不过也有可能是公司有空调，条件相对还舒适。

    另外需要观察春天秋天这些温度舒适时的学习效率，才能下定论。

* 高矮胖瘦，聪明愚钝，美丽丑陋，各种各样的人都有，如果这些都是上帝在地球这个实验室做的实验，观察形形色色人对抗命运的方式，那么真相未免也太残酷了。

* makefile 中的子文件夹与`.PHONY`

    假如当前的工程目录为：

    ```
    - proj
        my_lib.h
        my_lib.cpp
        Makefile
        - tests
            xxx.h
            xxx.cpp
            Makefile
        - imported_libs
            yyy.h
            yyy.cpp
            Makefile
    ```

    如果我们希望`proj`文件夹中的 makefile 可以进入到子文件夹`tests`和`imported_libs`中执行 make 进行子模块的编译，那么我们写出的`proj/Makefile`文件可能是这样的：

    ```makefile
    all: libs imported_libs tests
    	@echo "in all target"

    libs:
    	@echo "in libs target"
    	touch libs.txt
    	# g++ -c my_lib.cpp -o my_lib.o

    imported_libs:
    	@echo "in imported_libs target"
    	$(MAKE) -C imported_libs

    tests:
    	@echo "in tests target"
    	$(MAKE) -C tests

    clean:
    	$(MAKE) -C tests clean
    	$(MAKE) -C imported_libs clean
    	rm -f libs.txt
    ```

    `make`输出如下：

    ```
    in libs target
    touch libs.txt
    # g++ -c my_lib.cpp -o my_lib.o
    in all target
    ```

    可以看到虽然``all`的依赖目标中包含有`imported_libs`和`tests`，但是这两个根本没执行。因此已经有同名的文件夹存在。

    此时需要`.PHONY`来解决这个问题：

    ```makefile
    .PHONY: tests imported_libs

    all: libs imported_libs tests
    	@echo "in all target"

    libs:
    	@echo "in libs target"
    	touch libs.txt
    	# g++ -c my_lib.cpp -o my_lib.o

    imported_libs:
    	@echo "in imported_libs target"
    	$(MAKE) -C imported_libs

    tests:
    	@echo "in tests target"
    	$(MAKE) -C tests

    clean:
    	$(MAKE) -C tests clean
    	$(MAKE) -C imported_libs clean
    	rm -f libs.txt
    ```

    `make`的 output:

    ```
    in libs target
    touch libs.txt
    # g++ -c my_lib.cpp -o my_lib.o
    in imported_libs target
    make -C imported_libs
    make[1]: Entering directory '/home/hlc/Documents/Projects/makefile_test/imported_libs'
    in imported_libs dir...
    touch imported_libs.txt
    make[1]: Leaving directory '/home/hlc/Documents/Projects/makefile_test/imported_libs'
    in tests target
    make -C tests
    make[1]: Entering directory '/home/hlc/Documents/Projects/makefile_test/tests'
    in tests dir...
    touch tests.txt
    make[1]: Leaving directory '/home/hlc/Documents/Projects/makefile_test/tests'
    in all target
    ```

* makefile 中的依赖机制

    1. `target`如果没有依赖项，那么检测名为`target`的文件/文件夹是否存在，若不存在，则执行`target`，否则不执行

    2. 若`target`有依赖项`dep`，那么判断`dep`文件是否比`target`新，如果是，那么执行`target`，如果`dep`只是目标，不是文件，那么无论`dep`是否执行，总是认为`dep`比`target`新

    3. 如果有`.phony: target dep`存在，那么认为`target`和`dep`都只是目标，不是文件

* makefile 中的`export`

* `list_add_tail()`

    在链表尾部添加元素。

    syntax:

    ```c
    static inline void list_add_tail(struct list_head *new, struct list_head *head)
    ```

    example:

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/list.h>
    #include <linux/slab.h>

    struct my_list_node {
        struct list_head list_head;
        int val;
    };

    struct list_head lst_head;

    int hello_init(void) {
        pr_info("in hello_init()...\n");
        INIT_LIST_HEAD(&lst_head);
        struct my_list_node *new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 123;
        list_add_tail(&new_node->list_head, &lst_head);
        new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 456;
        list_add_tail(&new_node->list_head, &lst_head);

        struct my_list_node *cur_node;
        list_for_each_entry(cur_node, &lst_head, list_head) {
            pr_info("node val: %d\n", cur_node->val);
        }
        
    	return 0;
    }

    void hello_exit(void) {
        pr_info("in hello_exit()...\n");
        struct my_list_node *cur_node, *tmp_node;
        list_for_each_entry_safe(cur_node, tmp_node, &lst_head, list_head) {
            list_del(&cur_node->list_head);
            kfree(cur_node);
        }
    }

    module_init(hello_init);
    module_exit(hello_exit);
    MODULE_LICENSE("GPL");
    ```

    dmesg output:

    ```
    [  488.597973] in hello_init()...
    [  488.597977] node val: 123
    [  488.597981] node val: 456
    [  495.047735] in hello_exit()...
    ```

    如果链表越来越长，`list_add_tail()`的速度不会变慢，因为 linux 中的链表是双向循环链表，head 节点的 prev 即指向尾节点。

* `pci_register_driver()`

    `pci_register_driver()`是一个宏，用于向内核注册 pci 设备驱动。

    syntax:

    ```c
    int pci_register_driver(struct pci_driver *driver);
    ```

    `struct pci_driver`中比较重要的字段如下：

    * `.name`： 驱动程序的名称。

    * `.id_table`： 它指向一个`pci_device_id`数组，这个数组列出了该驱动程序所能支持的所有PCI设备的厂商ID（Vendor ID）和设备ID（Device ID）。用来进行设备匹配。

    * `.probe`: 用于驱动初始化

    * `.remove`: probe 的逆过程

    * `.shutdown`: 不知道干嘛用的

    在注册过程中，内核的PCI子系统会立刻遍历当前系统中所有已发现的PCI设备。

    注册成功后，内核会在`/sys/bus/pci/drivers/`目录下创建一个以驱动程序命名的新目录（例如`/sys/bus/pci/drivers/e1000e/`）。

    其逆函数为`pci_unregister_driver()`.

* `munmap()`主要用于释放进程的虚拟地址。

    如果 mmap() 映射的是文件，那么`munmap()`会在解除映射时把数据写回文件。

* `mmap()`内部原理

    将进程的一段 va　映射到某个对象上（文件，或内存），程序访问这段虚拟内存时，操作系统通过缺页异常（Page Fault）来自动完成数据的加载和同步。

    mmap 可以实现延迟加载（Lazy Loading）：调用 mmap 时，操作系统并不会立即将整个文件内容读入物理内存。它只是在内核中为进程创建一个数据结构（Linux 中是 `vm_area_struct`），记录下这个映射关系（例如：虚拟地址范围 0x4000 - 0x5000 对应文件 a.txt 的偏移 0 - 4096 字节）。这个过程非常快，消耗资源极少，并且与文件大小无关。真正的数据加载发生在程序首次访问对应的内存地址时。

    虚拟内存区域（VMA - Virtual Memory Area）

    `vm_area_struct`:

    vm_start, vm_end: 这段映射的起始和结束虚拟地址。

    vm_file: 被映射的文件。

    vm_pgoff: 文件中的偏移量（以页为单位）。

    vm_flags: 权限标志（如可读、可写、私有映射、共享映射）。

    进程访问 va 时，MMU 触发一个 缺页异常（Page Fault），CPU 从用户态陷入内核态。内核找到 va 对应的 vma，然后根据 vma 找到对应的文件，将文件内容按 page size （4KB）读到 page 中（数据在物理内存里），然后更新进程的页表，建立 virtual page 到 physical page 的映射。

    此时返回到用户态，并重新执行那条触发异常的指令。

    此后进程读写的都是 physical page 中的内容，此物理页被内核标记为脏页（dirty），意味着它比磁盘上的文件内容更新。

    最终，内核的 pdflush（页回写）守护进程会在后台自动将“脏页”写回到磁盘文件中，以保持数据同步。应用程序也可以主动调用 msync() 来强制立即同步数据。

* `list_for_each()`

    对`struct list_head`进行遍历，如果需要拿到外部 struct 的指针，那么需要手动调用`container_of()`。

    syntax:

    ```c
    list_for_each(pos, head)
    ```

    example:

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/list.h>
    #include <linux/slab.h>
    #include <linux/pci.h>

    struct my_list_node {
        struct list_head list_head;
        int val;
    };

    struct list_head lst_head;

    int hello_init(void) {
        pr_info("in hello_init()...\n");
        INIT_LIST_HEAD(&lst_head);
        struct my_list_node *new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 123;
        list_add_tail(&new_node->list_head, &lst_head);
        new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 456;
        list_add_tail(&new_node->list_head, &lst_head);

        struct list_head *cur_head;
        list_for_each(cur_head, &lst_head) {
            pr_info("node val: %d\n", container_of(cur_head, struct my_list_node, list_head)->val);
        }

    	return 0;
    }

    void hello_exit(void) {
        pr_info("in hello_exit()...\n");
        struct my_list_node *cur_node, *tmp_node;
        list_for_each_entry_safe(cur_node, tmp_node, &lst_head, list_head) {
            list_del(&cur_node->list_head);
            kfree(cur_node);
        }
    }

    module_init(hello_init);
    module_exit(hello_exit);
    MODULE_LICENSE("GPL");
    ```

    dmesg output:

    ```
    [ 3736.286051] in hello_init()...
    [ 3736.286191] node val: 123
    [ 3736.286198] node val: 456
    [ 3743.204415] in hello_exit()...
    ```

    `list_for_each_safe()`为`list_for_each()`的删除节点版本。

* `list_entry()`

    `list_entry()`和`container_of()`完全等价，用于从成员成员拿到外部 struct 的指针。

    syntax:

    ```c
    list_entry(ptr, type, member)
    ```

    example:

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/list.h>
    #include <linux/slab.h>
    #include <linux/pci.h>

    struct my_list_node {
        struct list_head list_head;
        int val;
    };

    struct list_head lst_head;

    int hello_init(void) {
        pr_info("in hello_init()...\n");
        INIT_LIST_HEAD(&lst_head);
        struct my_list_node *new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 123;
        list_add_tail(&new_node->list_head, &lst_head);
        new_node = kmalloc(sizeof(struct my_list_node), GFP_KERNEL);
        new_node->val = 456;
        list_add_tail(&new_node->list_head, &lst_head);

        struct my_list_node *cur_node;
        struct list_head *cur_head;
        list_for_each(cur_head, &lst_head) {
            cur_node = list_entry(cur_head, struct my_list_node, list_head);
            pr_info("node val: %d\n", cur_node->val);
        }

    	return 0;
    }

    void hello_exit(void) {
        pr_info("in hello_exit()...\n");
        struct my_list_node *cur_node, *tmp_node;
        list_for_each_entry_safe(cur_node, tmp_node, &lst_head, list_head) {
            list_del(&cur_node->list_head);
            kfree(cur_node);
        }
    }

    module_init(hello_init);
    module_exit(hello_exit);
    MODULE_LICENSE("GPL");
    ```

    dmesg output:

    ```
    [ 4057.550524] in hello_init()...
    [ 4057.550644] node val: 123
    [ 4057.550650] node val: 456
    [ 4063.035152] in hello_exit()...
    ```

* linux 内核没有提供方法直接得到链表的长度，需要我们自己实现。

    ```c
    #include <linux/list.h>

    int list_node_count(struct list_head *head)
    {
        int count = 0;
        struct list_head *pos;

        // 使用 list_for_each 遍历链表，每到一个节点计数器加一
        list_for_each(pos, head) {
            count++;
        }

        return count;
    }
    ```

* `list_empty()`

    判断链表是否为空。

    list_empty() 原理：它检查头节点的 next 指针是否指向它自己。

    ```c
    // list_empty 的典型实现
    #define list_empty(head) ((head)->next == (head))
    ```

    `list_empty()`只能作用于已经初始化的链表。

    一个被删除且未被重新 init 的节点调用 list_empty() 不会返回真。

* irq 11 example

    ```c
    #include <linux/init.h>
    #include <linux/module.h>
    #include <linux/interrupt.h>

    irqreturn_t my_irq_handler(int irq, void *dev_id) {
        pr_info("in my_irq_handler()...\n");
        pr_info("irq: %d, dev_id: %p\n", irq, dev_id);
        return IRQ_HANDLED;
    }

    int hello_init(void) {
        pr_info("in hello_init()...\n");
        int ret = request_irq(11, my_irq_handler, IRQF_SHARED, "hlc irq", my_irq_handler);
        if (ret != 0) {
            pr_err("fail to request irq\n");
            return -1;
        }
    	return 0;
    }

    void hello_exit(void) {
        pr_info("in hello_exit()...\n");
        free_irq(11, my_irq_handler);
    }

    module_init(hello_init);
    module_exit(hello_exit);
    MODULE_LICENSE("GPL");
    ```

    `cat /proc/interrupts ` output:

    ```
    test@Ubuntu22:~/Documents/Projects/driver_test$ cat /proc/interrupts 
               CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7       
      0:         33          0          0          0          0          0          0          0   IO-APIC   2-edge      timer
      1:         11          0          0          0          0          0          0          0   IO-APIC   1-edge      i8042
      6:          0          0          3          0          0          0          0          0   IO-APIC   6-edge      floppy
      7:          0          0          0          1          0          0          0          0   IO-APIC   7-edge      parport0
      8:          0          1          0          0          0          0          0          0   IO-APIC   8-edge      rtc0
      9:          0          0          0          0          0          0          0          0   IO-APIC   9-fasteoi   acpi
     11:          0          0          0          0          0          0          0          0   IO-APIC  11-fasteoi   hlc irq
     12:          0          0          0          0          0          0          0         15   IO-APIC  12-edge      i8042
    ```

* `pci_find_capability()`

    syntax:

    ```c
    #include <linux/pci.h>

    int pci_find_capability(struct pci_dev *dev, int cap);
    ```

    * `int cap_id`：要查找的能力类型的标识符（一个字节的 ID，如 0x10 代表 PCIe）。

    函数会从 PCI 配置空间的能力列表指针（Capabilities Pointer register，偏移量 `0x34`）开始，遍历整个能力链表。

    返回值：

    成功：如果找到了与 cap_id 匹配的能力项，则返回该能力结构在 PCI 配置空间中的偏移地址（例如，0x100）。驱动程序可以利用这个地址来读取或写入该能力结构中的具体寄存器（如配置 MSI 中断向量数、地址和数据）。

    失败：如果遍历完整个链表都没有找到指定的能力，或者设备根本不支持能力列表，则返回 0。

* pci capabilities list

    每个 node 代表一个 capabiiility，node 的大小并不固定，只有前两个字节是固定的。

    字节 0：Capability ID - 唯一标识能力的类型（如 0x01 是电源管理，0x10 是 PCIe）。

    字节 1：Next Capability Pointer - 指向下一个能力结构在配置空间中的偏移地址。这个指针将所有的能力节点链接在一起，形成链表。

    从字节 2 开始，驱动程序通过查询 Capability ID 来确定该如何解析后续的字节。详细的格式由 pci sig 维护。程序可以通过`pci_read_config_byte()`, `pci_read_config_word()`, `pci_read_config_dword()`来读取。开发者应该尽量使用更高级的接口，不要直接读取这些字节。

    常见的 pci capability id 与其对应的 struct:

    * `PCI_CAP_ID_MSI` (`0x05`): 消息信号中断

        MSI 结构有两种常见形式：32位和64位地址格式。

        * 最小形式 (32位地址, 1个向量)：

            偏移 0x00: Capability ID (0x05) + Next Pointer

            偏移 0x02: Message Control Register

            偏移 0x04: Message Address Register (低32位)

            偏移 0x08: Message Data Register

            总长度: 10 字节 (从链表指针开始算起的结构体大小)

        * 扩展形式 (64位地址, 多个向量)：

            包含最小形式的所有寄存器...

            偏移 0x08: Message Address Register (高32位)

            偏移 0x0C: Message Data Register

            偏移 0x10: Mask Bits Register (可选)

            偏移 0x14: Pending Bits Register (可选)

            总长度: 可达 24 字节或更多

    * `PCI_CAP_ID_MSIX` (`0x11`): 消息信号中断

    * `PCI_CAP_ID_PM` (`0x01`): 电源管理

    * `PCI_CAP_ID_EXP` (`0x10`): PCIe 特性

        PCI Express Capabilities Register

        Device Capabilities Register

        Device Status and Control Register

        Link Capabilities Register

        Link Status and Control Register

        Slot Capabilities Register (如果适用)

        ...

        总长度: 通常至少是 20 字节（对于端点设备），对于根端口或交换设备会更长

    * `PCI_CAP_ID_VNDR` (`0x09`): 虚拟通道

* MSI (Message Signaled Interrupts)

* 完整的 pci capability list

    可参考`uapi/linux/pci_regs.h`。

    | 常量 | 值 | 描述 |
    | - | - | - |
    | PCI_CAP_ID_PM | 0x01 | 电源管理 (Power Management) |
    | PCI_CAP_ID_AGP | 0x02 | 加速图形端口 (Accelerated Graphics Port) |
    | PCI_CAP_ID_VPD | 0x03 | 重要产品数据 (Vital Product Data) |
    | PCI_CAP_ID_SLOTID | 0x04 | 插槽识别 (Slot Identification) |
    | PCI_CAP_ID_MSI | 0x05 | 消息信号中断 (Message Signaled Interrupts) |
    | PCI_CAP_ID_CHSWP | 0x06 | 热插拔 (CompactPCI Hot-Swap) |
    | PCI_CAP_ID_PCIX | 0x07 | PCI-X |
    | PCI_CAP_ID_HT | 0x08 | HyperTransport |
    | PCI_CAP_ID_VNDR | 0x09 | 厂商特定信息 (Vendor-Specific) |
    | PCI_CAP_ID_DBG | 0x0A | 调试端口 (Debug port) |
    | PCI_CAP_ID_CCRC | 0x0B | 紧凑型PCI中央资源控制 (CompactPCI CRC) |
    | PCI_CAP_ID_SHPC | 0x0C | 标准热插拔控制器 (Standard Hot-Plug Controller) |
    | PCI_CAP_ID_SSVID | 0x0D | 子系统厂商ID (Subsystem Vendor/Device ID) |
    | PCI_CAP_ID_AGP3 | 0x0E | AGP 8x |
    | PCI_CAP_ID_SECDEV | 0x0F | 安全设备 (Secure Device) |
    | PCI_CAP_ID_EXP | 0x10 | PCI Express (这是最常用的之一) |
    | PCI_CAP_ID_MSIX | 0x11 | MSI-X 中断 (这是最常用的之一) |
    | PCI_CAP_ID_SATA | 0x12 | SATA 数据/配置索引 |
    | PCI_CAP_ID_AF | 0x13 | 高级功能 (Advanced Features) |

* `std::variant`

    `std::variant`是 c++ 17　的特性。

    std::variant 是一个类型安全的联合体（union）。它的作用是在一个变量中，安全地持有和管理多种可能类型中的一种。

    syntax:

    ```cpp
    #include <variant>

    template< class... Types >
    class variant;
    ```

    example:

    ```cpp
    #include <stdio.h>
    #include <variant>
    #include <string>
    #include <vector>
    #include <iostream>
    using namespace std;

    using MyVariant = std::variant<int, float, string>;
    // typedef std::variant<int, float, std::string> MyVariant;

    struct MyVisitor {
        void operator()(int i) const {
            std::cout << "Got an int: " << i << '\n';
        }
        void operator()(float f) const {
            std::cout << "Got a float: " << f << '\n';
        }
        void operator()(const std::string& s) const {
            std::cout << "Got a string: " << s << '\n';
        }
    };

    int main() {
        vector<MyVariant> values = { 3.14f, "Hello world", 42 };

        for (const auto& v : values) {
            std::visit(MyVisitor{}, v);
        }

        for (int i = 0; i < values.size(); ++i) {
            // cout << values[i] << endl;  // error
        }

        // get<1> means values[0] is a float type
        cout << get<1>(values[0]) << endl;
        // get<2> means values[1] is a string type
        cout << get<2>(values[1]) << endl;
        // get<0> means values[2] is a int type
        cout << get<0>(values[2]) << endl;

        try {
            MyVariant v = 10;
            string s = get<string>(v);  // 错误！ v 存的是 int
        } catch (const std::bad_variant_access& e) {
            cout << "Caught exception: " << e.what() << '\n';
        }

        return 0;
    }
    ```

    output:

    ```
    Got a float: 3.14
    Got a string: Hello world
    Got an int: 42
    3.14
    Hello world
    42
    Caught exception: std::get: wrong index for variant
    ```

    访问 variant 的方法通常为`std::get()`或`std::visit()`。如果类型错误，会抛出`std::bad_variant_access`异常。

    说明：

    1. 使用`using`和使用`typedef`效果一样的。

    1. `get<0>`里的`0`指的是`std::variant<int, float, string>`里的第 0 个类型。

* 写时复制（Copy-On-Write, COW）

    只有在真正需要写入（修改）数据时，才会去复制一份副本。在此之前，所有对象（或进程）共享同一份原始数据。

    `fork()`使用了 cow 机制，因此可快速创建一个新进程。

    在调用`fork()`时，内核会把当前进程的所有内存 page 改成只读权限，如果旧进程或新进程尝试往内存写入数据，那么会触发页错误（Page Fault），此时内核会把这一页数据复制一份新的，供尝试写入数据的进程使用。

    每个进程尝试写入数据，都会触发一次 page fault。所以如果新旧进程都写入了数据，那么目前会有三份数据：

    1. P：最初的共享数据（如果再无其他进程共享，它可能会被回收）。

    2. P_father：父进程的私有副本，包含了父进程的修改。

    3. P_child：子进程的私有副本，包含了子进程的修改（基于最初的数据，而非父进程修改后的数据）。

    写时复制（COW）的操作粒度通常是一个内存页（Page）。

* ssh config 中 HostName 和 Host

    Host 用于指定一个别名或模式，HostName 是实际的服务器地址。

    example:

    `~/.ssh/config`:

    ```conf
    Host myserver
        HostName example.com
        User alice
    ```

* qemu 无图形界面启动

    * 方案一
    
        `-nographic`

    * 方案二（未验证）

        `-display none`

* 强制关闭 qemu

    （未验证）

    强制退出：要强制终止 QEMU 进程，回到终端，可以先按下 Ctrl + A，松开后再按 X。

    * Ctrl + A 然后 X：立即终止 QEMU（相当于杀进程）。

    * Ctrl + A 然后 C：可以在 QEMU 监视器控制台和客户机串口控制台之间切换（用于更高级的操作）。
