* ubuntu 22.04 gnome 对 vnc 支持不好，目前即使端口 5900 打开也无法访问

* F1-score

    F1 指的是 F-score 或 F-measure 家族中的第一个成员，具体来说是当参数 β = 1 时的特殊情况。

    F-score 的通用公式是：

    $$F_\beta = (1 + \beta^2) \cdot \frac{\mathrm{Precision} \cdot \mathrm{Recall}}{(\beta^2 \cdot \mathrm{Precision}) + \mathrm{Recall}}$$

    当 $\beta = 1$ 时，公式简化为：

    $$F_1 = 2 \cdot \frac{\mathrm{Precision} \cdot \mathrm{Recall}}{\mathrm{Precision} + \mathrm{Recall}}$$

    这就是 F1-score 的由来 - 它是 F-measure with $\beta = 1$。

* f measure 延伸

    这里的 "F" 通常被认为是代表 F-measure（F 度量），源自统计学中的 F-test 概念。

    f1-score 有时也被解释为平衡 Precision 和 Recall 的 Harmonic Mean（调和平均）。

    $\beta$ 参数的意义：

    * $\beta$ 参数控制着 Precision 和 Recall 的相对重要性

    * $\beta = 1$：Precision 和 Recall 同等重要 → F1-score

    * $\beta > 1$：更重视 Recall（如 $\beta = 2$ 时，Recall 的权重是 Precision 的 4 倍）

    * $\beta < 1$：更重视 Precision（如 $\beta = 0.5$ 时，Precision 的权重是 Recall 的 4 倍）

* `scanf()`

    从标准输入流（stdin），通常是键盘，按照指定的格式读取数据，并将数据存储到给定的变量地址中。

    syntax:

    ```c
    int scanf(const char *format, ...);
    ```

    参数：

    * `format`：一个格式控制字符串，指定了期望输入的序列格式。它包含以下两种类型的字符：

        * 格式说明符：以 % 开头，如 %d（整数）、%f（浮点数）、%s（字符串，遇到空白字符停止）、%c（字符）等。

        * 空白字符：如空格、制表符、换行符。在格式字符串中，一个空白字符可以匹配输入中任意数量的空白字符。

        * 非空白字符：除了 % 之外的普通字符。输入时必须原样输入这些字符。

    * `...`：一个可变参数列表，是多个变量的地址。参数的数量和类型必须与 format 中的格式说明符一一对应。

    返回值：

    * 成功：返回成功匹配并赋值的输入项的数量。

    * 失败/错误：如果在读取任何数据前发生输入失败，则返回 EOF。

    example:

    ```c
    #include <stdio.h>

    int main() {
        int age;
        float height;
        char name[50];

        printf("请输入您的姓名、年龄和身高（例如：Alice 20 1.65）: ");
        
        // 从标准输入读取数据
        // 注意：变量前需要加 & 取地址操作符（数组名本身是地址，所以 name 不需要 &）
        int items_matched = scanf("%s %d %f", name, &age, &height);

        printf("成功读取了 %d 项数据。\n", items_matched);
        printf("姓名：%s，年龄：%d，身高：%.2f\n", name, age, height);

        return 0;
    }
    ```

    注意事项：

    * `scanf("%s", str)`读取字符串时，遇到空格、制表符或换行符就会停止，因此它不能读取包含空格的字符串。

    * 一定要在变量前加上取地址运算符 &，除非变量本身就是一个地址（如数组名、指针）。

* `sscanf()`

    从给定的字符串（str） 中按照指定的格式读取数据，并将数据存储到给定的变量地址中。可以看作是 scanf() 的“字符串版本”。

    syntax:

    ```c
    int sscanf(const char *str, const char *format, ...);
    ```

    参数：

    * `str`：源字符串，数据将从这里被读取。

    * `format`：格式控制字符串，与 scanf() 的 format 参数完全相同。

    * `...`：可变参数列表，同样是需要存储数据的变量的地址。

    返回值：

    * 成功：返回成功匹配并赋值的输入项的数量。

    * 失败：如果没有任何项被成功匹配，则返回 EOF。

    example:

    ```c
    #include <stdio.h>

    int main() {
        char info[] = "张三,25,80.5";
        char name[50];
        int age;
        float weight;

        // 从字符串 info 中解析数据
        int items_matched = sscanf(info, "%[^,],%d,%f", name, &age, &weight);

        printf("成功从字符串中解析了 %d 项数据。\n", items_matched);
        printf("姓名：%s，年龄：%d，体重：%.1f\n", name, age, weight);

        return 0;
    }
    ```

    示例解析：

    * 源字符串是`"张三,25,80.5"`。

    * 格式字符串`"%[^,],%d,%f"`的含义是：

        * `%[^,]`：读取一个字符串，直到遇到逗号`,`为止（`[^,]`是一个扫描集，表示匹配所有非逗号的字符）。

            这样可以匹配含有空格的字符串。

        * `,`：匹配一个逗号字符。

        * `%d`：读取一个整数。

        * `,`：再匹配一个逗号字符。

        * `%f`：读取一个浮点数。

* typer

    `pip install typer`

    example:

    ```py
    import typer

    app = typer.Typer()

    @app.command()
    def hello(name: str, age: int = 18, verbose: bool = False):
        """向某人问好"""
        typer.echo(f"你好 {name}, 年龄 {age}")
        if verbose:
            typer.echo("详细模式已开启")

    @app.command()
    def goodbye(name: str):
        """向某人道别"""
        typer.echo(f"再见 {name}!")

    if __name__ == "__main__":
        app()
    ```

    run:

    * `python main.py --help`

        output:

        ```
                                                                                        
         Usage: main_2.py [OPTIONS] COMMAND [ARGS]...                                   
                                                                                        
        ╭─ Options ────────────────────────────────────────────────────────────────────╮
        │ --install-completion          Install completion for the current shell.      │
        │ --show-completion             Show completion for the current shell, to copy │
        │                               it or customize the installation.              │
        │ --help                        Show this message and exit.                    │
        ╰──────────────────────────────────────────────────────────────────────────────╯
        ╭─ Commands ───────────────────────────────────────────────────────────────────╮
        │ hello     向某人问好                                                         │
        │ goodbye   向某人道别                                                         │
        ╰──────────────────────────────────────────────────────────────────────────────╯

        ```

    * `python main.py hello zhangsan --age 16 --verbose`

        output:

        ```
        你好 zhangsan, 年龄 16
        详细模式已开启
        ```

* argparse 中的 action

    `action='store_true'`表示当命令行中出现这个选项时，将参数值设置为 True；如果不出现，则设置为 False。

    配置了这个后，只需要写`--verbose`，就相当于`--verbose True`了。否则需要自己手动指定参数的值。（如果不写 action，只指定`--verbose`会发生什么？）

    `action`可接收的值：

    * `store` (默认值)

        存储参数的值（默认行为）

        ```py
        parser.add_argument('--file', action='store', type=str)
        # 命令行: --file data.txt
        # 结果: args.file = 'data.txt'
        ```

    * `store_true` / `store_false`

        ```py
        parser.add_argument('--enable', action='store_true')
        # 命令行指定 --enable: args.enable = True
        # 不指定: args.enable = False

        parser.add_argument('--disable', action='store_false')
        # 命令行指定 --disable: args.disable = False
        ```

    * `store_const`

        参数出现时设置为固定值

        example:

        `parser.add_argument('--level', action='store_const', const=10, help='出现时设置为固定值')`

        ```py
        parser.add_argument('--mode', action='store_const', const='fast')
        # 命令行指定 --mode: args.mode = 'fast'
        ```

    * `append`

        将多个参数值收集到列表中

        ```py
        parser.add_argument('--tag', action='append')
        # 命令行: --tag python --tag argparse --tag tutorial
        # 结果: args.tag = ['python', 'argparse', 'tutorial']
        ```

    * `count`

        计算参数出现的次数

        ```py
        parser.add_argument('-v', '--verbose', action='count', default=0)
        # 命令行: -v -v -v
        # 结果: args.verbose = 3
        # 或者: -vvv 同样得到 args.verbose = 3
        ```

    * `append_const`

        ```py
        parser.add_argument('--add-python', action='append_const', const='python')
        parser.add_argument('--add-java', action='append_const', const='java')
        # 命令行: --add-python --add-java --add-python
        # 结果: args.const_list = ['python', 'java', 'python']
        ```

* c / c++ 中是否有类似 argparse 的库，或者其他处理参数的库？

* alpha 主要包含两个方面

    * 公司的潜力（基本面）

    * 市场微小的错误定价

    由于上市公司数量有限，所有公开信息都已被充分挖掘。因此，基于传统基本面研究（潜力、价值）的Alpha几乎被挖掘殆尽。所以，量化机构必须寻找其他类型的“错误定价”。

    量化公司常见的策略：

    * 相似公司的股价背离 (统计套利)

    * 市场微观结构中的 Alpha（“抢跑”与“流动性提供”）

        核心思想：利用订单簿的瞬时失衡和交易指令的执行速度来获利。

        举例：

        * 高频做市：作为流动性提供者，赚取买一价和卖一价之间的微小价差（Spread）。

        * 延迟套利：利用不同交易所或数据源之间微小的信息传输速度差（几微秒）来获利。

        这为什么是Alpha：这完全不关心公司价值，只关心极短时间内市场的“生理反应”，是一种技术竞赛。

    * 另类数据驱动的Alpha（“信息差”）

        核心思想：在传统财报之外，寻找能预测公司业绩的独家数据，并抢在市场大多数人反应过来之前交易。

        举例：

        * 卫星图像：分析沃尔玛停车场的车辆数量来预测其季度营收。

        * 网络爬虫：抓取社交网络上对某款新品的讨论热度，预测苹果手机的销量。

        * 信用卡交易数据：通过汇总的消费数据，预测零售公司的表现。

        这为什么是Alpha：这不再是研究“公开信息”，而是研究“公开但未被有效处理的信息”，本质上是创造了一种新的、更快的信息优势。

    * 行为金融学中的系统性偏误（“人性的漏洞”）

        核心思想：市场参与者会系统性、可预测地犯下行为错误。

        举例：

        * 处置效应：投资者倾向于过早卖出盈利股票，过久持有亏损股票。量化模型可以反向操作，买入那些因“错杀”而超跌的股票。

        * 注意力偏差：投资者会追逐新闻热点，忽略那些不被关注的股票。量化模型可以系统性地挖掘这些“冷门股”。

        这为什么是Alpha：这不是公司基本面的错误，而是市场参与者集体心理在价格上留下的可预测印迹。您的均线策略，在某种程度上也是在利用这种“追涨杀跌”的群体行为。

    * 大规模、系统性的因子暴露

        核心思想：持有具有某些共同特征（因子）的一篮子股票，这些特征长期来看能带来超额回报。

        举例：

        * 动量因子：买入过去一段时间表现好的股票（这与您的策略内核一致）。

        * 价值因子：买入股价相对于其账面价值、盈利等更便宜的股票。

        * 低波因子：买入历史波动率较低的股票。

        这为什么是Alpha：量化机构通过复杂的模型，动态地配置于不同的因子，并管理因子之间的相关性，以获取稳健的收益。

* 水对不同波段光的吸收

    水对不同波段光的吸收能力差异，本质上是由水分子的分子结构、振动模式和电子能级共同决定的。其中，分子振动模式对红外和近红外的吸收起主导作用，而电子能级决定了紫外和可见光波段的吸收。

    将电磁波谱分为几个区域来看水（液态水）的吸收特性：

    * 微波/远红外区（波长 > 20 μm）：

        * 吸收强。主要吸收机制是水分子的整体转动能级跃迁。微波炉正是利用这个波段（~12 cm）来加热食物中的水分子。

    * 中红外区（~3 - 20 μm）：

        * 吸收极强，是水的“指纹区”。主要吸收机制是水分子内部化学键的振动能级跃迁，特别是O-H键的伸缩振动和弯曲振动。

        * 强吸收峰：在约3 μm（~3300 cm⁻¹，O-H伸缩）和6 μm（~1640 cm⁻¹，H-O-H弯曲）处有非常强烈的吸收峰。这使得水是地球上最强的温室气体之一（吸收地球热辐射）。

    * 近红外区（~0.7 - 2.5 μm）：

        * 吸收较弱，但有明显的吸收带。这正是您问题的关键。这些吸收带是上述中红外基频振动的倍频和合频。也就是说，光子能量不足以激发一次完整的基频振动，但可以激发振动能级的更高能级（倍频）或同时激发两种振动模式（合频）。由于跃迁概率较低，所以吸收比中红外基频要弱得多。

        * 主要吸收带：在0.97 μm、1.19 μm、1.45 μm、1.94 μm、2.95 μm附近。其中，1.45 μm和1.94 μm是水分析中最重要的特征波段。

    * 可见光区（~0.4 - 0.7 μm）：

        * 吸收非常弱，且随波长减小（蓝光）吸收略有增加。纯水看起来呈蓝色，就是因为它对红光（长波）吸收略少于蓝光（短波），发生瑞利散射后，散射光中蓝光成分更多。这个波段的吸收与电子能级的微弱跃迁以及高倍频振动有关。

    * 紫外区（< 0.4 μm）：

        * 吸收急剧增强。当光子能量足够高时，可以引发水分子外层电子的能级跃迁，从而被强烈吸收。

    结论：水的吸收存在多个“窗口”。近红外区（特别是0.7-1.3 μm）是其中一个相对透明的窗口，但并非完全透明，内部存在多个由振动倍频/合频造成的吸收带。

* 水对近红外光的吸收

    * 吸收机制的本质：振动倍频与合频

        * 近红外的吸收主要来源于水分子O-H键振动能级的高阶跃迁（倍频、合频）。根据量子力学，这种跃迁的概率远低于基频跃迁（中红外区）。

        * 可以类比：用力拉一根弹簧（基频，容易发生） vs. 用特定的力使弹簧振动幅度达到精确的2倍或3倍（倍频，更难精确匹配，概率更低）。因此，近红外的吸收系数通常比中红外基频小几个数量级。

    * 水的分子结构决定了振动模式

        * 水分子（H₂O）是一个极性分子，具有不对称的V形结构。这种结构产生了三种基本的振动模式：对称伸缩、不对称伸缩和弯曲振动。这些模式的固有频率（由原子质量、化学键力常数和分子几何结构决定）正好落在中红外区域。

        * 近红外吸收的能量，对应的是这些基本振动模式能量组合的“谐振”，所以其强度天生就弱。

    * 原子能级与电子能级的作用

        * 原子能级：这里主要指原子核的质量，它影响了振动频率（例如，重水D₂O的O-D键振动频率比H₂O低很多，其吸收峰位置也会向长波方向移动）。

        * 电子能级：在近红外和可见光区，光子能量不足以激发水分子从基态到电子激发态的跃迁（这需要紫外光能量）。因此，近红外的吸收与电子能级跃迁无关，完全由振动能级的高阶跃迁主导。电子能级决定了紫外区的强吸收边界。

    总结:

    * 根本决定因素：水的分子结构（H-O-H键角、O-H键长）和原子特性（H和O的质量）共同决定了其分子振动能级的固有频率。

    * 吸收机制：

        * 中红外强吸收 = 振动能级的基频跃迁（概率大）。

        * 近红外弱吸收 = 振动能级的倍频/合频跃迁（概率小）。

        * 紫外强吸收 = 电子能级跃迁（能量高）。

    * 为什么近红外窗口有用：正因为水在近红外（尤其是特定波段）吸收相对较弱，使得光可以穿透一定深度的生物组织（如肌肉、脑组织）或进行短距离的水下传感，这被广泛应用于近红外光谱分析、生物医学成像（如NIRS）、光纤通信（选择1.3μm和1.55μm低损耗窗口） 等领域。这些应用正是巧妙地利用了水的吸收“窗口”和“吸收带”来实现成分分析或信号传输。

    水的近红外吸收特性，是其分子振动能级特性（由分子结构和原子属性决定）的高阶表现形式，吸收较弱是因为高阶振动跃迁的概率远低于基频跃迁。

* X 射线 CT 使用的是简单几何光学吗？

    对于绝大多数临床应用的X射线CT而言，其重建算法的核心基础就是几何光学（直线传播），而完全忽略了波动光学效应（如衍射和干涉）。 这正是X射线CT与HD-DOT在物理层面最根本的区别。

    为什么X射线CT可以使用几何光学模型？

    * 波长极短： 临床 CT 使用的 X 射线波长大约在 0.01 到 0.1 纳米量级（相当于10⁻¹¹米）。这个尺度远小于被成像物体（如人体）的内部结构特征尺寸（细胞、血管、骨骼等，通常在微米到厘米量级），也远小于 CT 探测器的像素尺寸。

    * 散射相对较弱： 在人体组织中，X 射线的主要相互作用是光电效应和康普顿散射。

        * 光电效应是吸收性的，光子完全消失。

        * 康普顿散射会使光子改变方向，但对于诊断能段的X射线（~100 keV），在致密组织中，前向散射虽然存在，但其强度与初级（未散射的）射线相比通常较弱。更重要的是，CT扫描仪配备了**准直器**和**抗散射栅**，可以极大地过滤掉这些散射光子，防止它们到达探测器。

    “投影”的诞生： 由于上述两个原因，一束X射线穿过人体时，可以近似看作是一条笔直的线。光子要么被吸收（衰减），要么基本不受影响地直线穿过。因此，探测器在某一点测量到的信号强度衰减，可以认为只来自于这条直线路径上所有组织的衰减效应的累加。

    这就引出了CT重建的基石——朗伯-比尔定律：

    $$I = I_0 \cdot \exp {\left(- \int \mu(x, y, z) \mathrm dl \right)}$$

    * $I_0$ ： 入射 X 射线强度

    * $I$ ： 出射 X 射线强度

    * $\int \dots \mathrm d l$ ： 沿射线路径 $l$ 的线积分

    * $\mu(x, y, z)$ ： 物体在点 $(x, y, z)$ 的线性衰减系数，这就是 CT 图像要显示的物理量。

    对这个公式取对数，我们就得到了一个线积分，称为投影数据：

    $$p = - \ln \frac{I}{I_0} = \int \mu(x, y, z) \mathrm d l$$

    这个模型的简洁性至关重要：测量值 p 直接等于未知图像 μ 沿一条直线的积分。

    重建算法基石: Radon逆变换 / 滤波反投影

    重建算法:

    * 解析法：滤波反投影

        核心思想： 来源于 Radon 变换及其逆变换。每个投影（一个角度下的所有测量）都包含了物体在所有方向上的信息。FBP 算法将这些投影数据进行滤波（以消除星状伪影），然后反向投射回图像空间。

        优点： 速度快，易于实现，是临床 CT 的标配算法。

        前提： 完全依赖于“射线直线传播”这一假设。

    * 迭代重建算法

        核心思想： 与 HD-DOT 的求解思路类似。

        1. 先假设一个初始的衰减系数分布。

        2. 通过“正向投影”（计算假设图像沿所有 CT 射线路径的线积分）来模拟测量数据。

        3. 将模拟数据与真实测量数据比较，计算差异。

        4. 根据差异反向更新图像，不断迭代直至收敛。

        优点： 在低剂量扫描时能获得更好的图像质量，能更好地处理噪声和物理效应（如微弱的散射）。

        与 HD-DOT 的区别： 即使使用迭代法，CT 的正向模型仍然非常简单（还是线积分），因此计算量远小于 HD-DOT，且病态性问题也轻微得多。

* 什么是 Radon 变换？

* 光强与光子流密度是什么关系？

* 光子流密度$\Phi (r)$

    在空间某一点 $r$ 处，单位时间单位面积上通过的光子数量。

* 量子力学中的微扰论（Perturbation Theory）

    **哲学**： 对于一个难以直接求解的复杂系统，如果它在某个“微小变化”的扰动下，那么系统的响应可以近似为这个微小变化与某个“灵敏度”的线性乘积。

    * 系统与方程：

        * 系统：一个量子体系，比如一个原子。

        * 方程：薛定谔方程 H ψ = E ψ。这是一个本征值方程，H 是哈密顿算符（系统的总能量），E 是能量本征值，ψ 是波函数。这个方程通常很难精确求解。

    * 已知的“基线”状态：

        * 我们有一个已知的、可精确求解的未微扰系统。例如，氢原子。它的哈密顿量是 H⁰，对应的本征态 ψ_n⁰ 和本征能量 E_n⁰ 都是已知的。

        * 方程：H⁰ ψ_n⁰ = E_n⁰ ψ_n⁰

    * 引入“扰动”：

        * 系统受到一个小的外部影响，比如一个外加的电磁场。这个影响用一个微扰哈密顿量 H‘ 来表示，且 H’ << H⁰。

        * 此时，完整的哈密顿量变为 H = H⁰ + H‘。

        * 完整的薛定谔方程 (H⁰ + H’) ψ = E ψ 变得难以直接求解。

    * 线性扰动近似（一阶微扰论）：

        * 我们将未知的波函数和能量，在已知的基线状态附近进行展开：

            * ψ_n ≈ ψ_n⁰ + ψ_n¹ （波函数的一阶修正）

            * E_n ≈ E_n⁰ + E_n¹ （能量的一阶修正）

        * 然后将这些展开式代入完整的薛定谔方程，并只保留到 H‘ 的一阶项。

        * 最终，我们得到一个关键的线性公式，用于计算能量和波函数的变化：

            * 能量的一阶修正：E_n¹ = <ψ_n⁰ | H‘ | ψ_n⁰> （一个非常优美的线性表达式！）

            * 这个公式告诉我们，能量的小变化 E_n¹，近似等于微扰 H‘ 在未微扰状态 ψ_n⁰ 下的期望值。

* `\exp`后通常要加上括号，比如`\exp \left( x + y \right)`，不能只写成`\exp{x + y}`，更不能写成`\exp x + y`。

* vscode 插件 Cursor Align

    按光标对齐多行文本，功能有点像 latex 中的`&`。

    example:

    ```
    name = "John"
    age = 25
    city = "New York"
    ```

    使用 alt 键选中三个`=`前面的位置，然后按 alt + A，即可对齐，效果如下：

    ```
    name = "John"
    age  = 25
    city = "New York"
    ```

    主要功能：

    1. 对齐多行光标位置的文本 —— 在多行同时编辑时，自动将每行光标所在的列对齐到同一位置。

    2. 按特定字符对齐文本 —— 可以按照 =、:、# 等符号对齐选中的多行文本。

    3. 快速格式化选中的代码或文本 —— 无需手动添加空格，一键对齐，提升可读性。

    上面展示的是功能 1。功能 2 和 3 待探索。

* vscode 插件 CJK Word Handler

    按 Ctrl+Left/Right 移动光标时，能正确处理中英文混合的情况（例如“VS Code是一个编辑器”）

* 进化算法 es

    核心思想：仿生“优胜劣汰”

    进化算法是一种受生物进化论（物竞天择，适者生存）启发而设计的优化算法。它的核心思想是：通过模拟自然选择、交叉（杂交）和变异等过程，让一个“种群”在代代繁衍中不断进化，最终找到复杂问题的最优解或满意解。

    一个生动的比喻：寻找最高峰

    假设你的任务是在一个完全漆黑、地形复杂（有很多山丘和山谷）的区域里找到最高点。你没有地图，只能靠派出一支“探险队”去摸索。

        初始化种群（第一代探险队）：

            你随机地在地图上撒下一把“探险者”（这就是初始种群）。每个探险者都有一个位置坐标（这就是一个“染色体”或“解”）。

        评估适应度（判断谁站得高）：

            你让每个探险者报告他们所在位置的海拔高度。海拔越高，代表他的“适应度”越好。

        选择（优胜劣汰）：

            你更倾向于选择那些站得高的探险者作为“父母”，让他们繁衍下一代。站得越低的人，被选中的几率就越小。这保证了优秀的基因（位置信息）能传递下去。

        交叉/重组（父母生孩子）：

            你让选出的“父母”两两配对，交换他们的一部分位置信息（比如，取父亲的一半坐标和母亲的一半坐标，组合成一个新的坐标）。这样就产生了新的“孩子”探险者，他们可能站在父母位置之间的某个新地方。

        变异（随机的小变化）：

            在新生的“孩子”中，你随机地对极少数孩子的坐标进行一个微小的、随机的变动。比如，让某个孩子向左或向右随机移动一小步。变异非常重要，它能引入新的可能性，比如让孩子偶然发现一个父母从未探索过的、可能更高的新山丘。

        形成新一代，并循环：

            现在，你用这些新生的“孩子”们（通过选择和交叉、变异产生的）组成新一代的探险队，替换掉大部分老一代的成员。

            然后回到第2步，重复这个过程：评估新队伍的适应度 -> 选择 -> 交叉 -> 变异。

    经过很多代这样的循环后，你会发现，你的整个探险队会逐渐向地图上最高的几座山峰聚集，最终找到最高点（或一个非常高的点）。

    进化算法的关键组成部分

    根据上面的比喻，一个标准的进化算法包含以下要素：

        种群：一组潜在解的集合。

        染色体/个体：对问题的一个潜在解的编码（比如一串数字）。

        适应度函数：用于评估一个解好不好的标准。算法的目标就是最大化或最小化这个函数值。

        选择：根据适应度高低，从当前种群中挑选出优秀的个体作为父母。

        交叉：将两个父代个体的部分结构加以替换重组，生成新个体。这是产生新解的主要手段。

        变异：以一定的概率随机改变个体编码的某些部分，以增加种群的多样性，避免陷入局部最优。

    主要特点与优势

        适用于黑箱问题：你不需要知道问题的精确数学模型，只需要能评估每个解的好坏（适应度）即可。

        全局搜索能力强：由于同时处理一个种群（多个解），并且有变异操作，它不太容易像传统方法那样陷入局部最优解。

        鲁棒性好：对问题的数学性质（如是否可微、是否连续）要求不高，能处理各种奇形怪状的搜索空间。

        高度并行：种群中每个个体的评估可以同时进行，非常适合并行计算。

    常见的进化算法类型

        遗传算法：最经典和著名的一种，通常使用二进制字符串编码。

        遗传规划：用于进化计算机程序（通常表示为树形结构）。

        进化策略：主要用于连续数值优化，特别强调变异操作。

        进化规划：与进化策略类似，但通常没有交叉操作。

    总结

    进化算法是一类通过模拟生物进化过程中的“选择、交叉、变异”机制，来引导一个候选解种群朝着更优方向发展的随机优化算法。它特别擅长解决那些传统数学方法难以处理的、复杂的、非线性的优化问题。

    简单来说，它就是让计算机通过 “随机生成 -> 评估好坏 -> 优胜劣汰 -> 混合变异” 的循环，自己“摸索”出问题答案的一种强大方法。

* 进化算法中的交叉是否是必要的？

    这是一个非常深刻的问题，答案是：交叉不是严格必要的，但它极其重要。 没有交叉的进化算法（即只依赖选择和变异）仍然是完整且理论上可行的算法，但在大多数情况下，它的性能会大打折扣。

    下面我们从理论和实践两个角度来详细解释。
    1. 没有交叉的进化算法：进化策略(1+1)-ES

    一个著名的例子是 (1+1)-进化策略：

        种群大小： 1个个体。

        操作：

            变异： 从当前个体产生一个变异的后代。

            选择： 比较父代和子代，保留两者中适应度更高的一个。

        这个算法完全没有交叉操作。它就像一个独行侠在解空间里通过随机扰动（变异）进行摸索。

    它能工作吗？ 能！对于许多问题，它都能找到不错的解。它证明了变异是维持种群多样性和进行探索的必要操作。
    2. 为什么交叉如此重要？理论依据

    交叉的核心作用不是探索，而是开发。它将已有的优良“基因模块”进行重组，从而高效地构建出更优的解。其理论依据主要来自以下两个经典理论：
    a) 建筑块假说

    这是遗传算法最核心的理论基础。

        核心思想： 优秀的解通常是由一些短的、性能良好的“基因模块”组合而成。这些模块本身具有较高的平均适应度。

        交叉的作用： 交叉操作允许这些在不同个体中独立进化出来的优良模块（建筑块）组合到一起，从而像搭积木一样，快速构建出包含多个优良模块的、全局更优的解。

        比喻：

            只有变异： 就像你试图一个字一个字地随机修改来写出一篇好文章，过程极其缓慢。

            加入交叉： 就像两位作家（父代）交换了他们文章中最精彩的段落（建筑块），然后组合成一篇可能更精彩的新文章（子代）。这大大加速了创造过程。

    b) 模式定理

    这是对建筑块假说的数学化描述，由遗传算法之父John Holland提出。

        模式： 一个模式是描述一组具有特定基因相似性的字符串的模板。例如，在二进制编码中，模式 1**0*1 代表了所有第一位为1、第四位为0、第六位为1的字符串（*是通配符）。

        定理内容： 模式定理定量地证明了：短定义的、低阶的、高于平均适应度的模式（即建筑块）在种群中会以指数级增长。

        交叉的角色： 交叉虽然会破坏某些长的模式，但它对短的、优良的模式破坏概率很低。因此，总体上，这些“建筑块”能够通过选择被保留，并通过交叉被传播和重组，从而在种群中迅速占据主导地位。

    简单来说，模式定理从数学上解释了为什么交叉能有效地让“好点子”在种群中传播和组合。

    3. 交叉 vs. 变异：分工明确

    为了更好地理解，我们可以对比一下两者的角色：

    特性	变异	交叉
    主要角色	探索	开发
    操作对象	单个个体	两个或多个个体
    创造新基因	能。通过随机改变，可以产生种群中从未有过的基因值。	不能。它只能重新组合现有基因，无法创造全新的基因信息。
    作用方式	局部、随机的微调。	全局、结构化的重组。
    类比	一个发明家在自己的实验室里偶然发现了一个新材料。	两个公司合并，将各自的核心技术（建筑块）整合成一个更强大的新公司。
    结论与总结

        非必要性： 从存在性上讲，交叉不是必需的。一个只包含变异和选择的进化算法是完整的，并且可以解决问题。

        关键重要性： 从效率和性能上讲，交叉通常是至关重要的。它是进化算法区别于其他随机搜索算法的关键特征。

        理论依据： 建筑块假说和模式定理为交叉的重要性提供了坚实的理论依据。它们解释了交叉如何通过重组优良的“基因模块”来指数级地加速搜索过程，实现“1+1>2”的效果。

        协同工作： 变异和交叉是相辅相成的。变异负责“开疆拓土”，探索新的可能性和维持多样性；交叉负责“精耕细作”，高效地整合已有的成果。 没有变异，算法会过早收敛，失去发现新机会的能力；没有交叉，算法的收敛速度会非常缓慢，难以解决复杂问题。

    因此，在实际应用中，绝大多数进化算法都会同时包含交叉和变异这两个操作员，让它们在搜索过程中各司其职，协同工作。

* 进化算法引入表观遗传学机制

    在计算机模型中，表观遗传可以被模拟为：

        可遗传的标记：在基因型（染色体编码）之上，增加一个“标记层”。这个标记层可以决定某个基因是“开启”还是“关闭”（表达或不表达），而这个标记本身也可以以一定的概率遗传给后代。

        对环境的学习与继承：

            拉马克进化的引入：表观遗传在一定程度上支持了“获得性遗传”的可能性。父母一生中因环境因素（如饮食、压力）导致的表观标记变化，有可能传递给后代。

            在算法中的体现：个体在生命周期内可以通过局部搜索、学习等策略来“优化”自己的表现型，然后将这种优化成果通过某种机制（例如，改变基因的显性/隐性，或直接修改编码）部分地遗传给后代。这被证明可以显著加速收敛。

* 其他被引入进化算法的复杂生物学机制

    发育生物学：

        问题：传统进化算法中，基因型到表现型是直接转换（如，二进制字符串直接解码为一个数字）。

        更生物学的模型：引入一个发育过程。基因型作为“配方”，通过一个模拟胚胎发育的过程（如基因调控网络）逐步“生长”成复杂的表现型。这使得小的基因变化能通过发育过程产生巨大而结构化的表现型变化，从而创造出更复杂、更鲁棒的解决方案。

    生态位与共生：

        问题：传统算法中个体间主要是竞争关系。

        更生物学的模型：模拟生态系统，个体可以占据不同的“生态位”，避免直接竞争。还可以引入共生关系，即不同个体通过合作产生单独无法实现的适应度优势。

    性选择与宿主-寄生虫协同进化：

        不仅仅基于生存能力进行选择，还引入基于“吸引力”的选择。

        通过模拟宿主与寄生虫之间的“军备竞赛”，来维持种群的多样性和避免过早收敛。

* 把 rdp 的流量包在 ssh 流量里

    通常使用`ssh -L`进行转发：

    `ssh -N -L 本地端口:目标RDP服务器地址:3389 SSH用户名@SSH服务器地址`

    然后使用 xfreerdp 连接本地隧道端口：

    `xfreerdp /v:127.0.0.1:13389 /u:RDP用户名 /p:RDP密码`

    xfreerdp 本身没有原生支持 ssh tunnel 的方法

* 调研 Remmina 的功能，是否支持 wayland

* systemd 服务设置 ssh -R 反向隧道开机自启动

    1. 创建 systemd 服务文件

        ```bash
        sudo nano /etc/systemd/system/ssh-reverse-tunnel.service
        ```

    2. 编辑服务文件内容

        ```conf
        [Unit]
        Description=SSH Reverse Tunnel
        After=network.target

        [Service]
        Type=simple
        User=your_username
        ExecStart=/usr/bin/ssh -N -R remote_port:localhost:local_port username@remote_host -p remote_ssh_port -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -o StrictHostKeyChecking=accept-new
        Restart=always
        RestartSec=10

        [Install]
        WantedBy=multi-user.target
        ```

    3. 设置和启动服务

        ```bash
        # 重新加载 systemd
        sudo systemctl daemon-reload

        # 设置开机自启动
        sudo systemctl enable ssh-reverse-tunnel.service

        # 立即启动服务
        sudo systemctl start ssh-reverse-tunnel.service

        # 检查服务状态
        sudo systemctl status ssh-reverse-tunnel.service
        ```

    注意事项

        确保网络连通性: 服务在网络就绪后启动

        使用非特权端口: 如果非root用户运行，remote_port通常需要大于1024

        监控日志: 使用 journalctl -u ssh-reverse-tunnel.service -f 查看日志

        安全考虑: 确保远程服务器是可信的，因为反向隧道会暴露本地服务

    注：

    1. `After=network.target`
    
        不写`After=network-online.target`是因为后面有无限重连做保证。

        但是我觉得直接写成`After=network-online.target`更好，直接一步到位。

    1. `ExitOnForwardFailure=yes`

        如果无法端口转发，那么 ssh 连接直接报错。如果远程的端口被其他程序占用，那么 ssh 报错退出。

        ssh 的默认设置是如果端口转发失败（比如远程端口已被占用），SSH 连接仍然会建立，端口转发功能实际上没有工作。

        这个设置配合 systemd 的自动重启服务，可以一定程序上解决远程端口被占用的问题。

    1. `Type=simple`

        SSH 命令会长期运行，保持连接和隧道。进程在前台持续运行，不会立即退出。systemd 会监控这个长期运行的进程。

        如果使用`Type=oneshot`，那么程序执行完就退出。这个配置配合`RemainAfterExit=yes`使用，检查 status 时的效果如下：

        ```
        active (exited)
        ```

        如果不设置`RemainAfterExit=yes`，则会变成

        ```
        inactive
        ```

        使用 simple 的好处：

        * systemd 直接监控主进程

        * 进程退出时自动重启

        * 完整的生命周期管理

        * 简单的日志收集

        * systemctl stop 能正确终止进程

* systemd 的`Type=forking`是什么意思？

* systemd 的`Wants=`, `Requires=`, `After=`有什么不同？

* network.target vs network-online.target

    network.target：

        网络配置完成（接口已配置）

        不保证实际网络连通性

        启动较快

    network-online.target：

        网络真正连通（可以访问外部网络）

        等待 DHCP、DNS 等完全就绪

        启动较慢，可能超时

    所以这两个区别是，一个内网能访问通，一个能访问到公网？

* `Restart=on-failure`, `Restart=Always`，这些有什么不同？还有什么可取的值？是否大小写敏感？

* 除了`After=syslog.service`, `After=network.target`，还有什么常用的 service？

* `StartLimitInterval=300`, `StartLimitBurst=5`这两个是什么意思？

* 剧情：消耗了大量的人力物力成就的 AI：参考悖论引擎

* 剧情：幸好 AI 掌握在善良之人手中：参考芙莉莲

* 活在未来

    总是感觉想象中的一切都实现了，偶尔瞥一眼现在。

* 金钱就是意义

    假如一个人满足吃穿住行后，没有什么特别值得奋斗的目标，此时金钱就是意义。它是社会给个人定下的目标。

* 量化想法：针对不同板块的 etf，对 dmi 指标进行矩阵回测，找到最好用的 dmi 周期超参数。

* 听股评不一定是为了研究股票，可能只是想找些有共同话题的人陪伴。

* `who`, `w`, `last`这三个命令是什么意思？

* 调研 ufw 防火墙

    `ufw allow from YOUR_IP to any port 22`

* 调研 tcpdump 的用法

    `sudo tcpdump -i any port 22 -n`

* 调研 iptables

    ```bash
    # 记录所有访问22端口的连接
    sudo iptables -I INPUT -p tcp --dport 22 -j LOG --log-prefix "SSH_CONN: "

    # 查看iptables日志
    sudo tail -f /var/log/kern.log | grep SSH_CONN
    ```

    ```bash
    # 使用iptables限制连接频率
    iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set
    iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 4 -j DROP
    ```

* investigate fail2ban filter

    ```conf
    # /etc/fail2ban/filter.d/ssh-kex.conf
    [Definition]
    failregex = ^%(__prefix_line)serror: kex_exchange_identification:.* from <HOST>
                ^%(__prefix_line)serror: kex_exchange_identification: Connection closed by remote host.* from <HOST>
    ```

* investigate port knocking

    端口敲门 (port knocking)

* ECDSA

    ECDSA 密钥强度对比
    密钥类型	等效RSA密钥长度	安全性	性能
    ECDSA 256	RSA 3072	高	快
    ECDSA 384	RSA 7680	很高	较快
    ECDSA 521	RSA 15360	极高	中等

    ```bash
    # 您的521位ECDSA密钥提供极高的安全强度
    ssh-keygen -t ecdsa -b 521 -f ~/.ssh/id_ecdsa_521
    ```

    ECDSA 521属于NIST P-521曲线（secp521r1）, 被FIPS 186-4标准认可, 广泛支持于现代SSH客户端和服务器.

    兼容性 check:

    ```bash
    # 检查SSH客户端支持情况
    ssh -Q key
    # 应该包含: ecdsa-sha2-nistp521

    # 检查SSH服务器支持
    ssh -Q key-sig
    ```

    性能:

    比ECDSA 256稍慢，但差异很小, 在大多数场景下感知不到性能影响

* SSH密钥常用的位元长度和类型

    * RSA 密钥

        ```bash
        # 生成RSA密钥
        ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa_4096
        ```

        位元长度	安全性	兼容性	推荐程度
        RSA 1024	低	极高	❌ 已不安全，禁用
        RSA 2048	中	很高	⚠️ 最低要求
        RSA 3072	高	高	✅ 推荐
        RSA 4096	很高	高	✅ 推荐

    * ECDSA 密钥

        ```bash
        # 生成ECDSA密钥
        ssh-keygen -t ecdsa -b 256 -f ~/.ssh/id_ecdsa_256
        ```

        曲线类型	等效RSA强度	安全性	推荐程度
        ECDSA 256	RSA 3072	高	✅ 推荐
        ECDSA 384	RSA 7680	很高	✅ 良好
        ECDSA 521	RSA 15360	极高	✅ 良好

    * Ed25519 密钥

        ```bash
        # 生成Ed25519密钥（固定256位）
        ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519
        ```

        特性	说明	推荐程度
        固定256位	等效RSA 3072	✅ 强烈推荐

* 为什么选 ECDSA 521，而不是 2 的整数幂，比如 512？

    1. 基于素数域的特性

        ```py
        # 不是 2^521，而是基于素数：
        p_521 = 2^521 - 1  # 这是一个梅森素数

        # 对比：
        p_512 = 2^512 - 1  # 这不是质数！
        ```

    2. NIST标准曲线

        ECDSA使用的不是任意位数，而是特定的标准化曲线：
        曲线名称	字段大小	安全强度
        NIST P-256	256位	128位
        NIST P-384	384位	192位
        NIST P-521	521位	256位

    3. 521位的数学优势

        ```py
        # P-521曲线的素数域：
        p = 2^521 - 1
        ```

        这个素数的特性：

        - 是一个梅森素数
        - 支持高效的模运算
        - 提供恰好256位的安全强度

    安全强度匹配

        P-256: 256位字段 → 128位安全强度

        P-384: 384位字段 → 192位安全强度

        P-521: 521位字段 → 256位安全强度

* check cipher key info

    ```bash
    # 查看密钥信息
    ssh-keygen -l -f ~/.ssh/id_ecdsa
    ```

* ssh 中是否可以指定任意整数的位？

    不能指定任意整数的位元，SSH密钥生成有严格的限制。

    ```bash
    # 尝试生成非常规位数的密钥
    ssh-keygen -t ecdsa -b 512 -f test_key  # ❌ 会失败！
    ssh-keygen -t ecdsa -b 500 -f test_key  # ❌ 会失败！
    ssh-keygen -t ecdsa -b 300 -f test_key  # ❌ 会失败！
    ```

    各类型密钥的有效位元:

    * RSA 密钥

        ```bash
        # 有效位元：必须是较大数字，通常 ≥1024
        ssh-keygen -t rsa -b 1024    # ⚠️ 最小（不安全）
        ssh-keygen -t rsa -b 2048    # ✅
        ssh-keygen -t rsa -b 3072    # ✅
        ssh-keygen -t rsa -b 4096    # ✅
        ssh-keygen -t rsa -b 8192    # ✅（但性能差）

        ssh-keygen -t rsa -b 1000    # ❌ 无效！
        ssh-keygen -t rsa -b 512     # ❌ 太弱，现代SSH会拒绝
        ```

    * ECDSA 密钥

        ```bash
        # 有效位元：只有3个固定值
        ssh-keygen -t ecdsa -b 256   # ✅ NIST P-256
        ssh-keygen -t ecdsa -b 384   # ✅ NIST P-384  
        ssh-keygen -t ecdsa -b 521   # ✅ NIST P-521

        ssh-keygen -t ecdsa -b 512   # ❌ 无效！
        ssh-keygen -t ecdsa -b 300   # ❌ 无效！
        ```

    * Ed25519 密钥

        ```bash
        # 固定位元：不能指定位数
        ssh-keygen -t ed25519        # ✅ 固定256位
        ssh-keygen -t ed25519 -b 512 # ❌ 忽略-b参数
        ```