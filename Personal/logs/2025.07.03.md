* c++ 不允许对指针重载`==`，否则会造成指针的比较定义混淆

    ```cpp
    // OK
    bool operator==(XmlTag &tag_1, const XmlTag &tag_2) {
        //　...
    }

    // Error
    bool operator==(const XmlTag *tag_1, const XmlTag *tag_2) {
        //　...
    }
    ```

    那么如果在`vector`里存指针，比如`vector<XmlTag*>`，该如何使用`std::find()`呢？

* 必须使用 unique ptr 的场景

    按传统的方式需要调用两次函数，第一次得到 num，然后用户 malloc 内存拿到 buffer，第二次调用函数往 buffer 里填数据。

    如果在这里用 unique ptr，那么只需要调用一次函数就可以了，申请的内存也会自动释放。

* 蜘蛛

* grep 搜索一行内同时出现多个关键字

    example:

    `msg.txt`:

    ```
    hello, world, nihao, zaijian
    123, 234, 345, 456, nihao
    hello, 345
    ```

    需要搜索同时出现`hello`, `workd`和`nihao`的行。

    * 方案一，使用多个管道

        `grep hello ./msg.txt | grep world | grep nihao`

        output:

        ```
        hello, world, nihao, zaijian
        ```

        其中，只有`nihao`是标红的。我们希望的是`hello`, `workd`, `nihao`这三个单词都标红。

        可以使用`--color=always`实现这个效果：

        `grep hello ./msg.txt --color=always | grep --color=always world | grep nihao`

        最后一个 grep 本身就有标红功能，可以不写`--color`参数。

        output:

        ```
        hello, world, nihao, zaijian
        ```

        其中,`hello`, `world`, `nihao`分别被标红。

    * 方案二，使用`.*`连接三个关键字

        `grep hello.*world.*nihao ./msg.txt`

        output:

        ```
        hello, world, nihao, zaijian
        ```

        这种方式，整个`hello, world, nihao`字符串都标红，也不是我们想要的。

        而且这种方式，要求`hello`, `world`, `nihao`这三个关键字的顺序不能乱，如果我们无法事先知道顺序，那么就需要把所有的顺序都试一遍。

    可见，grep 并没有很方便地实现搜索 pattern_1 AND pattern_2 AND pattern_3 AND ... 的命令，但是使用管道还是能实现的。如果有需求并且有时间的话，我们可以自己定义一个命令实现这个功能。

* grep 搜索一行内出现多个关键词的其中一个

    example:

    `msg.txt`:

    ```
    hello, world, nihao, zaijian
    123, 234, 345, 456, nihao
    hello, 345
    ```

    `grep -e hello -e world -e nihao ./msg.txt`

    output:

    ```
    hello, world, nihao, zaijian
    123, 234, 345, 456, nihao
    hello, 345
    ```

    输出中所有的`hello`, `world`, `nihao`都被标红。