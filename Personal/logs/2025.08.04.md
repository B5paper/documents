* 文字与大模型

    大模型并没有展示创建概念这一过程，文字中的很多概念与抽象是人们事先已经创建好的，大模型只是做了适配。

* git merge 在使用 Fast-forward 时，看不出来是一个 merge 操作

    如果是处理冲突的 commit，则会显示一条 merge commit 的提示

    > Merge: aea1ecc ebdd241

    如果想将这个 merge commit 变成一个正常的 commit，那么有下面几种方法：

    1. 使用`git rebase -i <commit_id_before_merge>`，merge commit 选 pick （如果选 squash 会报错）。需要重新处理 confilit。

        假如现在有：

        ```
        commit 3
        commit 2
        commit 1
        ```

        我们想把 commit 2 和 3 合成一个 commit，那么在 rebase 时需要

        `git rebase -i <commit_1_id>`

        此时 todo list 会显示为：

        ```
        pick commit 2
        pick commit 3
        ```

        我们需要把 commit 3 的 pick 改为 squash (s)，保存退出即可。

        squash 与 fixup 的区别为：

        `squash`：合并到前一个 commit，并保留提交信息。

        `fixup`：合并到前一个 commit，但丢弃提交信息。

    1. 如果最新的一个 commit 是 merge commit，那么可以用`git reset <commit_before_merge>`将 commit 回退到 merge 的上一个 commit，同时又保留了 working directory 的更改，此时只需要再`git add .`，`git commit`就可以了。

    注：

    * `git rebase --rebase-merges <commit_id>`不可以以 rebase 的方式处理 merge commit.

* `git rebase -i`比较像从某个 commit 开始，将各个 commit 重新提交一遍。如果每次 commit 都有冲突，那么就需要一直处理冲突。如果不想每次都处理，想只保留最后一次 commit 的结果，或许可以用到`skip`选项。
