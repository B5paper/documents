* 炒股的收益要交多少税

    在中国大陆炒股，涉及的税收主要是“印花税”和“个人所得税（股息红利）”，而股票买卖的价差收益目前是暂免征收个人所得税的。

    * 股息红利: 需要缴纳个人所得税，税率根据持股时间有所不同。款通常在您收到分红时，由券商直接代扣代缴。

        税率标准如下：
        持股时间	税率	备注
        不足1个月（含1个月）	20%	税负较重，旨在鼓励长期投资
        1个月以上至1年（含1年）	10%	
        超过1年	免征	享受税收优惠

        持股时间计算：从您买入股票之日算起，到您卖出股票之日的前一天为止。不是按自然年算，而是按实际持有天数算。

        先进先出原则：如果您对同一只股票有多次买入，在卖出时，会按照“先进先出”的原则来确定您卖出的是哪一批股票，从而计算对应的持股时间。

    印花税

        性质：在卖出股票时单边征收的一种税。

        税率：按照成交金额的0.05% （即千分之零点五）计算。

        缴纳方：仅由卖方支付，买方不需要支付。

        示例：您卖出10万元的股票，需要缴纳印花税：100,000 × 0.05% = 50元。

    交易佣金

        性质：券商为您提供交易渠道和服务所收取的费用。

        费率：目前普遍在万分之三（0.03%） 左右，具体费率因券商和客户资金量而异，最高不得超过0.3%。每笔交易佣金最低收费5元（双向收取）。

        缴纳方：买卖双方都需支付。

    过户费

        性质：股票成交后，更换户名（即所有权从卖方转移到买方）所需支付的费用。

        费率：按成交金额的0.001% （十万分之一）收取。

        缴纳方：买卖双方都需支付（上海、深圳证券交易所均收取）。

    总结

    为了方便您理解，我们用一个表格来总结：
    税收/费用项目	征收环节	税率/费率	缴纳方	备注
    印花税	卖出时	0.05%	卖方	单边征收，国家主要税种
    股息红利税	分红时	0%（>1年）、10%（1月-1年）、20%（≤1月）	股东	持股时间越长，税率越低
    交易佣金	买卖时	≤0.3%（通常~0.03%）	买卖双方	券商收取，可协商，最低5元
    过户费	买卖时	0.001%	买卖双方	中国结算公司收取
    资本利得税	价差盈利	暂免征收	-	目前个人炒股价差收益不征税

* 常见科创板 etf

    华宝科技ETF（515000）：投资于A股各板块的科技龙头公司，其持仓中通常会包含部分科创板股票。

    华夏芯片ETF（159995）：主要投资于芯片半导体产业，其中也包含了在科创板上市的芯片公司。

    华泰柏瑞科创板50ETF（588000）：这是目前市场规模最大、流动性最好的科创板ETF。它跟踪的是上证科创板50成份指数，投资于科创板中市值最大、流动性最好的50只股票。

    工银瑞信科创板50ETF（588050）：同样是跟踪科创50指数的ETF。

    易方达科创板50ETF（588080）：同上。

* A 股名字后面跟一个-U是什么意思？

    这个“-U”代表的是 “未盈利”（Unprofitable）。即最近一个会计年度经审计的净利润为负值（即亏损）。

* 想法：一个基于写调查报告的电商

    电商平台对入驻商家明查暗访，定期发布调查报告、车间视频、暗访谈话、供应链追踪，清除消费者疑虑。

* 社会融资规模存量

    社会融资规模存量，简单来说，就是在某一时点（比如月末、季末或年末），整个实体经济（包括企业和个人）从整个金融体系那里获得的资金总额。

    您可以把它想象成：

        整个经济的“总负债”：它衡量的是金融体系对实体经济的“总支持”，或者说是实体经济为了发展而背负的“总债务”。

        资金的“蓄水池”：它反映了金融体系向实体经济“输血”的总量。存量越大，说明积累的资金支持越多。

    与之相对的一个概念是“社会融资规模增量”，它指的是在一定时期内（比如一个月、一个季度）新增加的社会融资规模，可以理解为“蓄水池”在这个时期里“新注入的水量”。

    **这个“资金总额”包括哪些？**

    这个“金融体系”是广义的，不仅仅指银行。它主要包括两大部分：

    1. 传统银行体系提供的资金

        * 人民币贷款：这是最主要的部分，指银行向企业和居民发放的各类贷款。

        * 外币贷款：指银行发放的外币形式折算成人民币的贷款。

    2. 非银行金融机构和金融市场提供的资金（“影子银行”和直接融资）

        这部分是社融指标的关键特色，它反映了金融脱媒（绕过银行直接融资）的情况。

        * 委托贷款：A公司通过银行等机构，将资金贷给B公司，银行只收取手续费，不承担信用风险。

        * 信托贷款：通过信托公司发起的贷款。

        * 未贴现银行承兑汇票：企业签发的、由银行承诺兑付但尚未到银行贴现的票据。

        * 企业债券：企业在银行间市场和交易所发行的债券，这是直接融资的重要部分。

        * 非金融企业境内股票融资：企业在国内股市通过IPO、增发等方式筹集的资金，这也是直接融资。

        * 存款类金融机构资产支持证券、贷款核销以及政府债券（近年来被纳入，因为地方政府债券也被视为对地方实体经济的支持）等。

    为什么这个指标如此重要？

    1. 全面反映金融对实体经济的支持：它比单纯看“新增人民币贷款”更全面，因为它涵盖了银行表内、表外以及资本市场的所有融资渠道。

    2. 衡量货币政策效果：中国人民银行（央行）通过调整利率、存款准备金率等手段，最终目的是影响社会融资规模，从而调控经济。如果社融存量增速过低，说明金融支持不足，经济可能面临下行压力；如果增速过快，则可能引发通胀和资产泡沫风险。

    3. 预测未来经济走势：今天的融资就是明天的投资和消费。因此，社融存量的规模和增速，是判断未来几个季度经济活跃度的重要先行指标。

    4. 揭示经济结构变化：通过分析社融存量中各部分的比例变化，可以洞察经济结构。例如：

        * 如果债券和股票融资占比上升，说明直接融资发展良好，经济结构在优化。

        * 如果信托贷款等表外融资激增，可能意味着“影子银行”活动活跃，需要警惕金融风险。

* vim 中常用的寄存器

    `"+` 寄存器：对应系统的 “Ctrl+C / Ctrl+V” 剪贴板。在大多数现代系统上，这是最常用的。

    `"*` 寄存器：在 Linux/Unix 系统上，通常对应 “鼠标中键” 或“选择”剪贴板（即你用鼠标选中文本，然后按鼠标中键粘贴的内容）。在 Windows/macOS 上，它和 "+ 通常是相同的。

    | 命令 | 描述 |
    | - | - |
    | `"+y` | 复制当前选中的文本到系统剪贴板 |
    | `"+yy` 或 `"+Y` | 复制当前行到系统剪贴板 |
    | `"+yiw` | 复制当前光标下的单词到系统剪贴板 |
    | `"+y$` | 从光标处复制到行尾到系统剪贴板 |
    | `"+d` | 剪切当前选中的文本到系统剪贴板 |
    | `"+dd` | 剪切当前行到系统剪贴板 |
    | `"+d$` | 从光标处剪切到行尾到系统剪贴板 |

    可视化模式下的操作：

        按 v (字符可视模式) 或 V (行可视模式) 或 Ctrl+v (块可视模式)。

        选中你要操作的文本。

        按 "+y (复制) 或 "+d (剪切)。

    从系统剪贴板 粘贴 到 Vim

    在 Normal 模式下，使用 "+p 或 "*p。
    命令	描述
    "+p	在光标后粘贴系统剪贴板的内容
    "+P	在光标前粘贴系统剪贴板的内容

    设置默认使用系统剪贴板（推荐）:

    ```vim
    " 设置默认寄存器为系统剪贴板
    set clipboard=unnamedplus " Linux, Windows (WSL)
    " 对于 macOS，有时可能需要使用 unnamed
    " set clipboard=unnamed
    ```

    解释：

        unnamedplus：让默认寄存器 (") 与 "+ (系统剪贴板) 联通。复制 (yy)、粘贴 (p) 等命令会直接操作系统剪贴板。

        unnamed：在 macOS 上，有时这个选项效果更好，它让默认寄存器与 "* 联通。

    **在命令行模式下粘贴**:

    如果你想在 Vim 的命令行（比如在搜索 / 或命令 : 中）粘贴系统剪贴板的内容，可以按 Ctrl+r 然后输入 +。

* 确认你的 Vim 版本是否编译了剪贴板支持

    在终端里运行以下命令：

    ```bash
    vim --version | grep clipboard
    ```

    或者直接在 Vim 内部输入：

    ```vim
    :version
    ```

    然后查找 clipboard 和 xterm_clipboard。

    * 如果看到 +clipboard 和 +xterm_clipboard：恭喜，你的 Vim 支持系统剪贴板，可以直接使用下面的所有方法。

    * 如果看到 -clipboard：说明你的 Vim 不支持。你需要安装一个带剪贴板功能的 Vim。

        * Ubuntu/Debian: sudo apt install vim-gtk3 (或者 vim-gnome, vim-gtk)

        * macOS (使用 Homebrew): brew install vim

        * CentOS/RHEL: sudo yum install vim-X11 (可能需要)

* linux 查看当前目录的大小

    1. du 命令（最常用）

        ```bash
        # 显示当前目录的总大小（人类可读格式）
        du -sh .

        # 显示详细的大小信息（包括子目录）
        du -sh *
        ```

        常用参数：

        * `-s`：汇总，只显示总大小

        * `-h`：人类可读格式（KB、MB、GB）

        * `-c`：显示总计

        * `--max-depth=N`：限制显示层级

    2. 显示当前目录的详细大小信息

        ```bash
        # 显示当前目录及所有子目录的大小
        du -h --max-depth=1

        # 按大小排序显示
        du -h --max-depth=1 | sort -hr
        ```

    3. 使用 ncdu（需要安装，但非常直观）
    
        ```bash
        # 安装ncdu
        sudo apt install ncdu    # Debian/Ubuntu
        sudo yum install ncdu    # CentOS/RHEL

        # 使用ncdu
        ncdu
        ```

    4. 显示磁盘使用情况

        ```bash
        # 查看整个文件系统的使用情况
        df -h .

        # 只显示当前目录所在分区的使用情况
        df -h $PWD
        ```

    5. 其他实用命令

        ```bash
        # 快速查看当前目录大小（以字节为单位）
        du -sb

        # 排除某些文件类型（如排除.log文件）
        du -sh --exclude="*.log" .

        # 仅显示超过特定大小的目录
        du -h --max-depth=1 | grep '[0-9]G\>'  # 显示GB级别的目录
        ```

    主要区别：

    * `du`：计算文件和目录占用的实际磁盘空间

    * `df`：显示文件系统的整体使用情况

    * `ncdu`：交互式磁盘使用分析器，更适合深入分析

    常用组合命令：

    ```bash
    # 查找当前目录下最大的10个文件/目录
    du -ah . | sort -rh | head -10

    # 只显示目录大小（不包括文件）
    du -h --max-depth=1 -t 1M .  # 只显示大于1MB的目录
    ```

    推荐使用：`du -sh .` 这是最简单直接的查看当前目录大小的方法。

* DMI

    DMI，中文全称为趋向指标或动向指标，由美国技术分析大师威尔斯·威尔德发明。它的核心作用是判断股票或其他金融资产价格趋势的强度和方向，尤其擅长识别市场是处于“有趋势”的行情（单边上涨或下跌）还是“无趋势”的盘整行情（横盘震荡）。

    简单来说，DMI不直接告诉你买卖点，而是先告诉你 “现在市场有没有明确的趋势？” ，在这个基础上再辅助判断方向。

    * DMI的四个组成部分

        DMI指标由四条线组成，

        1. `+DI`（正向动向线，白线）：

            * 含义：代表上升趋势的强度。

            * 计算原理：通过比较今日最高价与昨日最高价，来衡量多方的力量。

            * 如何看：+DI线上升，表示多头力量在增强；+DI线下降，表示多头力量在减弱。

        1. `-DI`（负向动向线，黄线）：

            * 含义：代表下降趋势的强度。

            * 计算原理：通过比较今日最低价与昨日最低价，来衡量空方的力量。

            * 如何看：-DI线上升，表示空头力量在增强；-DI线下降，表示空头力量在减弱。

        1. `ADX`（平均趋向指数，紫/红线）：

            * 含义：这是DMI系统的核心，代表当前趋势的总体强度（无论是上涨还是下跌）。

            * 关键点：ADX 不区分方向，只告诉我们趋势是强还是弱。

            * 如何看：

                * ADX值上升：表示趋势正在加强（可能是在强劲的上涨或下跌中）。

                * ADX值下降：表示趋势正在减弱，市场可能进入盘整或震荡期。

                * ADX值低位（通常低于20或25）：表明市场没有趋势，处于盘整状态。

                * ADX值高位（通常高于40）：表明市场存在强劲的单边趋势。

        1. ADXR（平均趋向指数的评估线，绿线）：

            * 含义：是ADX的平滑值，用于辅助判断ADX的可靠性，使信号更平稳。在实际应用中，很多投资者会主要关注前三条线。

    **DMI的经典用法与判断标准**

    1. 趋势方向的判断（+DI 与 -DI 的关系）

        * 买入信号：当 +DI 从下向上穿越 -DI，形成“金叉”，表明多头力量开始压倒空头力量，是潜在的看涨信号。

        * 卖出信号：当 -DI 从上向下穿越 +DI，形成“死叉”，表明空头力量开始压倒多头力量，是潜在的看跌信号。

        重要提示：在盘整行情中，+DI和-DI会频繁交叉，这些信号是无效的。因此，必须结合ADX来使用。
    
    2. 趋势强度的判断（ADX 的角色）

        * 强劲趋势的确认：当 ADX 线持续上升（特别是在20/25以上），并且 +DI 在上 -DI 在下，确认了强劲的上升趋势。反之，若ADX持续上升且 -DI 在上 +DI 在下，则确认了强劲的下降趋势。

        * 盘整市的警示：当 ADX 值降至20/25以下，表明市场失去方向，进入盘整。此时，任何+DI和-DI的交叉产生的买卖信号都不可靠，应避免依据其操作。

        * 趋势反转的预警：在一段强劲的趋势（ADX在高位）后，如果 ADX 开始从高位掉头向下，可能预示着当前的趋势即将结束，市场可能要进入盘整或反转阶段。

    **实战应用图解与口诀**

    你可以记住一个简单的口诀：

    > “看ADX定趋势，看DI交叉定方向。”

    * 情景A：强劲的上涨趋势

        图形：ADX持续在25以上并上升，+DI始终在-DI上方。

        解读：市场处于明确的单边上涨市，应持股或寻找买入机会。

    * 情景B：强劲的下跌趋势

        图形：ADX持续在25以上并上升，-DI始终在+DI上方。

        解读：市场处于明确的单边下跌市，应持币观望或谨慎做空。

    * 情景C：盘整震荡市

        图形：ADX在20以下，且+DI和-DI数值很低，并频繁纠缠交叉。

        解读：市场没有方向，此时DMI指标失效，应使用KDJ、RSI等震荡指标。

    总结：优缺点

        优点：

            能有效过滤盘整行情，避免在震荡市中频繁交易。

            能客观地量化趋势的强度，帮助交易者抓住主升浪或主跌浪。

            是一个综合性的趋势判断工具，比单一均线更全面。

        缺点：

            信号具有滞后性，不是领先指标。

            在盘整市中，+DI和-DI的交叉会提供大量虚假信号。

            计算复杂，需要借助软件。

    建议：

    DMI是一个非常好的“趋势过滤器”。在实际操作中，不要单独使用DMI，最好能结合其他指标一起使用，例如：

        与均线系统结合：当DMI发出买入信号时，股价最好也在关键均线（如60日线）之上。

        与K线形态结合：在DMI金叉的同时，出现看涨的K线组合（如早晨之星），会增加信号的可靠性。

* 早晨之星

    早晨之星，顾名思义，就是在太阳升起之前，黎明前最黑暗时刻出现的一颗启明星，它预示着光明和希望。

    在股市中，早晨之星是一个重要的底部反转信号。它通常出现在一段下跌趋势的末尾，预示着下跌行情可能即将结束，价格即将迎来反弹或反转上涨。

    **形态构成（三根K线的组合）**

    早晨之星由三根K线组合而成，这是一个标准的“三根K线组合”形态：

    1. 第一根K线：大阴线（实体部分较长）

        特征：这是一根顺应原有下跌趋势的、实体较长的阴线。它表明空方力量仍然占据绝对优势，市场处于恐慌或持续的抛售中。

    2. 第二根K线：星线（小实体，有上下影线）

        特征：这是形态的核心。它的实体部分很小（可以是小阴线、小阳线或十字星），并且实体与第一根阴线的实体之间有向下的跳空缺口。这个“星”形象地表明了市场趋势的不确定性和动能的衰竭：空方力量无法再大幅打压价格，但多方也还未完全占据主动。市场在此犹豫不决。

    3. 第三根K线：大阳线（实体部分较长）

        特征：这是一根强有力的阳线，其实体部分至少需要深入到第一根阴线实体的1/2以上，深入得越多，信号越强烈。理想情况下，它能覆盖第一根阴线的大部分或全部实体。这根阳线表明多方力量开始全力反攻，并成功扭转了局势，确认了反转的有效性。

    **形态的市场心理分析**

    1. 第一根大阴线：市场悲观情绪蔓延，抛售盘持续涌出，所有人都认为下跌还将继续。

    2. 第二根星线：

        * 开盘跳空低开，说明恐慌情绪还在，但价格却无法大幅下跌（实体很小）。

        * 这表明，虽然还有人在卖，但已经有逢低买入的资金开始在暗中吸纳筹码。多空力量达到了一个短暂的平衡。

        * 市场情绪从“一致看空”转变为“犹豫不决”。

    3. 第三根大阳线：

        * 多方力量经过前一交易日的蓄势后，发起总攻。价格强势上涨，并收复了第一根阴线的大部分失地。

        * 这极大地鼓舞了多方士气，同时迫使在下跌途中做空的空头回补平仓（买入），进一步推升价格。

        * 市场情绪彻底转向，新的上涨趋势得以确认。

    识别要点与交易策略

    * 识别要点：

        * 位置是关键：必须发生在一段清晰的下跌趋势之后。如果在上涨途中或横盘时出现，则没有意义。

        * 跳空缺口：第二根星线的实体最好与前后两根K线的实体都有价格跳空缺口（在实际分析中，与第一根的缺口更为重要）。

        * 第三根的确认：第三根阳线必须强势，收盘价深入第一根阴线实体内部越深越好。如果只是小幅上涨，则信号不可靠。

    * 交易策略：

        * 激进入场点：在第三根大阳线即将收盘确认时，可以轻仓介入。

        * 稳健入场点：在早晨之星形态完成后，次日如果价格继续上涨，或出现小幅回踩但不破早晨之星的低点时，是更安全的入场时机。

        * 止损位：应将止损位设置在早晨之星形态的最低点下方。因为一旦价格跌破这个位置，说明这个底部反转形态失败，下跌趋势可能延续。

        * 目标位：可以参考形态所处位置的前期压力位，或者利用形态的高度（第一根K线的最低点到第三根K线的最高点）来估算初步目标。

    早晨之星是一个由恐慌、犹豫到反转确认的经典三部曲。它是一个非常直观且有力的底部看涨信号。但在实战中，有几点需要注意：

    * 务必结合成交量：在早晨之星形态中，第三根大阳线如果有成交量的显著放大配合，那么这个信号的可靠性会大大增加。

    * 结合其他指标：如果早晨之星出现在重要的支撑位（如前期低点、长期均线附近），或者与其他技术指标（如MACD、KDJ的底背离）同时发出信号，那么成功率会更高。

* 黄昏之星

    黄昏之星是一种顶部形态，是早晨之星的反面。

    出现位置：出现在一段上涨趋势的末尾。

    形态构成：

    1. 第一根：大阳线。

    2. 第二根：星线（向上跳空）。

    3. 第三根：大阴线（深入第一根阳线实体内部）。

    信号含义：顶部反转信号，预示上涨行情可能结束，下跌即将开始。

* 左侧交易和右侧交易

    左侧交易和右侧交易的核心区别，在于你是在趋势“形成前”行动，还是在趋势“形成后”跟随。

    一、左侧交易

    1. 形象比喻：

        想象一个“V”形谷。股价从左边山坡下跌，跌到谷底，然后从右边山坡上涨。
        
        左侧交易者，是在下跌的半山腰（左侧）就开始买入，俗称“抄底”。

    2. 核心思想：

        逆势交易： 在价格还在持续下跌（趋势未确认反转）时，就提前预测底部并进行买入。

        价值投资： 交易者认为当前价格已经低于其内在价值，具备了投资吸引力，不在乎是否买在最低点，只在乎买在“便宜区域”。

        主观判断： 非常依赖于交易者个人的分析、估值和信念。

    3. 操作手法：

        买入： 在下跌过程中，分批、逢低买入，不断摊薄成本。

        卖出： 在上涨过程中，分批、逢高卖出，不追求卖在最高点。

    4. 优点：

        成本优势： 如果判断正确，买入的平均成本较低，潜在利润空间大。

        不会踏空： 由于是分批建仓，基本不会错过整个上涨行情。

    5. 缺点：

        风险较高： 容易抄底抄在半山腰，市场可能继续下跌，导致深度套牢。

        时间成本高： 买入后可能需要经历漫长的筑底和等待过程，非常考验耐心。

        需要雄厚资金： 通常需要准备充足的资金用于分批补仓。

    典型左侧交易者形象： 价值投资者、逆向投资者。 比如在股灾时，别人恐惧他贪婪，敢于逆市买入好公司。

    二、右侧交易

    1. 形象比喻：

        同样是一个“V”形谷。
        
        右侧交易者，会一直等到股价跌到底部并开始明确上涨（走出右侧）时，才跟随买入，俗称“追涨”。

    2. 核心思想：

        顺势交易： 不预测底部，等待市场自己走出底部并确认上升趋势后，再入场操作。

        趋势跟踪： 交易的核心是跟随趋势，认为趋势是你的朋友。

        客观信号： 依赖于技术指标发出的明确信号，如均线金叉、突破关键压力位、放量上涨等。

    3. 操作手法：

        买入： 在趋势确认反转并开始上涨后，果断买入。

        卖出： 在趋势确认反转并开始下跌后，果断卖出。

    4. 优点：

        安全性高： 避免了“接下落的飞刀”的风险，不会在下跌途中被深套。

        效率高，时间成本低： 买入后通常能较快地享受到股价上涨带来的收益。

    5. 缺点：

        成本较高： 无法买在最低点，买入成本通常比左侧交易者高。

        容易追高/踏空： 可能买在短期高点，面临回调风险；也可能因为等待确认信号而错过行情最初的一段。

        有滞后性： 信号确认需要时间，无法从头到尾吃完整个行情。

    典型右侧交易者形象： 趋势交易者、技术派。 他们严格遵守交易纪律，不见兔子不撒鹰。

    三、总结与对比

    为了更清晰，我们用一个表格来对比：

    | 特征 | 左侧交易 | 右侧交易 |
    | - | - | - |
    | 理念 | 逆势、预测、价值投资 | 顺势、跟随、趋势跟踪 |
    | 买入时机 | 下跌途中，预测底部 | 上涨初期，确认趋势 |
    | 卖出时机 | 上涨途中，预测顶部 | 下跌初期，确认下跌 |
    | 成本 | 低（理想情况下） | 高 |
    | 风险 | 高（可能抄底在半山腰） | 相对低（避免深套） |
    | 时间成本 | 高（需要长期等待） | 低（见效快） |
    | 对投资者要求 | 深厚的分析功底、强大的心理、充足的资金 | 严格的纪律、果断的执行力、技术分析能力 |
    | 俗称 | 抄底逃顶 | 追涨杀跌（这里的“杀跌”是止损纪律） |

    四、如何选择？

    * 左侧交易更适合长线投资者、价值投资者，他们有耐心、有深度研究能力，并且资金充裕，能承受较大的短期浮亏。

    * 右侧交易更适合中线或短线交易者、技术派，他们追求资金效率，纪律性强，愿意用一部分潜在利润去换取更高的安全性和确定性。

    重要提示：

    * 没有绝对的好坏之分，只有是否适合你。很多成熟的投资者会结合使用两种策略。例如，用左侧思维在低位收集筹码，然后用右侧思维在趋势确立后加仓。

    * 无论哪种交易，资金管理和止损纪律都是生存的根本。左侧交易尤其要避免“越跌越买”变成“无底洞”，右侧交易则要避免“追高”后不及时止损。

* 使用 git archive + 手动创建新仓库

    ```bash
    # 1. 为每个版本下载压缩包
    mkdir my-repo && cd my-repo
    wget https://github.com/user/repo/archive/refs/tags/v1.0.tar.gz
    wget https://github.com/user/repo/archive/refs/tags/v2.0.tar.gz
    wget https://github.com/user/repo/archive/refs/tags/v3.0.tar.gz

    # 2. 创建新的git仓库
    git init
    tar -xzf v1.0.tar.gz --strip-components=1
    git add . && git commit -m "v1.0"
    rm -rf *  # 清空目录

    tar -xzf v2.0.tar.gz --strip-components=1
    git add . && git commit -m "v2.0"
    rm -rf *

    tar -xzf v3.0.tar.gz --strip-components=1
    git add . && git commit -m "v3.0"

    # 现在你有一个只有3个提交的新仓库
    ```

* 医疗中的客观 AI

    医患关系中，患者可能会觉得医生水平不够，对医生的判断提出质疑，此时使用 AI 给出辅助意见，患者会比较放心。

* matlab legend()

    legend() 函数用于在 MATLAB 图形中添加图例，解释不同数据系列的含义。

    基本语法

    ```matlab
    legend('label1', 'label2', ..., 'labelN')
    legend({'label1', 'label2', ..., 'labelN'})  % 使用元胞数组
    ```

    常见用法示例

    1. 基础用法
    
        ```matlab
        x = 0:0.1:2*pi;
        y1 = sin(x);
        y2 = cos(x);

        plot(x, y1, 'r-', x, y2, 'b--');
        legend('sin(x)', 'cos(x)');
        ```

    2. 指定位置

        ```matlab
        legend('sin(x)', 'cos(x)', 'Location', 'best');           % 自动选择最佳位置
        legend('sin(x)', 'cos(x)', 'Location', 'northwest');      % 左上角
        legend('sin(x)', 'cos(x)', 'Location', 'northeast');      % 右上角
        legend('sin(x)', 'cos(x)', 'Location', 'southoutside');   % 底部外侧
        ```

    3. 高级选项

        ```matlab
        legend('sin(x)', 'cos(x)', ...
            'FontSize', 12, ...              % 字体大小
            'TextColor', 'blue', ...         % 文本颜色
            'Box', 'off', ...                % 关闭边框
            'Orientation', 'horizontal');    % 水平排列
        ```

    4. 自动获取句柄

        ```matlab
        h1 = plot(x, sin(x), 'r-');
        hold on;
        h2 = plot(x, cos(x), 'b--');
        legend([h1, h2], {'正弦函数', '余弦函数'});
        ```

    5. 动态更新

        ```matlab
        % 创建图形后动态修改
        lgd = legend('sin(x)', 'cos(x)');
        lgd.Title.String = '三角函数';          % 添加图例标题
        lgd.NumColumns = 2;                     % 分两列显示
        ```

    重要参数说明

    | 参数 | 说明 |
    | - | - |
    | `'Location'` | 位置：'best', 'north', 'south', 'east', 'west' 等 |
    | `'NumColumns'` | 列数 |
    | `'Box'` | 边框：'on'（默认）或 'off' |
    | `'FontSize'` | 字体大小 |
    | `'Orientation'` | 方向：'vertical'（默认）或 'horizontal' |

    注意事项

    * 图例顺序与绘图顺序一致

    * 使用 legend('off') 或 legend([]) 移除图例

    * 在多个子图中，每个子图需要单独添加图例

    * R2016b+ 支持 'AutoUpdate' 控制是否自动更新

    最佳实践：在完成所有绘图操作后再添加图例，确保所有数据系列都被正确标注。

* matlab 中，设置 3d figure 的长宽高比例

    * axis equal 和相关命令

        ```matlab
        % 创建3D图形
        [X,Y,Z] = peaks(30);
        surf(X,Y,Z);

        % 设置不同比例选项
        axis equal;        % 三个坐标轴等比例
        axis square;       % 使坐标框呈正方形
        axis tight;        % 紧凑模式，贴合数据范围
        axis vis3d;        % 保持比例不变，避免旋转时变形
        ```

    * daspect 函数 - 最常用方法
    
        ```matlab
        % 设置数据单位的比例
        daspect([1 2 3]);  % x:y:z = 1:2:3，z轴是x轴的3倍长度

        % 示例：使z轴拉伸2倍
        [x,y,z] = sphere(20);
        surf(x,y,z);
        daspect([1 1 2]);  % x和y轴1:1，z轴拉伸2倍

        % 获取当前比例
        current_ratio = daspect;
        ```

    * pbaspect 函数 - 设置绘图框比例
    
        ```matlab
        % 设置绘图框的相对比例
        pbaspect([1 1 1]);   % 立方体形状的绘图框
        pbaspect([2 1 1]);   % x方向占2份，y和z各占1份

        % 示例：宽高比2:1:1
        surf(peaks);
        pbaspect([2 1 1]);    % 绘图框比例，不是数据比例
        ```

    * axis 函数综合设置
    
        ```matlab
        % 设置坐标轴范围和比例
        [x,y,z] = peaks(30);
        surf(x,y,z);

        % 方法1：设置坐标范围
        axis([-3 3 -3 3 -10 10]);  % [xmin xmax ymin ymax zmin zmax]

        % 方法2：组合使用
        axis equal tight;          % 等比例且紧凑
        ```

    * view 函数调整视角

        ```matlab
        surf(peaks);
        daspect([1 1 3]);          % z轴拉伸3倍
        view(30, 30);              % 方位角30°，俯仰角30°
        view(3);                   % 默认3D视角
        ```

    * 完整示例

        ```matlab
        % 创建3D数据
        [X,Y] = meshgrid(-2:0.2:2);
        Z = X.*exp(-X.^2 - Y.^2);

        % 绘制曲面
        figure('Position', [100 100 800 600]);
        surf(X,Y,Z);
        title('调整3D图形比例示例');

        % 设置数据比例：使z轴更明显
        daspect([1 1 0.5]);  % z轴压缩为原来的一半

        % 设置绘图框比例
        pbaspect([1.5 1 1]);  % x方向绘图框更宽

        % 调整视角
        view(45, 30);

        % 添加坐标轴标签
        xlabel('X轴');
        ylabel('Y轴');
        zlabel('Z轴');

        % 添加网格和光照
        grid on;
        light;
        lighting gouraud;
        shading interp;
        ```

    * 重要区别

        daspect: 控制数据单位的显示比例

        pbaspect: 控制绘图框的形状比例

        axis equal: 使三个坐标轴的数据单位长度相等

    * 实际应用技巧

        ```matlab
        % 技巧1：恢复默认比例
        daspect('auto');
        pbaspect('auto');

        % 技巧2：保存和恢复设置
        original_daspect = daspect;
        original_pbaspect = pbaspect;
        % ... 进行修改 ...
        daspect(original_daspect);  % 恢复原始设置

        % 技巧3：结合subplot使用
        figure;
        subplot(1,2,1);
        surf(peaks);
        daspect([1 1 2]);  % 左图

        subplot(1,2,2);
        surf(peaks);
        daspect([1 1 0.5]);  % 右图，z轴压缩
        ```

    * 推荐使用流程：

        1. 先用 daspect 调整数据比例

        2. 再用 pbaspect 调整绘图框形状

        3. 最后用 view 调整最佳视角

        4. 使用 axis tight 确保图形充分利用空间

* matlab 画图时，由于鼠标可以和图片中的数据点交互，当数据量很大时，即使鼠标从图片上滑过也会很卡，如何禁用图片交互，减少卡顿？

    ```matlab
    % 禁用坐标轴交互
    ax = gca()
    disableDefaultInteractivity(ax);

    % 清空所有交互
    ax.Interactions = [];

    % 移除工具栏
    ax.Toolbar = [];

    % 只保留缩放和平移
    ax.Interactions = [zoomInteraction, panInteraction];
    ```

    旧版本 MATLAB 的解决方案

    ```matlab
    % 对于R2020b及更早版本
    fig = figure;
    ax = gca;

    % 方法1：禁用数据光标
    ax.Toolbar = [];  % 移除工具栏
    dcm_obj = datacursormode(fig);
    set(dcm_obj, 'Enable', 'off');  % 禁用数据光标

    % 方法2：关闭所有交互模式
    zoom off;    % 禁用缩放
    pan off;     % 禁用平移
    rotate3d off; % 禁用3D旋转
    datacursormode off; % 禁用数据光标

    % 方法3：设置图形属性
    set(fig, 'WindowButtonDownFcn', '');     % 清空鼠标点击回调
    set(fig, 'WindowButtonUpFcn', '');       % 清空鼠标释放回调
    set(fig, 'WindowButtonMotionFcn', '');   % 清空鼠标移动回调
    ```

    * 性能优化组合方案

        ```matlab
        function createNonInteractivePlot(x, y)
            % 创建非交互式图形以提高性能
            
            % 1. 创建图形并禁用交互
            fig = figure('Interactions', [], ...
                        'ToolBar', 'none', ...
                        'MenuBar', 'none', ...
                        'IntegerHandle', 'off');
            
            % 2. 创建坐标轴
            ax = axes('Parent', fig, ...
                    'Interactions', [], ...
                    'XTickMode', 'manual', ...
                    'YTickMode', 'manual', ...
                    'ZTickMode', 'manual');
            
            % 3. 绘制数据（使用性能优化选项）
            h = plot(x, y, '-', ...
                    'LineWidth', 1, ...
                    'Marker', 'none', ...      % 无标记点
                    'MarkerSize', 0.1);        % 最小化标记
            
            % 4. 进一步禁用交互
            disableDefaultInteractivity(ax);
            
            % 5. 设置渲染器
            set(fig, 'Renderer', 'opengl');     % 使用OpenGL渲染
            
            % 6. 关闭不必要的功能
            set(h, 'HitTest', 'off');           % 禁用图形对象点击检测
            set(h, 'PickableParts', 'none');    % 完全不可选取
            
            % 7. 对3D图形特别优化
            if ~isempty(findobj(ax, 'Type', 'surface'))
                axis(ax, 'vis3d');              % 保持3D视角不变
                set(ax, 'CameraViewAngleMode', 'manual');
            end
            
            % 8. 设置回调函数为空（防止意外交互）
            set(fig, 'WindowButtonMotionFcn', '');
            set(fig, 'WindowButtonDownFcn', '');
            set(fig, 'WindowButtonUpFcn', '');
        end
        ```

    6. 针对大数据量的特别优化

        ```matlab
        % 大数据量示例
        x = randn(1e6, 1);
        y = cumsum(x);

        % 方法1：使用快速绘制函数
        fig = figure('Interactions', []);
        scatter(x(1:100:end), y(1:100:end), 1);  % 降采样
        disableDefaultInteractivity(gca);

        % 方法2：设置对象属性
        fig = figure;
        ax = gca;
        h = plot(x, y);
        h.HitTest = 'off';            % 禁用点击测试
        h.PickableParts = 'none';     # 完全不可交互
        ax.PickableParts = 'none';    # 坐标轴也不可交互

        % 方法3：使用graphics.smoothline（R2023b+）
        % 对于曲线，使用平滑线对象
        ```

    7. 交互模式管理函数

        ```matlab
        % 快速切换函数
        function toggleInteractivity(state)
            % state: 'on' 或 'off'
            fig = gcf;
            ax = gca;
            
            if strcmpi(state, 'off')
                % 禁用交互
                zoom off;
                pan off;
                rotate3d off;
                datacursormode off;
                
                if verLessThan('matlab', '9.10')  % R2021a之前
                    set(fig, 'WindowButtonMotionFcn', '');
                else
                    disableDefaultInteractivity(fig);
                end
            else
                % 启用交互
                zoom on;
                pan on;
                rotate3d on;
            end
        end
        ```

    8. 最佳实践建议

        绘图前准备：

        ```matlab
        % 在绘制大数据前设置
        set(0, 'DefaultFigureInteractions', []);  % 设置默认不交互
        ```

        批量绘图时：

        ```matlab
        for i = 1:10
            fig = figure('Visible', 'off', 'Interactions', []);  % 先隐藏
            plot(bigData{i});
            % ... 其他设置
            disableDefaultInteractivity(gca);
            set(fig, 'Visible', 'on');  # 最后显示
        end
        ```

        临时禁用/启用：

        ```matlab
        % 需要交互时临时启用
        ax.Interactions = [zoomInteraction, panInteraction];

        % 完成后再次禁用
        ax.Interactions = [];
        ```

        最有效的单行解决方案：

        ```matlab
        disableDefaultInteractivity(gcf);  % R2021a+
        % 或
        set(gca, 'Interactions', []);      % R2021a+
        ```

        对于旧版本，使用：

        ```matlab
        zoom off; pan off; rotate3d off; datacursormode off;
        set(gcf, 'WindowButtonMotionFcn', '');
        ```

        这些方法可以显著提升大数据绘图时的响应速度。

* 假如 `a` 是一个 struct，`b = a.ages`，那么 `b` 是按值传递，还是按引用传递？

    在 MATLAB 中，`b = a.ages` 是值传递（Copy-on-Write 机制）

    详细解释：

    1. MATLAB 的基本传递规则

        ```matlab
        a = struct('ages', [25, 30, 35], 'names', {'Tom', 'Jerry', 'Spike'});
        b = a.ages;  % 此时创建了一个副本（但不是立即复制）
        ```

    2. Copy-on-Write（写时复制）机制

        ```matlab
        % 初始情况：b 和 a.ages 可能共享数据（内部优化）
        b = a.ages;  % 表面上复制，实际上可能只是引用（内部优化）

        % 但是一旦修改 b，就会触发真正的复制
        b(1) = 26;   % 此时 MATLAB 才会真正复制数据
        disp(a.ages(1));  % 输出: 25（a.ages 未被修改）
        ```

    3. 验证实验

        ```matlab
        % 测试1：基本赋值
        a = struct('ages', [25, 30, 35]);
        b = a.ages;
        disp('初始内存地址可能相同（内部优化）');

        % 测试2：修改验证
        b(1) = 100;  % 触发实际复制
        disp(['a.ages(1) = ', num2str(a.ages(1))]);  % 仍是 25
        disp(['b(1) = ', num2str(b(1))]);            % 变为 100

        % 测试3：使用内存函数验证（需要自定义函数）
        % memBefore = memory_usage();  % 伪代码，实际需要自己实现
        % b = a.ages;
        % b(1) = 26;  % 此时内存会增加
        % memAfter = memory_usage();
        ```

    4. 与引用传递的对比

        ```matlab
        % 对比：真正的引用传递（使用 handle 类）
        classdef Person < handle
            properties
                ages
            end
        end

        p = Person();
        p.ages = [25, 30, 35];
        b_ref = p.ages;  % 通过 handle，b_ref 是引用
        b_ref(1) = 26;
        disp(p.ages(1));  % 输出: 26（原数据被修改）
        ```

    5. 特殊情况：元胞数组和结构体数组

        ```matlab
        % 结构体数组的情况
        a(1).ages = 25;
        a(2).ages = 30;
        b = [a.ages];  % 这也会创建副本

        % 元胞数组
        a = struct('ages', {{25, 30, 35}});
        b = a.ages{1};  % 对元胞内容也是值传递
        b = 26;
        disp(a.ages{1});  % 仍是 25
        ```

    6. 性能考虑

        ```matlab
        % 大型数据时的优化策略
        a = struct('ages', randn(10000, 10000));  % 大型矩阵

        % 不好的做法：无意识复制
        b = a.ages;  % 表面上只是赋值
        % ...很多操作...
        % 如果不需要修改，这个复制是浪费的

        % 好的做法：明确是否需要修改
        if needToModify
            b = a.ages;  % 接受可能的复制开销
        else
            % 如果只是读取，可以考虑其他方式
            processData(a.ages);  % 直接使用原数据
        end
        ```

    7. 如何实现真正的引用传递

        ```matlab
        % 方法1：使用嵌套函数（共享工作区）
        function processLargeData()
            data = struct('ages', randn(1000));
            
            function innerFunc()
                % 可以直接访问和修改 data.ages
                data.ages(1) = 100;  % 修改的是原始数据
            end
            innerFunc();
        end

        % 方法2：使用 handle 类（面向对象）
        classdef DataHolder < handle
            properties
                ages
            end
        end

        holder = DataHolder();
        holder.ages = randn(1000);
        b = holder;  % b 是引用，不是副本
        b.ages(1) = 100;  % 修改的是原始数据
        ```

    8. 总结要点

        | 情况 | 传递方式 | 说明 |
        | - | - | - |
        | `b = a.ages` | 值传递（Copy-on-Write） | 默认行为，修改时复制 |
        | handle 类对象 | 引用传递 | 修改会影响原数据 |
        | 嵌套函数内访问 | 引用传递 | 共享父函数工作区 |
        | 大型数据操作 | 需谨慎 | 无意识复制可能导致内存问题 |

        核心结论：

        * MATLAB 中结构体字段的赋值是值传递

        * 但有 Copy-on-Write 优化：只在修改时才真正复制

        * 这既保证了安全性（默认不修改原数据），又在只读场景下有性能优化

        * 如果需要引用语义，需要使用 handle 类或嵌套函数

    9. 实际编程建议

        ```matlab
        % 如果确定不需要修改原数据
        function result = processData(inputStruct)
            % 直接使用，让MATLAB决定是否复制
            data = inputStruct.ages;  
            result = mean(data);  % 只读操作，可能不会复制
        end

        % 如果需要修改但不影响原数据
        function modified = modifyCopy(inputStruct)
            modified = inputStruct.ages;  % 可能复制（Copy-on-Write）
            modified(1) = newValue;       % 此时一定复制
        end

        % 如果需要修改原数据（引用传递）
        function modifyInPlace(dataHolder)  % dataHolder 是 handle 对象
            dataHolder.ages(1) = newValue;  % 直接修改原数据
        end
        ```

* vscode 插件

    Code Runner - 运行代码片段

    GitLens - 增强代码提示功能

    安装 Settings Cycler 或 Settings Watcher 扩展来管理设置变更

    扩展：Compareit 来比较文件

* vscode 中查看哪些配置被改过

    * 使用设置界面（推荐）

        打开设置：Ctrl+,（Windows/Linux）或 Cmd+,（Mac）

        在搜索框中输入 @modified

    * 使用命令面板

        按 Ctrl+Shift+P

        输入 Preferences: Open Settings (JSON)

    * 文件

        用户设置: %APPDATA%\Code\User\settings.json（Windows）或 ~/.config/Code/User/settings.json（Linux/Mac）

        工作区设置: .vscode/settings.json（项目根目录）
