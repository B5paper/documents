1. [v] cache tabs 15 mins

    10:05 ~ 10:13

2. [v] qa 4 个 30 mins

3. [v] vulkan: learn create synchronous objects 30 mins

    13:17 ~ 14:02

    feedback:

    1. cached task

        只剩下一个画图了

        current progress:

        ```cpp
        #include "../simple_vulkan/simple_vk.hpp"

        int main()
        {
            glfwInit();
            VkInstance inst;
            create_vk_instance(inst);
            glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
            GLFWwindow *window = glfwCreateWindow(700, 500, "hello", nullptr, nullptr);
            VkSurfaceKHR surf;
            glfwCreateWindowSurface(inst, window, nullptr, &surf);
            VkPhysicalDevice phy_dev;
            uint32_t queue_family_idx;
            select_vk_physical_device(phy_dev, queue_family_idx, queue_family_idx, inst, surf);
            VkDevice device;
            VkQueue queue;
            create_vk_device(device, queue, queue, phy_dev, queue_family_idx, queue_family_idx);
            VkSwapchainKHR swpch;
            create_vk_swapchain(swpch, device, surf, queue_family_idx);
            VkRenderPass render_pass = create_render_pass(VK_FORMAT_B8G8R8A8_SRGB, device);
            VkPipeline pipeline = create_pipeline("./vert_2.spv", "frag_2.spv", 0, {0, 0}, device, {700, 500}, render_pass);
            
            uint32_t swpch_img_count;
            vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, nullptr);
            std::vector<VkImage> swpch_imgs(swpch_img_count);
            vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, swpch_imgs.data());

            std::vector<VkImageView> swpch_img_views(swpch_img_count);
            VkImageViewCreateInfo img_view_crt_info{};
            img_view_crt_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
            img_view_crt_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
            img_view_crt_info.format = VK_FORMAT_B8G8R8A8_SRGB;
            img_view_crt_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};
            VkResult result;
            for (int i = 0; i < swpch_img_count; ++i)
            {
                img_view_crt_info.image = swpch_imgs[i];
                result = vkCreateImageView(device, &img_view_crt_info, nullptr, &swpch_img_views[i]);
                if (result != VK_SUCCESS)
                {
                    printf("fail to create image view, error code %d\n", result);
                    exit(-1);
                }
            }

            VkFramebufferCreateInfo frame_buf_crt_info{};
            frame_buf_crt_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
            frame_buf_crt_info.renderPass = render_pass;
            frame_buf_crt_info.attachmentCount = 1;
            frame_buf_crt_info.width = 700;
            frame_buf_crt_info.height = 500;
            frame_buf_crt_info.layers = 1;
            std::vector<VkFramebuffer> frame_bufs(swpch_img_count);
            for (int i = 0; i < swpch_img_count; ++i)
            {
                frame_buf_crt_info.pAttachments = &swpch_img_views[i];
                result = vkCreateFramebuffer(device, &frame_buf_crt_info, nullptr, &frame_bufs[i]);
                if (result != VK_SUCCESS)
                {
                    printf("fail to create frame buffer, error code: %d\n", result);
                    exit(-1);
                }
            }

            VkCommandPool cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
            cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
            VkCommandBuffer cmd_buf;
            VkCommandBufferAllocateInfo cmd_buf_alc_info{};
            cmd_buf_alc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
            cmd_buf_alc_info.commandBufferCount = 1;
            cmd_buf_alc_info.commandPool = cmd_pool;
            cmd_buf_alc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
            result = vkAllocateCommandBuffers(device, &cmd_buf_alc_info, &cmd_buf);
            if (result != VK_SUCCESS)
            {
                printf("fail to allocate command buffer\n");
                exit(-1);
            }

            float vtxs[9] = {
                -0.5, 0, 0,
                0, 0.5, 0,
                0.5, 0, 0
            };
            VkBuffer vtx_buf;
            VkDeviceMemory vtx_buf_mem;
            create_vk_buffer(vtx_buf, vtx_buf_mem, phy_dev, device, 3 * 3 * sizeof(float), VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
            float *p_mem_data = nullptr;
            result = vkMapMemory(device, vtx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
            memcpy(p_mem_data, vtxs, sizeof(vtxs));
            vkUnmapMemory(device, vtx_buf_mem);

            uint32_t idxs[3] = {0, 1, 2};
            VkBuffer idx_buf;
            VkDeviceMemory idx_buf_mem;
            create_vk_buffer(idx_buf, idx_buf_mem, phy_dev, device, sizeof(idxs), VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
            vkMapMemory(device, idx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
            memcpy(p_mem_data, idxs, sizeof(idxs));
            vkUnmapMemory(device, idx_buf_mem);
            
            VkCommandBufferBeginInfo cmd_buf_beg_info{};
            cmd_buf_beg_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
            cmd_buf_beg_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
            vkBeginCommandBuffer(cmd_buf, &cmd_buf_beg_info);
            VkDeviceSize offset = 0;
            vkCmdBindVertexBuffers(cmd_buf, 0, 1, &vtx_buf, &offset);
            vkCmdBindIndexBuffer(cmd_buf, idx_buf, 0, VK_INDEX_TYPE_UINT32);
            vkEndCommandBuffer(cmd_buf);

            VkSemaphore sem_finish_rendering = create_semaphore(device);
            VkSemaphore sem_img_available = create_semaphore(device);
            VkFence fence_acq_img = create_fence(device);
            VkFence fence_queue_submit = create_fence(device);

            vkResetFences(device, 1, &fence_acq_img);
            uint32_t available_img_idx;
            vkAcquireNextImageKHR(device, swpch, UINT64_MAX, sem_img_available, fence_acq_img, &available_img_idx);

            vkResetFences(device, 1, &fence_queue_submit);
            VkSubmitInfo submit_info{};
            submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
            submit_info.signalSemaphoreCount = 1;
            submit_info.pSignalSemaphores = &sem_finish_rendering;
            submit_info.waitSemaphoreCount = 1;
            submit_info.waitSemaphoreCount = 0;
            submit_info.pWaitSemaphores = &sem_img_available;
            submit_info.commandBufferCount = 1;
            submit_info.pCommandBuffers = &cmd_buf;
            VkPipelineStageFlags pipeline_stage_flags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
            submit_info.pWaitDstStageMask = &pipeline_stage_flags;
            vkQueueSubmit(queue, 1, &submit_info, fence_queue_submit);
            return 0;
        }
        ```

4. [v] vulkan qa, idx 12 is not completed. 30 mins

    fix it with dependencies and `GLFW_NO_API`.

    14:53 ~ 15:08

    feedback:

    1. 思考 qa 的 dependency 机制

5. [v] opencl 从 p133 开始调研

    15:13 ~ 16:11

    feedbacK:

    1. 如果一个 kernel 函数没有参数，那么调用 ocl simple 库就会出错

        有空了看一下这个 bug

6. [ ] compiler: 看正则表达式的缩写，图 2-2

7. [ ] 写一道图论题