* openshmem example: broadcast 2

    `main.c`:

    ```c
    #include <stdio.h>
    #include <shmem.h>

    long pSync[SHMEM_BCAST_SYNC_SIZE];

    int main(void)
    {
        static long source[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
        int nlong = 8;

        shmem_init();
        int me = shmem_my_pe();
        int npes = shmem_n_pes();

        long *target = (long *) shmem_malloc(8 * sizeof(long));

        for (int i = 0; i < SHMEM_BCAST_SYNC_SIZE; i += 1)
            pSync[i] = SHMEM_SYNC_VALUE;
        shmem_barrier_all();

        shmem_broadcast64(target, source, nlong, 0, 0, 0, npes, pSync);

        for (int i = 0; i < 8; i++) {
            printf("%d: target[%d] = %ld\n", me, i, target[i]);
        }

        shmem_free(target);
        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 4 ./main`

    output:

    ```
    0: target[0] = 0
    1: target[0] = 1
    1: target[1] = 2
    1: target[2] = 3
    1: target[3] = 4
    1: target[4] = 5
    1: target[5] = 6
    1: target[6] = 7
    1: target[7] = 8
    3: target[0] = 1
    3: target[1] = 2
    3: target[2] = 3
    3: target[3] = 4
    3: target[4] = 5
    3: target[5] = 6
    3: target[6] = 7
    3: target[7] = 8
    2: target[0] = 1
    2: target[1] = 2
    2: target[2] = 3
    2: target[3] = 4
    2: target[4] = 5
    2: target[5] = 6
    2: target[6] = 7
    2: target[7] = 8
    0: target[1] = 0
    0: target[2] = 0
    0: target[3] = 0
    0: target[4] = 0
    0: target[5] = 0
    0: target[6] = 0
    0: target[7] = 0
    ```

    可以看到，pe 0 的数据仍是 0，其他 pe 的数据都被 source 的数据做了广播。由此说明 broadcast 只是从 root 出发，并不会把数据发给 root。

    注：

    1. `SHMEM_BCAST_SYNC_SIZE`在程序中被扩展为 2，为什么？

    2. 理论上各个 pe 执行的顺序应该完全乱序才对，为什么看起来 output 比较有序？

* openshmem example: broadcast 3

    `main.c`:

    ```c
    #include <stdio.h>
    #include <shmem.h>

    long pSync[SHMEM_BCAST_SYNC_SIZE];

    int main(void)
    {
        static long source[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
        int nlong = 8;

        shmem_init();
        int me = shmem_my_pe();

        long *target = (long *) shmem_malloc(8 * sizeof(long));

        for (int i = 0; i < SHMEM_BCAST_SYNC_SIZE; i += 1)
            pSync[i] = SHMEM_SYNC_VALUE;
        shmem_barrier_all();

        shmem_broadcast64(target, source, nlong, 1, 0, 0, 4, pSync);

        for (int i = 0; i < 8; i++)
            printf("%d: target[%d] = %ld\n", me, i, target[i]);
        shmem_barrier_all();

        shmem_free(target);
        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 6 ./main`

    output:

    ```
    1: target[0] = 0
    0: target[0] = 1
    0: target[1] = 2
    0: target[2] = 3
    0: target[3] = 4
    0: target[4] = 5
    0: target[5] = 6
    0: target[6] = 7
    0: target[7] = 8
    2: target[0] = 1
    2: target[1] = 2
    2: target[2] = 3
    2: target[3] = 4
    2: target[4] = 5
    2: target[5] = 6
    2: target[6] = 7
    2: target[7] = 8
    5: target[0] = 0
    5: target[1] = 0
    5: target[2] = 0
    5: target[3] = 0
    5: target[4] = 0
    5: target[5] = 0
    5: target[6] = 0
    5: target[7] = 0
    4: target[0] = 0
    4: target[1] = 0
    4: target[2] = 0
    4: target[3] = 0
    4: target[4] = 0
    4: target[5] = 0
    4: target[6] = 0
    4: target[7] = 0
    3: target[0] = 1
    3: target[1] = 2
    3: target[2] = 3
    3: target[3] = 4
    3: target[4] = 5
    3: target[5] = 6
    3: target[6] = 7
    3: target[7] = 8
    1: target[1] = 0
    1: target[2] = 0
    1: target[3] = 0
    1: target[4] = 0
    1: target[5] = 0
    1: target[6] = 0
    1: target[7] = 0
    ```

    这个测试用例改了 root pe，也指定了 pe size，看起来像是专门测这两项功能的。

    在 run 的时候指定`-np 6`，稍微比代码中的 pe size 4 大一点，可以看到，pe 1, 4, 5 的数据都是 0。说明 broadcast 的规则是这样的：从 start pe 开始，往后数 pe size 个 pe 做 broadcast，同时排除 root pe。

* openshmem example: broadcast 4

    `main.c`:

    ```c
    #include <stdio.h>
    #include <shmem.h>

    long pSync[SHMEM_BCAST_SYNC_SIZE];

    int main()
    {
        static long source[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
        int nlong = 8;

        shmem_init();
        int me = shmem_my_pe();

        long *target = (long *) shmem_malloc(8 * sizeof(long));

        for (int i = 0; i < SHMEM_BCAST_SYNC_SIZE; i += 1)
            pSync[i] = SHMEM_SYNC_VALUE;
        shmem_barrier_all();

        shmem_broadcast64(target, source, nlong, 0, 0, 1, 2, pSync);

        shmem_barrier_all();

        for (int i = 0; i < 8; i++) {
            printf("%d: target[%d] = %ld\n", me, i, target[i]);
        }

        shmem_free(target);
        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 4 ./main`

    output:

    ```
    1: target[0] = 0
    3: target[0] = 0
    3: target[1] = 0
    3: target[2] = 0
    3: target[3] = 0
    3: target[4] = 0
    3: target[5] = 0
    3: target[6] = 0
    3: target[7] = 0
    0: target[0] = 0
    0: target[1] = 0
    0: target[2] = 0
    0: target[3] = 0
    0: target[4] = 0
    0: target[5] = 0
    0: target[6] = 0
    0: target[7] = 0
    1: target[1] = 0
    1: target[2] = 0
    1: target[3] = 0
    1: target[4] = 0
    1: target[5] = 0
    1: target[6] = 0
    1: target[7] = 0
    2: target[0] = 1
    2: target[1] = 2
    2: target[2] = 3
    2: target[3] = 4
    2: target[4] = 5
    2: target[5] = 6
    2: target[6] = 7
    2: target[7] = 8
    ```

    start pe 为 0，stride 设置为 1，pe size 设置为 2，那么就是从 0 开始，每间隔 1 个 pe 选 1 个，最终选到的结果为 pe 0, 2。又因为 0 是 root pe，所以最终只有 pe 2 接收到广播的数据。

    注：

    1. 原代码中写的是

        ```c
        if ((me % 2) == 0) {
            shmem_broadcast64(target, source, nlong, 0, 0, 1, 2, pSync);
        }
        ```

        不知道这个`me % 2 == 0`是想实现什么效果。

* openshmem example: cache

    `main.c`:

    ```c
    #include <stdio.h>
    #include <shmem.h>

    long var;

    int main()
    {
        shmem_init();
        
        shmem_clear_cache_inv();
        shmem_set_cache_inv();
        shmem_clear_cache_line_inv(&var);
        shmem_set_cache_line_inv(&var);
        shmem_udcflush();
        shmem_udcflush_line(&var);

        shmem_clear_cache_inv();
        shmem_set_cache_inv();
        shmem_clear_cache_line_inv(&var);
        shmem_set_cache_line_inv(&var);
        shmem_udcflush();
        shmem_udcflush_line(&var);

        shmem_finalize();
        return 0;
    }
    ```

    调用了两遍 cache 相关的函数，没有输出，不清楚有什么用。

* openshmem example: collect

    ```c
    #include <stdio.h>
    #include <shmem.h>

    #define ARR_SIZE 12

    long pSync[SHMEM_BCAST_SYNC_SIZE];
    int pe_arr[3];
    int arr[ARR_SIZE];

    int main()
    {
        shmem_init();
        int npes = shmem_n_pes();
        int me = shmem_my_pe();

        for (int i = 0; i < ARR_SIZE; ++i)
            arr[i] = -1;

        for (int i = 0; i < 3; ++i)
            pe_arr[i] = me * 3 + i;
            
        for (int i = 0; i < SHMEM_BCAST_SYNC_SIZE; i += 1)
            pSync[i] = SHMEM_SYNC_VALUE;
        shmem_barrier_all();

        for (int i = 0; i < npes; ++i)
        {
            if (me == i)
            {
                printf("before collect, pe %d: ", me);
                for (int j = 0; j < 12; ++j)
                    printf("%d, ", arr[j]);
                putchar('\n');
            }
        }
        shmem_barrier_all();

        shmem_collect32(arr, pe_arr, 3, 0, 0, 4, pSync);

        for (int i = 0; i < npes; ++i)
        {
            if (me == i)
            {
                printf("after collect, pe %d: ", me);
                for (int j = 0; j < 12; ++j)
                    printf("%d, ", arr[j]);
                putchar('\n');
            }
        }

        shmem_finalize();
        return 0;
    }
    ```

    compile: `oshcc -g main.c -o main`

    run: `oshrun -np 4 ./main`

    output:

    ```
    before collect, pe 0: -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
    before collect, pe 3: -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
    after collect, pe 3: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 
    after collect, pe 0: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 
    before collect, pe 1: -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
    after collect, pe 1: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 
    before collect, pe 2: -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
    after collect, pe 2: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 
    ```

    这个程序申请了个总数组`arr`，一共放 12 个数据。然后每个 pe 都申请了一个小数组`pe_arr`，放 3 个数据。这个程序一共起 4 个 pe，目标是用 collect 函数把每个 pe 的 3 个数据收集到`arr`中。

    注意在`collect32()`中，使用的`pSync`仍是`SHMEM_BCAST_SYNC_SIZE`。

* openshmem example: collect 64

    `main.c`:

    ```c
    #include <stdio.h>
    #include <string.h>
    #include <shmem.h>

    static long pSync[SHMEM_COLLECT_SYNC_SIZE];
    static long src[4] = { 11, 12, 13, 14 };
    #define DST_SIZE 20
    static long dst[DST_SIZE];

    int npes;
    int me;

    static void show_dst(char *tag)
    {
        int i;
        printf("%8s: dst[%d/%d] =", tag, me, npes);
        for (i = 0; i < DST_SIZE; i += 1) {
            printf(" %ld", dst[i]);
        }
        printf("\n");
    }

    int main()
    {
        shmem_init();
        npes = shmem_n_pes();
        me = shmem_my_pe();

        for (int i = 0; i < DST_SIZE; i++)
            dst[i] = -1;

        for (int i = 0; i < SHMEM_COLLECT_SYNC_SIZE; i += 1)
            pSync[i] = SHMEM_SYNC_VALUE;

        shmem_barrier_all();
        shmem_collect64(dst, src, me + 1, 0, 0, npes, pSync);
        shmem_barrier_all();
        show_dst("AFTER");
        shmem_finalize();
        return 0;
    }
    ```

    output:

    ```
    AFTER: dst[2/4] = 11 11 12 11 12 13 11 12 13 14 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
    AFTER: dst[1/4] = 11 11 12 11 12 13 11 12 13 14 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
    AFTER: dst[3/4] = 11 11 12 11 12 13 11 12 13 14 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
    AFTER: dst[0/4] = 11 11 12 11 12 13 11 12 13 14 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
    ```

    collect 的 64 位版本原版，其他没什么可说的，唯一需要注意的地方是这里使用的是`SHMEM_COLLECT_SYNC_SIZE`，在程序里被展开为`3`。

* shmem 中的 broadcast 与 collect 等函数，是每个 pe 各自执行一次，还是许多个 pe 共同执行一次？

    目前看来是多个 pe 共同执行一次，因为如果执行下面的代码，程序会卡住：

    ```c
    if (me != 3)
        shmem_collect32(arr, pe_arr, 3, 0, 0, 4, pSync);
    ```