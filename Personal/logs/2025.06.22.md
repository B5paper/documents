* ls 按时间排序

    `ls -lt`可以按文件修改时间排序，新文件在上面，旧文件在下面。如果需要倒序，那么可以使用`ls -ltr`。

    `ls -t`也是按修改时间排序，只不过不显示详细信息。读的时候先读从左往右数第一列，再读第二列。

* 使用`fprintf()`向 stderr 输出内容

    ```cpp
    #include <stdio.h>

    int main(int argc, const char **argv) {
        fprintf(stderr, "hello, world\n");
        return 0;
    }
    ```

    output:

    ```
    hello, world
    ```

    如何证明这是 stderr 的内容，而不是 stdout 的内容？我们已知`tee`命令可以把 stdout 的内容输出到文件里，而 stderr 的内容则不会写入到文件里，而是仅输出到 terminal。

    执行`./main | tee out.txt`，`cat out.txt`，文件内容为空。

    而执行`./main 2>& 1 | tee out.txt`，`cat out.txt`，可以看到文件内容：`hello, world`。

    说明`fprintf(stderr, ...)`确实把输出写到了 stderr 中，而不是 stdout。

* 根据 cache 动态地创建出 project，似乎效果挺好的，比直接生成静态的平衡池效果要好。

* c++ stl 容器中的 erase

    如果是顺序容器，比如 vector，那么`erase()`只支持传入 iterator 进行删除。比如要删第 1 个元素，那么就调用`vec.erase(vec.begin());`，如果要删除第 3 个元素，那么就调用`vec.erase(vec.begin() + 2)`。
    
    vector 的`erase()`无法通过传入元素引用的方式进行删除，比如`vec.erase(vec.back());`会编译报错。

    如果是关联容器，比如`unordered_map`, `set`等，那么`erase()`既支持传入 iterator，也支持传入 key 的 const 左值引用：

    ```cpp
    #include <stdio.h>
    #include <vector>
    #include <string>
    #include <iostream>
    #include <unordered_map>
    #include <map>
    using namespace std;

    template<typename T>
    void print(T &container) {
        for (auto iter = container.begin(); iter != container.end(); ++iter) {
            cout << *iter << ", ";
        }
        cout << endl;
    }

    ostream& operator<<(ostream &out, const pair<string, int> &p) {
        printf("(%s, %d)", p.first.c_str(), p.second);
        return out;
    }

    int main(int argc, const char **argv) {
        unordered_map<string, int> vec {
            {"hello", 1},
            {"world", 2},
            {"nihao", 3},
            {"zaijian", 4}
        };
        vec.erase("hello");
        print(vec);

        multimap<string, int> m {
            {"hello", 1},
            {"world", 2},
            {"hello", 3},
        };
        m.erase("hello");
        print(m);
        
        return 0;
    }
    ```

    output:

    ```
    (zaijian, 4), (nihao, 3), (world, 2), 
    (world, 2), 
    ```

    但是关联容器没有`.back()`方法，因此调用`m.erase(m.back())`无从谈起。

    如果是多 key 值容器，那么所有与传入参数相等的 key 都会被删除。