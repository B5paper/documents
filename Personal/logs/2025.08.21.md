* 我们的目标究竟是在认知限制下的梦想的满足，还是超越限制，追求绝对理性的目标？

    在时代赋予的认识限制下，我们可以认为自己做到了认知的最高点就达到了幸福，比如结婚生子，老有所养，家庭和睦；比如登陆火星，建造飞船，探索太空。大部分人也都这样幸福着。但是还有些人追求理性的边界，追求从虚无到有的过程，追求对认知的重新定义，求而不得往往十分痛苦。所以似乎认知越少，越幸福？

    如果我们追求的就是幸福，那为什么不刻意减少自己的认知呢？

* `msync()`

    （未验证）

    将内存中的内容写回到文件。

    操作系统会不定期将`mmap()`内存中的内容写回到文件，但是如果我们对进程间同步的要求较高，那么就需要手动`msync()`。

    syntax:

    ```c
    #include <sys/mman.h>

    int msync(void *addr, size_t length, int flags);
    ```

    其中`flags`可取值如下：

    * `MS_SYNC`：回写完成后函数返回。

    * `MS_ASYNC`：发出回写命令，函数立即返回。

    * `MS_INVALIDATE`：通知其他进程的映射副本失效，使其他进程重新读取文件内容。

    如果是匿名映射，那么`msync()`无意义。

    进程 A 和 B 同时以 shared 模式 mmap 一个文件，进程 A 修改文件，进程 B 并不会定期重新读取文件，除非遇到`MS_INVALIDATE`的`msync()`。

* `pci_request_region()`

    （未验证）

    I/O 端口地址和内存地址都是操作系统的资源，当检测到 pci 设备时，pci 设备需要向操作系统申请这些资源，并映射到 pci 设备上，才能正常工作。

    这个申请资源的动作，即`pci_request_region()`。

    syntax:

    ```c
    int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name);
    ```

    * `res_name`： 一个字符串标识符，通常为驱动名，用于在资源树中标识该资源的所有者（在 /proc/ioports 或 /proc/iomem 中可以看到）。

    其逆操作函数为`pci_release_region()`。

    example:

    ```c
    static int my_driver_probe(struct pci_dev *pdev, const struct pci_device_id *id)
    {
        int ret;
        ...
        // 首先启用设备
        ret = pci_enable_device(pdev);
        if (ret) {
            dev_err(&pdev->dev, "Enable device failed\n");
            return ret;
        }

        // 然后请求设备的某个区域（例如 BAR 0）
        ret = pci_request_region(pdev, 0, "my_nic_driver");
        if (ret) {
            dev_err(&pdev->dev, "Request region for BAR0 failed\n");
            pci_disable_device(pdev); // 失败则禁用设备
            return ret;
        }

        // 请求成功，现在可以安全地映射和使用这个区域了
        my_priv->ioaddr = pci_iomap(pdev, 0, 0);
        ...
    }

    static void my_driver_remove(struct pci_dev *pdev)
    {
        ...
        // 在移除时，按相反顺序释放资源
        pci_iounmap(pdev, my_priv->ioaddr); // 取消映射
        pci_release_region(pdev, 0);        // 释放区域
        pci_disable_device(pdev);           // 禁用设备
    }
    ```

* `static int __init edu_init(void)`中的`__init`

    （未验证）

    作用是标记此函数只执行一次，后续可以将此函数占用的资源释放。

    编译器会把`__init`函数的代码段放到`.init.text`中，把`__initdata`的变量放到`.init.data`中。当函数执行完成后，操作系统会调用`free_initmem()`，释放这两个 init 段中的内存，释放出空间。

    `__exit`标记的函数，如果 module 被静态编译进了内核，那么类似`edu_exit(void)`的函数将永不会被调用，这些函数会被直接丢弃。