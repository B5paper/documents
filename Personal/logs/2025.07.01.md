* find 不输出没有权限的文件

    find 对没有权限的文件会输出类似

    ```
    ...
    find: ‘/proc/1188309/task/1188309/ns’: Permission denied
    find: ‘/proc/1188309/fd’: Permission denied
    find: ‘/proc/1188309/map_files’: Permission denied
    find: ‘/proc/1188309/fdinfo’: Permission denied
    find: ‘/proc/1188309/ns’: Permission denied
    ...
    ```

    的信息。这些信息其实都是 stderr。因此可以考虑过滤掉 stderr 的输出：

    `find <path> -name <pattern> 2>/dev/null`

    example:

    `find / -name hello 2>/dev/null`

    output:

    ```
    /home/hlc/miniconda3/pkgs/tk-8.6.14-h39e8969_0/lib/tk8.6/demos/hello
    /home/hlc/miniconda3/lib/tk8.6/demos/hello
    /home/hlc/miniconda3/envs/torch/lib/tk8.6/demos/hello
    /home/hlc/miniconda3/envs/vllm/lib/tk8.6/demos/hello
    /home/hlc/Documents/Projects/boost_1_87_0/tools/build/example/qt/qt4/hello
    /home/hlc/Documents/Projects/boost_1_87_0/tools/build/example/qt/qt3/hello
    /home/hlc/Documents/Projects/boost_1_87_0/tools/build/example/hello
    /home/hlc/Documents/Projects/chisel-tutorial/src/main/scala/hello
    /home/hlc/Documents/Projects/makefile_test/hello
    ```

* c++ 中的结构体初始化

    ```cpp
    #include <stdio.h>
    #include <vector>
    #include <string>
    #include <iostream>
    using namespace std;

    struct AAA {
        string msg;
        int val;
    };

    struct MyObj {
        vector<int> ints;
        vector<string> strs;
        AAA a;
    };

    int main()
    {
        MyObj obj {
            {1, 2, 3},
            {"hello", "world"},
            "nihao", 456  // {"nihao", 456}
        };
        for (int val : obj.ints) {
            printf("%d, ", val);
        }
        putchar('\n');
        for (string &str : obj.strs) {
            printf("%s, ", str.c_str());
        }
        putchar('\n');
        printf("a: %s\n", obj.a.msg.c_str());
        printf("val: %d\n", obj.a.val);
        return 0;
    }
    ```

    output:

    ```
    1, 2, 3, 
    hello, world, 
    a: nihao
    val: 456
    ```

    在没有自定义构造函数的情况下，仅需使用内嵌的大括号消除歧义，使可直接用大括号来初始化一个对象。内部的大括号也并不是必须的，`"nihao", 456`的写法和`{"nihao", 456}`的写法都是正确的。

    目前并不清楚其原理。

* 由于`initializer_list`必须要指定模板类型，所以多个`initializer_list`是非常有必须的。

    ```cpp
    #include <stdio.h>
    #include <vector>
    #include <string>
    #include <iostream>
    using namespace std;


    struct MyObj {
        vector<int> ints;
        vector<string> strs;
        MyObj(initializer_list<int> &&init_list_1,
            initializer_list<string> &&init_list_2) {
            for (int val : init_list_1) {
                ints.push_back(val);
            }
            for (const string &str : init_list_2) {
                strs.push_back(str);
            }
        }
    };

    int main()
    {
        MyObj obj {
            {1, 2, 3},
            {"hello", "world"},
        };
        for (int val : obj.ints) {
            printf("%d, ", val);
        }
        putchar('\n');
        for (string &str : obj.strs) {
            printf("%s, ", str.c_str());
        }
        putchar('\n');
        return 0;
    }
    ```

    output:

    ```
    1, 2, 3, 
    hello, world, 
    a: nihao
    val: 456
    ```

* `emplace()`和`emplace_back()`

    `emplace()`有点像`insert()`，需要指定要插入元素的位置的迭代器。`emplace_back()`则是在容器的末尾添加。

    ```cpp
    #include <stdio.h>
    #include <vector>
    #include <string>
    using namespace std;

    struct MyObj {
        string msg;
        int val;
        MyObj(const string& m, int v) : msg(m), val(v) {}
    };

    int main() {
        vector<MyObj> objs;
        objs.emplace_back("hello", 123);
        objs.emplace_back("world", 456);
        objs.emplace(objs.begin() + 1, "nihao", 789);
        for (int i = 0; i < objs.size(); ++i) {
            printf("msg: %s, val: %d\n", objs[i].msg.c_str(), objs[i].val);
        }
        return 0;
    }
    ```

    output:

    ```
    msg: hello, val: 123
    msg: nihao, val: 789
    msg: world, val: 456
    ```

    `emplace()`在构造元素时，需要调用构造函数，无法使用 c++ 的聚合构造功能。

* 由于一天结束前可以会陆续地添加任务，所以 task 文件必须由第二天起处理。
