* leetcode problem

    * 颜色交替的最短路径

        给定一个整数 n，即有向图中的节点数，其中节点标记为 0 到 n - 1。图中的每条边为红色或者蓝色，并且可能存在自环或平行边。

        给定两个数组 redEdges 和 blueEdges，其中：

            redEdges[i] = [ai, bi] 表示图中存在一条从节点 ai 到节点 bi 的红色有向边，
            blueEdges[j] = [uj, vj] 表示图中存在一条从节点 uj 到节点 vj 的蓝色有向边。

        返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 answer[x] = -1。

        

        示例 1：

        输入：n = 3, red_edges = [[0,1],[1,2]], blue_edges = []
        输出：[0,1,-1]

        示例 2：

        输入：n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]
        输出：[0,1,-1]

        

        提示：

            1 <= n <= 100
            0 <= redEdges.length, blueEdges.length <= 400
            redEdges[i].length == blueEdges[j].length == 2
            0 <= ai, bi, uj, vj < n


        解答：

        * 自己写的（时间击败 99%）

            ```cpp
            class Solution {
            public:
                vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
                    vector<vector<int>> red_edges(n), blue_edges(n);
                    for (int i = 0; i < redEdges.size(); ++i)
                        red_edges[redEdges[i][0]].push_back(redEdges[i][1]);
                    for (int i = 0; i < blueEdges.size(); ++i)
                        blue_edges[blueEdges[i][0]].push_back(blueEdges[i][1]);

                    vector<bool> red_visited(n, false), blue_visited(n, false);
                    vector<int> ans(n, -1);
                    int edge_count = 0;
                    bool red_flag = true;

                    vector<int> cur_nodes;
                    cur_nodes = {0};
                    vector<int> next_nodes;
                    int idx;
                    while (!cur_nodes.empty())
                    {
                        for (int j = 0; j < cur_nodes.size(); ++j)
                        {
                            idx = cur_nodes[j];
                            if (red_flag && red_visited[idx] ||
                                !red_flag && blue_visited[idx])
                                continue;
                            ans[idx] = ans[idx] == -1 ? edge_count : min(ans[idx], edge_count);
                            if (red_flag)
                                red_visited[idx] = true;
                            else
                                blue_visited[idx] = true;
                            if (red_flag)
                                next_nodes.insert(next_nodes.end(), red_edges[idx].begin(), red_edges[idx].end());
                            else
                                next_nodes.insert(next_nodes.end(),
                                    blue_edges[idx].begin(), blue_edges[idx].end());
                        }
                        ++edge_count;
                        cur_nodes = next_nodes;
                        next_nodes.clear();
                        red_flag = !red_flag;
                    }

                    cur_nodes = {0};
                    edge_count = 0;
                    red_flag = false;
                    red_visited.assign(n, false);
                    blue_visited.assign(n, false);
                    while (!cur_nodes.empty())
                    {
                        for (int j = 0; j < cur_nodes.size(); ++j)
                        {
                            idx = cur_nodes[j];
                            if (red_flag && red_visited[idx] ||
                                !red_flag && blue_visited[idx])
                                continue;
                            ans[idx] = ans[idx] == -1 ? edge_count : min(ans[idx], edge_count);
                            if (red_flag)
                                red_visited[idx] = true;
                            else
                                blue_visited[idx] = false;
                            if (red_flag)
                                next_nodes.insert(next_nodes.end(),
                                    red_edges[idx].begin(), red_edges[idx].end());
                            else
                                next_nodes.insert(next_nodes.end(),
                                    blue_edges[idx].begin(), blue_edges[idx].end());
                        }
                        ++edge_count;
                        cur_nodes = next_nodes;
                        next_nodes.clear();
                        red_flag = !red_flag;
                    }
                        
                    return ans;
                }
            };
            ```

            首先题目给的边的数据是一条一条的，不方便快速按索引查找，所以改了改形式，给定 node 的索引，可以直接查到它和哪些其他 node 相连。

            整个代码一个朴素的想法是，使用一个 flag 来保存状态，当前要找的边是红边还是蓝边。由于是从 0 节点出发，所以出发边要么是红，要么是蓝，最多遍历两次就可以了。

            如果从某个节点集合搜索不到下一个节点集合，那么就退出循环。

            由于下一个节点集合没有先后顺序，所以 vector 可以存储， queue 也可以。这里选择了 vector。

            题目允许有环，也允许自指，但是我们不可能无限搜索下去，所以我们允许一红一蓝交替地成环，但是不搜索重复的节点。

            还有一个细节，`ans[idx] = ans[idx] == -1 ? edge_count : min(ans[idx], edge_count);`，按道理`ans`数组初始应该赋值 max int32 value，然后只需要每次取 min 值就可以了。但是题目要求使用 -1 代表无法到达，我们将 ans 数组的初值设置为 -1，并在更新答案时加了个判断。

            这道题整个思路仍是 bfs，但是加了一些条件，这么写有点繁琐，肯定有更好的方案。

        * 官方题解（没看）

            ```cpp
            class Solution {
            public:
                vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
                    vector<vector<vector<int>>> next(2, vector<vector<int>>(n));
                    for (auto &e : redEdges) {
                        next[0][e[0]].push_back(e[1]);
                    }
                    for (auto &e : blueEdges) {
                        next[1][e[0]].push_back(e[1]);
                    }

                    vector<vector<int>> dist(2, vector<int>(n, INT_MAX)); // 两种类型的颜色最短路径的长度
                    queue<pair<int, int>> q;
                    dist[0][0] = 0;
                    dist[1][0] = 0;
                    q.push({0, 0});
                    q.push({0, 1});
                    while (!q.empty()) {
                        auto [x, t] = q.front();
                        q.pop();
                        for (auto y : next[1 - t][x]) {
                            if (dist[1 - t][y] != INT_MAX) {
                                continue;
                            }
                            dist[1 - t][y] = dist[t][x] + 1;
                            q.push({y, 1 - t});
                        }
                    }
                    vector<int> answer(n);
                    for (int i = 0; i < n; i++) {
                        answer[i] = min(dist[0][i], dist[1][i]);
                        if (answer[i] == INT_MAX) {
                            answer[i] = -1;
                        }
                    }
                    return answer;
                }
            };
            ```

* 所谓调研就是在尽量不做实验的情况下，看看能理解多少东西，不理解的东西就记下来

* vulkan: `VkVertexInputBindingDescription`中的`stride`指的是给每个流处理器分的数据的长度

    比如，对于位置坐标，float, `(x, y, z)`三个分量，`stride`就是`sizeof(float) * 3 = 4 * 3 = 12`。

    `inputRate`似乎涉及到 vertex 还是 instance 的数据索引，因为没使用过 instance，所以不清楚这个是怎么回事。

    目前只需要填`VK_VERTEX_INPUT_RATE_VERTEX`就可以了。

    * `VkVertexInputAttributeDescription`似乎是指，比如 vertex buffer，给每个流处理器分 5 个 float 数，前 2 个 float 数表示 x, y 坐标，后 3 个 float 数表示 r, g, b 颜色。那么就认为这个 input vertex buffer 有两个 attribute，分别为 xy 坐标和 rgb 颜色。

        我们使用 offset 来指定偏移，从而获得不同的 attribute。

        每个 attrib 对应一个 location，location 从 0 开始依次递增。这些 location 都同属于一个 binding。

* 不清楚为什么要在 pipeline 里填写 scissor 和 viewport 的信息

    vkCmd 的 scissor 和 viewport 和 pipeline 中的是一样的吗？

* 实际上 vertex input buffer 并不是只能传递 vertex 数据

    因为 shader pipeline 是串行执行的，要想给 fragment shader 数据，必须先把数据给 vertex shader

    因此 vertex shader 的 input 实际上是所有的输入数据。

* `vkCmdDraw()`的参数`vertexCount`指的是有几个顶点。

    比如画一个三角形有 3 个顶点，那么就把它设置为 3。

* vulkan 的坐标系

    窗口中间为`(0, 0)`，向右为`x`轴正方向，向下为`y`轴正方向，`x`的范围为`[-1, 1]`，`y`的范围也为`[-1, 1]`。

    这点与 opengl 不一样。

* vulkan 画三角形的代码

    ```cpp
    #include "../simple_vulkan/simple_vk.hpp"

    int main()
    {
        glfwInit();
        VkInstance inst;
        create_vk_instance(inst);
        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        GLFWwindow *window = glfwCreateWindow(700, 500, "hello", nullptr, nullptr);
        VkSurfaceKHR surf;
        glfwCreateWindowSurface(inst, window, nullptr, &surf);
        VkPhysicalDevice phy_dev;
        uint32_t queue_family_idx;
        select_vk_physical_device(phy_dev, queue_family_idx, queue_family_idx, inst, surf);
        VkDevice device;
        VkQueue queue;
        create_vk_device(device, queue, queue, phy_dev, queue_family_idx, queue_family_idx);
        VkSwapchainKHR swpch;
        create_vk_swapchain(swpch, device, surf, queue_family_idx);
        VkRenderPass render_pass = create_render_pass(VK_FORMAT_B8G8R8A8_SRGB, device);

        // create pipeline
        auto vert_shader_code = read_file("vert_2.spv");  // "vert_2.spv"
        auto frag_shader_code = read_file("frag_2.spv");  // "frag_2.spv"
        VkShaderModule vertShaderModule = create_shader_module(vert_shader_code, device);
        VkShaderModule fragShaderModule = create_shader_module(frag_shader_code, device);
        VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
        vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
        vertShaderStageInfo.module = vertShaderModule;
        vertShaderStageInfo.pName = "main";
        VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
        fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
        fragShaderStageInfo.module = fragShaderModule;
        fragShaderStageInfo.pName = "main";
        VkPipelineShaderStageCreateInfo shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};
        
        VkVertexInputBindingDescription vtx_binding_desc{};
        vtx_binding_desc.binding = 0;
        vtx_binding_desc.stride = sizeof(float) * 3;  // (x, y, z) 三个分量
        vtx_binding_desc.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

        VkVertexInputAttributeDescription vtx_attr_desc{};
        vtx_attr_desc.binding = 0;
        vtx_attr_desc.location = 0;
        vtx_attr_desc.format = VK_FORMAT_R32G32B32_SFLOAT;
        vtx_attr_desc.offset = 0;

        VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
        vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
        vertexInputInfo.vertexBindingDescriptionCount = 1;
        vertexInputInfo.pVertexBindingDescriptions = &vtx_binding_desc;
        vertexInputInfo.vertexAttributeDescriptionCount = 1;
        vertexInputInfo.pVertexAttributeDescriptions = &vtx_attr_desc;

        VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
        inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
        inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
        inputAssembly.primitiveRestartEnable = VK_FALSE;

        VkPipelineViewportStateCreateInfo viewportState{};
        viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
        viewportState.viewportCount = 1;
        viewportState.scissorCount = 1;

        VkPipelineRasterizationStateCreateInfo rasterizer{};
        rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
        rasterizer.depthClampEnable = VK_FALSE;
        rasterizer.rasterizerDiscardEnable = VK_FALSE;
        rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
        rasterizer.lineWidth = 1.0f;
        rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
        rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
        rasterizer.depthBiasEnable = VK_FALSE;

        VkPipelineMultisampleStateCreateInfo multisampling{};
        multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
        multisampling.sampleShadingEnable = VK_FALSE;
        multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

        VkPipelineColorBlendAttachmentState colorBlendAttachment{};
        colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
        colorBlendAttachment.blendEnable = VK_FALSE;

        VkPipelineColorBlendStateCreateInfo colorBlending{};
        colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
        colorBlending.logicOpEnable = VK_FALSE;
        colorBlending.logicOp = VK_LOGIC_OP_COPY;
        colorBlending.attachmentCount = 1;
        colorBlending.pAttachments = &colorBlendAttachment;
        colorBlending.blendConstants[0] = 0.0f;
        colorBlending.blendConstants[1] = 0.0f;
        colorBlending.blendConstants[2] = 0.0f;
        colorBlending.blendConstants[3] = 0.0f;

        std::vector<VkDynamicState> dynamicStates = {
            VK_DYNAMIC_STATE_VIEWPORT,
            VK_DYNAMIC_STATE_SCISSOR
        };
        VkPipelineDynamicStateCreateInfo dynamicState{};
        dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
        dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
        dynamicState.pDynamicStates = dynamicStates.data();

        VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
        pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
        pipelineLayoutInfo.setLayoutCount = 0;
        pipelineLayoutInfo.pushConstantRangeCount = 0;
        VkPipelineLayout pipelineLayout{};
        vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout);

        VkGraphicsPipelineCreateInfo pipelineInfo{};
        pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
        pipelineInfo.stageCount = 2;
        pipelineInfo.pStages = shaderStages;
        pipelineInfo.pVertexInputState = &vertexInputInfo;
        pipelineInfo.pInputAssemblyState = &inputAssembly;
        pipelineInfo.pViewportState = &viewportState;
        pipelineInfo.pRasterizationState = &rasterizer;
        pipelineInfo.pMultisampleState = &multisampling;
        pipelineInfo.pColorBlendState = &colorBlending;
        pipelineInfo.pDynamicState = &dynamicState;
        pipelineInfo.layout = pipelineLayout;
        pipelineInfo.renderPass = render_pass;
        pipelineInfo.subpass = 0;
        pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

        VkPipeline pipeline;
        if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &pipeline) != VK_SUCCESS) {
            throw std::runtime_error("failed to create graphics pipeline!");
        }

        // VkPipeline pipeline = create_pipeline("./vert_2.spv", "frag_2.spv", 9 * sizeof(float), {0, 3 * sizeof(float)}, device, {700, 500}, render_pass);
        
        uint32_t swpch_img_count;
        vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, nullptr);
        std::vector<VkImage> swpch_imgs(swpch_img_count);
        vkGetSwapchainImagesKHR(device, swpch, &swpch_img_count, swpch_imgs.data());

        std::vector<VkImageView> swpch_img_views(swpch_img_count);
        VkImageViewCreateInfo img_view_crt_info{};
        img_view_crt_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
        img_view_crt_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
        img_view_crt_info.format = VK_FORMAT_B8G8R8A8_SRGB;
        img_view_crt_info.subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};
        VkResult result;
        for (int i = 0; i < swpch_img_count; ++i)
        {
            img_view_crt_info.image = swpch_imgs[i];
            result = vkCreateImageView(device, &img_view_crt_info, nullptr, &swpch_img_views[i]);
            if (result != VK_SUCCESS)
            {
                printf("fail to create image view, error code %d\n", result);
                exit(-1);
            }
        }

        VkFramebufferCreateInfo frame_buf_crt_info{};
        frame_buf_crt_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
        frame_buf_crt_info.renderPass = render_pass;
        frame_buf_crt_info.attachmentCount = 1;
        frame_buf_crt_info.width = 700;
        frame_buf_crt_info.height = 500;
        frame_buf_crt_info.layers = 1;
        std::vector<VkFramebuffer> frame_bufs(swpch_img_count);
        for (int i = 0; i < swpch_img_count; ++i)
        {
            frame_buf_crt_info.pAttachments = &swpch_img_views[i];
            result = vkCreateFramebuffer(device, &frame_buf_crt_info, nullptr, &frame_bufs[i]);
            if (result != VK_SUCCESS)
            {
                printf("fail to create frame buffer, error code: %d\n", result);
                exit(-1);
            }
        }

        VkCommandPool cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
        cmd_pool = create_command_pool(device, phy_dev, queue_family_idx);
        VkCommandBuffer cmd_buf;
        VkCommandBufferAllocateInfo cmd_buf_alc_info{};
        cmd_buf_alc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        cmd_buf_alc_info.commandBufferCount = 1;
        cmd_buf_alc_info.commandPool = cmd_pool;
        cmd_buf_alc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        result = vkAllocateCommandBuffers(device, &cmd_buf_alc_info, &cmd_buf);
        if (result != VK_SUCCESS)
        {
            printf("fail to allocate command buffer\n");
            exit(-1);
        }

        float vtxs[9] = {
            0, -1, 0,
            1, 1, 0,
            -1, 1, 0
        };
        VkBuffer vtx_buf;
        VkDeviceMemory vtx_buf_mem;
        create_vk_buffer(vtx_buf, vtx_buf_mem, phy_dev, device, 3 * 3 * sizeof(float), VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
        float *p_mem_data = nullptr;
        result = vkMapMemory(device, vtx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
        memcpy(p_mem_data, vtxs, sizeof(vtxs));
        vkUnmapMemory(device, vtx_buf_mem);
        vkDeviceWaitIdle(device);

        float temp_mem[9];
        vkMapMemory(device, vtx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
        memcpy(temp_mem, p_mem_data, sizeof(vtxs));
        vkUnmapMemory(device, vtx_buf_mem);

        uint32_t idxs[3] = {0, 1, 2};
        VkBuffer idx_buf;
        VkDeviceMemory idx_buf_mem;
        create_vk_buffer(idx_buf, idx_buf_mem, phy_dev, device, sizeof(idxs), VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
        vkMapMemory(device, idx_buf_mem, 0, VK_WHOLE_SIZE, 0, (void**) &p_mem_data);
        memcpy(p_mem_data, idxs, sizeof(idxs));
        vkUnmapMemory(device, idx_buf_mem);

        VkSemaphore sem_finish_rendering = create_semaphore(device);
        VkSemaphore sem_img_available = create_semaphore(device);
        VkFence fence_acq_img = create_fence(device);
        VkFence fence_queue_submit = create_fence(device);

        vkResetFences(device, 1, &fence_acq_img);
        uint32_t available_img_idx;
        result = vkAcquireNextImageKHR(device, swpch, UINT64_MAX, sem_img_available, fence_acq_img, &available_img_idx);

        VkCommandBufferBeginInfo cmd_buf_beg_info{};
        cmd_buf_beg_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        cmd_buf_beg_info.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
        vkBeginCommandBuffer(cmd_buf, &cmd_buf_beg_info);

            VkRenderPassBeginInfo rdps_beg_info{};
            rdps_beg_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
            rdps_beg_info.renderPass = render_pass;
            rdps_beg_info.framebuffer = frame_bufs[available_img_idx];
            rdps_beg_info.renderArea.offset = {0, 0};
            rdps_beg_info.renderArea.extent = {700, 500};
            rdps_beg_info.clearValueCount = 1;
            VkClearValue clr_val{0, 0, 0, 1};
            rdps_beg_info.pClearValues = &clr_val;
            vkCmdBeginRenderPass(cmd_buf, &rdps_beg_info, VK_SUBPASS_CONTENTS_INLINE);

                vkCmdBindPipeline(cmd_buf, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);
                VkViewport viewport{};
                viewport.x = 0.0f;
                viewport.y = 0.0f;
                viewport.width = 700;
                viewport.height = 500;
                viewport.minDepth = 0.0f;
                viewport.maxDepth = 1.0f;
                vkCmdSetViewport(cmd_buf, 0, 1, &viewport);
                VkRect2D scissor{};
                scissor.offset = {0, 0};
                scissor.extent.width = 700;
                scissor.extent.height = 500;
                vkCmdSetScissor(cmd_buf, 0, 1, &scissor);
                VkDeviceSize offset = 0;
                vkCmdBindVertexBuffers(cmd_buf, 0, 1, &vtx_buf, &offset);
                // vkCmdBindIndexBuffer(cmd_buf, idx_buf, 0, VK_INDEX_TYPE_UINT32);
                // vkCmdDrawIndexed(cmd_buf, 3, 1, 0, 0, 0);
                vkCmdDraw(cmd_buf, 3, 1, 0, 0);

            vkCmdEndRenderPass(cmd_buf);

        result = vkEndCommandBuffer(cmd_buf);

        vkResetFences(device, 1, &fence_queue_submit);
        VkSubmitInfo submit_info{};
        submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        submit_info.signalSemaphoreCount = 1;
        submit_info.pSignalSemaphores = &sem_finish_rendering;
        submit_info.waitSemaphoreCount = 1;
        submit_info.waitSemaphoreCount = 0;
        submit_info.pWaitSemaphores = &sem_img_available;
        submit_info.commandBufferCount = 1;
        submit_info.pCommandBuffers = &cmd_buf;
        VkPipelineStageFlags pipeline_stage_flags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        submit_info.pWaitDstStageMask = &pipeline_stage_flags;
        vkQueueSubmit(queue, 1, &submit_info, fence_queue_submit);

        vkQueueWaitIdle(queue);
        vkDeviceWaitIdle(device);

        VkPresentInfoKHR prst_info{};
        prst_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
        prst_info.swapchainCount = 1;
        prst_info.pSwapchains = &swpch;
        prst_info.pImageIndices = &available_img_idx;
        prst_info.waitSemaphoreCount = 1;
        prst_info.pWaitSemaphores = &sem_finish_rendering;
        vkQueuePresentKHR(queue, &prst_info);

        getchar();
        return 0;
    }
    ```

    `shader_2.vert`:

    ```glsl
    #version 450

    layout(location = 0) in vec3 inPosition;

    void main() {
        gl_Position = vec4(inPosition, 1.0);
    }
    ```

    `shader_2.frag`:

    ```glsl
    #version 450

    // layout(location = 0) in vec3 fragColor;

    layout(location = 0) out vec3 outColor;

    void main() {
        // outColor = vec4(fragColor, 1.0);
        outColor = vec3(0.5, 0.8, 0.5);
    }
    ```

    编译 shader:

    ```bash
    glsl shader_2.vert -o vert_2.spv
    glsl shader_2.frag -o frag_2.spv
    ```

    编译`main.cpp`:

    ```makefile
    main: main.cpp
        g++ -g main.cpp -lglfw -lvulkan -ldl -lpthread -lX11 -lXxf86vm -lXrandr -lXi -o main
    ```

    运行：

    ```bash
    ./main
    ```

* opencl 记录一些感觉可能有用的内置函数

    * `clamp`

        ```c
        gentype clamp(gentype x,
            gentype minval,
            gentype maxval)
        ```

        Returns `fmin(fmax(x, minval), maxval)`.

        钳位函数，返回最小值和最大值定义的区间中的数

    * `gentype degrees(gentype radians)`

        将弧度转化为角度。

        与函数`gentype radians(gentype degrees)`配置使用

    * `mix`

        ```c
        gentype mix(gentype x,
            gentype y, gentype a)
        ```

        Returns the linear blend of x and y implemented as

        x + (y – x) * a

        a must be a value in the range 0.0 … 1.0. If a is not in this range, the return values are undefined.

        线性混合。

    * `gentype step(gentype edge, gentype x)`

        Returns 0.0 if x < edge; otherwise it returns 1.0. The step function can be used to create a discontinuous jump at an arbitrary point.

        阶跃函数。

    * `gentype sign(gentype x)`

        Returns 1.0 if x > 0, -0.0 if x = -0.0, +0.0 if x = +0.0, or -1.0 if x < 0. Returns 0.0 if x is a NaN.

        返回`x`的符号。

    * `float4 cross(float4 p0, float4 p1)`

        Returns the cross-product of p0.xyz and p1.xyz. The w compo- nent of a 4-component vector result returned will be 0.

        向量叉乘。参数可以同时为`float3`，也可以同时为`float4`，但是不能一个`float3`，另一个`float4`。

    * `float dot(gentypef p0, gentypef p1)`

        点乘。

        这里没说`p0`和`p1`是什么类型。可能任意长度的向量都支持。

    * `float length(gentypef p)`

        Returns the length of vector p, i.e., $\sqrt{p.x^2 + p.y^2 + …}$

        The length is calculated without overflow or extraordinary precision loss due to underflow.

        不清楚这里的 *underflow* 说的是什么意思。

    * `gentypef normalize(gentypef p)`

        Returns a vector in the same direction as p but with a length of 1.

    * `intn isequal(floatn x, floatn y)`

        Returns the component-wise compare of x == y.

    * `intn isless(floatn x, floatn y)`

        Returns the component-wise compare of x < y.

    * `intn isfinite(floatn x)`

        Tests for the finite value of x.

    * `intn isinf(floatn x)`

    * `intn isnan(floatn x)`

    * `intn isnormal(floatn x)`

        Tests for a normal value (i.e., x is neither zero, denormal, infinite, nor NaN).

        检测`x`是否为一个正常数字。

    * `int any(sgentype x)`

        Returns 1 if the most significant bit in any component of x is set; otherwise returns 0.

        不明白这里的 significant bit 是什么意思

    * `select`

        ```c
        entype select(gentype a,
            gentype b,
            sgentype c)
        ```

        For each component of a vector type `result[i] = if MSB of c[i] is set ? b[i] : a[i]`

        这个函数有点像 numpy 的 where().

        cached task: 有时间可以做个实验试试。