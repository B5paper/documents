# Math Note

## cache

* 什么是 Radon 变换？

    Radon 变换是一种数学积分变换，用于将函数（如图像）从其在空间域中的表示，转换到其沿不同方向投影（线积分）的域中。简单来说，它计算一个对象在所有可能方向上的“投影”，是计算机断层扫描（CT）成像等领域的核心数学工具。

    核心定义

    对于二维函数 f(x,y)f(x,y)，其 Radon 变换定义为沿一条直线 LL 的线积分：

    $$R(\rho, \theta) = \int_{L(\rho, \theta)} f(x, y) ds$$

    其中：

    * $\rho$ 是直线到原点的垂直距离（有时记作 $s$），

    * $\theta$ 是直线的法线与 $x$ 轴的夹角，

    * $L(\rho, \theta)$ 是直线方程： $x \cos \theta + y \sin \theta = \rho$。

    几何上，$R(\rho, \theta)$ 表示了图像 $f(x, y)$ 在角度 $\theta$ 方向上、到原点距离为 $\rho$ 的直线上的投影（即沿该直线方向的线积分和）。

    直观理解

    想象一束平行射线以角度 $\theta$ 穿过物体，测量射线被吸收或衰减的强度（如 CT 扫描）。每个射线路径对应一条直线 $L$，测得的衰减值就是 Radon 变换在该直线上的值。旋转不同角度 $θ$ 并重复测量，就得到了完整的 Radon 变换数据 $R(\rho, \theta)$。

    重要性质

    * 与傅里叶变换的关系（中心切片定理）：

        Radon 变换的一维傅里叶变换（对 $\rho$）等于原图像二维傅里叶变换在对应角度 $θ$ 的切片。这提供了图像重建的理论基础。

    * 逆变换：

        通过滤波反投影（Filtered Back Projection, FBP）等算法，可以从 Radon 变换数据重建原始图像。

    主要应用

    * 医学成像：CT 扫描的数学基础，通过 X 射线投影数据重建人体断层图像。

    * 地球物理学：地震波层析成像，通过地震波走时数据反演地下结构。

    * 雷达与合成孔径雷达（SAR）：用于目标检测与成像。

    * 材料科学：对样本进行无损检测和三维重建。

    举例说明

    对于一幅包含一个亮点的图像，其 Radon 变换在每条穿过亮点的直线上会有一个较高的值。在 $\rho, \theta$ 平面中，亮点对应的 Radon 变换呈现为正弦曲线（sinogram 图像中的一条正弦亮带）。

    总结：Radon 变换是将图像转换为沿不同方向投影的数学工具，其逆变换可用于从投影数据重建图像，是断层扫描成像的核心基础。

* 生日问题

    **问题抽象**

    有 $N$ 个可用 units（例如 $N = 50$），随机均匀地选取 kk 个 units（可重复抽取）。

    问：至少有一个 unit 被重复选中的概率是多少？

    **计算方法**

    1. 计算“所有 units 都不同”的概率（无重复）

        第一次选择：有 $N$ 种可能。

        第二次选择：不能和第一次相同 →  $N−1$ 种 → 概率为 $\frac{N - 1}{N}$。

        第三次选择：不能和前两次相同 → 概率为 $\frac{N - 2}{N}$。

        因此，选取 $k$ 次且全部不同的概率为：

        $$P_{不同} = \frac{N}{N} \cdot \frac{N－1}{Ｎ} \cdot \frac{N - 2}{N} \cdots \frac{N - (k-1)}{N}$$

        即：

        $$Ｐ_{不同}　=　\frac{N!}{N^k (N - k)!}$$

        更常用的是写成连乘形式：

        $$P_{不同} = \prod_{i=0}^{k-1} \left( 1 - \frac{i}{N} \right)$$

    2. 至少重复一次的概率

        $$P_{重复} = 1 - P_{不同}$$



* 详细讲讲	AHP（层次分析法）

    好的，我们来详细拆解AHP（层次分析法）。它是一种将定性与定量分析相结合、系统化、层次化的多准则决策方法，由美国运筹学家托马斯·塞蒂在20世纪70年代提出。它尤其擅长处理那些难以完全用定量数据描述的复杂决策问题。

    一、AHP的核心思想与特点

    核心思想：将复杂问题分解为不同的组成因素（指标），并按照支配关系形成层次结构。然后通过两两比较的方式，确定各因素（指标）的相对重要性，最终计算出最底层（方案层）相对于最高层（目标层）的相对权重或优劣排序。

    三大特点：

    * 系统性：将对象视为一个整体，按分解、比较、综合的思维方式进行决策。

    * 简洁性：将复杂的多指标比较转化为简单的两两比较。

    * 实用性：结合主观判断和定量计算，适合解决结构较为复杂、决策准则难以量化的问题。

    二、AHP的完整步骤

    我们用一个经典例子贯穿始终：选择旅游目的地。目标层是“选择最佳目的地”，准则层考虑“景色”、“费用”、“饮食”、“交通”，方案层是“城市A”、“城市B”、“城市C”。

    第1步：建立层次结构模型

    将问题条理化、层次化，构建一个从目标到准则、再到方案的树状层次结构。

    * 目标层（最高层）：决策的最终目的。例：选择最佳旅游地

    * 准则层（中间层）：评判方案所依据的准则或指标。例：景色、费用、饮食、交通

    * 方案层（最底层）：可供选择的备选方案。例：城市A、城市B、城市C

    ```text
              目标层
         [选择最佳旅游地]
                |
         ------------------
         |      |      |      |
       景色    费用   饮食   交通   ← 准则层
         |      |      |      |
        ...    ...    ...    ...
         |      |      |      |
       城市A  城市B  城市C   ...    ← 方案层
    ```

    第2步：构造判断（成对比较）矩阵

    这一步是AHP的关键。针对上一层的某个元素，对本层的所有相关元素进行两两比较，并用1-9标度法将主观判断量化。

    1-9标度法的含义：

    | 标度 | 含义 |
    | - | - |
    | 1 | 两个因素同样重要 |
    | 3 | 一个因素比另一个因素稍微重要 |
    | 5 | 一个因素比另一个因素明显重要 |
    | 7 | 一个因素比另一个因素强烈重要 |
    | 9 | 一个因素比另一个因素极端重要 |
    | 2, 4, 6, 8 | 上述相邻判断的中间值 |
    | 倒数 | 若因素i与j的重要性比为a_ij，则因素j与i的重要性比为1/a_ij |

    以准则层相对于目标层为例：

    假设决策者认为：对于“选择旅游地”这个目标：

    * 景色比费用明显重要（景色 vs 费用 = 5）

    * 景色比饮食稍微重要（景色 vs 饮食 = 3）

    * 景色比交通稍微重要（景色 vs 交通 = 3）

    * 费用比饮食稍微重要（费用 vs 饮食 = 3）

    * 费用比交通同样重要（费用 vs 交通 = 1）

    * 饮食比交通同样重要（饮食 vs 交通 = 1）

    则构造的判断矩阵 A 如下：

    | 选择最佳旅游地 | 景色 | 费用 | 饮食 | 交通 |
    | - | - | - | - | - |
    | 景色 | 1 | 5 | 3 | 3 |
    | 费用 | 1/5 | 1 | 3 | 1 |
    | 饮食 | 1/3 | 1/3 | 1 | 1 |
    | 交通 | 1/3 | 1 | 1 | 1 |

    注意：矩阵必须满足对角线为1（自己比自己同样重要），且满足互反性 a_ji = 1/a_ij。

    同样，我们需要为方案层相对于每一个准则也构造判断矩阵。例如，在“景色”这个准则下，比较三个城市的优劣。

    第3步：层次单排序与一致性检验

    这一步的目的是：根据一个判断矩阵，计算出其最大特征值对应的特征向量，这个特征向量就是本层元素相对于上一层某元素的权重排序（即层次单排序）。

    计算步骤（以准则层矩阵A为例）：

    * 计算权重向量（近似方法：和积法）：

        * 将判断矩阵A按列归一化：b_ij = a_ij / (Σ_i a_ij)

        * 将归一化后的矩阵按行求和：w_i = Σ_j b_ij

        * 再将w_i归一化：W_i = w_i / (Σ_i w_i)，得到的向量 W = [W1, W2, W3, W4]^T 就是近似的权重向量。

    * 一致性检验（防止逻辑错误）：

        由于主观判断可能存在矛盾（例如A比B重要，B比C重要，但C又比A重要），因此需要进行一致性检验。

        * 计算最大特征值 λ_max： λ_max ≈ (1/n) * Σ_i ((AW)_i / W_i)，其中 (AW)_i 是矩阵A与权重向量W乘积的第i个分量。

        * 计算一致性指标 CI： CI = (λ_max - n) / (n - 1)

        * 查找平均随机一致性指标 RI：对于n阶矩阵，有固定的RI值（可查表获得，例如n=3时RI=0.52，n=4时RI=0.89）。

        * 计算一致性比率 CR： CR = CI / RI

        * 判断：当 CR < 0.10 时，认为判断矩阵的一致性是可以接受的，否则需要调整判断矩阵中的元素。

        对于我们的矩阵A，计算后可能得到权重向量 W = [0.52, 0.20, 0.13, 0.15]^T（此处为示例值），CR < 0.1，通过检验。这意味着对于“选择旅游地”，景色权重52%，费用20%，饮食13%，交通15%。

    第4步：层次总排序与一致性检验

    这一步的目的是：计算方案层所有元素相对于目标层（总目标）的权重，即最终的综合排序。

    * 计算：

        * 假设我们已经计算出了：

            * 准则层对目标的权重向量：W_criteria = [w1, w2, w3, w4]

            * 每个方案相对于每个准则的权重（来自第3步，针对每个准则的判断矩阵计算出的权重向量）。

        * 将方案相对于各准则的权重列表组合成矩阵 P，然后计算：总权重向量 = P * W_criteria

    * 总排序的一致性检验：

        * 这一步通常可以省略，因为若每个单排序都通过了一致性检验，总排序一般也会通过。

        * 如需严格检验，可以用各准则的单排序CI值加权平均来计算。

    三、AHP的优缺点

    优点：

    * 系统性：结构清晰，便于理解和沟通。

    * 实用性：将复杂的决策过程简化成一系列两两比较和计算。

    * 灵活性：能够容纳定性和定量因素，并能处理主观判断。

    缺点与注意事项：

    * 主观性较强：权重高度依赖于专家的判断，不同专家可能得出不同结论。解决方法：使用群决策AHP（综合多位专家意见）。

    * 构造判断矩阵可能困难：当元素过多（如 >9）时，两两比较次数激增，容易导致逻辑混乱和一致性难以通过。解决方法：在准则层下再建立子准则层，减少同层比较元素。

    * 对一致性要求严格：CR>0.1时需要反复调整判断，有时会耗费时间。

    四、应用场景与工具

    经典应用场景：

    * 综合评价：供应商选择、投资项目评估、员工绩效考评。

    * 资源分配：预算分配、资源优先级排序。

    * 预测与规划：风险评估、技术发展趋势预测。

    * 冲突解决：谈判中多方利益权衡。

    常用工具：

    * 手动计算：适合教学和理解原理，实际应用繁琐。

    * Excel：可编写公式实现和积法及一致性检验。

    * 专业软件：Yaahp（国产，非常易用）、Expert Choice、Super Decisions（用于ANP，即网络层次分析法）。

    * 编程实现：MATLAB、Python（有pyAHP等库）可轻松实现算法并处理复杂问题。

    五、总结

    AHP是一个强大的思维和决策工具，其精髓在于 “分解-比较-综合”。它提供了一种将人的主观判断进行量化，并系统化地处理复杂多准则问题的框架。在实际数学建模中，AHP常与其他方法（如熵权法、TOPSIS）结合，形成主客观结合的组合赋权法，以增强模型的科学性和说服力。

* 数学建模中，如果遇到需要综合考虑多个指标的问题，该如何解决？

    在数学建模中，处理多指标综合评价问题是常见且关键的。以下是系统性的解决思路与常用方法：

    一、核心思路

    多指标问题通常涉及：

    * 指标间量纲不统一（如价格 vs 质量）

    * 指标权重不同（重要性差异）

    * 可能存在冲突（如成本越低越好，质量越高越好）

    解决路径：数据标准化 → 确定权重 → 综合集成 → 敏感性分析

    二、具体步骤与方法

    1. 数据预处理（标准化/归一化）

        消除量纲影响，常见方法：

        * 极差标准化（Min-Max）：

            $$x' = \frac{x - \min}{\max - \min}$$


        * Z-score标准化（标准差标准化）：

            $$x' = \frac{x - \mu}{\sigma}$$

        * 对数/指数变换：处理偏态分布数据

    2. 确定指标权重

        根据问题背景选择合适方法：

        | 方法类型 | 典型方法 | 适用场景 |
        | - | - | - |
        | 主观赋权 | AHP（层次分析法） | 专家经验可靠，指标可分层比较 |
        | 客观赋权 | 熵权法、CRITIC法 | 数据本身包含信息量差异 |
        | 主客观结合 | 组合赋权（如AHP+熵权） | 兼顾主观判断与数据规律 |

        举例：

        * AHP步骤：建立层次结构 → 构造判断矩阵 → 计算权重 → 一致性检验

        * 熵权法原理：指标数据变异程度越大，信息熵越小，权重越大

    3. 综合评价模型

        * (1) 线性加权综合法（最常用）

            $$S = \sum_{i=1}^n w_i \cdot x_i'$$

            * 优点：简单直观，易解释

            * 注意：要求指标间相互独立

        * (2) 非线性方法

            * TOPSIS法（逼近理想解排序）：

                计算各方案与“正理想解”和“负理想解”的距离，进行相对优劣排序

            * 模糊综合评价：适用于指标带模糊性的问题（如“满意度高”“质量好”）

            * 数据包络分析（DEA）：适用于多输入多输出的效率评价

        * (3) 机器学习方法

            * 主成分分析（PCA）：将多个相关指标转化为少数不相关的主成分，降维后评价

            * 神经网络评价模型：适合复杂非线性关系，但需要足够数据且解释性较弱

    三、建模注意事项

    * 指标选取的科学性：避免信息重叠（可用相关系数矩阵检验）

    * 权重敏感性分析：检验权重变化对结果的影响，增强结论稳健性

    * 结果解释需结合背景：综合得分高低需在实际问题中有明确意义

    四、实例框架（以城市发展评价为例）

    * 构建指标体系：经济（GDP、人均收入）、环境（PM2.5、绿化率）、社会（失业率、医疗资源）

    * 数据标准化：Z-score处理

    * 确定权重：AHP（专家打分） + 熵权法组合

    * 综合评价：TOPSIS法排序

    * 稳健性检验：调整权重，观察排名变化

    五、常见误区

    * 盲目使用复杂的模型，忽视问题实际背景

    * 忽略指标间的相关性导致信息重复计算

    * 未进行敏感性分析，导致结论脆弱

    六、推荐工具

    * MATLAB/Python：实现标准化、熵权法、TOPSIS等算法

    * Yaahp/SPSS：辅助AHP、PCA分析

    * Excel：快速实现简单加权综合

    如果需要针对具体问题（如环境评估、企业竞争力比较等）进一步展开，我可以提供更具体的模型选择建议和实现细节。

* Beta 分布

    Beta 分布简介

    Beta 分布是定义在区间 $[0, 1]$ 上的连续概率分布，由两个正参数 $\alpha$ (alpha) 和 $\beta$ (beta) 控制。

    1. 概率密度函数（PDF）

        $$f(x; \alpha, \beta) = \frac{x^{\alpha - 1} (1 - x)^{\beta - 1}}{B(\alpha, \beta)} , 0 \leq x \leq 1$$

        其中 $B(\alpha, \beta)$ 是 Beta 函数：

        $$B(\alpha, \beta) = \int_0^1 t^{\alpha - 1} (1 - t)^{\beta - 1} dt = \frac{\Gamma(\alpha) \Gamma(\beta)}{\Gamma(\alpha + \beta)}$$

        $\Gamma$ 是伽马函数。

    2. 统计特征

        均值：

        $$E[X] = \frac{\alpha}{\alpha + \beta}$$

        方差：

        $$Var(X) = \frac{\alpha \beta}{(\alpha + \beta)^2 (\alpha + \beta + 1)}$$

        众数（当 $\alpha \gt 1$,$\beta \gt 1$ 时）：

        $$Mode = \frac{\alpha - 1}{\alpha + \beta - 2}$$

    3. 形状变化

        通过改变 $\alpha$ 和 $\beta$ 可以产生多种形状：

        * $\alpha = \beta = 1$：均匀分布 $U(0,1)$

        * $\alpha \gt 1$, $\beta \gt 1$：单峰，在 (0,1) 内

        * $\alpha < 1$, $\beta < 1$：U 形（两端高中间低）

        * $\alpha > 1$, $\beta = 1$：在 1 处为 0，在 0 处为有限值，右偏

        * $\alpha = 1$, $\beta > 1$：在 0 处为 0，在 1 处为有限值，左偏

        * $\alpha < 1$, $\beta > 1$：反 J 形（集中在 0 附近）

        * $\alpha > 1$, $\beta < 1$：J 形（集中在 1 附近）

    4. 与二项分布的关系

    如果先验分布是 Beta 分布，观测到二项分布数据后，后验分布也是 Beta 分布（共轭先验）：

    先验：$Beta(\alpha, \beta)$, 数据：$k$次成功（总试验 $n$）

    后验：$Beta(\alpha + k,\beta + n - k)$

    5. 应用场景

        * 比例或概率的建模：例如点击率、转化率等（因为范围在 0~1）

        * 贝叶斯统计：作为二项分布的成功概率 p 的先验分布

        * 顺序统计量：均匀分布样本的第 k 个顺序统计量服从 Beta(k, n-k+1)

        * 项目管理：PERT 中用于任务完成时间的建模（经过缩放平移）

        * 机器学习：作为分类器输出的校准分布，或变分推断中的变分分布

    6. 与其他分布的关系

        * Gamma 分布：如果 $X \sim \mathrm{Gamma}(\alpha, 1)$, $Y \sim \mathrm{Gamma}(\beta, 1)$,则

            $$\frac{X}{X + Y} \sim \mathrm{Beta}(\alpha, \beta)$$

        * F 分布：有转换关系

        * 二项分布/伯努利分布：共轭先验

* $\Gamma$ 函数（Gamma function）

    $\Gamma$ 函数（Gamma function） 是阶乘在实数和复数域的推广，计算它主要有以下几种方法：

    1. 定义

        * 1.1 积分定义（$Re(z) > 0$）

            $$\Gamma(z) = \int_0^\infty t^{z-1} e^{-t} dt$$

            对于正整数 $n$：

            $$\Gamma(n) = (n-1)!$$

            特殊值：

            $$\Gamma(1) = 1,\ \Gamma(1/2) = \sqrt{\pi}$$

        * 1.2 递推关系

            $$\Gamma(z+1) = z \Gamma(z)$$

            这个性质让我们可以将任意复平面上的 $\Gamma$ 函数计算转化到主区间（如 1 ≤ Re(z) < 2）。

    2. 计算方法

        * 2.1 直接数值积分

            * 对积分定义式进行数值积分（如 Gauss-Laguerre 积分）

            * 适用于 Re(z) > 0

        * 2.2 Lanczos 近似（最常用）

            这是计算 $\Gamma$ 函数最流行的高精度方法。核心公式：

            $$\Gamma(z+1) = \sqrt{2 \pi} \left( z + g + \frac 1 2 \right)^{z + \frac 1 2} e^{-(z + g + \frac 1 2)} A_g(z)$$

            其中 $g$ 是常数（常用 $g = 607 / 128$，$A_g(z)$ 是一组预先计算的有理函数近似。

            特点：

            * 在整个复平面（除负整数点）都有高精度

            * 计算速度快

            * 被多数数学库采用

    3. 特殊情况的简便计算
    
        * 3.1 正整数

            $$\Gamma(n) = (n-1)! = 1 \times 2 \times \cdots \times (n-1)$$

        * 3.2 半整数

            利用递推和 $\Gamma (1/2) = \sqrt{\pi}$:

            $$\Gamma(n + \frac 1 2) = \frac{(2n)!}{4^n n!} \sqrt{\pi}$$

            例如：

            $$\Gamma(3/2) = \frac 1 2 \sqrt{\pi},\ \Gamma(5/2) = \frac 3 4 \sqrt{\pi}$$

        * 3.3 负数的 $\Gamma$ 函数

            利用反射公式：

            $$\Gamma(1-z) \Gamma(z) = \frac{\pi}{\sin (\pi z)}$$

            例如：

            $$\Gamma(-1/2) = \frac{\Gamma(1/2)}{(-1 / 2)} = -2 \sqrt{\pi}$$

            注意：负整数处是极点（发散）。

    4. 常用近似公式

        * 4.1 Stirling 公式（大 z）

            $$\Gamma(z) \sim \sqrt{\frac{2 \pi}{z}}(\frac{z}{e})^z (1 + \frac{1}{12 z} + \frac{1}{288 z^2} - \cdots)$$
            
            适用于 $\lvert z \rvert$ 较大时。

        * 4.2 小 z 近似

            用递推转到 z>1 再计算。

    5. 实际应用中的计算

        编程实现：

        * Python: math.gamma()（实数）, scipy.special.gamma()（复数）

        * C++: std::tgamma()（C++11）

        * MATLAB: gamma()

        * R: gamma()

        Python 示例：

        ```python
        import math
        print(math.gamma(5))      # 24.0
        print(math.gamma(2.5))    # 1.329340388179137
        ```

        注意事项：

        * 大参数可能溢出（如 $\Gamma(172)$ 超过双精度浮点）

        * 负整数参数返回 NaN 或报错

        * 可用对数 Gamma 函数避免溢出：

            $$\ln \Gamma(z) = \ln(\Gamma(z))$$

            函数：math.lgamma()。

    6. 与 Beta 函数的关系

        Beta 函数通过 Γ 函数计算：

        $$\Beta(x, y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x + y)}$$

        这就是 Beta 分布的归一化常数的来源。

    7. 历史与发展

        * 由欧拉（1729）和勒让德（命名）引入

        * 推广了阶乘到非整数

        * 在概率统计、数论、物理中广泛应用

    总结计算建议：

    * 日常使用：直接调用数学库函数

    * 需要理解：记住递推公式 $\Gamma(z + 1) = z \Gamma(z)$ 和 $\Gamma(1 / 2) = \sqrt{\pi}$

    * 数值稳定性：大参数时使用对数 Gamma 函数

    * 实现原理：Lanczos 近似是工业标准方法

* 初等数学的英文

    elementary mathematics

    primary mathematics （小学阶段的数学）

    fundamental mathematics：强调数学基础原理

## note
