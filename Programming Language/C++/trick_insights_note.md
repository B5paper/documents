# Programming insights

This note is used to summarize tricks in C++ language.

* If we want to verify if two numbers are the same sign, we can use XOR: `sign_1 ^ sign_2`.

    This trick can get the product sign of two multipliers.

* the absolute value of `INT32_MIN` is greater by 1 than `INT32_MAX`

    So don't convert negative value to positive. Turn positive value to negative to avoid overflow.

* 首先让最底层的函数暴露尽量多的信息和细节，然后再在上面套一层封装，适应不同的调用需求

    比如对射线和空间三维物体交点的计算，底层的计算函数需要输出是否相交，相交的话`t`是多少，交点在哪里，相交的是哪个物体，交点处的法向量，颜色等等，然后上层函数再对这个函数进行一次封装，有些需求是只需要判断是否相交就可以，有些需求是要得到交点位置。我们使用第二层函数来对接这些需求。

* 如果想要实现复杂的功能，可以用 c/c++ 写许多小程序，然后把它们组合起来使用。

    这个建议的原理同上面相同。让每个 c/c++ 程序专注一个功能，比如搜索字符串，做内存拷贝，等等，然后让上层的程序组合多个底层的程序，实现一个功能。

    让 c/c++ 写复杂的交互效率很低，还不好写。

    不要让一个程序变得很臃肿。

* 在写多线程的代码时，由于负载不均衡是个很大的问题，所以子线程函数的颗粒需要尽可能细，细到无法再分。然后在上层再写一层调度，进行任务的分配。

* 写代码时，前面写过的代码，实现过的函数，经常会被忘记，因此写代码也需要进行 qa 记忆巩固。

* 引入一个头文件，就代表了引入一种功能。头文件与头文件之间尽量独立

* array 类似于一个数组，而 vector 类似一个指针

    array 是占用栈，而 vector 占用的是堆。

* 每个函数代码尽量控制在 30 以内。人每次只能处理很短的一段逻辑，太长的逻辑就算当前能正常处理，过段时间遗忘后再加载也会浪费时间。

    不一定是 30 行，但目前看来，超过 90 行一定是不容易处理的。

* 对于一些文本或格式化的文件进行数据处理时，通常用有限状态机解决。使用状态机处理是一种很自然的想法。

    可以设置一些 bool 值来控制状态。有时间了系统学一下这个编程思想。

* 编程时，如果变量名称没有明显的歧义或者冗余，那么就不需要优化

    比如 direction 不需要刻意写成 dir

    如果感到变量名太长，确实影响了效率，再使用缩写。比如大片的代码长度超过了 2/3 行。

* 复杂项目的渐进编程法

    不要想着一开始就实现一个接口灵活，非常好用的框架。因为我们编程时面对的是当前的项目，所谓的“灵活”是针对大量的项目而言的，接手的项目比较少时，无法抽象出需要在什么地方灵活。

    比如在渲染物体表面时，一开始可能只用到`Kd`，`Ks`这两个材质参数，后面慢慢又增加了折射，色散之类的效果，又增加了透明度，折射率，吸收率，衰减系统，brdf 之类的材质参数。刚开始的时候不可能考虑到后面的这么多东西，因此过度考虑代码的灵活性也是在浪费时间。

    一个比较好的想法是，对于每个项目，都只使用已有的知识，想办法最快地实现目标，记录下其中学到的东西。然后再开启下一个项目，同样以最快的方式达到目标。一直这样循环下去。

    比如在给函数传参数`vec3`时，既可以使用引用，也可以按值传递。如果要传引用，需要区分左值引用，右值引用，为了统一这两种引用，还要写模板，为了使模板只对`vec3`类型生效，还要写模板元编程`enable_if`，非常麻烦。如果我们的目标仅仅是渲染，那么直接按值传递，可以节省很多时间。只有当按值传递确实成为性能瓶颈时，再考虑将值换成引用。

    如果希望对引用和模板展开调研，可以另开一个项目，专门研究引用，模板，完美转发。但在当前项目中去研究这些东西，是不值得推荐的。

* 按格式解析文件

    目前我觉得比较好的方法是使用有限状态机。有空了刷刷相关的题目。不知道有什么更好的方法。

* c/c++ 的程序开发效率低

    c/c++ 写程序原型不容易写得复杂。c/c++ 适合写单一功能，或者架构已经大概规划好的程序。

    c/c++ 不适合写有大量交互的程序，因为交互的程序逻辑复杂，走走停停，而且需求变动太，使用c/c++开发效率太低。

* 如果一个底层的资源不在上层的控制中，那么这个资源其实就相当于泄漏的内存了，越积越多，就会导致电脑放不下。

    由于各种复杂因素的限制，我们无法像 rust 或 c++ 那样精确处理泄漏内存，一个折中的办法是模仿 java，隔一段时间就去遍历一遍底层资源，看是否有什么资源失去了控制。

    联想：java 的 gc 其实可以做到少次多量，与分配内存形成动态平衡，未来的程序应该这样比较好。

* 有关c++框架的调试

    有些程序是 c++ 的框架程序，代码分为上下层两部分，上层以是抽象类和接口，下层是接口的实现。整个代码中用到了大量的虚函数。

    这种程序调试时的一些经验如下：

    * 对于一个基类对象，在调用它的虚函数时，使用静态分析代码+跳转可能找不到正确的虚函数，可以在程序运行时，使用 F11 step in 到虚函数里，就能找到正确的虚函数了。

    * 想要将下层实现的头文件包含到上层，然后强制将基类对象指针转换成继承类的指针，很有可能会编译失败。通常的解决方法为在基类中写个虚函数，然后自己在派生类里实现一下。

        如果基类里是纯虚函数，那么需要在所有的派生类里实现一遍。

        最后用基类指针去调用虚函数就可以了，c++会自动帮你找到派生类的虚函数。

    * 如果不熟悉项目的编译系统，可以尝试在`.cpp`文件里引入`.hpp`文件，把实现写到头文件里。